<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qoffscreensurface.cpp -->
  <title>QOffscreenSurface Class | Qt GUI 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtgui-index.html">Qt GUI</a></td><td ><a href="qtgui-module.html">C++类</a></td><td >QOffscreenSurface</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#reimplemented-public-functions">重新实现的公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QOffscreenSurface Class</h1>
<!-- $$$QOffscreenSurface-brief -->
<p>The <a href="qoffscreensurface.html">QOffscreenSurface</a> class represents an offscreen surface in the underlying platform. <a href="#details">More...</a></p>
<!-- @@@QOffscreenSurface -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QOffscreenSurface&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.1</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html">QObject</a> 和 <a href="qsurface.html">QSurface</a></td></tr></table></div><ul>
<li><a href="qoffscreensurface-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qoffscreensurface-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#QOffscreenSurface">QOffscreenSurface</a></b>(QScreen *<i>targetScreen</i>, QObject *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#QOffscreenSurface-1">QOffscreenSurface</a></b>(QScreen *<i>targetScreen</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#dtor.QOffscreenSurface">~QOffscreenSurface</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#create">create</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#destroy">destroy</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#isValid">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void *</td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#nativeHandle">nativeHandle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSurfaceFormat </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#requestedFormat">requestedFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QScreen *</td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#screen">screen</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#setFormat">setFormat</a></b>(const QSurfaceFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#setNativeHandle">setNativeHandle</a></b>(void *<i>handle</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#setScreen">setScreen</a></b>(QScreen *<i>newScreen</i>)</td></tr>
</table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">重新实现的公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSurfaceFormat </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#format">format</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#size">size</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSurface::SurfaceType </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#surfaceType">surfaceType</a></b>() const override</td></tr>
</table></div>
<ul>
<li class="fn">31 public functions inherited from <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
<li class="fn">6 public functions inherited from <a href="qsurface.html#public-functions">QSurface</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#screenChanged">screenChanged</a></b>(QScreen *<i>screen</i>)</td></tr>
</table></div>
<ul>
<li class="fn">2 signals inherited from <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qoffscreensurface.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">9 static public members inherited from <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
<li class="fn">1 static public member inherited from <a href="qsurface.html#static-public-members">QSurface</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
<li class="fn">1 public slot inherited from <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 public variable inherited from <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">2 protected variables inherited from <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
<li class="fn">2 protected variables inherited from <a href="qsurface.html#protected-variables">QSurface</a></li>
</ul>
<a name="details"></a>
<!-- $$$QOffscreenSurface-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qoffscreensurface.html">QOffscreenSurface</a> class represents an offscreen surface in the underlying platform.</p>
<p><a href="qoffscreensurface.html">QOffscreenSurface</a> is intended to be used with <a href="qopenglcontext.html">QOpenGLContext</a> to allow rendering with OpenGL in an arbitrary thread without the need to create a <a href="qwindow.html">QWindow</a>.</p>
<p>Even though the surface is typically renderable, the surface's pixels are not accessible. <a href="qoffscreensurface.html">QOffscreenSurface</a> should only be used to create OpenGL resources such as textures or framebuffer objects.</p>
<p>An application will typically use <a href="qoffscreensurface.html">QOffscreenSurface</a> to perform some time-consuming tasks in a separate thread in order to avoid stalling the main rendering thread. Resources created in the <a href="qoffscreensurface.html">QOffscreenSurface</a>'s context can be shared with the main OpenGL context. Some common use cases are asynchronous texture uploads or rendering into a <a href="qopenglframebufferobject.html">QOpenGLFramebufferObject</a>.</p>
<p>How the offscreen surface is implemented depends on the underlying platform, but it will typically use a pixel buffer (pbuffer). If the platform doesn't implement or support offscreen surfaces, <a href="qoffscreensurface.html">QOffscreenSurface</a> will use an invisible <a href="qwindow.html">QWindow</a> internally.</p>
<p><b>Note: </b>Due to the fact that <a href="qoffscreensurface.html">QOffscreenSurface</a> is backed by a <a href="qwindow.html">QWindow</a> on some platforms, cross-platform applications must ensure that <a href="qoffscreensurface.html#create">create</a>() is only called on the main (GUI) thread. The <a href="qoffscreensurface.html">QOffscreenSurface</a> is then safe to be used with <a href="qopenglcontext.html#makeCurrent">makeCurrent()</a> on other threads, but the initialization and destruction must always happen on the main (GUI) thread.</p><p><b>Note: </b>In order to create an offscreen surface that is guaranteed to be compatible with a given context and window, make sure to set the format to the context's or the window's actual format, that is, the <a href="qsurfaceformat.html">QSurfaceFormat</a> returned from <a href="qopenglcontext.html#format">QOpenGLContext::format</a>() or <a href="qwindow.html#format">QWindow::format</a>() <i>after the context or window has been created</i>. Passing the format returned from <a href="qwindow.html#requestedFormat">QWindow::requestedFormat</a>() to <a href="qoffscreensurface.html#setFormat">setFormat</a>() may result in an incompatible offscreen surface since the underlying windowing system interface may offer a different set of configurations for window and pbuffer surfaces.</p><p><b>Note: </b>Some platforms may utilize a surfaceless context extension (for example EGL_KHR_surfaceless_context) when available. In this case there will be no underlying native surface. For the use cases of <a href="qoffscreensurface.html">QOffscreenSurface</a> (rendering to FBOs, texture upload) this is not a problem.</p></div>
<!-- @@@QOffscreenSurface -->
<div class="types">
<h2>成员类型文档</h2>
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QOffscreenSurface[overload1]$$$QOffscreenSurfaceQScreen*QObject* -->
<h3 class="fn" id="QOffscreenSurface"><a name="QOffscreenSurface"></a>QOffscreenSurface::<span class="name">QOffscreenSurface</span>(<span class="type"><a href="qscreen.html">QScreen</a></span> *<i>targetScreen</i>, <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i>)</h3>
<p>Creates an offscreen surface for the <i>targetScreen</i> with the given <i>parent</i>.</p>
<p>The underlying platform surface is not created until <a href="qoffscreensurface.html#create">create</a>() is called.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#setScreen">setScreen</a>() 和 <a href="qoffscreensurface.html#create">create</a>().</p>
<!-- @@@QOffscreenSurface -->
<!-- $$$QOffscreenSurface$$$QOffscreenSurfaceQScreen* -->
<h3 class="fn" id="QOffscreenSurface-1"><a name="QOffscreenSurface-1"></a>QOffscreenSurface::<span class="name">QOffscreenSurface</span>(<span class="type"><a href="qscreen.html">QScreen</a></span> *<i>targetScreen</i> = nullptr)</h3>
<p>Creates an offscreen surface for the <i>targetScreen</i>.</p>
<p>The underlying platform surface is not created until <a href="qoffscreensurface.html#create">create</a>() is called.</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#setScreen">setScreen</a>() 和 <a href="qoffscreensurface.html#create">create</a>().</p>
<!-- @@@QOffscreenSurface -->
<!-- $$$~QOffscreenSurface[overload1]$$$~QOffscreenSurface -->
<h3 class="fn" id="dtor.QOffscreenSurface"><a name="dtor.QOffscreenSurface"></a><code>[virtual] </code>QOffscreenSurface::<span class="name">~QOffscreenSurface</span>()</h3>
<p>Destroys the offscreen surface.</p>
<!-- @@@~QOffscreenSurface -->
<!-- $$$create[overload1]$$$create -->
<h3 class="fn" id="create"><a name="create"></a><span class="type">void</span> QOffscreenSurface::<span class="name">create</span>()</h3>
<p>Allocates the platform resources associated with the offscreen surface.</p>
<p>It is at this point that the surface format set using <a href="qoffscreensurface.html#setFormat">setFormat</a>() gets resolved into an actual native surface.</p>
<p>Call <a href="qoffscreensurface.html#destroy">destroy</a>() to free the platform resources if necessary.</p>
<p><b>Note: </b>Some platforms require this function to be called on the main (GUI) thread.</p><p><b> 参见 </b><a href="qoffscreensurface.html#destroy">destroy</a>().</p>
<!-- @@@create -->
<!-- $$$destroy[overload1]$$$destroy -->
<h3 class="fn" id="destroy"><a name="destroy"></a><span class="type">void</span> QOffscreenSurface::<span class="name">destroy</span>()</h3>
<p>Releases the native platform resources associated with this offscreen surface.</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#create">create</a>().</p>
<!-- @@@destroy -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" id="format"><a name="format"></a><code>[override virtual] </code><span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span> QOffscreenSurface::<span class="name">format</span>() const</h3>
<p>Reimplemented from <a href="qsurface.html#format">QSurface::format</a>().</p>
<p>Returns the actual format of this offscreen surface.</p>
<p>After the offscreen surface has been created, this function will return the actual surface format of the surface. It might differ from the requested format if the requested format could not be fulfilled by the platform.</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#setFormat">setFormat</a>(), <a href="qoffscreensurface.html#create">create</a>(), 和 <a href="qoffscreensurface.html#requestedFormat">requestedFormat</a>().</p>
<!-- @@@format -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid"><a name="isValid"></a><span class="type">bool</span> QOffscreenSurface::<span class="name">isValid</span>() const</h3>
<p>Returns <code>true</code> if this offscreen surface is valid; otherwise returns <code>false</code>.</p>
<p>The offscreen surface is valid if the platform resources have been successfuly allocated.</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#create">create</a>().</p>
<!-- @@@isValid -->
<!-- $$$nativeHandle[overload1]$$$nativeHandle -->
<h3 class="fn" id="nativeHandle"><a name="nativeHandle"></a><span class="type">void</span> *QOffscreenSurface::<span class="name">nativeHandle</span>() const</h3>
<p>Returns an optional native handle to which the offscreen surface is connected.</p>
<p>这个函数是在Qt 5.9版本中新增引入的。</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#setNativeHandle">setNativeHandle</a>().</p>
<!-- @@@nativeHandle -->
<!-- $$$requestedFormat[overload1]$$$requestedFormat -->
<h3 class="fn" id="requestedFormat"><a name="requestedFormat"></a><span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span> QOffscreenSurface::<span class="name">requestedFormat</span>() const</h3>
<p>Returns the requested surfaceformat of this offscreen surface.</p>
<p>If the requested format was not supported by the platform implementation, the requestedFormat will differ from the actual offscreen surface format.</p>
<p>This is the value set with <a href="qoffscreensurface.html#setFormat">setFormat</a>().</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#setFormat">setFormat</a>() 和 <a href="qoffscreensurface.html#format">format</a>().</p>
<!-- @@@requestedFormat -->
<!-- $$$screen[overload1]$$$screen -->
<h3 class="fn" id="screen"><a name="screen"></a><span class="type"><a href="qscreen.html">QScreen</a></span> *QOffscreenSurface::<span class="name">screen</span>() const</h3>
<p>Returns the screen to which the offscreen surface is connected.</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#setScreen">setScreen</a>().</p>
<!-- @@@screen -->
<!-- $$$screenChanged[overload1]$$$screenChangedQScreen* -->
<h3 class="fn" id="screenChanged"><a name="screenChanged"></a><code>[signal] </code><span class="type">void</span> QOffscreenSurface::<span class="name">screenChanged</span>(<span class="type"><a href="qscreen.html">QScreen</a></span> *<i>screen</i>)</h3>
<p>This signal is emitted when an offscreen surface's <i>screen</i> changes, either by being set explicitly with <a href="qoffscreensurface.html#setScreen">setScreen</a>(), or automatically when the window's screen is removed.</p>
<!-- @@@screenChanged -->
<!-- $$$setFormat[overload1]$$$setFormatconstQSurfaceFormat& -->
<h3 class="fn" id="setFormat"><a name="setFormat"></a><span class="type">void</span> QOffscreenSurface::<span class="name">setFormat</span>(const <span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span> &amp;<i>format</i>)</h3>
<p>Sets the offscreen surface <i>format</i>.</p>
<p>The surface format will be resolved in the <a href="qoffscreensurface.html#create">create</a>() function. Calling this function after <a href="qoffscreensurface.html#create">create</a>() will not re-resolve the surface format of the native surface.</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#format">format</a>(), <a href="qoffscreensurface.html#create">create</a>(), 和 <a href="qoffscreensurface.html#destroy">destroy</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setNativeHandle[overload1]$$$setNativeHandlevoid* -->
<h3 class="fn" id="setNativeHandle"><a name="setNativeHandle"></a><span class="type">void</span> QOffscreenSurface::<span class="name">setNativeHandle</span>(<span class="type">void</span> *<i>handle</i>)</h3>
<p>Sets the native handle to which the offscreen surface is connected to <i>handle</i>.</p>
<p>The native handle will be resolved in the <a href="qoffscreensurface.html#create">create</a>() function. Calling this function after <a href="qoffscreensurface.html#create">create</a>() will not re-create a native surface.</p>
<p><b>Note: </b>The interpretation of the native handle is platform specific. Only some platforms will support adopting native handles of offscreen surfaces and platforms that do not implement this support will ignore the handle.</p><p>这个函数是在Qt 5.9版本中新增引入的。</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#nativeHandle">nativeHandle</a>().</p>
<!-- @@@setNativeHandle -->
<!-- $$$setScreen[overload1]$$$setScreenQScreen* -->
<h3 class="fn" id="setScreen"><a name="setScreen"></a><span class="type">void</span> QOffscreenSurface::<span class="name">setScreen</span>(<span class="type"><a href="qscreen.html">QScreen</a></span> *<i>newScreen</i>)</h3>
<p>Sets the screen to which the offscreen surface is connected.</p>
<p>If the offscreen surface has been created, it will be recreated on the <i>newScreen</i>.</p>
<p><b> 参见 </b><a href="qoffscreensurface.html#screen">screen</a>().</p>
<!-- @@@setScreen -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><a name="size"></a><code>[override virtual] </code><span class="type"><a href="../qtcore/qsize.html">QSize</a></span> QOffscreenSurface::<span class="name">size</span>() const</h3>
<p>Reimplemented from <a href="qsurface.html#size">QSurface::size</a>().</p>
<p>Returns the size of the offscreen surface.</p>
<!-- @@@size -->
<!-- $$$surfaceType[overload1]$$$surfaceType -->
<h3 class="fn" id="surfaceType"><a name="surfaceType"></a><code>[override virtual] </code><span class="type"><a href="qsurface.html#SurfaceType-enum">QSurface::SurfaceType</a></span> QOffscreenSurface::<span class="name">surfaceType</span>() const</h3>
<p>Reimplemented from <a href="qsurface.html#surfaceType">QSurface::surfaceType</a>().</p>
<p>Returns the surface type of the offscreen surface.</p>
<p>The surface type of an offscreen surface is always <a href="qsurface.html#SurfaceType-enum">QSurface::OpenGLSurface</a>.</p>
<!-- @@@surfaceType -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
