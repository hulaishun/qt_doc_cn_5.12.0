<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qimageiohandler.cpp -->
  <title>QImageIOHandler Class | Qt GUI 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtgui-index.html">Qt GUI</a></td><td ><a href="qtgui-module.html">C++类</a></td><td >QImageIOHandler</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#protected-variables">保护变量</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QImageIOHandler Class</h1>
<!-- $$$QImageIOHandler-brief -->
<p>The <a href="qimageiohandler.html">QImageIOHandler</a> class defines the common image I/O interface for all image formats in Qt. <a href="#details">More...</a></p>
<!-- @@@QImageIOHandler -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QImageIOHandler&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr></table></div><ul>
<li><a href="qimageiohandler-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qimageiohandler-obsolete.html">过时的成员</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html">reentrant</a>.</p>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#ImageOption-enum">ImageOption</a></b> { Size, ClipRect, ScaledSize, ScaledClipRect, ..., TransformedByDefault }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#Transformation-enum">Transformation</a></b> { TransformationNone, TransformationMirror, TransformationFlip, TransformationRotate180, ..., TransformationRotate270 }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#Transformation-enum">Transformations</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#QImageIOHandler">QImageIOHandler</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#dtor.QImageIOHandler">~QImageIOHandler</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#canRead">canRead</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#currentImageNumber">currentImageNumber</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRect </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#currentImageRect">currentImageRect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QIODevice *</td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#device">device</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#format">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#imageCount">imageCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#jumpToImage">jumpToImage</a></b>(int <i>imageNumber</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#jumpToNextImage">jumpToNextImage</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#loopCount">loopCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#nextImageDelay">nextImageDelay</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#option">option</a></b>(QImageIOHandler::ImageOption <i>option</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#read">read</a></b>(QImage *<i>image</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#setDevice">setDevice</a></b>(QIODevice *<i>device</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#setFormat">setFormat</a></b>(const QByteArray &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#setFormat-1">setFormat</a></b>(const QByteArray &amp;<i>format</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#setOption">setOption</a></b>(QImageIOHandler::ImageOption <i>option</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#supportsOption">supportsOption</a></b>(QImageIOHandler::ImageOption <i>option</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#write">write</a></b>(const QImage &amp;<i>image</i>)</td></tr>
</table></div>
<a name="protected-variables"></a>
<h2 id="protected-variables">保护变量</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qimageiohandler.html#d_ptr-var">d_ptr</a></b></td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QImageIOHandler-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qimageiohandler.html">QImageIOHandler</a> class defines the common image I/O interface for all image formats in Qt.</p>
<p>Qt uses <a href="qimageiohandler.html">QImageIOHandler</a> for reading and writing images through <a href="qimagereader.html">QImageReader</a> and <a href="qimagewriter.html">QImageWriter</a>. You can also derive from this class to write your own image format handler using Qt's plugin mechanism.</p>
<p>Call <a href="qimageiohandler.html#setDevice">setDevice</a>() to assign a device to the handler, and <a href="qimageiohandler.html#setFormat">setFormat</a>() to assign a format to it. One <a href="qimageiohandler.html">QImageIOHandler</a> may support more than one image format. <a href="qimageiohandler.html#canRead">canRead</a>() returns <code>true</code> if an image can be read from the device, and <a href="qimageiohandler.html#read">read</a>() and <a href="qimageiohandler.html#write">write</a>() return true if reading or writing an image was completed successfully.</p>
<p><a href="qimageiohandler.html">QImageIOHandler</a> also has support for animations formats, through the functions <a href="qimageiohandler.html#loopCount">loopCount</a>(), <a href="qimageiohandler.html#imageCount">imageCount</a>(), <a href="qimageiohandler.html#nextImageDelay">nextImageDelay</a>() and <a href="qimageiohandler.html#currentImageNumber">currentImageNumber</a>().</p>
<p>In order to determine what options an image handler supports, Qt will call <a href="qimageiohandler.html#supportsOption">supportsOption</a>() and <a href="qimageiohandler.html#setOption">setOption</a>(). Make sure to reimplement these functions if you can provide support for any of the options in the <a href="qimageiohandler.html#ImageOption-enum">ImageOption</a> enum.</p>
<p>To write your own image handler, you must at least reimplement <a href="qimageiohandler.html#canRead">canRead</a>() and <a href="qimageiohandler.html#read">read</a>(). Then create a <a href="qimageioplugin.html">QImageIOPlugin</a> that can create the handler. Finally, install your plugin, and <a href="qimagereader.html">QImageReader</a> and <a href="qimagewriter.html">QImageWriter</a> will then automatically load the plugin, and start using it.</p>
</div>
<p><b>See also </b><a href="qimageioplugin.html">QImageIOPlugin</a>, <a href="qimagereader.html">QImageReader</a>, and <a href="qimagewriter.html">QImageWriter</a>.</p>
<!-- @@@QImageIOHandler -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$ImageOption$$$Size$$$ClipRect$$$Description$$$ScaledClipRect$$$ScaledSize$$$CompressionRatio$$$Gamma$$$Quality$$$Name$$$SubType$$$IncrementalReading$$$Endianness$$$Animation$$$BackgroundColor$$$ImageFormat$$$SupportedSubTypes$$$OptimizedWrite$$$ProgressiveScanWrite$$$ImageTransformation$$$TransformedByDefault -->
<h3 class="fn" id="ImageOption-enum"><a name="ImageOption-enum"></a>enum QImageIOHandler::<span class="name">ImageOption</span></h3>
<p>This enum describes the different options supported by <a href="qimageiohandler.html">QImageIOHandler</a>. Some options are used to query an image for properties, and others are used to toggle the way in which an image should be written.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QImageIOHandler::Size</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">The original size of an image. A handler that supports this option is expected to read the size of the image from the image metadata, and return this size from <a href="qimageiohandler.html#option">option</a>() as a <a href="../qtcore/qsize.html">QSize</a>.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::ClipRect</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">The clip rect, or ROI (Region Of Interest). A handler that supports this option is expected to only read the provided <a href="../qtcore/qrect.html">QRect</a> area from the original image in <a href="qimageiohandler.html#read">read</a>(), before any other transformation is applied.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::ScaledSize</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">The scaled size of the image. A handler that supports this option is expected to scale the image to the provided size (a <a href="../qtcore/qsize.html">QSize</a>), after applying any clip rect transformation (ClipRect). If the handler does not support this option, <a href="qimagereader.html">QImageReader</a> will perform the scaling after the image has been read.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::ScaledClipRect</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">The scaled clip rect (or ROI, Region Of Interest) of the image. A handler that supports this option is expected to apply the provided clip rect (a <a href="../qtcore/qrect.html">QRect</a>), after applying any scaling (ScaleSize) or regular clipping (ClipRect). If the handler does not support this option, <a href="qimagereader.html">QImageReader</a> will apply the scaled clip rect after the image has been read.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::Description</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">The image description. Some image formats, such as GIF and PNG, allow embedding of text or comments into the image data (e.g&#x2e;, for storing copyright information). It's common that the text is stored in key-value pairs, but some formats store all text in one continuous block. <a href="qimageiohandler.html">QImageIOHandler</a> returns the text as one <a href="../qtcore/qstring.html">QString</a>, where keys and values are separated by a ':', and keys-value pairs are separated by two newlines (\n\n). For example, &quot;Title: Sunset\n\nAuthor: Jim Smith\nSarah Jones\n\n&quot;. Formats that store text in a single block can use &quot;Description&quot; as the key.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::CompressionRatio</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">The compression ratio of the image data. A handler that supports this option is expected to set its compression rate depending on the value of this option (an int) when writing.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::Gamma</code></td><td class="topAlign tblval"><code>6</code></td><td class="topAlign">The gamma level of the image. A handler that supports this option is expected to set the image gamma level depending on the value of this option (a float) when writing.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::Quality</code></td><td class="topAlign tblval"><code>7</code></td><td class="topAlign">The quality level of the image. A handler that supports this option is expected to set the image quality level depending on the value of this option (an int) when writing.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::Name</code></td><td class="topAlign tblval"><code>8</code></td><td class="topAlign">The name of the image. A handler that supports this option is expected to read the name from the image metadata and return this as a <a href="../qtcore/qstring.html">QString</a>, or when writing an image it is expected to store the name in the image metadata.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::SubType</code></td><td class="topAlign tblval"><code>9</code></td><td class="topAlign">The subtype of the image. A handler that supports this option can use the subtype value to help when reading and writing images. For example, a PPM handler may have a subtype value of &quot;ppm&quot; or &quot;ppmraw&quot;.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::IncrementalReading</code></td><td class="topAlign tblval"><code>10</code></td><td class="topAlign">A handler that supports this option is expected to read the image in several passes, as if it was an animation. <a href="qimagereader.html">QImageReader</a> will treat the image as an animation.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::Endianness</code></td><td class="topAlign tblval"><code>11</code></td><td class="topAlign">The endianness of the image. Certain image formats can be stored as BigEndian or LittleEndian. A handler that supports Endianness uses the value of this option to determine how the image should be stored.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::Animation</code></td><td class="topAlign tblval"><code>12</code></td><td class="topAlign">Image formats that support animation return true for this value in <a href="qimageiohandler.html#supportsOption">supportsOption</a>(); otherwise, false is returned.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::BackgroundColor</code></td><td class="topAlign tblval"><code>13</code></td><td class="topAlign">Certain image formats allow the background color to be specified. A handler that supports BackgroundColor initializes the background color to this option (a <a href="qcolor.html">QColor</a>) when reading an image.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::ImageFormat</code></td><td class="topAlign tblval"><code>14</code></td><td class="topAlign">The image's data format returned by the handler. This can be any of the formats listed in <a href="qimage.html#Format-enum">QImage::Format</a>.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::SupportedSubTypes</code></td><td class="topAlign tblval"><code>15</code></td><td class="topAlign">Image formats that support different saving variants should return a list of supported variant names (<a href="../qtcore/qlist.html">QList</a>&lt;<a href="../qtcore/qbytearray.html">QByteArray</a>&gt;) in this option.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::OptimizedWrite</code></td><td class="topAlign tblval"><code>16</code></td><td class="topAlign">. A handler which supports this option is expected to turn on optimization flags when writing.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::ProgressiveScanWrite</code></td><td class="topAlign tblval"><code>17</code></td><td class="topAlign">. A handler which supports this option is expected to write the image as a progressive scan image.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::ImageTransformation</code></td><td class="topAlign tblval"><code>18</code></td><td class="topAlign">. A handler which supports this option can read the transformation metadata of an image. A handler that supports this option should not apply the transformation itself.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::TransformedByDefault</code></td><td class="topAlign tblval"><code>19</code></td><td class="topAlign">. A handler that reports support for this feature will have image transformation metadata applied by default on read.</td></tr>
</table></div>
<!-- @@@ImageOption -->
<!-- $$$Transformation$$$TransformationNone$$$TransformationMirror$$$TransformationFlip$$$TransformationRotate180$$$TransformationRotate90$$$TransformationMirrorAndRotate90$$$TransformationFlipAndRotate90$$$TransformationRotate270 -->
<h3 class="flags" id="Transformation-enum"><a name="Transformation-enum"></a>enum QImageIOHandler::<span class="name">Transformation</span><br/>flags QImageIOHandler::<span class="name">Transformations</span></h3>
<p>This enum describes the different transformations or orientations supported by some image formats, usually through EXIF.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QImageIOHandler::TransformationNone</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">No transformation should be applied.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::TransformationMirror</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">Mirror the image horizontally.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::TransformationFlip</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">Mirror the image vertically.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::TransformationRotate180</code></td><td class="topAlign tblval"><code>TransformationMirror | TransformationFlip</code></td><td class="topAlign">Rotate the image 180 degrees. This is the same as mirroring it both horizontally and vertically.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::TransformationRotate90</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">Rotate the image 90 degrees.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::TransformationMirrorAndRotate90</code></td><td class="topAlign tblval"><code>TransformationMirror | TransformationRotate90</code></td><td class="topAlign">Mirror the image horizontally and then rotate it 90 degrees.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::TransformationFlipAndRotate90</code></td><td class="topAlign tblval"><code>TransformationFlip | TransformationRotate90</code></td><td class="topAlign">Mirror the image vertically and then rotate it 90 degrees.</td></tr>
<tr><td class="topAlign"><code>QImageIOHandler::TransformationRotate270</code></td><td class="topAlign tblval"><code>TransformationRotate180 | TransformationRotate90</code></td><td class="topAlign">Rotate the image 270 degrees. This is the same as mirroring it both horizontally, vertically and then rotating it 90 degrees.</td></tr>
</table></div>
<p>This enum was introduced or modified in  Qt 5.5.</p>
<p>The Transformations type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Transformation&gt;. It stores an OR combination of Transformation values.</p>
<p><b>See also </b><a href="qimagereader.html#transformation">QImageReader::transformation</a>(), <a href="qimagereader.html#setAutoTransform">QImageReader::setAutoTransform</a>(), and <a href="qimagewriter.html#setTransformation">QImageWriter::setTransformation</a>().</p>
<!-- @@@Transformation -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QImageIOHandler[overload1]$$$QImageIOHandler -->
<h3 class="fn" id="QImageIOHandler"><a name="QImageIOHandler"></a>QImageIOHandler::<span class="name">QImageIOHandler</span>()</h3>
<p>Constructs a <a href="qimageiohandler.html">QImageIOHandler</a> object.</p>
<!-- @@@QImageIOHandler -->
<!-- $$$~QImageIOHandler[overload1]$$$~QImageIOHandler -->
<h3 class="fn" id="dtor.QImageIOHandler"><a name="dtor.QImageIOHandler"></a><code>[virtual] </code>QImageIOHandler::<span class="name">~QImageIOHandler</span>()</h3>
<p>Destructs the <a href="qimageiohandler.html">QImageIOHandler</a> object.</p>
<!-- @@@~QImageIOHandler -->
<!-- $$$canRead[overload1]$$$canRead -->
<h3 class="fn" id="canRead"><a name="canRead"></a><code>[pure virtual] </code><span class="type">bool</span> QImageIOHandler::<span class="name">canRead</span>() const</h3>
<p>Returns <code>true</code> if an image can be read from the device (i.e&#x2e;, the image format is supported, the device can be read from and the initial header information suggests that the image can be read); otherwise returns <code>false</code>.</p>
<p>When reimplementing canRead(), make sure that the I/O device (<a href="qimageiohandler.html#device">device</a>()) is left in its original state (e.g&#x2e;, by using peek() rather than <a href="qimageiohandler.html#read">read</a>()).</p>
<p><b>See also </b><a href="qimageiohandler.html#read">read</a>() and <a href="../qtcore/qiodevice.html#peek-1">QIODevice::peek</a>().</p>
<!-- @@@canRead -->
<!-- $$$currentImageNumber[overload1]$$$currentImageNumber -->
<h3 class="fn" id="currentImageNumber"><a name="currentImageNumber"></a><code>[virtual] </code><span class="type">int</span> QImageIOHandler::<span class="name">currentImageNumber</span>() const</h3>
<p>For image formats that support animation, this function returns the sequence number of the current image in the animation. If this function is called before any image is <a href="qimageiohandler.html#read">read</a>(), -1 is returned. The number of the first image in the sequence is 0.</p>
<p>If the image format does not support animation, 0 is returned.</p>
<p><b>See also </b><a href="qimageiohandler.html#read">read</a>().</p>
<!-- @@@currentImageNumber -->
<!-- $$$currentImageRect[overload1]$$$currentImageRect -->
<h3 class="fn" id="currentImageRect"><a name="currentImageRect"></a><code>[virtual] </code><span class="type"><a href="../qtcore/qrect.html">QRect</a></span> QImageIOHandler::<span class="name">currentImageRect</span>() const</h3>
<p>Returns the rect of the current image. If no rect is defined for the image, and empty QRect() is returned.</p>
<p>This function is useful for animations, where only parts of the frame may be updated at a time.</p>
<!-- @@@currentImageRect -->
<!-- $$$device[overload1]$$$device -->
<h3 class="fn" id="device"><a name="device"></a><span class="type"><a href="../qtcore/qiodevice.html">QIODevice</a></span> *QImageIOHandler::<span class="name">device</span>() const</h3>
<p>Returns the device currently assigned to the <a href="qimageiohandler.html">QImageIOHandler</a>. If not device has been assigned, 0 is returned.</p>
<p><b>See also </b><a href="qimageiohandler.html#setDevice">setDevice</a>().</p>
<!-- @@@device -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" id="format"><a name="format"></a><span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> QImageIOHandler::<span class="name">format</span>() const</h3>
<p>Returns the format that is currently assigned to <a href="qimageiohandler.html">QImageIOHandler</a>. If no format has been assigned, an empty string is returned.</p>
<p><b>See also </b><a href="qimageiohandler.html#setFormat">setFormat</a>().</p>
<!-- @@@format -->
<!-- $$$imageCount[overload1]$$$imageCount -->
<h3 class="fn" id="imageCount"><a name="imageCount"></a><code>[virtual] </code><span class="type">int</span> QImageIOHandler::<span class="name">imageCount</span>() const</h3>
<p>For image formats that support animation, this function returns the number of images in the animation. If the image format does not support animation, or if it is unable to determine the number of images, 0 is returned.</p>
<p>The default implementation returns 1 if <a href="qimageiohandler.html#canRead">canRead</a>() returns <code>true</code>; otherwise 0 is returned.</p>
<!-- @@@imageCount -->
<!-- $$$jumpToImage[overload1]$$$jumpToImageint -->
<h3 class="fn" id="jumpToImage"><a name="jumpToImage"></a><code>[virtual] </code><span class="type">bool</span> QImageIOHandler::<span class="name">jumpToImage</span>(<span class="type">int</span> <i>imageNumber</i>)</h3>
<p>For image formats that support animation, this function jumps to the image whose sequence number is <i>imageNumber</i>. The next call to <a href="qimageiohandler.html#read">read</a>() will attempt to read this image.</p>
<p>The default implementation does nothing, and returns <code>false</code>.</p>
<!-- @@@jumpToImage -->
<!-- $$$jumpToNextImage[overload1]$$$jumpToNextImage -->
<h3 class="fn" id="jumpToNextImage"><a name="jumpToNextImage"></a><code>[virtual] </code><span class="type">bool</span> QImageIOHandler::<span class="name">jumpToNextImage</span>()</h3>
<p>For image formats that support animation, this function jumps to the next image.</p>
<p>The default implementation does nothing, and returns <code>false</code>.</p>
<!-- @@@jumpToNextImage -->
<!-- $$$loopCount[overload1]$$$loopCount -->
<h3 class="fn" id="loopCount"><a name="loopCount"></a><code>[virtual] </code><span class="type">int</span> QImageIOHandler::<span class="name">loopCount</span>() const</h3>
<p>For image formats that support animation, this function returns the number of times the animation should loop. If the image format does not support animation, 0 is returned.</p>
<!-- @@@loopCount -->
<!-- $$$nextImageDelay[overload1]$$$nextImageDelay -->
<h3 class="fn" id="nextImageDelay"><a name="nextImageDelay"></a><code>[virtual] </code><span class="type">int</span> QImageIOHandler::<span class="name">nextImageDelay</span>() const</h3>
<p>For image formats that support animation, this function returns the number of milliseconds to wait until reading the next image. If the image format does not support animation, 0 is returned.</p>
<!-- @@@nextImageDelay -->
<!-- $$$option[overload1]$$$optionQImageIOHandler::ImageOption -->
<h3 class="fn" id="option"><a name="option"></a><code>[virtual] </code><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QImageIOHandler::<span class="name">option</span>(<span class="type"><a href="qimageiohandler.html#ImageOption-enum">QImageIOHandler::ImageOption</a></span> <i>option</i>) const</h3>
<p>Returns the value assigned to <i>option</i> as a <a href="../qtcore/qvariant.html">QVariant</a>. The type of the value depends on the option. For example, option(Size) returns a <a href="../qtcore/qsize.html">QSize</a> variant.</p>
<p><b>See also </b><a href="qimageiohandler.html#setOption">setOption</a>() and <a href="qimageiohandler.html#supportsOption">supportsOption</a>().</p>
<!-- @@@option -->
<!-- $$$read[overload1]$$$readQImage* -->
<h3 class="fn" id="read"><a name="read"></a><code>[pure virtual] </code><span class="type">bool</span> QImageIOHandler::<span class="name">read</span>(<span class="type"><a href="qimage.html">QImage</a></span> *<i>image</i>)</h3>
<p>Read an image from the device, and stores it in <i>image</i>. Returns <code>true</code> if the image is successfully read; otherwise returns false.</p>
<p>For image formats that support incremental loading, and for animation formats, the image handler can assume that <i>image</i> points to the previous frame.</p>
<p><b>See also </b><a href="qimageiohandler.html#canRead">canRead</a>().</p>
<!-- @@@read -->
<!-- $$$setDevice[overload1]$$$setDeviceQIODevice* -->
<h3 class="fn" id="setDevice"><a name="setDevice"></a><span class="type">void</span> QImageIOHandler::<span class="name">setDevice</span>(<span class="type"><a href="../qtcore/qiodevice.html">QIODevice</a></span> *<i>device</i>)</h3>
<p>Sets the device of the <a href="qimageiohandler.html">QImageIOHandler</a> to <i>device</i>. The image handler will use this device when reading and writing images.</p>
<p>The device can only be set once and must be set before calling <a href="qimageiohandler.html#canRead">canRead</a>(), <a href="qimageiohandler.html#read">read</a>(), <a href="qimageiohandler.html#write">write</a>(), etc. If you need to read multiple files, construct multiple instances of the appropriate <a href="qimageiohandler.html">QImageIOHandler</a> subclass.</p>
<p><b>See also </b><a href="qimageiohandler.html#device">device</a>().</p>
<!-- @@@setDevice -->
<!-- $$$setFormat[overload1]$$$setFormatconstQByteArray& -->
<h3 class="fn" id="setFormat"><a name="setFormat"></a><span class="type">void</span> QImageIOHandler::<span class="name">setFormat</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>format</i>)</h3>
<p>Sets the format of the <a href="qimageiohandler.html">QImageIOHandler</a> to <i>format</i>. The format is most useful for handlers that support multiple image formats.</p>
<p><b>See also </b><a href="qimageiohandler.html#format">format</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setFormat$$$setFormatconstQByteArray& -->
<h3 class="fn" id="setFormat-1"><a name="setFormat-1"></a><span class="type">void</span> QImageIOHandler::<span class="name">setFormat</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>format</i>) const</h3>
<p>Sets the format of the <a href="qimageiohandler.html">QImageIOHandler</a> to <i>format</i>. The format is most useful for handlers that support multiple image formats.</p>
<p>This function is declared const so that it can be called from <a href="qimageiohandler.html#canRead">canRead</a>().</p>
<p><b>See also </b><a href="qimageiohandler.html#format">format</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setOption[overload1]$$$setOptionQImageIOHandler::ImageOptionconstQVariant& -->
<h3 class="fn" id="setOption"><a name="setOption"></a><code>[virtual] </code><span class="type">void</span> QImageIOHandler::<span class="name">setOption</span>(<span class="type"><a href="qimageiohandler.html#ImageOption-enum">QImageIOHandler::ImageOption</a></span> <i>option</i>, const <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Sets the option <i>option</i> with the value <i>value</i>.</p>
<p><b>See also </b><a href="qimageiohandler.html#option">option</a>() and <a href="qimageiohandler.html#ImageOption-enum">ImageOption</a>.</p>
<!-- @@@setOption -->
<!-- $$$supportsOption[overload1]$$$supportsOptionQImageIOHandler::ImageOption -->
<h3 class="fn" id="supportsOption"><a name="supportsOption"></a><code>[virtual] </code><span class="type">bool</span> QImageIOHandler::<span class="name">supportsOption</span>(<span class="type"><a href="qimageiohandler.html#ImageOption-enum">QImageIOHandler::ImageOption</a></span> <i>option</i>) const</h3>
<p>Returns <code>true</code> if the <a href="qimageiohandler.html">QImageIOHandler</a> supports the option <i>option</i>; otherwise returns <code>false</code>. For example, if the <a href="qimageiohandler.html">QImageIOHandler</a> supports the <a href="qimageiohandler.html#ImageOption-enum">Size</a> option, supportsOption(Size) must return true.</p>
<p><b>See also </b><a href="qimageiohandler.html#setOption">setOption</a>() and <a href="qimageiohandler.html#option">option</a>().</p>
<!-- @@@supportsOption -->
<!-- $$$write[overload1]$$$writeconstQImage& -->
<h3 class="fn" id="write"><a name="write"></a><code>[virtual] </code><span class="type">bool</span> QImageIOHandler::<span class="name">write</span>(const <span class="type"><a href="qimage.html">QImage</a></span> &amp;<i>image</i>)</h3>
<p>Writes the image <i>image</i> to the assigned device. Returns <code>true</code> on success; otherwise returns <code>false</code>.</p>
<p>The default implementation does nothing, and simply returns <code>false</code>.</p>
<!-- @@@write -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
