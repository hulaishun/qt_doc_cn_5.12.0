<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qopengldebug.cpp -->
  <title>QOpenGLDebugLogger Class | Qt GUI 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtgui-index.html">Qt GUI</a></td><td ><a href="qtgui-module.html">C++类</a></td><td >QOpenGLDebugLogger</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#public-slots">公共槽函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#introduction">介绍</a></li>
<li class="level2"><a href="#creating-an-opengl-debug-context">Creating an OpenGL Debug Context</a></li>
<li class="level2"><a href="#creating-and-initializing-a-qopengldebuglogger">Creating and Initializing a QOpenGLDebugLogger</a></li>
<li class="level2"><a href="#reading-the-internal-opengl-debug-log">Reading the Internal OpenGL Debug Log</a></li>
<li class="level2"><a href="#real-time-logging-of-messages">Real-time logging of messages</a></li>
<li class="level2"><a href="#inserting-messages-in-the-debug-log">Inserting Messages in the Debug Log</a></li>
<li class="level2"><a href="#controlling-the-debug-output">Controlling the Debug Output</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QOpenGLDebugLogger Class</h1>
<!-- $$$QOpenGLDebugLogger-brief -->
<p>The <a href="qopengldebuglogger.html">QOpenGLDebugLogger</a> enables logging of OpenGL debugging messages. <a href="#details">更多详情...</a></p>
<!-- @@@QOpenGLDebugLogger -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QOpenGLDebugLogger&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.1</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html">QObject</a></td></tr></table></div><ul>
<li><a href="qopengldebuglogger-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qopengldebuglogger-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#LoggingMode-enum">LoggingMode</a></b> { AsynchronousLogging, SynchronousLogging }</td></tr>
</table></div>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<ul>
<li class="fn"><b><a href="qopengldebuglogger.html#loggingMode-prop">loggingMode</a></b> : const LoggingMode</li>
</ul>
<ul>
<li class="fn">1 个属性继承于 <a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#QOpenGLDebugLogger">QOpenGLDebugLogger</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#dtor.QOpenGLDebugLogger">~QOpenGLDebugLogger</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#disableMessages">disableMessages</a></b>(QOpenGLDebugMessage::Sources <i>sources</i>, QOpenGLDebugMessage::Types <i>types</i>, QOpenGLDebugMessage::Severities <i>severities</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#disableMessages-1">disableMessages</a></b>(const QVector&lt;GLuint&gt; &amp;<i>ids</i>, QOpenGLDebugMessage::Sources <i>sources</i>, QOpenGLDebugMessage::Types <i>types</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#enableMessages">enableMessages</a></b>(QOpenGLDebugMessage::Sources <i>sources</i>, QOpenGLDebugMessage::Types <i>types</i>, QOpenGLDebugMessage::Severities <i>severities</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#enableMessages-1">enableMessages</a></b>(const QVector&lt;GLuint&gt; &amp;<i>ids</i>, QOpenGLDebugMessage::Sources <i>sources</i>, QOpenGLDebugMessage::Types <i>types</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#initialize">initialize</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#isLogging">isLogging</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QOpenGLDebugMessage&gt; </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#loggedMessages">loggedMessages</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLDebugLogger::LoggingMode </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#loggingMode">loggingMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#maximumMessageLength">maximumMessageLength</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#popGroup">popGroup</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#pushGroup">pushGroup</a></b>(const QString &amp;<i>name</i>, GLuint <i>id</i> = 0, QOpenGLDebugMessage::Source <i>source</i> = QOpenGLDebugMessage::ApplicationSource)</td></tr>
</table></div>
<ul>
<li class="fn">31 个公共函数继承于 <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="public-slots"></a>
<h2 id="public-slots">公共槽函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#logMessage">logMessage</a></b>(const QOpenGLDebugMessage &amp;<i>debugMessage</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#startLogging">startLogging</a></b>(QOpenGLDebugLogger::LoggingMode <i>loggingMode</i> = AsynchronousLogging)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#stopLogging">stopLogging</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">1 个公共槽函数继承于 <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#messageLogged">messageLogged</a></b>(const QOpenGLDebugMessage &amp;<i>debugMessage</i>)</td></tr>
</table></div>
<ul>
<li class="fn">2 个信号继承于 <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qopengldebuglogger.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">9 个静态公共成员继承于 <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<h3>其他继承成员有</h3>
<ul>
<li class="fn">1 个公共变量继承于 <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">9 个保护函数继承于 <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">2 个保护变量继承于 <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QOpenGLDebugLogger-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qopengldebuglogger.html">QOpenGLDebugLogger</a> enables logging of OpenGL debugging messages.</p>
<a name="introduction"></a>
<h3 >介绍</h3>
<p>OpenGL programming can be very error prone. Most of the time, a single failing call to OpenGL can cause an entire portion of an application to stop working, with nothing being drawn on the screen.</p>
<p>The only way to be sure that no errors are being returned from the OpenGL implementation is checking with <code>glGetError</code> after each and every API call. Moreover, OpenGL errors stack up, therefore glGetError should always be used in a loop like this:</p>
<pre class="cpp">

      GLenum error <span class="operator">=</span> GL_NO_ERROR;
      <span class="keyword">do</span> {
          error <span class="operator">=</span> glGetError();
          <span class="keyword">if</span> (error <span class="operator">!</span><span class="operator">=</span> GL_NO_ERROR)
              <span class="comment">// handle the error</span>
      } <span class="keyword">while</span> (error <span class="operator">!</span><span class="operator">=</span> GL_NO_ERROR);

</pre>
<p>If you try to clear the error stack, make sure not just keep going until GL_NO_ERROR is returned but also break on GL_CONTEXT_LOST as that error value will keep repeating.</p>
<p>There are also many other information we are interested in (as application developers), for instance performance issues, or warnings about using deprecated APIs. Those kind of messages are not reported through the ordinary OpenGL error reporting mechanisms.</p>
<p><a href="qopengldebuglogger.html">QOpenGLDebugLogger</a> aims at addressing these issues by providing access to the <i>OpenGL debug log</i>. If your OpenGL implementation supports it (by exposing the <code>GL_KHR_debug</code> extension), messages from the OpenGL server will be either logged in an internal OpenGL log, or passed in &quot;real-time&quot; to listeners as they're generated from OpenGL.</p>
<p><a href="qopengldebuglogger.html">QOpenGLDebugLogger</a> supports both these modes of operation. Refer to the following sections to find out the differences between them.</p>
<a name="creating-an-opengl-debug-context"></a>
<h3 >Creating an OpenGL Debug Context</h3>
<p>For efficiency reasons, OpenGL implementations are allowed not to create any debug output at all, unless the OpenGL context is a debug context. In order to create a debug context from Qt, you must set the <a href="qsurfaceformat.html#FormatOption-enum">QSurfaceFormat::DebugContext</a> format option on the <a href="qsurfaceformat.html">QSurfaceFormat</a> used to create the <a href="qopenglcontext.html">QOpenGLContext</a> object:</p>
<pre class="cpp">

      <span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span> format;
      <span class="comment">// asks for a OpenGL 3.2 debug context using the Core profile</span>
      format<span class="operator">.</span>setMajorVersion(<span class="number">3</span>);
      format<span class="operator">.</span>setMinorVersion(<span class="number">2</span>);
      format<span class="operator">.</span>setProfile(<span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span><span class="operator">::</span>CoreProfile);
      format<span class="operator">.</span>setOption(<span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span><span class="operator">::</span>DebugContext);

      <span class="type"><a href="qopenglcontext.html">QOpenGLContext</a></span> <span class="operator">*</span>context <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qopenglcontext.html">QOpenGLContext</a></span>;
      context<span class="operator">-</span><span class="operator">&gt;</span>setFormat(format);
      context<span class="operator">-</span><span class="operator">&gt;</span>create();

</pre>
<p>Note that requesting a 3.2 OpenGL Core Profile is just for the example's purposes; this class is not tied to any specific OpenGL or OpenGL ES version, as it relies on the availability of the <code>GL_KHR_debug</code> extension (see below).</p>
<a name="creating-and-initializing-a-qopengldebuglogger"></a>
<h3 >Creating and Initializing a QOpenGLDebugLogger</h3>
<p><a href="qopengldebuglogger.html">QOpenGLDebugLogger</a> is a simple <a href="../qtcore/qobject.html">QObject</a>-derived class. Just like all <a href="../qtcore/qobject.html">QObject</a> subclasses, you create an instance (and optionally specify a parent object), and like the other OpenGL functions in Qt you <i>must</i> initialize it before usage by calling <a href="qopengldebuglogger.html#initialize">initialize</a>() whilst there is a current OpenGL context:</p>
<pre class="cpp">

      <span class="type"><a href="qopenglcontext.html">QOpenGLContext</a></span> <span class="operator">*</span>ctx <span class="operator">=</span> <span class="type"><a href="qopenglcontext.html">QOpenGLContext</a></span><span class="operator">::</span>currentContext();
      <span class="type"><a href="qopengldebuglogger.html#QOpenGLDebugLogger">QOpenGLDebugLogger</a></span> <span class="operator">*</span>logger <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qopengldebuglogger.html#QOpenGLDebugLogger">QOpenGLDebugLogger</a></span>(<span class="keyword">this</span>);

      logger<span class="operator">-</span><span class="operator">&gt;</span>initialize(); <span class="comment">// initializes in the current context, i.e. ctx</span>

</pre>
<p>Note that the <code>GL_KHR_debug</code> extension <i>must</i> be available in the context in order to access the messages logged by OpenGL. You can check the presence of this extension by calling:</p>
<pre class="cpp">

      ctx<span class="operator">-</span><span class="operator">&gt;</span>hasExtension(<span class="type"><a href="../qtcore/qbytearray.html#QByteArrayLiteral">QByteArrayLiteral</a></span>(<span class="string">&quot;GL_KHR_debug&quot;</span>))

</pre>
<p>where <code>ctx</code> is a valid <a href="qopenglcontext.html">QOpenGLContext</a>. If the extension is not available, <a href="qopengldebuglogger.html#initialize">initialize</a>() will return false.</p>
<a name="reading-the-internal-opengl-debug-log"></a>
<h3 >Reading the Internal OpenGL Debug Log</h3>
<p>OpenGL implementations keep an internal log of debug messages. Messages stored in this log can be retrieved by using the <a href="qopengldebuglogger.html#loggedMessages">loggedMessages</a>() function:</p>
<pre class="cpp">

      <span class="keyword">const</span> <span class="type">QList</span><span class="operator">&lt;</span><span class="type"><a href="qopengldebugmessage.html">QOpenGLDebugMessage</a></span><span class="operator">&gt;</span> messages <span class="operator">=</span> logger<span class="operator">-</span><span class="operator">&gt;</span>loggedMessages();
      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="type"><a href="qopengldebugmessage.html">QOpenGLDebugMessage</a></span> <span class="operator">&amp;</span>message : messages)
          <a href="../qtcore/qtglobal.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> message;

</pre>
<p>The internal log has a limited size; when it fills up, older messages will get discarded to make room for the new incoming messages. When you call <a href="qopengldebuglogger.html#loggedMessages">loggedMessages</a>(), the internal log will be emptied as well.</p>
<p>If you want to be sure not to lose any debug message, you must use real-time logging instead of calling this function. However, debug messages might still be generated in the timespan between context creation and activation of real-time logging (or, in general, when the real-time logging is disabled).</p>
<a name="real-time-logging-of-messages"></a>
<h3 >Real-time logging of messages</h3>
<p>It is also possible to receive a stream of debug messages from the OpenGL server <i>as they are generated</i> by the implementation. In order to do so, you need to connect a suitable slot to the <a href="qopengldebuglogger.html#messageLogged">messageLogged</a>() signal, and start logging by calling <a href="qopengldebuglogger.html#startLogging">startLogging</a>():</p>
<pre class="cpp">

      connect(logger<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qopengldebuglogger.html#QOpenGLDebugLogger">QOpenGLDebugLogger</a></span><span class="operator">::</span>messageLogged<span class="operator">,</span> receiver<span class="operator">,</span> <span class="operator">&amp;</span>LogHandler<span class="operator">::</span>handleLoggedMessage);
      logger<span class="operator">-</span><span class="operator">&gt;</span>startLogging();

</pre>
<p>Similarly, logging can be disabled at any time by calling the <a href="qopengldebuglogger.html#stopLogging">stopLogging</a>() function.</p>
<p>Real-time logging can be either asynchronous or synchronous, depending on the parameter passed to <a href="qopengldebuglogger.html#startLogging">startLogging</a>(). When logging in asynchronous mode (the default, as it has a very small overhead), the OpenGL implementation can generate messages at any time, and/or in an order which is different from the order of the OpenGL commands which caused those messages to be logged. The messages could also be generated from a thread that it's different from the thread the context is currently bound to. This is because OpenGL implementations are usually highly threaded and asynchronous, and therefore no warranties are made about the relative order and the timings of the debug messages.</p>
<p>On the other hand, logging in synchronous mode has a high overhead, but the OpenGL implementation guarantees that all the messages caused by a certain command are received in order, before the command returns, and from the same thread the OpenGL context is bound to.</p>
<p>This means that when logging in synchronous mode you will be able to run your OpenGL application in a debugger, put a breakpoint on a slot connected to the <a href="qopengldebuglogger.html#messageLogged">messageLogged</a>() signal, and see in the backtrace the exact call that caused the logged message. This can be extremely useful to debug an OpenGL problem. Note that if OpenGL rendering is happening in another thread, you must force the signal/slot connection type to <a href="../qtcore/qt.html#ConnectionType-enum">Qt::DirectConnection</a> in order to be able to see the actual backtrace.</p>
<p>Refer to the <a href="qopengldebuglogger.html#LoggingMode-enum">LoggingMode</a> enum documentation for more information about logging modes.</p>
<p><b>注意： </b>When real-time logging is enabled, debug messages will <i>not</i> be inserted in the internal OpenGL debug log any more; messages already present in the internal log will not be deleted, nor they will be emitted through the <a href="qopengldebuglogger.html#messageLogged">messageLogged</a>() signal. Since some messages might be generated before real-time logging is started (and therefore be kept in the internal OpenGL log), it is important to always check if it contains any message after calling <a href="qopengldebuglogger.html#startLogging">startLogging</a>().</p><a name="inserting-messages-in-the-debug-log"></a>
<h3 >Inserting Messages in the Debug Log</h3>
<p>It is possible for applications and libraries to insert custom messages in the debug log, for instance for marking a group of related OpenGL commands and therefore being then able to identify eventual messages coming from them.</p>
<p>In order to do so, you can create a <a href="qopengldebugmessage.html">QOpenGLDebugMessage</a> object by calling <a href="qopengldebugmessage.html#createApplicationMessage">createApplicationMessage()</a> or <a href="qopengldebugmessage.html#createThirdPartyMessage">createThirdPartyMessage()</a>, and then inserting it into the log by calling <a href="qopengldebuglogger.html#logMessage">logMessage</a>():</p>
<pre class="cpp">

      <span class="type"><a href="qopengldebugmessage.html">QOpenGLDebugMessage</a></span> message <span class="operator">=</span>
          <span class="type"><a href="qopengldebugmessage.html">QOpenGLDebugMessage</a></span><span class="operator">::</span>createApplicationMessage(<span class="type"><a href="../qtcore/qstring.html#QStringLiteral">QStringLiteral</a></span>(<span class="string">&quot;Custom message&quot;</span>));

      logger<span class="operator">-</span><span class="operator">&gt;</span>logMessage(message);

</pre>
<p>Note that OpenGL implementations have a vendor-specific limit to the length of the messages that can be inserted in the debug log. You can retrieve this length by calling the <a href="qopengldebuglogger.html#maximumMessageLength">maximumMessageLength</a>() method; messages longer than the limit will automatically get truncated.</p>
<a name="controlling-the-debug-output"></a>
<h3 >Controlling the Debug Output</h3>
<p><a href="qopengldebugmessage.html">QOpenGLDebugMessage</a> is also able to apply filters to the debug messages, and therefore limit the amount of messages logged. You can enable or disable logging of messages by calling <a href="qopengldebuglogger.html#enableMessages">enableMessages</a>() 和 <a href="qopengldebuglogger.html#disableMessages">disableMessages</a>() respectively. By default, all messages are logged.</p>
<p>It is possible to enable or disable messages by selecting them by:</p>
<ul>
<li>source, type and severity (and including all ids in the selection);</li>
<li>id, source and type (and including all severities in the selection).</li>
</ul>
<p>Note that the &quot;enabled&quot; status for a given message is a property of the (id, source, type, severity) tuple; the message attributes <i>do not</i> form a hierarchy of any kind. You should be careful about the order of the calls to <a href="qopengldebuglogger.html#enableMessages">enableMessages</a>() 和 <a href="qopengldebuglogger.html#disableMessages">disableMessages</a>(), as it will change which messages will are enabled / disabled.</p>
<p>It's not possible to filter by the message text itself; applications have to do that on their own (in slots connected to the <a href="qopengldebuglogger.html#messageLogged">messageLogged</a>() signal, or after fetching the messages in the internal debug log through <a href="qopengldebuglogger.html#loggedMessages">loggedMessages</a>()).</p>
<p>In order to simplify the management of the enabled / disabled statuses, <a href="qopengldebugmessage.html">QOpenGLDebugMessage</a> also supports the concept of <code>debug groups</code>. A debug group contains the group of enabled / disabled configurations of debug messages. Moreover, debug groups are organized in a stack: it is possible to push and pop groups by calling <a href="qopengldebuglogger.html#pushGroup">pushGroup</a>() 和 <a href="qopengldebuglogger.html#popGroup">popGroup</a>() respectively. (When an OpenGL context is created, there is already a group in the stack).</p>
<p>The <a href="qopengldebuglogger.html#enableMessages">enableMessages</a>() 和 <a href="qopengldebuglogger.html#disableMessages">disableMessages</a>() functions will modify the configuration in the current debug group, that is, the one at the top of the debug groups stack.</p>
<p>When a new group is pushed onto the debug groups stack, it will inherit the configuration of the group that was previously on the top of the stack. Vice versa, popping a debug group will restore the configuration of the debug group that becomes the new top.</p>
<p>Pushing (respectively popping) debug groups will also automatically generate a debug message of type <a href="qopengldebugmessage.html#Type-enum">QOpenGLDebugMessage::GroupPushType</a> (respectively <a href="qopengldebugmessage.html#Type-enum">GroupPopType</a>).</p>
</div>
<p><b> 参见 </b><a href="qopengldebugmessage.html">QOpenGLDebugMessage</a>.</p>
<!-- @@@QOpenGLDebugLogger -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$LoggingMode$$$AsynchronousLogging$$$SynchronousLogging -->
<h3 class="fn" id="LoggingMode-enum"><a name="LoggingMode-enum"></a>enum QOpenGLDebugLogger::<span class="name">LoggingMode</span></h3>
<p>The LoggingMode enum defines the logging mode of the logger object.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QOpenGLDebugLogger::AsynchronousLogging</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">Messages from the OpenGL server are logged asynchronously. This means that messages can be logged some time after the corresponding OpenGL actions that caused them, and even be received in an out-of-order fashion, depending on the OpenGL implementation. This mode has a very low performance penalty, as OpenGL implementations are heavily threaded and asynchronous by nature.</td></tr>
<tr><td class="topAlign"><code>QOpenGLDebugLogger::SynchronousLogging</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">Messages from the OpenGL server are logged synchronously and sequentially. This has a severe performance hit, as OpenGL implementations are very asynchronous by nature; but it's very useful to debug OpenGL problems, as OpenGL guarantees that the messages generated by a OpenGL command will be logged before the corresponding command execution has returned. Therefore, you can install a breakpoint on the <a href="qopengldebuglogger.html#messageLogged">messageLogged</a>() signal and see in the backtrace which OpenGL command caused it; the only caveat is that if you are using OpenGL from multiple threads you may need to force direct connection when connecting to the <a href="qopengldebuglogger.html#messageLogged">messageLogged</a>() signal.</td></tr>
</table></div>
<!-- @@@LoggingMode -->
</div>
<div class="prop">
<h2>属性文档</h2>
<!-- $$$loggingMode-prop$$$loggingMode -->
<h3 class="fn" id="loggingMode-prop"><a name="loggingMode-prop"></a><span class="name">loggingMode</span> : const <span class="type"><a href="qopengldebuglogger.html#LoggingMode-enum">LoggingMode</a></span></h3>
<p>This property holds the logging mode passed to <a href="qopengldebuglogger.html#startLogging">startLogging</a>().</p>
<p>Note that logging must have been started or the value of this property will be meaningless.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QOpenGLDebugLogger::LoggingMode </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qopengldebuglogger.html#loggingMode">loggingMode</a></b></span>() const</td></tr>
</table></div>
<p><b> 参见 </b><a href="qopengldebuglogger.html#startLogging">startLogging</a>() 和 <a href="qopengldebuglogger.html#isLogging">isLogging</a>().</p>
<!-- @@@loggingMode -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QOpenGLDebugLogger[overload1]$$$QOpenGLDebugLoggerQObject* -->
<h3 class="fn" id="QOpenGLDebugLogger"><a name="QOpenGLDebugLogger"></a>QOpenGLDebugLogger::<span class="name">QOpenGLDebugLogger</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new logger object with the given <i>parent</i>.</p>
<p><b>注意： </b>The object must be initialized before logging can happen.</p><p><b> 参见 </b><a href="qopengldebuglogger.html#initialize">initialize</a>().</p>
<!-- @@@QOpenGLDebugLogger -->
<!-- $$$~QOpenGLDebugLogger[overload1]$$$~QOpenGLDebugLogger -->
<h3 class="fn" id="dtor.QOpenGLDebugLogger"><a name="dtor.QOpenGLDebugLogger"></a><code>[虚函数] </code>QOpenGLDebugLogger::<span class="name">~QOpenGLDebugLogger</span>()</h3>
<p>Destroys the logger object.</p>
<!-- @@@~QOpenGLDebugLogger -->
<!-- $$$disableMessages[overload1]$$$disableMessagesQOpenGLDebugMessage::SourcesQOpenGLDebugMessage::TypesQOpenGLDebugMessage::Severities -->
<h3 class="fn" id="disableMessages"><a name="disableMessages"></a><span class="type">void</span> QOpenGLDebugLogger::<span class="name">disableMessages</span>(<span class="type"><a href="qopengldebugmessage.html#Source-enum">QOpenGLDebugMessage::Sources</a></span> <i>sources</i>, <span class="type"><a href="qopengldebugmessage.html#Type-enum">QOpenGLDebugMessage::Types</a></span> <i>types</i>, <span class="type"><a href="qopengldebugmessage.html#Severity-enum">QOpenGLDebugMessage::Severities</a></span> <i>severities</i>)</h3>
<p>Disables the logging of messages with the given <i>sources</i>, of the given <i>types</i> and with the given <i>severities</i> and any message id.</p>
<p>The logging will be disabled in the current control group.</p>
<p><b> 参见 </b><a href="qopengldebuglogger.html#enableMessages">enableMessages</a>(), <a href="qopengldebuglogger.html#pushGroup">pushGroup</a>(), 和 <a href="qopengldebuglogger.html#popGroup">popGroup</a>().</p>
<!-- @@@disableMessages -->
<!-- $$$disableMessages$$$disableMessagesconstQVector<GLuint>&QOpenGLDebugMessage::SourcesQOpenGLDebugMessage::Types -->
<h3 class="fn" id="disableMessages-1"><a name="disableMessages-1"></a><span class="type">void</span> QOpenGLDebugLogger::<span class="name">disableMessages</span>(const <span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type">GLuint</span>&gt; &amp;<i>ids</i>, <span class="type"><a href="qopengldebugmessage.html#Source-enum">QOpenGLDebugMessage::Sources</a></span> <i>sources</i>, <span class="type"><a href="qopengldebugmessage.html#Type-enum">QOpenGLDebugMessage::Types</a></span> <i>types</i>)</h3>
<p>Disables the logging of messages with the given <i>ids</i>, from the given <i>sources</i> and of the given <i>types</i> and any severity.</p>
<p>The logging will be disabled in the current control group.</p>
<p><b> 参见 </b><a href="qopengldebuglogger.html#enableMessages">enableMessages</a>(), <a href="qopengldebuglogger.html#pushGroup">pushGroup</a>(), 和 <a href="qopengldebuglogger.html#popGroup">popGroup</a>().</p>
<!-- @@@disableMessages -->
<!-- $$$enableMessages[overload1]$$$enableMessagesQOpenGLDebugMessage::SourcesQOpenGLDebugMessage::TypesQOpenGLDebugMessage::Severities -->
<h3 class="fn" id="enableMessages"><a name="enableMessages"></a><span class="type">void</span> QOpenGLDebugLogger::<span class="name">enableMessages</span>(<span class="type"><a href="qopengldebugmessage.html#Source-enum">QOpenGLDebugMessage::Sources</a></span> <i>sources</i>, <span class="type"><a href="qopengldebugmessage.html#Type-enum">QOpenGLDebugMessage::Types</a></span> <i>types</i>, <span class="type"><a href="qopengldebugmessage.html#Severity-enum">QOpenGLDebugMessage::Severities</a></span> <i>severities</i>)</h3>
<p>Enables the logging of messages from the given <i>sources</i>, of the given <i>types</i> and with the given <i>severities</i> and any message id.</p>
<p>The logging will be enabled in the current control group.</p>
<p><b> 参见 </b><a href="qopengldebuglogger.html#disableMessages">disableMessages</a>(), <a href="qopengldebuglogger.html#pushGroup">pushGroup</a>(), 和 <a href="qopengldebuglogger.html#popGroup">popGroup</a>().</p>
<!-- @@@enableMessages -->
<!-- $$$enableMessages$$$enableMessagesconstQVector<GLuint>&QOpenGLDebugMessage::SourcesQOpenGLDebugMessage::Types -->
<h3 class="fn" id="enableMessages-1"><a name="enableMessages-1"></a><span class="type">void</span> QOpenGLDebugLogger::<span class="name">enableMessages</span>(const <span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type">GLuint</span>&gt; &amp;<i>ids</i>, <span class="type"><a href="qopengldebugmessage.html#Source-enum">QOpenGLDebugMessage::Sources</a></span> <i>sources</i>, <span class="type"><a href="qopengldebugmessage.html#Type-enum">QOpenGLDebugMessage::Types</a></span> <i>types</i>)</h3>
<p>Enables the logging of messages with the given <i>ids</i>, from the given <i>sources</i> and of the given <i>types</i> and any severity.</p>
<p>The logging will be enabled in the current control group.</p>
<p><b> 参见 </b><a href="qopengldebuglogger.html#disableMessages">disableMessages</a>(), <a href="qopengldebuglogger.html#pushGroup">pushGroup</a>(), 和 <a href="qopengldebuglogger.html#popGroup">popGroup</a>().</p>
<!-- @@@enableMessages -->
<!-- $$$initialize[overload1]$$$initialize -->
<h3 class="fn" id="initialize"><a name="initialize"></a><span class="type">bool</span> QOpenGLDebugLogger::<span class="name">initialize</span>()</h3>
<p>Initializes the object in the current OpenGL context. The context must support the <code>GL_KHR_debug</code> extension for the initialization to succeed. The object must be initialized before any logging can happen.</p>
<p>It is safe to call this function multiple times from the same context.</p>
<p>This function can also be used to change the context of a previously initialized object; note that in this case the object must not be logging when you call this function.</p>
<p>Returns <code>true</code> if the logger is successfully initialized; false otherwise.</p>
<p><b> 参见 </b><a href="qopenglcontext.html">QOpenGLContext</a>.</p>
<!-- @@@initialize -->
<!-- $$$isLogging[overload1]$$$isLogging -->
<h3 class="fn" id="isLogging"><a name="isLogging"></a><span class="type">bool</span> QOpenGLDebugLogger::<span class="name">isLogging</span>() const</h3>
<p>Returns <code>true</code> if this object is currently logging, false otherwise.</p>
<p><b> 参见 </b><a href="qopengldebuglogger.html#startLogging">startLogging</a>().</p>
<!-- @@@isLogging -->
<!-- $$$logMessage[overload1]$$$logMessageconstQOpenGLDebugMessage& -->
<h3 class="fn" id="logMessage"><a name="logMessage"></a><code>[槽函数] </code><span class="type">void</span> QOpenGLDebugLogger::<span class="name">logMessage</span>(const <span class="type"><a href="qopengldebugmessage.html">QOpenGLDebugMessage</a></span> &amp;<i>debugMessage</i>)</h3>
<p>Inserts the message <i>debugMessage</i> into the OpenGL debug log. This provides a way for applications or libraries to insert custom messages that can ease the debugging of OpenGL applications.</p>
<p><b>注意： </b><i>debugMessage</i> must have <a href="qopengldebugmessage.html#Source-enum">QOpenGLDebugMessage::ApplicationSource</a> or <a href="qopengldebugmessage.html#Source-enum">QOpenGLDebugMessage::ThirdPartySource</a> as its source, and a valid type and severity, otherwise it will not be inserted into the log.</p><p><b>注意： </b>The object must be initialized before logging can happen.</p><p><b> 参见 </b><a href="qopengldebuglogger.html#initialize">initialize</a>().</p>
<!-- @@@logMessage -->
<!-- $$$loggedMessages[overload1]$$$loggedMessages -->
<h3 class="fn" id="loggedMessages"><a name="loggedMessages"></a><span class="type">QList</span>&lt;<span class="type"><a href="qopengldebugmessage.html">QOpenGLDebugMessage</a></span>&gt; QOpenGLDebugLogger::<span class="name">loggedMessages</span>() const</h3>
<p>Reads all the available messages in the OpenGL internal debug log and returns them. Moreover, this function will clear the internal debug log, so that subsequent invocations will not return messages that were already returned.</p>
<p><b> 参见 </b><a href="qopengldebuglogger.html#startLogging">startLogging</a>().</p>
<!-- @@@loggedMessages -->
<!-- $$$loggingMode -->
<h3 class="fn" id="loggingMode"><a name="loggingMode"></a><span class="type"><a href="qopengldebuglogger.html#LoggingMode-enum">QOpenGLDebugLogger::LoggingMode</a></span> QOpenGLDebugLogger::<span class="name">loggingMode</span>() const</h3>
<p>Returns the logging mode of the object.</p>
<p><b>注意：</b> 此获取函数来自于属性 <a href="qopengldebuglogger.html#loggingMode-prop">loggingMode</a>. </p><p><b> 参见 </b><a href="qopengldebuglogger.html#startLogging">startLogging</a>().</p>
<!-- @@@loggingMode -->
<!-- $$$maximumMessageLength[overload1]$$$maximumMessageLength -->
<h3 class="fn" id="maximumMessageLength"><a name="maximumMessageLength"></a><span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> QOpenGLDebugLogger::<span class="name">maximumMessageLength</span>() const</h3>
<p>Returns the maximum supported length, in bytes, for the text of the messages passed to <a href="qopengldebuglogger.html#logMessage">logMessage</a>(). This is also the maximum length of a debug group name, as pushing or popping groups will automatically log a message with the debug group name as the message text.</p>
<p>If a message text is too long, it will be automatically truncated by <a href="qopengldebuglogger.html">QOpenGLDebugLogger</a>.</p>
<p><b>注意： </b>Message texts are encoded in UTF-8 when they get passed to OpenGL, so their size in bytes does not usually match the amount of UTF-16 code units, as returned f.i&#x2e; by <a href="../qtcore/qstring.html#length">QString::length</a>(). (It does if the message contains 7-bit ASCII only data, which is typical for debug messages.)</p><!-- @@@maximumMessageLength -->
<!-- $$$messageLogged[overload1]$$$messageLoggedconstQOpenGLDebugMessage& -->
<h3 class="fn" id="messageLogged"><a name="messageLogged"></a><code>[信号] </code><span class="type">void</span> QOpenGLDebugLogger::<span class="name">messageLogged</span>(const <span class="type"><a href="qopengldebugmessage.html">QOpenGLDebugMessage</a></span> &amp;<i>debugMessage</i>)</h3>
<p>This signal is emitted when a debug message (wrapped by the <i>debugMessage</i> argument) is logged from the OpenGL server.</p>
<p>Depending on the OpenGL implementation, this signal can be emitted from other threads than the one(s) the receiver(s) lives in, and even different from the thread the <a href="qopenglcontext.html">QOpenGLContext</a> in which this object has been initialized lives in. Moreover, the signal could be emitted from multiple threads at the same time. This is normally not a problem, as Qt will utilize a queued connection for cross-thread signal emissions, but if you force the connection type to Direct then you must be aware of the potential races in the slots connected to this signal.</p>
<p>If logging have been started in <a href="qopengldebuglogger.html#LoggingMode-enum">SynchronousLogging</a> mode, OpenGL guarantees that this signal will be emitted from the same thread the <a href="qopenglcontext.html">QOpenGLContext</a> has been bound to, and no concurrent invocations will ever happen.</p>
<p><b>注意： </b>Logging must have been started, or this signal will not be emitted.</p><p><b> 参见 </b><a href="qopengldebuglogger.html#startLogging">startLogging</a>().</p>
<!-- @@@messageLogged -->
<!-- $$$popGroup[overload1]$$$popGroup -->
<h3 class="fn" id="popGroup"><a name="popGroup"></a><span class="type">void</span> QOpenGLDebugLogger::<span class="name">popGroup</span>()</h3>
<p>Pops the topmost debug group from the debug groups stack. If the group is successfully popped, OpenGL will automatically log a message with message, id and source matching those of the popped group, type <a href="qopengldebugmessage.html#Type-enum">QOpenGLDebugMessage::GroupPopType</a> and severity <a href="qopengldebugmessage.html#Severity-enum">QOpenGLDebugMessage::NotificationSeverity</a>.</p>
<p>Popping a debug group will restore the message filtering settings of the group that becomes the top of the debug groups stack.</p>
<p><b>注意： </b>The object must be initialized before managing debug groups.</p><p><b> 参见 </b><a href="qopengldebuglogger.html#pushGroup">pushGroup</a>().</p>
<!-- @@@popGroup -->
<!-- $$$pushGroup[overload1]$$$pushGroupconstQString&GLuintQOpenGLDebugMessage::Source -->
<h3 class="fn" id="pushGroup"><a name="pushGroup"></a><span class="type">void</span> QOpenGLDebugLogger::<span class="name">pushGroup</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>name</i>, <span class="type">GLuint</span> <i>id</i> = 0, <span class="type"><a href="qopengldebugmessage.html#Source-enum">QOpenGLDebugMessage::Source</a></span> <i>source</i> = QOpenGLDebugMessage::ApplicationSource)</h3>
<p>Pushes a debug group with name <i>name</i>, id <i>id</i>, and source <i>source</i> onto the debug groups stack. If the group is successfully pushed, OpenGL will automatically log a message with message <i>name</i>, id <i>id</i>, source <i>source</i>, type <a href="qopengldebugmessage.html#Type-enum">QOpenGLDebugMessage::GroupPushType</a> and severity <a href="qopengldebugmessage.html#Severity-enum">QOpenGLDebugMessage::NotificationSeverity</a>.</p>
<p>The newly pushed group will inherit the same filtering settings of the group that was on the top of the stack; that is, the filtering will not be changed by pushing a new group.</p>
<p><b>注意： </b>The <i>source</i> must either be <a href="qopengldebugmessage.html#Source-enum">QOpenGLDebugMessage::ApplicationSource</a> or <a href="qopengldebugmessage.html#Source-enum">QOpenGLDebugMessage::ThirdPartySource</a>, otherwise the group will not be pushed.</p><p><b>注意： </b>The object must be initialized before managing debug groups.</p><p><b> 参见 </b><a href="qopengldebuglogger.html#popGroup">popGroup</a>(), <a href="qopengldebuglogger.html#enableMessages">enableMessages</a>(), 和 <a href="qopengldebuglogger.html#disableMessages">disableMessages</a>().</p>
<!-- @@@pushGroup -->
<!-- $$$startLogging[overload1]$$$startLoggingQOpenGLDebugLogger::LoggingMode -->
<h3 class="fn" id="startLogging"><a name="startLogging"></a><code>[槽函数] </code><span class="type">void</span> QOpenGLDebugLogger::<span class="name">startLogging</span>(<span class="type"><a href="qopengldebuglogger.html#LoggingMode-enum">QOpenGLDebugLogger::LoggingMode</a></span> <i>loggingMode</i> = AsynchronousLogging)</h3>
<p>Starts logging messages coming from the OpenGL server. When a new message is received, the signal <a href="qopengldebuglogger.html#messageLogged">messageLogged</a>() is emitted, carrying the logged message as argument.</p>
<p><i>loggingMode</i> specifies whether the logging must be asynchronous (the default) or synchronous.</p>
<p><a href="qopengldebuglogger.html">QOpenGLDebugLogger</a> will record the values of <code>GL_DEBUG_OUTPUT</code> and <code>GL_DEBUG_OUTPUT_SYNCHRONOUS</code> when logging is started, and set them back when logging is stopped. Moreover, any user-defined OpenGL debug callback installed when this function is invoked will be restored when logging is stopped; <a href="qopengldebuglogger.html">QOpenGLDebugLogger</a> will ensure that the pre-existing callback will still be invoked when logging.</p>
<p><b>注意： </b>It's not possible to change the logging mode without stopping and starting logging again. This might change in a future version of Qt.</p><p><b>注意： </b>The object must be initialized before logging can happen.</p><p><b> 参见 </b><a href="qopengldebuglogger.html#stopLogging">stopLogging</a>() 和 <a href="qopengldebuglogger.html#initialize">initialize</a>().</p>
<!-- @@@startLogging -->
<!-- $$$stopLogging[overload1]$$$stopLogging -->
<h3 class="fn" id="stopLogging"><a name="stopLogging"></a><code>[槽函数] </code><span class="type">void</span> QOpenGLDebugLogger::<span class="name">stopLogging</span>()</h3>
<p>Stops logging messages from the OpenGL server.</p>
<p><b> 参见 </b><a href="qopengldebuglogger.html#startLogging">startLogging</a>().</p>
<!-- @@@stopLogging -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
