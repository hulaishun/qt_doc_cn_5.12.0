<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qopenglcontext.cpp -->
  <title>QOpenGLContext Class | Qt GUI 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtgui-index.html">Qt GUI</a></td><td ><a href="qtgui-module.html">C++类</a></td><td >QOpenGLContext</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#thread-affinity">Thread Affinity</a></li>
<li class="level2"><a href="#context-resource-sharing">Context Resource Sharing</a></li>
<li class="level2"><a href="#default-framebuffer">Default Framebuffer</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QOpenGLContext Class</h1>
<!-- $$$QOpenGLContext-brief -->
<p>The <a href="qopenglcontext.html">QOpenGLContext</a> class represents a native OpenGL context, enabling OpenGL rendering on a <a href="qsurface.html">QSurface</a>. <a href="#details">More...</a></p>
<!-- @@@QOpenGLContext -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QOpenGLContext&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.0</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html">QObject</a></td></tr></table></div><ul>
<li><a href="qopenglcontext-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qopenglcontext-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#OpenGLModuleType-enum">OpenGLModuleType</a></b> { LibGL, LibGLES }</td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#QOpenGLContext">QOpenGLContext</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#dtor.QOpenGLContext">~QOpenGLContext</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#create">create</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#defaultFramebufferObject">defaultFramebufferObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#doneCurrent">doneCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#extensions">extensions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLExtraFunctions *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#extraFunctions">extraFunctions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSurfaceFormat </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#format">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLFunctions *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#functions">functions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFunctionPointer </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#getProcAddress">getProcAddress</a></b>(const QByteArray &amp;<i>procName</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFunctionPointer </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#getProcAddress-1">getProcAddress</a></b>(const char *<i>procName</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#hasExtension">hasExtension</a></b>(const QByteArray &amp;<i>extension</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#isOpenGLES">isOpenGLES</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#isValid">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#makeCurrent">makeCurrent</a></b>(QSurface *<i>surface</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#nativeHandle">nativeHandle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QScreen *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#screen">screen</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#setFormat">setFormat</a></b>(const QSurfaceFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#setNativeHandle">setNativeHandle</a></b>(const QVariant &amp;<i>handle</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#setScreen">setScreen</a></b>(QScreen *<i>screen</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#setShareContext">setShareContext</a></b>(QOpenGLContext *<i>shareContext</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContext *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#shareContext">shareContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContextGroup *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#shareGroup">shareGroup</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSurface *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#surface">surface</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#swapBuffers">swapBuffers</a></b>(QSurface *<i>surface</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractOpenGLFunctions *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#versionFunctions">versionFunctions</a></b>(const QOpenGLVersionProfile &amp;<i>versionProfile</i> = QOpenGLVersionProfile()) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> TYPE *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#versionFunctions-1">versionFunctions</a></b>() const</td></tr>
</table></div>
<ul>
<li class="fn">31 public functions inherited from <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#aboutToBeDestroyed">aboutToBeDestroyed</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">2 signals inherited from <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#areSharing">areSharing</a></b>(QOpenGLContext *<i>first</i>, QOpenGLContext *<i>second</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContext *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#currentContext">currentContext</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContext *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#globalShareContext">globalShareContext</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void *</td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#openGLModuleHandle">openGLModuleHandle</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContext::OpenGLModuleType </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#openGLModuleType">openGLModuleType</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qopenglcontext.html#supportsThreadedOpenGL">supportsThreadedOpenGL</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">9 static public members inherited from <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
<li class="fn">1 public slot inherited from <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 public variable inherited from <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">2 protected variables inherited from <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QOpenGLContext-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qopenglcontext.html">QOpenGLContext</a> class represents a native OpenGL context, enabling OpenGL rendering on a <a href="qsurface.html">QSurface</a>.</p>
<p><a href="qopenglcontext.html">QOpenGLContext</a> represents the OpenGL state of an underlying OpenGL context. To set up a context, set its screen and format such that they match those of the surface or surfaces with which the context is meant to be used, if necessary make it share resources with other contexts with <a href="qopenglcontext.html#setShareContext">setShareContext</a>(), and finally call <a href="qopenglcontext.html#create">create</a>(). Use the return value or <a href="qopenglcontext.html#isValid">isValid</a>() to check if the context was successfully initialized.</p>
<p>A context can be made current against a given surface by calling <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>(). When OpenGL rendering is done, call <a href="qopenglcontext.html#swapBuffers">swapBuffers</a>() to swap the front and back buffers of the surface, so that the newly rendered content becomes visible. To be able to support certain platforms, <a href="qopenglcontext.html">QOpenGLContext</a> requires that you call <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>() again before starting rendering a new frame, after calling <a href="qopenglcontext.html#swapBuffers">swapBuffers</a>().</p>
<p>If the context is temporarily not needed, such as when the application is not rendering, it can be useful to delete it in order to free resources. You can connect to the <a href="qopenglcontext.html#aboutToBeDestroyed">aboutToBeDestroyed</a>() signal to clean up any resources that have been allocated with different ownership from the <a href="qopenglcontext.html">QOpenGLContext</a> itself.</p>
<p>Once a <a href="qopenglcontext.html">QOpenGLContext</a> has been made current, you can render to it in a platform independent way by using Qt's OpenGL enablers such as <a href="qopenglfunctions.html">QOpenGLFunctions</a>, <a href="qopenglbuffer.html">QOpenGLBuffer</a>, <a href="qopenglshaderprogram.html">QOpenGLShaderProgram</a>, 和 <a href="qopenglframebufferobject.html">QOpenGLFramebufferObject</a>. It is also possible to use the platform's OpenGL API directly, without using the Qt enablers, although potentially at the cost of portability. The latter is necessary when wanting to use OpenGL 1.x or OpenGL ES 1.x&#x2e;</p>
<p>For more information about the OpenGL API, refer to the official <a href="http://www.opengl.org">OpenGL documentation</a>.</p>
<p>For an example of how to use <a href="qopenglcontext.html">QOpenGLContext</a> see the <a href="qtgui-openglwindow-example.html">OpenGL Window</a> example.</p>
<a name="thread-affinity"></a>
<h3 >Thread Affinity</h3>
<p><a href="qopenglcontext.html">QOpenGLContext</a> can be moved to a different thread with <a href="../qtcore/qobject.html#moveToThread">moveToThread</a>(). Do not call <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>() from a different thread than the one to which the <a href="qopenglcontext.html">QOpenGLContext</a> object belongs. A context can only be current in one thread and against one surface at a time, and a thread only has one context current at a time.</p>
<a name="context-resource-sharing"></a>
<h3 >Context Resource Sharing</h3>
<p>Resources, such as framebuffer objects, textures, and vertex buffer objects can be shared between contexts. Use <a href="qopenglcontext.html#setShareContext">setShareContext</a>() before calling <a href="qopenglcontext.html#create">create</a>() to specify that the contexts should share these resources. <a href="qopenglcontext.html">QOpenGLContext</a> internally keeps track of a <a href="qopenglcontextgroup.html">QOpenGLContextGroup</a> object which can be accessed with <a href="qopenglcontext.html#shareGroup">shareGroup</a>(), and which can be used to find all the contexts in a given share group. A share group consists of all contexts that have been successfully initialized and are sharing with an existing context in the share group. A non-sharing context has a share group consisting of a single context.</p>
<a name="default-framebuffer"></a>
<h3 >Default Framebuffer</h3>
<p>On certain platforms, a framebuffer other than 0 might be the default frame buffer depending on the current surface. Instead of calling glBindFramebuffer(0), it is recommended that you use glBindFramebuffer(ctx-&gt;<a href="qopenglcontext.html#defaultFramebufferObject">defaultFramebufferObject</a>()), to ensure that your application is portable between different platforms. However, if you use <a href="qopenglfunctions.html#glBindFramebuffer">QOpenGLFunctions::glBindFramebuffer</a>(), this is done automatically for you.</p>
</div>
<p><b> 参见 </b><a href="qopenglfunctions.html">QOpenGLFunctions</a>, <a href="qopenglbuffer.html">QOpenGLBuffer</a>, <a href="qopenglshaderprogram.html">QOpenGLShaderProgram</a>, 和 <a href="qopenglframebufferobject.html">QOpenGLFramebufferObject</a>.</p>
<!-- @@@QOpenGLContext -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$OpenGLModuleType$$$LibGL$$$LibGLES -->
<h3 class="fn" id="OpenGLModuleType-enum"><a name="OpenGLModuleType-enum"></a>enum QOpenGLContext::<span class="name">OpenGLModuleType</span></h3>
<p>This enum defines the type of the underlying OpenGL implementation.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QOpenGLContext::LibGL</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">OpenGL</td></tr>
<tr><td class="topAlign"><code>QOpenGLContext::LibGLES</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">OpenGL ES 2.0 or higher</td></tr>
</table></div>
<p>这个枚举类型是在Qt 5.3版本中引入或修改的。</p>
<!-- @@@OpenGLModuleType -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QOpenGLContext[overload1]$$$QOpenGLContextQObject* -->
<h3 class="fn" id="QOpenGLContext"><a name="QOpenGLContext"></a>QOpenGLContext::<span class="name">QOpenGLContext</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Creates a new OpenGL context instance with parent object <i>parent</i>.</p>
<p>Before it can be used you need to set the proper format and call <a href="qopenglcontext.html#create">create</a>().</p>
<p><b> 参见 </b><a href="qopenglcontext.html#create">create</a>() 和 <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>().</p>
<!-- @@@QOpenGLContext -->
<!-- $$$~QOpenGLContext[overload1]$$$~QOpenGLContext -->
<h3 class="fn" id="dtor.QOpenGLContext"><a name="dtor.QOpenGLContext"></a><code>[virtual] </code>QOpenGLContext::<span class="name">~QOpenGLContext</span>()</h3>
<p>Destroys the <a href="qopenglcontext.html">QOpenGLContext</a> object.</p>
<p>If this is the current context for the thread, <a href="qopenglcontext.html#doneCurrent">doneCurrent</a>() is also called.</p>
<!-- @@@~QOpenGLContext -->
<!-- $$$aboutToBeDestroyed[overload1]$$$aboutToBeDestroyed -->
<h3 class="fn" id="aboutToBeDestroyed"><a name="aboutToBeDestroyed"></a><code>[signal] </code><span class="type">void</span> QOpenGLContext::<span class="name">aboutToBeDestroyed</span>()</h3>
<p>This signal is emitted before the underlying native OpenGL context is destroyed, such that users may clean up OpenGL resources that might otherwise be left dangling in the case of shared OpenGL contexts.</p>
<p>If you wish to make the context current in order to do clean-up, make sure to only connect to the signal using a direct connection.</p>
<!-- @@@aboutToBeDestroyed -->
<!-- $$$areSharing[overload1]$$$areSharingQOpenGLContext*QOpenGLContext* -->
<h3 class="fn" id="areSharing"><a name="areSharing"></a><code>[static] </code><span class="type">bool</span> QOpenGLContext::<span class="name">areSharing</span>(<span class="type"><a href="qopenglcontext.html#QOpenGLContext">QOpenGLContext</a></span> *<i>first</i>, <span class="type"><a href="qopenglcontext.html#QOpenGLContext">QOpenGLContext</a></span> *<i>second</i>)</h3>
<p>Returns <code>true</code> if the <i>first</i> and <i>second</i> contexts are sharing OpenGL resources.</p>
<!-- @@@areSharing -->
<!-- $$$create[overload1]$$$create -->
<h3 class="fn" id="create"><a name="create"></a><span class="type">bool</span> QOpenGLContext::<span class="name">create</span>()</h3>
<p>Attempts to create the OpenGL context with the current configuration.</p>
<p>The current configuration includes the format, the share context, and the screen.</p>
<p>If the OpenGL implementation on your system does not support the requested version of OpenGL context, then <a href="qopenglcontext.html">QOpenGLContext</a> will try to create the closest matching version. The actual created context properties can be queried using the <a href="qsurfaceformat.html">QSurfaceFormat</a> returned by the <a href="qopenglcontext.html#format">format</a>() function. For example, if you request a context that supports OpenGL 4.3 Core profile but the driver and/or hardware only supports version 3.2 Core profile contexts then you will get a 3.2 Core profile context.</p>
<p>Returns <code>true</code> if the native context was successfully created and is ready to be used with <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>(), <a href="qopenglcontext.html#swapBuffers">swapBuffers</a>(), etc.</p>
<p><b>Note: </b>If the context already exists, this function destroys the existing context first, and then creates a new one.</p><p><b> 参见 </b><a href="qopenglcontext.html#makeCurrent">makeCurrent</a>() 和 <a href="qopenglcontext.html#format">format</a>().</p>
<!-- @@@create -->
<!-- $$$currentContext[overload1]$$$currentContext -->
<h3 class="fn" id="currentContext"><a name="currentContext"></a><code>[static] </code><span class="type"><a href="qopenglcontext.html#QOpenGLContext">QOpenGLContext</a></span> *QOpenGLContext::<span class="name">currentContext</span>()</h3>
<p>Returns the last context which called <a href="qopenglcontext.html#makeCurrent">makeCurrent</a> in the current thread, or 0, if no context is current.</p>
<!-- @@@currentContext -->
<!-- $$$defaultFramebufferObject[overload1]$$$defaultFramebufferObject -->
<h3 class="fn" id="defaultFramebufferObject"><a name="defaultFramebufferObject"></a><span class="type">GLuint</span> QOpenGLContext::<span class="name">defaultFramebufferObject</span>() const</h3>
<p>Call this to get the default framebuffer object for the current surface.</p>
<p>On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0. Thus, instead of calling glBindFramebuffer(0), you should call glBindFramebuffer(ctx-&gt;defaultFramebufferObject()) if you want your application to work across different Qt platforms.</p>
<p>If you use the glBindFramebuffer() in <a href="qopenglfunctions.html">QOpenGLFunctions</a> you do not have to worry about this, as it automatically binds the current context's defaultFramebufferObject() when 0 is passed.</p>
<p><b>Note: </b>Widgets that render via framebuffer objects, like <a href="../qtwidgets/qopenglwidget.html">QOpenGLWidget</a> 和 <a href="../qtquick/qquickwidget.html">QQuickWidget</a>, will override the value returned from this function when painting is active, because at that time the correct &quot;default&quot; framebuffer is the widget's associated backing framebuffer, not the platform-specific one belonging to the top-level window's surface. This ensures the expected behavior for this function and other classes relying on it (for example, <a href="qopenglframebufferobject.html#bindDefault">QOpenGLFramebufferObject::bindDefault</a>() or <a href="qopenglframebufferobject.html#release">QOpenGLFramebufferObject::release</a>()).</p><p><b> 参见 </b><a href="qopenglframebufferobject.html">QOpenGLFramebufferObject</a>.</p>
<!-- @@@defaultFramebufferObject -->
<!-- $$$doneCurrent[overload1]$$$doneCurrent -->
<h3 class="fn" id="doneCurrent"><a name="doneCurrent"></a><span class="type">void</span> QOpenGLContext::<span class="name">doneCurrent</span>()</h3>
<p>Convenience function for calling <a href="qopenglcontext.html#makeCurrent">makeCurrent</a> with a 0 surface.</p>
<p>This results in no context being current in the current thread.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#makeCurrent">makeCurrent</a>() 和 <a href="qopenglcontext.html#currentContext">currentContext</a>().</p>
<!-- @@@doneCurrent -->
<!-- $$$extensions[overload1]$$$extensions -->
<h3 class="fn" id="extensions"><a name="extensions"></a><span class="type"><a href="../qtcore/qset.html">QSet</a></span>&lt;<span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span>&gt; QOpenGLContext::<span class="name">extensions</span>() const</h3>
<p>Returns the set of OpenGL extensions supported by this context.</p>
<p>The context or a sharing context must be current.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#hasExtension">hasExtension</a>().</p>
<!-- @@@extensions -->
<!-- $$$extraFunctions[overload1]$$$extraFunctions -->
<h3 class="fn" id="extraFunctions"><a name="extraFunctions"></a><span class="type"><a href="qopenglextrafunctions.html">QOpenGLExtraFunctions</a></span> *QOpenGLContext::<span class="name">extraFunctions</span>() const</h3>
<p>Get the <a href="qopenglextrafunctions.html">QOpenGLExtraFunctions</a> instance for this context.</p>
<p><a href="qopenglcontext.html">QOpenGLContext</a> offers this as a convenient way to access <a href="qopenglextrafunctions.html">QOpenGLExtraFunctions</a> without having to manage it manually.</p>
<p>The context or a sharing context must be current.</p>
<p>The returned <a href="qopenglextrafunctions.html">QOpenGLExtraFunctions</a> instance is ready to be used and it does not need initializeOpenGLFunctions() to be called.</p>
<p><b>Note: </b><a href="qopenglextrafunctions.html">QOpenGLExtraFunctions</a> contains functionality that is not guaranteed to be available at runtime. Runtime availability depends on the platform, graphics driver, and the OpenGL version requested by the application.</p><p><b> 参见 </b><a href="qopenglfunctions.html">QOpenGLFunctions</a> 和 <a href="qopenglextrafunctions.html">QOpenGLExtraFunctions</a>.</p>
<!-- @@@extraFunctions -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" id="format"><a name="format"></a><span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span> QOpenGLContext::<span class="name">format</span>() const</h3>
<p>Returns the format of the underlying platform context, if <a href="qopenglcontext.html#create">create</a>() has been called.</p>
<p>Otherwise, returns the requested format.</p>
<p>The requested and the actual format may differ. Requesting a given OpenGL version does not mean the resulting context will target exactly the requested version. It is only guaranteed that the version/profile/options combination for the created context is compatible with the request, as long as the driver is able to provide such a context.</p>
<p>For example, requesting an OpenGL version 3.x core profile context may result in an OpenGL 4.x core profile context. Similarly, a request for OpenGL 2.1 may result in an OpenGL 3.0 context with deprecated functions enabled. Finally, depending on the driver, unsupported versions may result in either a context creation failure or in a context for the highest supported version.</p>
<p>Similar differences are possible in the buffer sizes, for example, the resulting context may have a larger depth buffer than requested. This is perfectly normal.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#setFormat">setFormat</a>().</p>
<!-- @@@format -->
<!-- $$$functions[overload1]$$$functions -->
<h3 class="fn" id="functions"><a name="functions"></a><span class="type"><a href="qopenglfunctions.html">QOpenGLFunctions</a></span> *QOpenGLContext::<span class="name">functions</span>() const</h3>
<p>Get the <a href="qopenglfunctions.html">QOpenGLFunctions</a> instance for this context.</p>
<p><a href="qopenglcontext.html">QOpenGLContext</a> offers this as a convenient way to access <a href="qopenglfunctions.html">QOpenGLFunctions</a> without having to manage it manually.</p>
<p>The context or a sharing context must be current.</p>
<p>The returned <a href="qopenglfunctions.html">QOpenGLFunctions</a> instance is ready to be used and it does not need initializeOpenGLFunctions() to be called.</p>
<!-- @@@functions -->
<!-- $$$getProcAddress[overload1]$$$getProcAddressconstQByteArray& -->
<h3 class="fn" id="getProcAddress"><a name="getProcAddress"></a><span class="type"><a href="../qtcore/qtglobal.html#QFunctionPointer-typedef">QFunctionPointer</a></span> QOpenGLContext::<span class="name">getProcAddress</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>procName</i>) const</h3>
<p>Resolves the function pointer to an OpenGL extension function, identified by <i>procName</i></p>
<p>Returns 0 if no such function can be found.</p>
<!-- @@@getProcAddress -->
<!-- $$$getProcAddress$$$getProcAddressconstchar* -->
<h3 class="fn" id="getProcAddress-1"><a name="getProcAddress-1"></a><span class="type"><a href="../qtcore/qtglobal.html#QFunctionPointer-typedef">QFunctionPointer</a></span> QOpenGLContext::<span class="name">getProcAddress</span>(const <span class="type">char</span> *<i>procName</i>) const</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.8版本中新增引入的。</p>
<!-- @@@getProcAddress -->
<!-- $$$globalShareContext[overload1]$$$globalShareContext -->
<h3 class="fn" id="globalShareContext"><a name="globalShareContext"></a><code>[static] </code><span class="type"><a href="qopenglcontext.html#QOpenGLContext">QOpenGLContext</a></span> *QOpenGLContext::<span class="name">globalShareContext</span>()</h3>
<p>Returns the application-wide shared OpenGL context, if present. Otherwise, returns a null pointer.</p>
<p>This is useful if you need to upload OpenGL objects (buffers, textures, etc.) before creating or showing a <a href="../qtwidgets/qopenglwidget.html">QOpenGLWidget</a> or <a href="../qtquick/qquickwidget.html">QQuickWidget</a>.</p>
<p><b>Note: </b>You must set the <a href="../qtcore/qt.html#ApplicationAttribute-enum">Qt::AA_ShareOpenGLContexts</a> flag on <a href="qguiapplication.html">QGuiApplication</a> before creating the <a href="qguiapplication.html">QGuiApplication</a> object, otherwise Qt may not create a global shared context.</p><p><b>Warning:</b> Do not attempt to make the context returned by this function current on any surface. Instead, you can create a new context which shares with the global one, and then make the new context current.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="../qtcore/qt.html#ApplicationAttribute-enum">Qt::AA_ShareOpenGLContexts</a>, <a href="qopenglcontext.html#setShareContext">setShareContext</a>(), 和 <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>().</p>
<!-- @@@globalShareContext -->
<!-- $$$hasExtension[overload1]$$$hasExtensionconstQByteArray& -->
<h3 class="fn" id="hasExtension"><a name="hasExtension"></a><span class="type">bool</span> QOpenGLContext::<span class="name">hasExtension</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>extension</i>) const</h3>
<p>Returns <code>true</code> if this OpenGL context supports the specified OpenGL <i>extension</i>, <code>false</code> otherwise.</p>
<p>The context or a sharing context must be current.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#extensions">extensions</a>().</p>
<!-- @@@hasExtension -->
<!-- $$$isOpenGLES[overload1]$$$isOpenGLES -->
<h3 class="fn" id="isOpenGLES"><a name="isOpenGLES"></a><span class="type">bool</span> QOpenGLContext::<span class="name">isOpenGLES</span>() const</h3>
<p>Returns true if the context is an OpenGL ES context.</p>
<p>If the context has not yet been created, the result is based on the requested format set via <a href="qopenglcontext.html#setFormat">setFormat</a>().</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qopenglcontext.html#create">create</a>(), <a href="qopenglcontext.html#format">format</a>(), 和 <a href="qopenglcontext.html#setFormat">setFormat</a>().</p>
<!-- @@@isOpenGLES -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid"><a name="isValid"></a><span class="type">bool</span> QOpenGLContext::<span class="name">isValid</span>() const</h3>
<p>Returns if this context is valid, i.e&#x2e; has been successfully created.</p>
<p>On some platforms the return value of <code>false</code> for a context that was successfully created previously indicates that the OpenGL context was lost.</p>
<p>The typical way to handle context loss scenarios in applications is to check via this function whenever <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>() fails and returns <code>false</code>. If this function then returns <code>false</code>, recreate the underlying native OpenGL context by calling <a href="qopenglcontext.html#create">create</a>(), call <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>() again and then reinitialize all OpenGL resources.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#create">create</a>().</p>
<!-- @@@isValid -->
<!-- $$$makeCurrent[overload1]$$$makeCurrentQSurface* -->
<h3 class="fn" id="makeCurrent"><a name="makeCurrent"></a><span class="type">bool</span> QOpenGLContext::<span class="name">makeCurrent</span>(<span class="type"><a href="qsurface.html">QSurface</a></span> *<i>surface</i>)</h3>
<p>Makes the context current in the current thread, against the given <i>surface</i>. Returns <code>true</code> if successful; otherwise returns <code>false</code>. The latter may happen if the surface is not exposed, or the graphics hardware is not available due to e.g&#x2e; the application being suspended.</p>
<p>If <i>surface</i> is 0 this is equivalent to calling <a href="qopenglcontext.html#doneCurrent">doneCurrent</a>().</p>
<p>Avoid calling this function from a different thread than the one the <a href="qopenglcontext.html">QOpenGLContext</a> instance lives in. If you wish to use <a href="qopenglcontext.html">QOpenGLContext</a> from a different thread you should first make sure it's not current in the current thread, by calling <a href="qopenglcontext.html#doneCurrent">doneCurrent</a>() if necessary. Then call <a href="../qtcore/qobject.html#moveToThread">moveToThread</a>(otherThread) before using it in the other thread.</p>
<p>By default Qt employs a check that enforces the above condition on the thread affinity. It is still possible to disable this check by setting the <code>Qt::AA_DontCheckOpenGLContextThreadAffinity</code> application attribute. Be sure to understand the consequences of using QObjects from outside the thread they live in, as explained in the <a href="../qtcore/qobject.html#thread-affinity">QObject thread affinity</a> documentation.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#functions">functions</a>(), <a href="qopenglcontext.html#doneCurrent">doneCurrent</a>(), 和 <a href="../qtcore/qt.html#ApplicationAttribute-enum">Qt::AA_DontCheckOpenGLContextThreadAffinity</a>.</p>
<!-- @@@makeCurrent -->
<!-- $$$nativeHandle[overload1]$$$nativeHandle -->
<h3 class="fn" id="nativeHandle"><a name="nativeHandle"></a><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QOpenGLContext::<span class="name">nativeHandle</span>() const</h3>
<p>Returns the native handle for the context.</p>
<p>This function provides access to the <a href="qopenglcontext.html">QOpenGLContext</a>'s underlying native context. The returned variant contains a platform-specific value type. These classes can be found in the module <a href="../qtplatformheaders/qtplatformheaders-module.html">QtPlatformHeaders</a>.</p>
<p>On platforms where retrieving the native handle is not supported, or if neither <a href="qopenglcontext.html#create">create</a>() nor <a href="qopenglcontext.html#setNativeHandle">setNativeHandle</a>() was called, a null variant is returned.</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qopenglcontext.html#setNativeHandle">setNativeHandle</a>().</p>
<!-- @@@nativeHandle -->
<!-- $$$openGLModuleHandle[overload1]$$$openGLModuleHandle -->
<h3 class="fn" id="openGLModuleHandle"><a name="openGLModuleHandle"></a><code>[static] </code><span class="type">void</span> *QOpenGLContext::<span class="name">openGLModuleHandle</span>()</h3>
<p>Returns the platform-specific handle for the OpenGL implementation that is currently in use. (for example, a HMODULE on Windows)</p>
<p>On platforms that do not use dynamic GL switch the return value is null.</p>
<p>The library might be GL-only, meaning that windowing system interface functions (for example EGL) may live in another, separate library.</p>
<p><b>Note: </b>This function requires that the <a href="qguiapplication.html">QGuiApplication</a> instance is already created.</p><p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qopenglcontext.html#openGLModuleType">openGLModuleType</a>().</p>
<!-- @@@openGLModuleHandle -->
<!-- $$$openGLModuleType[overload1]$$$openGLModuleType -->
<h3 class="fn" id="openGLModuleType"><a name="openGLModuleType"></a><code>[static] </code><span class="type"><a href="qopenglcontext.html#OpenGLModuleType-enum">QOpenGLContext::OpenGLModuleType</a></span> QOpenGLContext::<span class="name">openGLModuleType</span>()</h3>
<p>Returns the underlying OpenGL implementation type.</p>
<p>On platforms where the OpenGL implementation is not dynamically loaded, the return value is determined during compile time and never changes.</p>
<p><b>Note: </b>A desktop OpenGL implementation may be capable of creating ES-compatible contexts too. Therefore in most cases it is more appropriate to check <a href="qsurfaceformat.html#renderableType">QSurfaceFormat::renderableType</a>() or use the convenience function <a href="qopenglcontext.html#isOpenGLES">isOpenGLES</a>().</p><p><b>Note: </b>This function requires that the <a href="qguiapplication.html">QGuiApplication</a> instance is already created.</p><p>这个函数是在Qt 5.3版本中新增引入的。</p>
<!-- @@@openGLModuleType -->
<!-- $$$screen[overload1]$$$screen -->
<h3 class="fn" id="screen"><a name="screen"></a><span class="type"><a href="qscreen.html">QScreen</a></span> *QOpenGLContext::<span class="name">screen</span>() const</h3>
<p>Returns the screen the context was created for.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#setScreen">setScreen</a>().</p>
<!-- @@@screen -->
<!-- $$$setFormat[overload1]$$$setFormatconstQSurfaceFormat& -->
<h3 class="fn" id="setFormat"><a name="setFormat"></a><span class="type">void</span> QOpenGLContext::<span class="name">setFormat</span>(const <span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span> &amp;<i>format</i>)</h3>
<p>Sets the <i>format</i> the OpenGL context should be compatible with. You need to call <a href="qopenglcontext.html#create">create</a>() before it takes effect.</p>
<p>When the format is not explicitly set via this function, the format returned by <a href="qsurfaceformat.html#defaultFormat">QSurfaceFormat::defaultFormat</a>() will be used. This means that when having multiple contexts, individual calls to this function can be replaced by one single call to <a href="qsurfaceformat.html#setDefaultFormat">QSurfaceFormat::setDefaultFormat</a>() before creating the first context.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#format">format</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setNativeHandle[overload1]$$$setNativeHandleconstQVariant& -->
<h3 class="fn" id="setNativeHandle"><a name="setNativeHandle"></a><span class="type">void</span> QOpenGLContext::<span class="name">setNativeHandle</span>(const <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> &amp;<i>handle</i>)</h3>
<p>Set the native handles for this context. When <a href="qopenglcontext.html#create">create</a>() is called and a native handle is set, configuration settings, like <a href="qopenglcontext.html#format">format</a>(), are ignored since this <a href="qopenglcontext.html">QOpenGLContext</a> will wrap an already created native context instead of creating a new one from scratch.</p>
<p>On some platforms the native context handle is not sufficient and other related handles (for example, for a window or display) have to be provided in addition. Therefore <i>handle</i> is variant containing a platform-specific value type. These classes can be found in the <a href="../qtplatformheaders/qtplatformheaders-module.html">QtPlatformHeaders</a> module.</p>
<p>When <a href="qopenglcontext.html#create">create</a>() is called with native handles set, <a href="qopenglcontext.html">QOpenGLContext</a> does not take ownership of the handles, so destroying the <a href="qopenglcontext.html">QOpenGLContext</a> does not destroy the native context.</p>
<p><b>Note: </b>Some frameworks track the current context and surfaces internally. Making the adopted <a href="qopenglcontext.html">QOpenGLContext</a> current via Qt will have no effect on such other frameworks' internal state. Therefore a subsequent <a href="qopenglcontext.html#makeCurrent">makeCurrent</a> done via the other framework may have no effect. It is therefore advisable to make explicit calls to make no context and surface current to reset the other frameworks' internal state after performing OpenGL operations via Qt.</p><p><b>Note: </b>Using foreign contexts with Qt windows and Qt contexts with windows and surfaces created by other frameworks may give unexpected results, depending on the platform, due to potential mismatches in context and window pixel formats. To make sure this does not happen, avoid making contexts and surfaces from different frameworks current together. Instead, prefer approaches based on context sharing where OpenGL resources like textures are accessible both from Qt's and the foreign framework's contexts.</p><p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qopenglcontext.html#nativeHandle">nativeHandle</a>().</p>
<!-- @@@setNativeHandle -->
<!-- $$$setScreen[overload1]$$$setScreenQScreen* -->
<h3 class="fn" id="setScreen"><a name="setScreen"></a><span class="type">void</span> QOpenGLContext::<span class="name">setScreen</span>(<span class="type"><a href="qscreen.html">QScreen</a></span> *<i>screen</i>)</h3>
<p>Sets the <i>screen</i> the OpenGL context should be valid for. You need to call <a href="qopenglcontext.html#create">create</a>() before it takes effect.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#screen">screen</a>().</p>
<!-- @@@setScreen -->
<!-- $$$setShareContext[overload1]$$$setShareContextQOpenGLContext* -->
<h3 class="fn" id="setShareContext"><a name="setShareContext"></a><span class="type">void</span> QOpenGLContext::<span class="name">setShareContext</span>(<span class="type"><a href="qopenglcontext.html#QOpenGLContext">QOpenGLContext</a></span> *<i>shareContext</i>)</h3>
<p>Makes this context share textures, shaders, and other OpenGL resources with <i>shareContext</i>. You need to call <a href="qopenglcontext.html#create">create</a>() before it takes effect.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#shareContext">shareContext</a>().</p>
<!-- @@@setShareContext -->
<!-- $$$shareContext[overload1]$$$shareContext -->
<h3 class="fn" id="shareContext"><a name="shareContext"></a><span class="type"><a href="qopenglcontext.html#QOpenGLContext">QOpenGLContext</a></span> *QOpenGLContext::<span class="name">shareContext</span>() const</h3>
<p>Returns the share context this context was created with.</p>
<p>If the underlying platform was not able to support the requested sharing, this will return 0.</p>
<p><b> 参见 </b><a href="qopenglcontext.html#setShareContext">setShareContext</a>().</p>
<!-- @@@shareContext -->
<!-- $$$shareGroup[overload1]$$$shareGroup -->
<h3 class="fn" id="shareGroup"><a name="shareGroup"></a><span class="type"><a href="qopenglcontextgroup.html">QOpenGLContextGroup</a></span> *QOpenGLContext::<span class="name">shareGroup</span>() const</h3>
<p>Returns the share group this context belongs to.</p>
<!-- @@@shareGroup -->
<!-- $$$supportsThreadedOpenGL[overload1]$$$supportsThreadedOpenGL -->
<h3 class="fn" id="supportsThreadedOpenGL"><a name="supportsThreadedOpenGL"></a><code>[static] </code><span class="type">bool</span> QOpenGLContext::<span class="name">supportsThreadedOpenGL</span>()</h3>
<p>Returns <code>true</code> if the platform supports OpenGL rendering outside the main (gui) thread.</p>
<p>The value is controlled by the platform plugin in use and may also depend on the graphics drivers.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@supportsThreadedOpenGL -->
<!-- $$$surface[overload1]$$$surface -->
<h3 class="fn" id="surface"><a name="surface"></a><span class="type"><a href="qsurface.html">QSurface</a></span> *QOpenGLContext::<span class="name">surface</span>() const</h3>
<p>Returns the surface the context has been made current with.</p>
<p>This is the surface passed as an argument to <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>().</p>
<!-- @@@surface -->
<!-- $$$swapBuffers[overload1]$$$swapBuffersQSurface* -->
<h3 class="fn" id="swapBuffers"><a name="swapBuffers"></a><span class="type">void</span> QOpenGLContext::<span class="name">swapBuffers</span>(<span class="type"><a href="qsurface.html">QSurface</a></span> *<i>surface</i>)</h3>
<p>Swap the back and front buffers of <i>surface</i>.</p>
<p>Call this to finish a frame of OpenGL rendering, and make sure to call <a href="qopenglcontext.html#makeCurrent">makeCurrent</a>() again before issuing any further OpenGL commands, for example as part of a new frame.</p>
<!-- @@@swapBuffers -->
<!-- $$$versionFunctions[overload1]$$$versionFunctionsconstQOpenGLVersionProfile& -->
<h3 class="fn" id="versionFunctions"><a name="versionFunctions"></a><span class="type"><a href="qabstractopenglfunctions.html">QAbstractOpenGLFunctions</a></span> *QOpenGLContext::<span class="name">versionFunctions</span>(const <span class="type"><a href="qopenglversionprofile.html">QOpenGLVersionProfile</a></span> &amp;<i>versionProfile</i> = QOpenGLVersionProfile()) const</h3>
<p>Returns a pointer to an object that provides access to all functions for the <i>versionProfile</i> of this context. There is no need to call QAbstractOpenGLFunctions::initializeOpenGLFunctions() as long as this context is current. It is also possible to call this function when the context is not current, but in that case it is the caller's responsibility to ensure proper initialization by calling QAbstractOpenGLFunctions::initializeOpenGLFunctions() afterwards.</p>
<p>Usually one would use the template version of this function to automatically have the result cast to the correct type.</p>
<!-- @@@versionFunctions -->
<!-- $$$versionFunctions$$$versionFunctions -->
<h3 class="fn" id="versionFunctions-1"><a name="versionFunctions-1"></a><span class="type">TYPE</span> *QOpenGLContext::<span class="name">versionFunctions</span>() const</h3>
<p>This function overloads versionFunctions().</p>
<p>Returns a pointer to an object that provides access to all functions for the version and profile of this context. There is no need to call QAbstractOpenGLFunctions::initializeOpenGLFunctions() as long as this context is current. It is also possible to call this function when the context is not current, but in that case it is the caller's responsibility to ensure proper initialization by calling QAbstractOpenGLFunctions::initializeOpenGLFunctions() afterwards.</p>
<p>Usually one would use the template version of this function to automatically have the result cast to the correct type.</p>
<pre class="cpp">

  QOpenGLFunctions_3_3_Core<span class="operator">*</span> funcs <span class="operator">=</span> <span class="number">0</span>;
  funcs <span class="operator">=</span> context<span class="operator">-</span><span class="operator">&gt;</span>versionFunctions<span class="operator">&lt;</span>QOpenGLFunctions_3_3_Core<span class="operator">&gt;</span>();
  <span class="keyword">if</span> (<span class="operator">!</span>funcs) {
      <a href="../qtcore/qtglobal.html#qWarning">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Could not obtain required OpenGL context version&quot;</span>;
      exit(<span class="number">1</span>);
  }

</pre>
<p>It is possible to request a functions object for a different version and profile than that for which the context was created. To do this either use the template version of this function specifying the desired functions object type as the template parameter or by passing in a <a href="qopenglversionprofile.html">QOpenGLVersionProfile</a> object as an argument to the non-template function.</p>
<p>Note that requests for function objects of other versions or profiles can fail and in doing so will return a null pointer. Situations in which creation of the functions object can fail are if the request cannot be satisfied due to asking for functions that are not in the version or profile of this context. For example:</p>
<ul>
<li>Requesting a 3.3 core profile functions object would succeed.</li>
<li>Requesting a 3.3 compatibility profile functions object would fail. We would fail to resolve the deprecated functions.</li>
<li>Requesting a 4.3 core profile functions object would fail. We would fail to resolve the new core functions introduced in versions 4.0-4.3&#x2e;</li>
<li>Requesting a 3.1 functions object would succeed. There is nothing in 3.1 that is not also in 3.3 core.</li>
</ul>
<p>Note that if creating a functions object via this method that the <a href="qopenglcontext.html">QOpenGLContext</a> retains ownership of the object. This is to allow the object to be cached and shared.</p>
<!-- @@@versionFunctions -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
