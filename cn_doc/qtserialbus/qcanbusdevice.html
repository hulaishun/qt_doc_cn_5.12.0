<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qcanbusdevice.cpp -->
  <title>QCanBusDevice Class | Qt Serial Bus 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtserialbus-index.html">Qt串行总线</a></td><td ><a href="qtserialbus-module.html">C++类</a></td><td >QCanBusDevice</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#protected-functions">保护函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QCanBusDevice Class</h1>
<!-- $$$QCanBusDevice-brief -->
<p>The <a href="qcanbusdevice.html">QCanBusDevice</a> class is the interface class for CAN bus. <a href="#details">More...</a></p>
<!-- @@@QCanBusDevice -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QCanBusDevice&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += serialbus</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.8</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html">QObject</a></td></tr></table></div><ul>
<li><a href="qcanbusdevice-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qcanbusdevice-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice-filter.html">Filter</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#CanBusDeviceState-enum">CanBusDeviceState</a></b> { UnconnectedState, ConnectingState, ConnectedState, ClosingState }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#CanBusError-enum">CanBusError</a></b> { NoError, ReadError, WriteError, ConnectionError, ConfigurationError, UnknownError }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#ConfigurationKey-enum">ConfigurationKey</a></b> { RawFilterKey, ErrorFilterKey, LoopbackKey, ReceiveOwnKey, ..., UserKey }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#Direction-enum">Direction</a></b> { Input, Output, AllDirections }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#Direction-enum">Directions</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#QCanBusDevice">QCanBusDevice</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#clear">clear</a></b>(QCanBusDevice::Directions <i>direction</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;int&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#configurationKeys">configurationKeys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#configurationParameter">configurationParameter</a></b>(int <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#connectDevice">connectDevice</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#disconnectDevice">disconnectDevice</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCanBusDevice::CanBusError </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#error">error</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#errorString">errorString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#framesAvailable">framesAvailable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#framesToWrite">framesToWrite</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QString </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#interpretErrorFrame">interpretErrorFrame</a></b>(const QCanBusFrame &amp;<i>frame</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QCanBusFrame&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#readAllFrames">readAllFrames</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCanBusFrame </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#readFrame">readFrame</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#setConfigurationParameter">setConfigurationParameter</a></b>(int <i>key</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCanBusDevice::CanBusDeviceState </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#state">state</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#waitForFramesReceived">waitForFramesReceived</a></b>(int <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#waitForFramesWritten">waitForFramesWritten</a></b>(int <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#writeFrame">writeFrame</a></b>(const QCanBusFrame &amp;<i>frame</i>) = 0</td></tr>
</table></div>
<ul>
<li class="fn">31 public functions inherited from <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#errorOccurred">errorOccurred</a></b>(<i>QCanBusDevice::CanBusError</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#framesReceived">framesReceived</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#framesWritten">framesWritten</a></b>(qint64 <i>framesCount</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#stateChanged">stateChanged</a></b>(QCanBusDevice::CanBusDeviceState <i>state</i>)</td></tr>
</table></div>
<ul>
<li class="fn">2 signals inherited from <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">9 static public members inherited from <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="protected-functions"></a>
<h2 id="protected-functions">保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#close">close</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCanBusFrame </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#dequeueOutgoingFrame">dequeueOutgoingFrame</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#enqueueOutgoingFrame">enqueueOutgoingFrame</a></b>(const QCanBusFrame &amp;<i>newFrame</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#enqueueReceivedFrames">enqueueReceivedFrames</a></b>(const QVector&lt;QCanBusFrame&gt; &amp;<i>newFrames</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#hasOutgoingFrames">hasOutgoingFrames</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#open">open</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#setError">setError</a></b>(const QString &amp;<i>errorText</i>, QCanBusDevice::CanBusError <i>errorId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#setState">setState</a></b>(QCanBusDevice::CanBusDeviceState <i>newState</i>)</td></tr>
</table></div>
<ul>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
<li class="fn">1 public slot inherited from <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 public variable inherited from <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">2 protected variables inherited from <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QCanBusDevice-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qcanbusdevice.html">QCanBusDevice</a> class is the interface class for CAN bus.</p>
<p><a href="qcanbusdevice.html">QCanBusDevice</a> communicates with a CAN plugin providing users with a convenient API. The CAN plugin must be specified during the object creation.</p>
</div>
<!-- @@@QCanBusDevice -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$CanBusDeviceState$$$UnconnectedState$$$ConnectingState$$$ConnectedState$$$ClosingState -->
<h3 class="fn" id="CanBusDeviceState-enum"><a name="CanBusDeviceState-enum"></a>enum QCanBusDevice::<span class="name">CanBusDeviceState</span></h3>
<p>This enum describes all possible device states.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QCanBusDevice::UnconnectedState</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">The device is disconnected.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::ConnectingState</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">The device is being connected.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::ConnectedState</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">The device is connected to the CAN bus.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::ClosingState</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">The device is being closed.</td></tr>
</table></div>
<!-- @@@CanBusDeviceState -->
<!-- $$$CanBusError$$$NoError$$$ReadError$$$WriteError$$$ConnectionError$$$ConfigurationError$$$UnknownError -->
<h3 class="fn" id="CanBusError-enum"><a name="CanBusError-enum"></a>enum QCanBusDevice::<span class="name">CanBusError</span></h3>
<p>This enum describes all the possible error conditions.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QCanBusDevice::NoError</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">No errors have occurred.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::ReadError</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">An error occurred during a read operation.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::WriteError</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">An error occurred during a write operation.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::ConnectionError</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">An error occurred when attempting to open the plugin.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::ConfigurationError</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">An error occurred when attempting to set a configuration parameter.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::UnknownError</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">An unknown error occurred.</td></tr>
</table></div>
<!-- @@@CanBusError -->
<!-- $$$ConfigurationKey$$$RawFilterKey$$$ErrorFilterKey$$$LoopbackKey$$$ReceiveOwnKey$$$BitRateKey$$$CanFdKey$$$DataBitRateKey$$$UserKey -->
<h3 class="fn" id="ConfigurationKey-enum"><a name="ConfigurationKey-enum"></a>enum QCanBusDevice::<span class="name">ConfigurationKey</span></h3>
<p>This enum describes the possible configuration options for the CAN bus connection.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QCanBusDevice::RawFilterKey</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">This configuration determines the type of CAN bus frames that the current device accepts. The expected value is <code>QList&lt;QCanBusDevice::Filter&gt;</code>. Passing an empty list clears all previously set filters including default filters. For more details see <a href="qcanbusdevice-filter.html">QCanBusDevice::Filter</a>.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::ErrorFilterKey</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">This key defines the type of error that should be forwarded via the current connection. The associated value should be of type <a href="qcanbusframe.html#FrameError-enum">QCanBusFrame::FrameErrors</a>.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::LoopbackKey</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">This key defines whether the CAN bus device should operate in loopback mode. Loopback means, whenever a CAN frame is transmitted on the CAN bus, a local echo of this frame is sent to all applications connected to this CAN device. The expected value for this key is <code>bool</code>.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::ReceiveOwnKey</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">This key defines whether this CAN device receives its own send frames. This can be used to check if the transmission was successful. The expected value for this key is <code>bool</code>.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::BitRateKey</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">This key defines the CAN bitrate in bits per second. With CAN FD, the payload can be transmitted at a higher data bitrate, if <a href="qcanbusframe.html#hasBitrateSwitch">QCanBusFrame::hasBitrateSwitch</a>() is set. In this case, <code>QCanBusDevice::BitRateKey</code> is only used for the CAN ID arbitration phase. See also <code>QCanBusDevice::DataBitRateKey</code></td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::CanFdKey</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">This key defines whether sending and receiving of CAN FD frames should be enabled. The expected value for this key is <code>bool</code>.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::DataBitRateKey</code></td><td class="topAlign tblval"><code>6</code></td><td class="topAlign">This key defines the CAN FD payload bitrate in bits per second. CAN FD allows to transmit the payload of frames with <a href="qcanbusframe.html#hasBitrateSwitch">QCanBusFrame::hasBitrateSwitch</a>() flag at a higher data bitrate, after the arbitration phase at the nominal bitrate is finished. This enum value was introduced in Qt 5.9&#x2e; See also <code>QCanBusDevice::BitRateKey</code></td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::UserKey</code></td><td class="topAlign tblval"><code>30</code></td><td class="topAlign">This key defines the range where custom keys start. Its most common purpose is to permit platform-specific configuration options.</td></tr>
</table></div>
<p><b> 参见 </b><a href="qcanbusdevice.html#configurationParameter">configurationParameter</a>().</p>
<!-- @@@ConfigurationKey -->
<!-- $$$Direction$$$Input$$$Output$$$AllDirections -->
<h3 class="flags" id="Direction-enum"><a name="Direction-enum"></a>enum QCanBusDevice::<span class="name">Direction</span><br/>flags QCanBusDevice::<span class="name">Directions</span></h3>
<p>This enum describes possible data transmission directions.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QCanBusDevice::Input</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">Input direction.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::Output</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">Output direction.</td></tr>
<tr><td class="topAlign"><code>QCanBusDevice::AllDirections</code></td><td class="topAlign tblval"><code>Input | Output</code></td><td class="topAlign">Both directions, input and output.</td></tr>
</table></div>
<p>This enum was introduced or modified in  Qt 5.12.</p>
<p>The Directions type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Direction&gt;. It stores an OR combination of Direction values.</p>
<!-- @@@Direction -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QCanBusDevice[overload1]$$$QCanBusDeviceQObject* -->
<h3 class="fn" id="QCanBusDevice"><a name="QCanBusDevice"></a>QCanBusDevice::<span class="name">QCanBusDevice</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a serial bus device with the specified <i>parent</i>.</p>
<!-- @@@QCanBusDevice -->
<!-- $$$clear[overload1]$$$clearQCanBusDevice::Directions -->
<h3 class="fn" id="clear"><a name="clear"></a><span class="type">void</span> QCanBusDevice::<span class="name">clear</span>(<span class="type"><a href="qcanbusdevice.html#Direction-enum">QCanBusDevice::Directions</a></span> <i>direction</i>)</h3>
<p>Clears the devices input or output buffers, depending on <i>direction</i>.</p>
<p>This function only operates on <a href="qcanbusdevice.html">QCanBusDevice</a> buffers. Frames that are already written to the CAN driver or CAN hardware layer, or that are not yet read from these layers, are not cleared by this function.</p>
<p><b>Note: </b>Clearing the output buffers is only possible for buffered devices.</p><p>这个函数是在Qt 5.12版本中新增引入的。</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#framesAvailable">framesAvailable</a>(), <a href="qcanbusdevice.html#readFrame">readFrame</a>(), <a href="qcanbusdevice.html#framesToWrite">framesToWrite</a>(), 和 <a href="qcanbusdevice.html#writeFrame">writeFrame</a>().</p>
<!-- @@@clear -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" id="close"><a name="close"></a><code>[pure virtual protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">close</span>()</h3>
<p>This function is responsible for closing the CAN bus connection. The implementation must ensure that the instance's <a href="qcanbusdevice.html#state">state</a>() is set to <a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::UnconnectedState</a>.</p>
<p>This function's most important task is to close the socket to the CAN device and to call <a href="qcanbusdevice.html#setState">QCanBusDevice::setState</a>().</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#disconnectDevice">disconnectDevice</a>().</p>
<!-- @@@close -->
<!-- $$$configurationKeys[overload1]$$$configurationKeys -->
<h3 class="fn" id="configurationKeys"><a name="configurationKeys"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type">int</span>&gt; QCanBusDevice::<span class="name">configurationKeys</span>() const</h3>
<p>Returns the list of keys used by the CAN bus connection.</p>
<p>The the meaning of the keys is equivalent to <a href="qcanbusdevice.html#ConfigurationKey-enum">ConfigurationKey</a>. If a key is not explicitly mentioned the platform's default setting for the relevant key is used.</p>
<!-- @@@configurationKeys -->
<!-- $$$configurationParameter[overload1]$$$configurationParameterint -->
<h3 class="fn" id="configurationParameter"><a name="configurationParameter"></a><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QCanBusDevice::<span class="name">configurationParameter</span>(<span class="type">int</span> <i>key</i>) const</h3>
<p>Returns the current value assigned to the <a href="qcanbusdevice.html#ConfigurationKey-enum">ConfigurationKey</a> <i>key</i>; otherwise an invalid <a href="../qtcore/qvariant.html">QVariant</a>.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#setConfigurationParameter">setConfigurationParameter</a>() 和 <a href="qcanbusdevice.html#configurationKeys">configurationKeys</a>().</p>
<!-- @@@configurationParameter -->
<!-- $$$connectDevice[overload1]$$$connectDevice -->
<h3 class="fn" id="connectDevice"><a name="connectDevice"></a><span class="type">bool</span> QCanBusDevice::<span class="name">connectDevice</span>()</h3>
<p>Connects the device to the CAN bus. Returns <code>true</code> on success; otherwise <code>false</code>.</p>
<p>This function calls <a href="qcanbusdevice.html#open">open</a>() as part of its implementation.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#disconnectDevice">disconnectDevice</a>().</p>
<!-- @@@connectDevice -->
<!-- $$$dequeueOutgoingFrame[overload1]$$$dequeueOutgoingFrame -->
<h3 class="fn" id="dequeueOutgoingFrame"><a name="dequeueOutgoingFrame"></a><code>[protected] </code><span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> QCanBusDevice::<span class="name">dequeueOutgoingFrame</span>()</h3>
<p>Returns the next <a href="qcanbusframe.html">QCanBusFrame</a> from the internal list of outgoing frames; otherwise returns an invalid <a href="qcanbusframe.html">QCanBusFrame</a>. The returned frame is removed from the internal list.</p>
<!-- @@@dequeueOutgoingFrame -->
<!-- $$$disconnectDevice[overload1]$$$disconnectDevice -->
<h3 class="fn" id="disconnectDevice"><a name="disconnectDevice"></a><span class="type">void</span> QCanBusDevice::<span class="name">disconnectDevice</span>()</h3>
<p>Disconnects the device from the CAN bus.</p>
<p>This function calls <a href="qcanbusdevice.html#close">close</a>() as part of its implementation.</p>
<p><b>Note: </b>This function should only be called, if <a href="qcanbusdevice.html#connectDevice">connectDevice</a>() returned <code>true</code>.</p><p><b> 参见 </b><a href="qcanbusdevice.html#connectDevice">connectDevice</a>().</p>
<!-- @@@disconnectDevice -->
<!-- $$$enqueueOutgoingFrame[overload1]$$$enqueueOutgoingFrameconstQCanBusFrame& -->
<h3 class="fn" id="enqueueOutgoingFrame"><a name="enqueueOutgoingFrame"></a><code>[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">enqueueOutgoingFrame</span>(const <span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> &amp;<i>newFrame</i>)</h3>
<p>Appends <i>newFrame</i> to the internal list of outgoing frames which can be accessed by <a href="qcanbusdevice.html#writeFrame">writeFrame</a>().</p>
<p>Subclasses must call this function when they write a new frame.</p>
<!-- @@@enqueueOutgoingFrame -->
<!-- $$$enqueueReceivedFrames[overload1]$$$enqueueReceivedFramesconstQVector<QCanBusFrame>& -->
<h3 class="fn" id="enqueueReceivedFrames"><a name="enqueueReceivedFrames"></a><code>[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">enqueueReceivedFrames</span>(const <span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span>&gt; &amp;<i>newFrames</i>)</h3>
<p>Appends <i>newFrames</i> to the internal list of frames which can be accessed using <a href="qcanbusdevice.html#readFrame">readFrame</a>() and emits the <a href="qcanbusdevice.html#framesReceived">framesReceived</a>() signal.</p>
<p>Subclasses must call this function when they receive frames.</p>
<!-- @@@enqueueReceivedFrames -->
<!-- $$$error[overload1]$$$error -->
<h3 class="fn" id="error"><a name="error"></a><span class="type"><a href="qcanbusdevice.html#CanBusError-enum">QCanBusDevice::CanBusError</a></span> QCanBusDevice::<span class="name">error</span>() const</h3>
<p>Returns the last error that has occurred. The error value is always set to last error that occurred and it is never reset.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#setError">setError</a>() 和 <a href="qcanbusdevice.html#errorString">errorString</a>().</p>
<!-- @@@error -->
<!-- $$$errorOccurred[overload1]$$$errorOccurredQCanBusDevice::CanBusError -->
<h3 class="fn" id="errorOccurred"><a name="errorOccurred"></a><code>[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">errorOccurred</span>(<i>QCanBusDevice::CanBusError</i>)</h3>
<p>This signal is emitted when an error occurs.</p>
<!-- @@@errorOccurred -->
<!-- $$$errorString[overload1]$$$errorString -->
<h3 class="fn" id="errorString"><a name="errorString"></a><span class="type"><a href="../qtcore/qstring.html">QString</a></span> QCanBusDevice::<span class="name">errorString</span>() const</h3>
<p>Returns a human-readable description of the last device error that occurred.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#error">error</a>().</p>
<!-- @@@errorString -->
<!-- $$$framesAvailable[overload1]$$$framesAvailable -->
<h3 class="fn" id="framesAvailable"><a name="framesAvailable"></a><span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> QCanBusDevice::<span class="name">framesAvailable</span>() const</h3>
<p>Returns the number of available frames. If no frames are available, this function returns 0.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#clear">clear</a>(), <a href="qcanbusdevice.html#readFrame">readFrame</a>(), 和 <a href="qcanbusdevice.html#readAllFrames">readAllFrames</a>().</p>
<!-- @@@framesAvailable -->
<!-- $$$framesReceived[overload1]$$$framesReceived -->
<h3 class="fn" id="framesReceived"><a name="framesReceived"></a><code>[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">framesReceived</span>()</h3>
<p>This signal is emitted when one or more frames have been received. The frames should be read using <a href="qcanbusdevice.html#readFrame">readFrame</a>() 和 <a href="qcanbusdevice.html#framesAvailable">framesAvailable</a>().</p>
<!-- @@@framesReceived -->
<!-- $$$framesToWrite[overload1]$$$framesToWrite -->
<h3 class="fn" id="framesToWrite"><a name="framesToWrite"></a><span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> QCanBusDevice::<span class="name">framesToWrite</span>() const</h3>
<p>For buffered devices, this function returns the number of frames waiting to be written. For unbuffered devices, this function always returns zero.</p>
<p><b>Note: </b>There may be additional buffering in the CAN driver and CAN hardware layer. Therefore, if this function returns zero, that does not mean all CAN frames are already written to the CAN bus.</p><p><b> 参见 </b><a href="qcanbusdevice.html#clear">clear</a>() 和 <a href="qcanbusdevice.html#writeFrame">writeFrame</a>().</p>
<!-- @@@framesToWrite -->
<!-- $$$framesWritten[overload1]$$$framesWrittenqint64 -->
<h3 class="fn" id="framesWritten"><a name="framesWritten"></a><code>[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">framesWritten</span>(<span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> <i>framesCount</i>)</h3>
<p>This signal is emitted every time a payload of frames has been written to the CAN bus. The <i>framesCount</i> argument is set to the number of frames that were written in this payload.</p>
<!-- @@@framesWritten -->
<!-- $$$hasOutgoingFrames[overload1]$$$hasOutgoingFrames -->
<h3 class="fn" id="hasOutgoingFrames"><a name="hasOutgoingFrames"></a><code>[protected] </code><span class="type">bool</span> QCanBusDevice::<span class="name">hasOutgoingFrames</span>() const</h3>
<p>Returns <code>true</code> if the internal list of outgoing frames is not empty; otherwise returns <code>false</code>.</p>
<!-- @@@hasOutgoingFrames -->
<!-- $$$interpretErrorFrame[overload1]$$$interpretErrorFrameconstQCanBusFrame& -->
<h3 class="fn" id="interpretErrorFrame"><a name="interpretErrorFrame"></a><code>[pure virtual] </code><span class="type"><a href="../qtcore/qstring.html">QString</a></span> QCanBusDevice::<span class="name">interpretErrorFrame</span>(const <span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> &amp;<i>frame</i>)</h3>
<p>Interprets <i>frame</i> as error frame and returns a human readable description of the error.</p>
<p>If <i>frame</i> is not an error frame, the returned string is empty.</p>
<!-- @@@interpretErrorFrame -->
<!-- $$$open[overload1]$$$open -->
<h3 class="fn" id="open"><a name="open"></a><code>[pure virtual protected] </code><span class="type">bool</span> QCanBusDevice::<span class="name">open</span>()</h3>
<p>This function is called by <a href="qcanbusdevice.html#connectDevice">connectDevice</a>(). Subclasses must provide an implementation which returns <code>true</code> if the CAN bus connection could be established; otherwise <code>false</code>. The <a href="qcanbusdevice.html">QCanBusDevice</a> implementation ensures upon entry of this function that the device's <a href="qcanbusdevice.html#state">state</a>() is set to <a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::ConnectingState</a> already.</p>
<p>The implementation must ensure that upon success the instance's <a href="qcanbusdevice.html#state">state</a>() is set to <a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::ConnectedState</a>; otherwise <a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::UnconnectedState</a>. <a href="qcanbusdevice.html#setState">setState</a>() must be used to set the new device state.</p>
<p>The custom implementation is responsible for opening the socket, instanciation of a potentially required <a href="../qtcore/qsocketnotifier.html">QSocketNotifier</a> and the application of custom and default <a href="qcanbusdevice.html#configurationParameter">QCanBusDevice::configurationParameter</a>().</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#connectDevice">connectDevice</a>().</p>
<!-- @@@open -->
<!-- $$$readAllFrames[overload1]$$$readAllFrames -->
<h3 class="fn" id="readAllFrames"><a name="readAllFrames"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span>&gt; QCanBusDevice::<span class="name">readAllFrames</span>()</h3>
<p>Returns all <a href="qcanbusframe.html">QCanBusFrame</a>s from the queue; otherwise returns an empty <a href="../qtcore/qvector.html">QVector</a>. The returned frames are removed from the queue.</p>
<p>The queue operates according to the FIFO principle.</p>
<p>这个函数是在Qt 5.12版本中新增引入的。</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#clear">clear</a>(), <a href="qcanbusdevice.html#framesAvailable">framesAvailable</a>(), 和 <a href="qcanbusdevice.html#readFrame">readFrame</a>().</p>
<!-- @@@readAllFrames -->
<!-- $$$readFrame[overload1]$$$readFrame -->
<h3 class="fn" id="readFrame"><a name="readFrame"></a><span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> QCanBusDevice::<span class="name">readFrame</span>()</h3>
<p>Returns the next <a href="qcanbusframe.html">QCanBusFrame</a> from the queue; otherwise returns an empty <a href="qcanbusframe.html">QCanBusFrame</a>. The returned frame is removed from the queue.</p>
<p>The queue operates according to the FIFO principle.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#clear">clear</a>(), <a href="qcanbusdevice.html#framesAvailable">framesAvailable</a>(), 和 <a href="qcanbusdevice.html#readAllFrames">readAllFrames</a>().</p>
<!-- @@@readFrame -->
<!-- $$$setConfigurationParameter[overload1]$$$setConfigurationParameterintconstQVariant& -->
<h3 class="fn" id="setConfigurationParameter"><a name="setConfigurationParameter"></a><code>[virtual] </code><span class="type">void</span> QCanBusDevice::<span class="name">setConfigurationParameter</span>(<span class="type">int</span> <i>key</i>, const <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Sets the configuration parameter <i>key</i> for the CAN bus connection to <i>value</i>. The potential keys are represented by <a href="qcanbusdevice.html#ConfigurationKey-enum">ConfigurationKey</a>.</p>
<p>A parameter can be unset by setting an invalid <a href="../qtcore/qvariant.html">QVariant</a>. Unsetting a parameter implies that the configuration is reset to its default setting.</p>
<p><b>Note: </b>In most cases, configuration changes only take effect after a reconnect.</p><p><b> 参见 </b><a href="qcanbusdevice.html#configurationParameter">configurationParameter</a>().</p>
<!-- @@@setConfigurationParameter -->
<!-- $$$setError[overload1]$$$setErrorconstQString&QCanBusDevice::CanBusError -->
<h3 class="fn" id="setError"><a name="setError"></a><code>[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">setError</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>errorText</i>, <span class="type"><a href="qcanbusdevice.html#CanBusError-enum">QCanBusDevice::CanBusError</a></span> <i>errorId</i>)</h3>
<p>Sets the human readable description of the last device error to <i>errorText</i>. <i>errorId</i> categorizes the type of error.</p>
<p>CAN bus implementations must use this function to update the device's error state.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#error">error</a>() 和 <a href="qcanbusdevice.html#errorOccurred">errorOccurred</a>().</p>
<!-- @@@setError -->
<!-- $$$setState[overload1]$$$setStateQCanBusDevice::CanBusDeviceState -->
<h3 class="fn" id="setState"><a name="setState"></a><code>[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">setState</span>(<span class="type"><a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::CanBusDeviceState</a></span> <i>newState</i>)</h3>
<p>Sets the state of the device to <i>newState</i>. CAN bus implementations must use this function to update the device state.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#state">state</a>().</p>
<!-- @@@setState -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn" id="state"><a name="state"></a><span class="type"><a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::CanBusDeviceState</a></span> QCanBusDevice::<span class="name">state</span>() const</h3>
<p>Returns the current state of the device.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#setState">setState</a>() 和 <a href="qcanbusdevice.html#stateChanged">stateChanged</a>().</p>
<!-- @@@state -->
<!-- $$$stateChanged[overload1]$$$stateChangedQCanBusDevice::CanBusDeviceState -->
<h3 class="fn" id="stateChanged"><a name="stateChanged"></a><code>[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">stateChanged</span>(<span class="type"><a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::CanBusDeviceState</a></span> <i>state</i>)</h3>
<p>This signal is emitted every time the state of the device changes. The new state is represented by <i>state</i>.</p>
<p><b> 参见 </b><a href="qcanbusdevice.html#setState">setState</a>() 和 <a href="qcanbusdevice.html#state">state</a>().</p>
<!-- @@@stateChanged -->
<!-- $$$waitForFramesReceived[overload1]$$$waitForFramesReceivedint -->
<h3 class="fn" id="waitForFramesReceived"><a name="waitForFramesReceived"></a><code>[virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">waitForFramesReceived</span>(<span class="type">int</span> <i>msecs</i>)</h3>
<p>Blocks until new frames are available for reading and the <a href="qcanbusdevice.html#framesReceived">framesReceived</a>() signal has been emitted, or until <i>msecs</i> milliseconds have passed. If <i>msecs</i> is <code>-1</code>, this function will not time out.</p>
<p>Returns <code>true</code> if new frames are available for reading and the <a href="qcanbusdevice.html#framesReceived">framesReceived</a>() signal is emitted; otherwise returns <code>false</code> (if the operation timed out or if an error occurred).</p>
<p><b>Note: </b>This function will start a local event loop. This may lead to scenarios whereby other application slots may be called while the execution of this function scope is blocking. To avoid problems, the signals for this class should not be connected to slots. Similarly this function must never be called in response to the <a href="qcanbusdevice.html#framesReceived">framesReceived</a>() or <a href="qcanbusdevice.html#errorOccurred">errorOccurred</a>() signals.</p><p><b> 参见 </b><a href="qcanbusdevice.html#waitForFramesWritten">waitForFramesWritten</a>().</p>
<!-- @@@waitForFramesReceived -->
<!-- $$$waitForFramesWritten[overload1]$$$waitForFramesWrittenint -->
<h3 class="fn" id="waitForFramesWritten"><a name="waitForFramesWritten"></a><code>[virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">waitForFramesWritten</span>(<span class="type">int</span> <i>msecs</i>)</h3>
<p>For buffered devices, this function waits until all buffered frames have been written to the device and the <a href="qcanbusdevice.html#framesWritten">framesWritten</a>() signal has been emitted, or until <i>msecs</i> milliseconds have passed. If <i>msecs</i> is -1, this function will not time out. For unbuffered devices, it returns immediately with <code>false</code> as <a href="qcanbusdevice.html#writeFrame">writeFrame</a>() does not require a write buffer.</p>
<p>Returns <code>true</code> if the <a href="qcanbusdevice.html#framesWritten">framesWritten</a>() signal is emitted; otherwise returns <code>false</code> (i.e&#x2e; if the operation timed out, or if an error occurred).</p>
<p><b>Note: </b>This function will start a local event loop. This may lead to scenarios whereby other application slots may be called while the execution of this function scope is blocking. To avoid problems, the signals for this class should not be connected to slots. Similarly this function must never be called in response to the <a href="qcanbusdevice.html#framesWritten">framesWritten</a>() or <a href="qcanbusdevice.html#errorOccurred">errorOccurred</a>() signals.</p><p><b> 参见 </b><a href="qcanbusdevice.html#waitForFramesReceived">waitForFramesReceived</a>().</p>
<!-- @@@waitForFramesWritten -->
<!-- $$$writeFrame[overload1]$$$writeFrameconstQCanBusFrame& -->
<h3 class="fn" id="writeFrame"><a name="writeFrame"></a><code>[pure virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">writeFrame</span>(const <span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> &amp;<i>frame</i>)</h3>
<p>Writes <i>frame</i> to the CAN bus and returns <code>true</code> on success; otherwise <code>false</code>.</p>
<p>On some platforms, the frame may be put into a queue and the return value may only indicate a successful insertion into the queue. The actual frame will be send later on. Therefore the <a href="qcanbusdevice.html#framesWritten">framesWritten</a>() signal is the final confirmation that the frame has been handed off to the transport layer. If an error occurs the <a href="qcanbusdevice.html#errorOccurred">errorOccurred</a>() is emitted.</p>
<p>As per CAN bus specification, frames of type <a href="qcanbusframe.html#FrameType-enum">remote transfer request (RTR)</a> do not have a payload, but a length from 0 to 8 (including). This length indicates the expected response payload length from the remote party. Therefore when sending a RTR frame using this function it may still be required to set an arbitrary payload on <i>frame</i>. The length of the arbitrary payload is what is set as size expectation for the RTR frame.</p>
<p><b> 参见 </b><a href="qcanbusframe.html#setPayload">QCanBusFrame::setPayload</a>().</p>
<!-- @@@writeFrame -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
