<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qmodbusserver.cpp -->
  <title>QModbusServer Class | Qt Serial Bus 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtserialbus-index.html">Qt串行总线</a></td><td ><a href="qtserialbus-module.html">C++类</a></td><td >QModbusServer</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#protected-functions">保护函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QModbusServer Class</h1>
<!-- $$$QModbusServer-brief -->
<p>The <a href="qmodbusserver.html">QModbusServer</a> class is the interface to receive and process Modbus requests. <a href="#details">More...</a></p>
<!-- @@@QModbusServer -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QModbusServer&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += serialbus</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.8</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="qmodbusdevice.html">QModbusDevice</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的子类有：</td><td class="memItemRight bottomAlign"> <p><a href="qmodbusrtuserialslave.html">QModbusRtuSerialSlave</a> 和 <a href="qmodbustcpserver.html">QModbusTcpServer</a></p>
</td></tr></table></div><ul>
<li><a href="qmodbusserver-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qmodbusserver-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#Option-enum">选项</a></b> { DiagnosticRegister, ExceptionStatusOffset, DeviceBusy, AsciiInputDelimiter, ..., UserOption }</td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#QModbusServer">QModbusServer</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#data">data</a></b>(QModbusDataUnit *<i>newData</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#data-1">data</a></b>(QModbusDataUnit::RegisterType <i>table</i>, quint16 <i>address</i>, quint16 *<i>data</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#processesBroadcast">processesBroadcast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#serverAddress">serverAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setData">setData</a></b>(const QModbusDataUnit &amp;<i>newData</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setData-1">setData</a></b>(QModbusDataUnit::RegisterType <i>table</i>, quint16 <i>address</i>, quint16 <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setMap">setMap</a></b>(const QModbusDataUnitMap &amp;<i>map</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setServerAddress">setServerAddress</a></b>(int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setValue">setValue</a></b>(int <i>option</i>, const QVariant &amp;<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#value">value</a></b>(int <i>option</i>) const</td></tr>
</table></div>
<ul>
<li class="fn">7 个公共函数继承于 <a href="qmodbusdevice.html#public-functions">QModbusDevice</a></li>
<li class="fn">31 个公共函数继承于 <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#dataWritten">dataWritten</a></b>(QModbusDataUnit::RegisterType <i>table</i>, int <i>address</i>, int <i>size</i>)</td></tr>
</table></div>
<ul>
<li class="fn">2 个信号继承于 <a href="qmodbusdevice.html#signals">QModbusDevice</a></li>
<li class="fn">2 个信号继承于 <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">1 个静态公共成员继承于 <a href="qmodbusdevice.html#static-public-members">QModbusDevice</a></li>
<li class="fn">9 个静态公共成员继承于 <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="protected-functions"></a>
<h2 id="protected-functions">保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QModbusResponse </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#processPrivateRequest">processPrivateRequest</a></b>(const QModbusPdu &amp;<i>request</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QModbusResponse </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#processRequest">processRequest</a></b>(const QModbusPdu &amp;<i>request</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#readData">readData</a></b>(QModbusDataUnit *<i>newData</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#writeData">writeData</a></b>(const QModbusDataUnit &amp;<i>newData</i>)</td></tr>
</table></div>
<ul>
<li class="fn">4 个保护函数继承于 <a href="qmodbusdevice.html#protected-functions">QModbusDevice</a></li>
<li class="fn">9 个保护函数继承于 <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
</ul>
<h3>其他继承成员有</h3>
<ul>
<li class="fn">1 个属性继承于 <a href="../qtcore/qobject.html#properties">QObject</a></li>
<li class="fn">1 个公共槽函数继承于 <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 个公共变量继承于 <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">2 个保护变量继承于 <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QModbusServer-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qmodbusserver.html">QModbusServer</a> class is the interface to receive and process Modbus requests.</p>
<p>Modbus networks can have multiple Modbus servers. Modbus Servers are read/written by a Modbus client represented by <a href="qmodbusclient.html">QModbusClient</a>. <a href="qmodbusserver.html">QModbusServer</a> communicates with a Modbus backend, providing users with a convenient API.</p>
</div>
<!-- @@@QModbusServer -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$Option$$$DiagnosticRegister$$$ExceptionStatusOffset$$$DeviceBusy$$$AsciiInputDelimiter$$$ListenOnlyMode$$$ServerIdentifier$$$RunIndicatorStatus$$$AdditionalData$$$DeviceIdentification$$$UserOption -->
<h3 class="fn" id="Option-enum"><a name="Option-enum"></a>enum QModbusServer::<span class="name">选项</span></h3>
<p>Each Modbus server has a set of values associated with it, each with its own option.</p>
<p>The general purpose options (and the associated types) are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QModbusServer::DiagnosticRegister</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">The diagnostic register of the server. <code>quint16</code></td></tr>
<tr><td class="topAlign"><code>QModbusServer::ExceptionStatusOffset</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">The exception status byte offset of the server. <code>quint16</code></td></tr>
<tr><td class="topAlign"><code>QModbusServer::DeviceBusy</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">Flag to signal the server is engaged in processing a long-duration program command. <code>quint16</code></td></tr>
<tr><td class="topAlign"><code>QModbusServer::AsciiInputDelimiter</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">The Modbus ASCII end of message delimiter. <code>char</code></td></tr>
<tr><td class="topAlign"><code>QModbusServer::ListenOnlyMode</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">Flag to set listen only mode of the server. This function is typically supported only by Modbus serial devices. <code>bool</code></td></tr>
<tr><td class="topAlign"><code>QModbusServer::ServerIdentifier</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">The identifier of the server, <b>not</b> the server address. <code>quint8</code></td></tr>
<tr><td class="topAlign"><code>QModbusServer::RunIndicatorStatus</code></td><td class="topAlign tblval"><code>6</code></td><td class="topAlign">The run indicator of the server. <code>quint8</code></td></tr>
<tr><td class="topAlign"><code>QModbusServer::AdditionalData</code></td><td class="topAlign tblval"><code>7</code></td><td class="topAlign">The additional data of the server. <code>QByteArray</code></td></tr>
<tr><td class="topAlign"><code>QModbusServer::DeviceIdentification</code></td><td class="topAlign tblval"><code>8</code></td><td class="topAlign">The physical and functional description of the server. <code>QModbusDeviceIdentification</code></td></tr>
</table></div>
<p>User options:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="even"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QModbusServer::UserOption</code></td><td class="topAlign tblval"><code>0x100</code></td><td class="topAlign">The first option that can be used for user-specific purposes.</td></tr>
</table></div>
<p>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</p>
<!-- @@@Option -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QModbusServer[overload1]$$$QModbusServerQObject* -->
<h3 class="fn" id="QModbusServer"><a name="QModbusServer"></a>QModbusServer::<span class="name">QModbusServer</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a Modbus server with the specified <i>parent</i>.</p>
<!-- @@@QModbusServer -->
<!-- $$$data[overload1]$$$dataQModbusDataUnit* -->
<h3 class="fn" id="data"><a name="data"></a><span class="type">bool</span> QModbusServer::<span class="name">data</span>(<span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> *<i>newData</i>) const</h3>
<p>Returns the values in the register range given by <i>newData</i>.</p>
<p><i>newData</i> must provide a valid register type, start address and valueCount. The returned <i>newData</i> will contain the register values associated with the given range.</p>
<p>If <i>newData</i> contains a valid register type but a negative start address the entire register map is returned and <i>newData</i> appropriately sized.</p>
<p><b> 参见 </b><a href="qmodbusserver.html#setData">setData</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$dataQModbusDataUnit::RegisterTypequint16quint16* -->
<h3 class="fn" id="data-1"><a name="data-1"></a><span class="type">bool</span> QModbusServer::<span class="name">data</span>(<span class="type"><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a></span> <i>table</i>, <span class="type"><a href="../qtcore/qtglobal.html#quint16-typedef">quint16</a></span> <i>address</i>, <span class="type"><a href="../qtcore/qtglobal.html#quint16-typedef">quint16</a></span> *<i>data</i>) const</h3>
<p>Reads data stored in the Modbus server. A Modbus server has four tables (<i>table</i>) and each have a unique <i>address</i> field, which is used to read <i>data</i> from the desired field. See <a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a> for more information about the different tables. Returns <code>false</code> if address is outside of the map range or the register type is not even defined.</p>
<p><b> 参见 </b><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a> 和 <a href="qmodbusserver.html#setData">setData</a>().</p>
<!-- @@@data -->
<!-- $$$dataWritten[overload1]$$$dataWrittenQModbusDataUnit::RegisterTypeintint -->
<h3 class="fn" id="dataWritten"><a name="dataWritten"></a><code>[signal] </code><span class="type">void</span> QModbusServer::<span class="name">dataWritten</span>(<span class="type"><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a></span> <i>table</i>, <span class="type">int</span> <i>address</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>This signal is emitted when a Modbus client has written one or more fields of data to the Modbus server. The signal contains information about the fields that were written:</p>
<ul>
<li>Register type (<i>table</i>) that was written,</li>
<li><i>address</i> of the first field that was written,</li>
<li>and <i>size</i> of consecutive fields that were written starting from <i>address</i>.</li>
</ul>
<p>The signal is not emitted when the to-be-written fields have not changed due to no change in value.</p>
<!-- @@@dataWritten -->
<!-- $$$processPrivateRequest[overload1]$$$processPrivateRequestconstQModbusPdu& -->
<h3 class="fn" id="processPrivateRequest"><a name="processPrivateRequest"></a><code>[virtual protected] </code><span class="type"><a href="qmodbusresponse.html">QModbusResponse</a></span> QModbusServer::<span class="name">processPrivateRequest</span>(const <span class="type"><a href="qmodbuspdu.html">QModbusPdu</a></span> &amp;<i>request</i>)</h3>
<p>This function should be implemented by custom Modbus servers. It is called by <a href="qmodbusserver.html#processRequest">processRequest</a>() if the given <i>request</i> is not a standard Modbus request.</p>
<p>Overwriting this function allows handling of additional function codes and subfunction-codes not specified in the Modbus Application Protocol Specification 1.1b. Reimplementations should call this function again to ensure an exception response is returned for all unknown function codes the custom Modbus implementation does not handle.</p>
<p>This default implementation returns a <code>QModbusExceptionResponse</code> with the <i>request</i> function code and error code set to illegal function.</p>
<p><b> 参见 </b><a href="qmodbusserver.html#processRequest">processRequest</a>().</p>
<!-- @@@processPrivateRequest -->
<!-- $$$processRequest[overload1]$$$processRequestconstQModbusPdu& -->
<h3 class="fn" id="processRequest"><a name="processRequest"></a><code>[virtual protected] </code><span class="type"><a href="qmodbusresponse.html">QModbusResponse</a></span> QModbusServer::<span class="name">processRequest</span>(const <span class="type"><a href="qmodbuspdu.html">QModbusPdu</a></span> &amp;<i>request</i>)</h3>
<p>Processes a Modbus client <i>request</i> and returns a Modbus response. This function returns a <a href="qmodbusresponse.html">QModbusResponse</a> or <a href="qmodbusexceptionresponse.html">QModbusExceptionResponse</a> depending on the nature of the request.</p>
<p>The default implementation of this function handles all standard Modbus function codes as defined by the Modbus Application Protocol Specification 1.1b. All other Modbus function codes not included in the specification are forwarded to <a href="qmodbusserver.html#processPrivateRequest">processPrivateRequest</a>().</p>
<p>The default handling of the standard Modbus function code requests can be overwritten by reimplementing this function. The override must handle the request type in question and return the appropriate <a href="qmodbusresponse.html">QModbusResponse</a>. A common reason might be to filter out function code requests for data values to limit read/write access and function codes not desired in particular implementations such as serial line diagnostics on ethernet or Modbus Plus transport layers. Every other request type should be forwarded to this default implementation.</p>
<p><b>Note: </b>This function should not be overridden to provide a custom implementation for non-standard Modbus request types.</p><p><b> 参见 </b><a href="qmodbusserver.html#processPrivateRequest">processPrivateRequest</a>().</p>
<!-- @@@processRequest -->
<!-- $$$processesBroadcast[overload1]$$$processesBroadcast -->
<h3 class="fn" id="processesBroadcast"><a name="processesBroadcast"></a><code>[virtual] </code><span class="type">bool</span> QModbusServer::<span class="name">processesBroadcast</span>() const</h3>
<p>Subclasses should implement this function if the transport layer shall handle broadcasts. The implementation then should return <code>true</code> if the currently processed request is a broadcast request; otherwise <code>false</code>. The default implementation returns always <code>false</code>.</p>
<p><b>Note: </b>The return value of this function only makes sense from within <a href="qmodbusserver.html#processRequest">processRequest</a>() or <a href="qmodbusserver.html#processPrivateRequest">processPrivateRequest</a>(), otherwise it can only tell that the last request processed was a broadcast request.</p><!-- @@@processesBroadcast -->
<!-- $$$readData[overload1]$$$readDataQModbusDataUnit* -->
<h3 class="fn" id="readData"><a name="readData"></a><code>[virtual protected] </code><span class="type">bool</span> QModbusServer::<span class="name">readData</span>(<span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> *<i>newData</i>) const</h3>
<p>Reads the values in the register range given by <i>newData</i> and writes the data back to <i>newData</i>. Returns <code>true</code> on success or <code>false</code> if <i>newData</i> is <code>0</code>, the <i>newData</i> range is outside of the map range or the registerType() does not exist.</p>
<p><b>Note: </b>Sub-classes that implement reading from a different backing store then default one, also need to implement <a href="qmodbusserver.html#setMap">setMap</a>() 和 <a href="qmodbusserver.html#writeData">writeData</a>().</p><p><b> 参见 </b><a href="qmodbusserver.html#setMap">setMap</a>() 和 <a href="qmodbusserver.html#writeData">writeData</a>().</p>
<!-- @@@readData -->
<!-- $$$serverAddress[overload1]$$$serverAddress -->
<h3 class="fn" id="serverAddress"><a name="serverAddress"></a><span class="type">int</span> QModbusServer::<span class="name">serverAddress</span>() const</h3>
<p>Returns the address of this Mobus server instance.</p>
<p><b> 参见 </b><a href="qmodbusserver.html#setServerAddress">setServerAddress</a>().</p>
<!-- @@@serverAddress -->
<!-- $$$setData[overload1]$$$setDataconstQModbusDataUnit& -->
<h3 class="fn" id="setData"><a name="setData"></a><span class="type">bool</span> QModbusServer::<span class="name">setData</span>(const <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> &amp;<i>newData</i>)</h3>
<p>Writes <i>newData</i> to the Modbus server map. Returns <code>false</code> if the <i>newData</i> range is outside of the map range.</p>
<p>If the call was successful the <a href="qmodbusserver.html#dataWritten">dataWritten</a>() signal is emitted. Note that the signal is not emitted when the addressed register has not changed. This may happen when <i>newData</i> contains exactly the same values as the register already. Nevertheless this function returns <code>true</code> in such cases.</p>
<p><b> 参见 </b><a href="qmodbusserver.html#data">data</a>().</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataQModbusDataUnit::RegisterTypequint16quint16 -->
<h3 class="fn" id="setData-1"><a name="setData-1"></a><span class="type">bool</span> QModbusServer::<span class="name">setData</span>(<span class="type"><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a></span> <i>table</i>, <span class="type"><a href="../qtcore/qtglobal.html#quint16-typedef">quint16</a></span> <i>address</i>, <span class="type"><a href="../qtcore/qtglobal.html#quint16-typedef">quint16</a></span> <i>data</i>)</h3>
<p>Writes data to the Modbus server. A Modbus server has four tables (<i>table</i>) and each have a unique <i>address</i> field, which is used to write <i>data</i> to the desired field. Returns <code>false</code> if address outside of the map range.</p>
<p>If the call was successful the <a href="qmodbusserver.html#dataWritten">dataWritten</a>() signal is emitted. Note that the signal is not emitted when <i>data</i> has not changed. Nevertheless this function returns <code>true</code> in such cases.</p>
<p><b> 参见 </b><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a>, <a href="qmodbusserver.html#data">data</a>(), 和 <a href="qmodbusserver.html#dataWritten">dataWritten</a>().</p>
<!-- @@@setData -->
<!-- $$$setMap[overload1]$$$setMapconstQModbusDataUnitMap& -->
<h3 class="fn" id="setMap"><a name="setMap"></a><code>[virtual] </code><span class="type">bool</span> QModbusServer::<span class="name">setMap</span>(const <span class="type"><a href="qmodbusdataunit.html#QModbusDataUnitMap-typedef">QModbusDataUnitMap</a></span> &amp;<i>map</i>)</h3>
<p>Sets the registered map structure for requests from other ModBus clients to <i>map</i>. The register values are initialized with zero. Returns <code>true</code> on success; otherwise <code>false</code>.</p>
<p>If this function is not called before connecting, a default register with zero entries is setup.</p>
<p><b>Note: </b>Calling this function discards any register value that was previously set.</p><!-- @@@setMap -->
<!-- $$$setServerAddress[overload1]$$$setServerAddressint -->
<h3 class="fn" id="setServerAddress"><a name="setServerAddress"></a><span class="type">void</span> QModbusServer::<span class="name">setServerAddress</span>(<span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sets the address for this Modbus server instance to <i>serverAddress</i>.</p>
<p><b> 参见 </b><a href="qmodbusserver.html#serverAddress">serverAddress</a>().</p>
<!-- @@@setServerAddress -->
<!-- $$$setValue[overload1]$$$setValueintconstQVariant& -->
<h3 class="fn" id="setValue"><a name="setValue"></a><code>[virtual] </code><span class="type">bool</span> QModbusServer::<span class="name">setValue</span>(<span class="type">int</span> <i>option</i>, const <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> &amp;<i>newValue</i>)</h3>
<p>Sets the <i>newValue</i> for <i>option</i> and returns <code>true</code> on success; <code>false</code> otherwise.</p>
<p><b>Note: </b>If the option's associated type is <code>quint8</code> or <code>quint16</code> and the type of <i>newValue</i> is larger, the data will be truncated or conversation will fail.</p><div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Key</th><th >描述</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::DiagnosticRegister</a></td><td >Sets the diagnostic register of the server in a device specific encoding to <i>newValue</i>. The default value preset is <code>0x0000</code>. The bit values of the register need device specific documentation.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::ExceptionStatusOffset</a></td><td >Sets the exception status byte offset of the server to <i>newValue</i> which is the absolute offset address in the coils (0x register). Modbus register table starting with <code>0x0000h</code>. The default value preset is <code>0x0000</code>, using the exception status coils similar to Modicon 984 CPUs (coils 1-8).<p>The function returns <code>true</code> if the coils register contains the 8 bits required for storing and retrieving the status coils, otherwise <code>false</code>.</p>
</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::DeviceBusy</a></td><td >Sets a flag that signals that the server is engaged in processing a long-duration program command. Valid values are <code>0x0000</code> (not busy) and <code>0xffff</code> (busy). The default value preset is <code>0x0000</code>.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::AsciiInputDelimiter</a></td><td >The <i>newValue</i> becomes the end of message delimiter for future Modbus ASCII messages. The default value preset is <code>\n</code>.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::ListenOnlyMode</a></td><td >Ss the server's listen only state to <i>newValue</i>. If listen only mode is set to <code>true</code>, messages are monitored but no response will be sent. The default value preset is <code>false</code>.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::ServerIdentifier</a></td><td >Sets the server's manufacturer identifier to <i>newValue</i>. Possible values are in the range of <code>0x00</code> to 0xff. The default value preset is <code>0x0a</code>.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::RunIndicatorStatus</a></td><td >Sets the servers' run indicator status to <i>newValue</i>. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum">QModbusPdu::ReportServerId</a> function code. Valid values are <code>0x00</code> (OFF) and <code>0xff</code> (ON). The default value preset is <code>0xff</code> (ON).</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::AdditionalData</a></td><td >Sets the server's additional data to <i>newValue</i>. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum">QModbusPdu::ReportServerId</a> function code. The maximum data size cannot exceed 249 bytes to match response message size restrictions. The default value preset is <code>Qt Modbus Server</code>.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::DeviceIdentification</a></td><td >Sets the server's physical and functional description. By default there is no additional device identification data set.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::UserOption</a></td><td >Sets the value of a user option to <i>newValue</i>.<p><b>Note: </b>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</p></td></tr>
</table></div>
<p><b> 参见 </b><a href="qmodbusserver.html#value">value</a>().</p>
<!-- @@@setValue -->
<!-- $$$value[overload1]$$$valueint -->
<h3 class="fn" id="value"><a name="value"></a><code>[virtual] </code><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QModbusServer::<span class="name">value</span>(<span class="type">int</span> <i>option</i>) const</h3>
<p>Returns the value for <i>option</i> or an invalid <code>QVariant</code> if the option is not set.</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >选项</th><th >描述</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::DiagnosticRegister</a></td><td >Returns the diagnostic register value of the server. The diagnostic register contains device specific contents where each bit has a specific meaning.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::ExceptionStatusOffset</a></td><td >Returns the offset address of the exception status byte location in the coils register.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::DeviceBusy</a></td><td >Returns a flag that signals if the server is engaged in processing a long-duration program command.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::AsciiInputDelimiter</a></td><td >Returns a end of message delimiter of Modbus ASCII messages.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::ListenOnlyMode</a></td><td >Returns the server's listen only state. Messages are monitored but no response will be sent.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::ServerIdentifier</a></td><td >Returns the server manufacturer's identifier code. This can be an arbitrary value in the range of <code>0x00</code> to 0xff.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::RunIndicatorStatus</a></td><td >Returns the server's run indicator status. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum">QModbusPdu::ReportServerId</a> function code.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::AdditionalData</a></td><td >Returns the server's additional data. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum">QModbusPdu::ReportServerId</a> function code.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::DeviceIdentification</a></td><td >Returns the server's physical and functional description.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum">QModbusServer::UserOption</a></td><td >Returns the value of a user option.<p><b>Note: </b>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</p></td></tr>
</table></div>
<p><b> 参见 </b><a href="qmodbusserver.html#setValue">setValue</a>().</p>
<!-- @@@value -->
<!-- $$$writeData[overload1]$$$writeDataconstQModbusDataUnit& -->
<h3 class="fn" id="writeData"><a name="writeData"></a><code>[virtual protected] </code><span class="type">bool</span> QModbusServer::<span class="name">writeData</span>(const <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> &amp;<i>newData</i>)</h3>
<p>Writes <i>newData</i> to the Modbus server map. Returns <code>true</code> on success, or <code>false</code> if the <i>newData</i> range is outside of the map range or the registerType() does not exist.</p>
<p><b>Note: </b>Sub-classes that implement writing to a different backing store then default one, also need to implement <a href="qmodbusserver.html#setMap">setMap</a>() 和 <a href="qmodbusserver.html#readData">readData</a>(). The <a href="qmodbusserver.html#dataWritten">dataWritten</a>() signal needs to be emitted from within the functions implementation as well.</p><p><b> 参见 </b><a href="qmodbusserver.html#setMap">setMap</a>(), <a href="qmodbusserver.html#readData">readData</a>(), 和 <a href="qmodbusserver.html#dataWritten">dataWritten</a>().</p>
<!-- @@@writeData -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
