<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- xml-patterns.qdoc -->
  <title>XQuery | Qt XML Patterns 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtxmlpatterns-index.html">Qt XML Patterns</a></td><td >XQuery</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
  <link rel="prev" href="../qtxml/xml-dom-tml.html" />
<p class="naviNextPrevious headerNavi">
<a class="prevPage" href="../qtxml/xml-dom-tml.html">Working with the DOM Tree</a>
</p><p/>
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level1"><a href="#advantages-of-using-qt-xml-patterns-and-xquery">Advantages of Using Qt XML Patterns and XQuery</a></li>
<li class="level1"><a href="#using-the-qt-xml-patterns-module">Using the Qt XML Patterns Module</a></li>
<li class="level2"><a href="#running-the-query-engine-from-your-qt-application">Running the query engine from your Qt application</a></li>
<li class="level2"><a href="#running-the-query-engine-from-the-command-line-utility">Running the query engine from the command line utility</a></li>
<li class="level1"><a href="#the-xquery-data-model">The XQuery Data Model</a></li>
<li class="level2"><a href="#binding-program-variables-to-xquery-variables">Binding program variables to XQuery variables</a></li>
<li class="level2"><a href="#interpreting-xquery-results">Interpreting XQuery results</a></li>
<li class="level1"><a href="#using-xquery-with-non-xml-data">Using XQuery with Non-XML Data</a></li>
<li class="level1"><a href="#more-on-using-qt-xml-patterns-with-non-xml-data">More on Using Qt XML Patterns with Non-XML Data</a></li>
<li class="level1"><a href="#security-considerations">Security Considerations</a></li>
<li class="level2"><a href="#code-injection">Code Injection</a></li>
<li class="level2"><a href="#denial-of-service-attacks">Denial of Service Attacks</a></li>
<li class="level1"><a href="#features-and-conformance">Features and Conformance</a></li>
<li class="level2"><a href="#xquery-1-0">XQuery 1.0</a></li>
<li class="level2"><a href="#xslt-2-0">XSLT 2.0</a></li>
<li class="level2"><a href="#xpath-2-0">XPath 2.0</a></li>
<li class="level2"><a href="#xml-id">xml:id</a></li>
<li class="level2"><a href="#xml-schema-1-0">XML Schema 1.0</a></li>
<li class="level2"><a href="#resource-loading">Resource Loading</a></li>
<li class="level2"><a href="#xml">XML</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">XQuery</h1>
<span class="subtitle"></span>
<!-- $$$xmlprocessing.html-description -->
<div class="descr"> <a name="details"></a>
<a name="introduction"></a>
<h2 id="introduction">Introduction</h2>
<p><a href="xmlprocessing.html">XQuery</a> is a language for traversing XML documents to select and aggregate items of interest and to transform them for output as XML or some other format. XPath is the <i>element selection</i> part of <a href="xmlprocessing.html">XQuery</a>.</p>
<p>The Qt XML Patterns module supports using <a href="http://www.w3.org/TR/xquery">XQuery 1.0</a> and <a href="http://www.w3.org/TR/xpath20">XPath 2.0</a> in Qt applications, for querying XML data <i>and</i> for querying <a href="qabstractxmlnodemodel.html">non-XML data that can be modeled to look like XML</a>. Readers who are not familiar with the <a href="xmlprocessing.html">XQuery</a>/XPath language can read <a href="xquery-introduction.html">A Short Path to XQuery</a> for a brief introduction.</p>
<a name="advantages-of-using-qt-xml-patterns-and-xquery"></a>
<h2 id="advantages-of-using-qt-xml-patterns-and-xquery">Advantages of Using Qt XML Patterns and XQuery</h2>
<p>The <a href="xmlprocessing.html">XQuery</a>/XPath language simplifies data searching and transformation tasks by eliminating the need for doing a lot of C++ or Java procedural programming for each new query task. Here is an <a href="xmlprocessing.html">XQuery</a> that constructs a bibliography of the contents of a library:</p>
<a name="qtxmlpatterns-example-query"></a><pre class="cpp">

  &lt;bibliography&gt;
  {doc(&quot;library.xml&quot;)/bib/book[publisher=&quot;Addison-Wesley&quot; and @year&gt;1991]/&lt;book year=&quot;{@year}&quot;&gt;{title}&lt;/book&gt;}
  &lt;/bibliography&gt;

</pre>
<p>First, the query opens a <code>&lt;bibliography&gt;</code> element in the output. The <a href="xquery-introduction.html#using-path-expressions-to-match-and-select-items">embedded path expression</a> then loads the XML document describing the contents of the library (<code>library.xml</code>) and begins the search. For each <code>&lt;book&gt;</code> element it finds, where the publisher was Addison-Wesley and the publication year was after 1991, it creates a new <code>&lt;book&gt;</code> element in the output as a child of the open <code>&lt;bibliography&gt;</code> element. Each new <code>&lt;book&gt;</code> element gets the book's title as its contents and the book's publication year as an attribute. Finally, the <code>&lt;bibliography&gt;</code> element is closed.</p>
<p>The advantages of using Qt XML Patterns and <a href="xmlprocessing.html">XQuery</a> in your Qt programs are summarized as follows:</p>
<ul>
<li><b>Ease of development</b>: All the C++ programming required to perform data query tasks can be replaced by a simple <a href="xmlprocessing.html">XQuery</a> like the example above.</li>
<li><b>Comprehensive functionality</b>: The <a href="http://www.w3.org/TR/xquery/#id-expressions">expression syntax</a> and rich set of <a href="http://www.w3.org/TR/xpath-functions">functions and operators</a> provided by <a href="xmlprocessing.html">XQuery</a> are sufficient for performing any data searching, selecting, and sorting tasks.</li>
<li><b>Conformance to standards</b>: Conformance to all applicable XML and <a href="xmlprocessing.html">XQuery</a> standards ensures that Qt XML Patterns can always process XML documents generated by other conformant applications, and that XML documents created with Qt XML Patterns can be processed by other conformant applications.</li>
<li><b>Maximal flexibility</b> The Qt XML Patterns module can be used to query XML data <i>and</i> non-XML data that can be <a href="qabstractxmlnodemodel.html">modeled to look like XML</a>.</li>
</ul>
<a name="using-the-qt-xml-patterns-module"></a>
<h2 id="using-the-qt-xml-patterns-module">Using the Qt XML Patterns Module</h2>
<p>There are two ways Qt XML Patterns can be used to evaluate queries. You can run the query engine in your Qt application using the Qt XML Patterns C++ API, or you can run the query engine from the command line using Qt's <code>xmlpatterns</code> command line utility.</p>
<a name="running-the-query-engine-from-your-qt-application"></a>
<h3 >Running the query engine from your Qt application</h3>
<p>If we save the example <a href="xmlprocessing.html">XQuery</a> shown above in a text file (e.g&#x2e; <code>myquery.xq</code>), we can run it from a Qt application using a standard Qt XML Patterns code sequence:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qfile.html">QFile</a></span> xq(<span class="string">&quot;myquery.xq&quot;</span>);

      <span class="type"><a href="qxmlquery.html">QXmlQuery</a></span> query;
      query<span class="operator">.</span>setQuery(<span class="operator">&amp;</span>xq<span class="operator">,</span> <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span><span class="operator">::</span>fromLocalFile(xq<span class="operator">.</span>fileName()));

      <span class="type"><a href="qxmlserializer.html">QXmlSerializer</a></span> serializer(query<span class="operator">,</span> myOutputDevice);
      query<span class="operator">.</span>evaluateTo(<span class="operator">&amp;</span>serializer);

</pre>
<p>First construct a <a href="../qtcore/qfile.html">QFile</a> for the text file containing the <a href="xmlprocessing.html">XQuery</a> (<code>myquery.xq</code>). Then create an instance of <a href="qxmlquery.html">QXmlQuery</a> and call its <a href="qxmlquery.html#setQuery">setQuery()</a> function to load and parse the <a href="xmlprocessing.html">XQuery</a> file. Then create an <a href="qxmlserializer.html">XML serializer</a> to output the query's result set as unformatted XML. Finally, call the <a href="qxmlquery.html#evaluateTo">evaluateTo()</a> function to evaluate the query and serialize the results as XML.</p>
<p><b>Note: </b>If you compile Qt yourself, the Qt XML Patterns module will <i>not</i> be built if exceptions are disabled, or if you compile Qt with a compiler that doesn't support member templates, e.g&#x2e;, MSVC 6.</p><p>See the <a href="qxmlquery.html">QXmlQuery</a> documentation for more information about the Qt XML Patterns C++ API.</p>
<a name="running-the-query-engine-from-the-command-line-utility"></a>
<h3 >Running the query engine from the command line utility</h3>
<p><i>xmlpatterns</i> is a command line utility for running XQueries. It expects the name of a file containing the <a href="xmlprocessing.html">XQuery</a> text.</p>
<pre class="cpp">

  xmlpatterns myQuery<span class="operator">.</span>xq

</pre>
<p>The <a href="xmlprocessing.html">XQuery</a> in <code>myQuery.xq</code> will be evaluated and its output written to <code>stdout</code>. Pass the <code>-help</code> switch to get the list of input flags and their meanings.</p>
<p>xmlpatterns can be used in scripting. However, the descriptions and messages it outputs were not meant to be parsed and may be changed in future releases of Qt.</p>
<a name="qtxdm"></a><a name="the-xquery-data-model"></a>
<h2 id="the-xquery-data-model">The XQuery Data Model</h2>
<p><a href="xmlprocessing.html">XQuery</a> represents data items as <i>atomic values</i> or <i>nodes</i>. An atomic value is a value in the domain of one of the <a href="http://www.w3.org/TR/xmlschema-2/#built-in-datatypes">built-in datatypes</a> defined in <a href="http://www.w3.org/TR/xmlschema-2">Part 2</a> of the W3C XML Schema. A node is normally an XML element or attribute, but when non-XML data is <a href="qabstractxmlnodemodel.html">modeled to look like XML</a>, a node can also represent a non-XML data items.</p>
<p>When you run an <a href="xmlprocessing.html">XQuery</a> using the C++ API in a Qt application, you will often want to bind program variables to $variables in the <a href="xmlprocessing.html">XQuery</a>. After the query is evaluated, you will want to interpret the sequence of data items in the result set.</p>
<a name="binding-program-variables-to-xquery-variables"></a>
<h3 >Binding program variables to XQuery variables</h3>
<p>When you want to run a parameterized <a href="xmlprocessing.html">XQuery</a> from your Qt application, you will need to <a href="qxmlquery.html#bindVariable">bind variables</a> in your program to $name variables in your <a href="xmlprocessing.html">XQuery</a>.</p>
<p>Suppose you want to parameterize the bibliography <a href="xmlprocessing.html">XQuery</a> in the example above. You could define variables for the catalog that contains the library (<code>$file</code>), the publisher name (<code>$publisher</code>), and the year of publication (<code>$year</code>):</p>
<a name="qtxmlpatterns-example-query2"></a><pre class="cpp">

  &lt;bibliography&gt;
  {
      doc($file)/bib/book[publisher = $publisher and @year &gt; $year]/&lt;book year=&quot;{@year}&quot;&gt;{title}&lt;/book&gt;
  }
  &lt;/bibliography&gt;

</pre>
<p>Modify the Qt XML Patterns code to use one of the <a href="qxmlquery.html#bindVariable">bindVariable()</a> functions to bind a program variable to each <a href="xmlprocessing.html">XQuery</a> $variable:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qfile.html">QFile</a></span> xq(<span class="string">&quot;myquery.xq&quot;</span>);
      <span class="type"><a href="../qtcore/qstring.html">QString</a></span> fileName(<span class="string">&quot;the filename&quot;</span>);
      <span class="type"><a href="../qtcore/qstring.html">QString</a></span> publisherName(<span class="string">&quot;the publisher&quot;</span>);
      <span class="type"><a href="../qtcore/qtglobal.html#qlonglong-typedef">qlonglong</a></span> year <span class="operator">=</span> <span class="number">1234</span>;

      <span class="type"><a href="qxmlquery.html">QXmlQuery</a></span> query;

      query<span class="operator">.</span>bindVariable(<span class="string">&quot;file&quot;</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>(fileName));
      query<span class="operator">.</span>bindVariable(<span class="string">&quot;publisher&quot;</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>(publisherName));
      query<span class="operator">.</span>bindVariable(<span class="string">&quot;year&quot;</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>(year));

      query<span class="operator">.</span>setQuery(<span class="operator">&amp;</span>xq<span class="operator">,</span> <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span><span class="operator">::</span>fromLocalFile(xq<span class="operator">.</span>fileName()));

      <span class="type"><a href="qxmlserializer.html">QXmlSerializer</a></span> serializer(query<span class="operator">,</span> myOutputDevice);
      query<span class="operator">.</span>evaluateTo(<span class="operator">&amp;</span>serializer);

</pre>
<p>Each program variable is passed to Qt XML Patterns as a <a href="../qtcore/qvariant.html">QVariant</a> of the type of the C++ variable or constant from which it is constructed. Note that Qt XML Patterns assumes that the type of the <a href="../qtcore/qvariant.html">QVariant</a> in the bindVariable() call is the correct type, so the $variable it is bound to must be used in the <a href="xmlprocessing.html">XQuery</a> accordingly. The following table shows how <a href="../qtcore/qvariant.html">QVariant</a> types are mapped to <a href="xmlprocessing.html">XQuery</a> $variable types:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th ><a href="../qtcore/qvariant.html">QVariant</a> type</th><th ><a href="xmlprocessing.html">XQuery</a> $variable type</th></tr></thead>
<tr valign="top" class="odd"><td >QVariant::LongLong</td><td ><code>xs:integer</code></td></tr>
<tr valign="top" class="even"><td >QVariant::Int</td><td ><code>xs:integer</code></td></tr>
<tr valign="top" class="odd"><td >QVariant::UInt</td><td ><code>xs:nonNegativeInteger</code></td></tr>
<tr valign="top" class="even"><td >QVariant::ULongLong</td><td ><code>xs:unsignedLong</code></td></tr>
<tr valign="top" class="odd"><td >QVariant::String</td><td ><code>xs:string</code></td></tr>
<tr valign="top" class="even"><td >QVariant::Double</td><td ><code>xs:double</code></td></tr>
<tr valign="top" class="odd"><td >QVariant::Bool</td><td ><code>xs:boolean</code></td></tr>
<tr valign="top" class="even"><td >QVariant::Double</td><td ><code>xs:decimal</code></td></tr>
<tr valign="top" class="odd"><td >QVariant::ByteArray</td><td ><code>xs:base64Binary</code></td></tr>
<tr valign="top" class="even"><td >QVariant::StringList</td><td ><code>xs:string*</code></td></tr>
<tr valign="top" class="odd"><td >QVariant::Url</td><td ><code>xs:string</code></td></tr>
<tr valign="top" class="even"><td >QVariant::Date</td><td ><code>xs:date</code>.</td></tr>
<tr valign="top" class="odd"><td >QVariant::DateTime</td><td ><code>xs:dateTime</code></td></tr>
<tr valign="top" class="even"><td >QVariant::Time.</td><td ><code>xs:time</code>. (see <a href="xmlprocessing.html#binding-to-time">Binding To QVariant::Time</a> below)</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qvariant.html#QVariantList-typedef">QVariantList</a></td><td >(see <a href="xmlprocessing.html#binding-to-qvariantlist">Binding To QVariantList</a> below)</td></tr>
</table></div>
<p>A type not shown in the table is not supported and will cause undefined <a href="xmlprocessing.html">XQuery</a> behavior or a $variable binding error, depending on the context in the <a href="xmlprocessing.html">XQuery</a> where the variable is used.</p>
<a name="binding-to-time"></a><a name="binding-to-qvariant-time"></a>
<h4 >Binding To QVariant::Time</h4>
<p>Because the instance of <a href="../qtcore/qtime.html">QTime</a> used in QVariant::Time does not include a zone offset, an instance of QVariant::Time should not be bound to an <a href="xmlprocessing.html">XQuery</a> variable of type <code>xs:time</code>, unless the <a href="../qtcore/qtime.html">QTime</a> is UTC. When binding a non-UTC <a href="../qtcore/qtime.html">QTime</a> to an <a href="xmlprocessing.html">XQuery</a> variable, it should first be passed as a string, or converted to a <a href="../qtcore/qdatetime.html">QDateTime</a> with an arbitrary date, and then bound to an <a href="xmlprocessing.html">XQuery</a> variable of type <code>xs:dateTime</code>.</p>
<a name="binding-to-qvariantlist"></a><a name="binding-to-qvariantlist"></a>
<h4 >Binding To QVariantList</h4>
<p>A <a href="../qtcore/qvariant.html#QVariantList-typedef">QVariantList</a> can be bound to an <a href="xmlprocessing.html">XQuery</a> $variable. All the <a href="../qtcore/qvariant.html">QVariant</a>s in the list must be of the same atomic type, and the $variable the variant list is bound to must be of that same atomic type. If the QVariants in the list are not all of the same atomic type, the <a href="xmlprocessing.html">XQuery</a> behavior is undefined.</p>
<a name="interpreting-xquery-results"></a>
<h3 >Interpreting XQuery results</h3>
<p>When the results of an <a href="xmlprocessing.html">XQuery</a> are returned in a sequence of <a href="qxmlresultitems.html">result items</a>, atomic values in the sequence are treated as instances of <a href="../qtcore/qvariant.html">QVariant</a>. Suppose that instead of serializing the results of the <a href="xmlprocessing.html">XQuery</a> as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of <a href="qxmlquery.html#evaluateTo">QXmlQuery::evaluateTo</a>() that populates a sequence of <a href="qxmlresultitems.html">result items</a> with the <a href="xmlprocessing.html">XQuery</a> results:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qfile.html">QFile</a></span> xq(<span class="string">&quot;myquery.xq&quot;</span>);
      <span class="type"><a href="../qtcore/qstring.html">QString</a></span> fileName(<span class="string">&quot;the filename&quot;</span>);
      <span class="type"><a href="../qtcore/qstring.html">QString</a></span> publisherName(<span class="string">&quot;the publisher&quot;</span>);
      <span class="type"><a href="../qtcore/qtglobal.html#qlonglong-typedef">qlonglong</a></span> year <span class="operator">=</span> <span class="number">1234</span>;

      <span class="type"><a href="qxmlquery.html">QXmlQuery</a></span> query;

      query<span class="operator">.</span>bindVariable(<span class="string">&quot;file&quot;</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>(fileName));
      query<span class="operator">.</span>bindVariable(<span class="string">&quot;publisher&quot;</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>(publisherName));
      query<span class="operator">.</span>bindVariable(<span class="string">&quot;year&quot;</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>(year));

      query<span class="operator">.</span>setQuery(<span class="operator">&amp;</span>xq<span class="operator">,</span> <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span><span class="operator">::</span>fromLocalFile(xq<span class="operator">.</span>fileName()));

      <span class="type"><a href="qxmlresultitems.html">QXmlResultItems</a></span> result;
      query<span class="operator">.</span>evaluateTo(<span class="operator">&amp;</span>result);
      <span class="type"><a href="qxmlitem.html">QXmlItem</a></span> item(result<span class="operator">.</span>next());
      <span class="keyword">while</span> (<span class="operator">!</span>item<span class="operator">.</span>isNull()) {
          <span class="keyword">if</span> (item<span class="operator">.</span>isAtomicValue()) {
              <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> v <span class="operator">=</span> item<span class="operator">.</span>toAtomicValue();
              <span class="keyword">switch</span> (v<span class="operator">.</span>type()) {
                  <span class="keyword">case</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span><span class="operator">::</span>LongLong:
                      <span class="comment">// xs:integer</span>
                      <span class="keyword">break</span>;
                  <span class="keyword">case</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span><span class="operator">::</span>String:
                      <span class="comment">// xs:string</span>
                      <span class="keyword">break</span>;
                  <span class="keyword">default</span>:
                      <span class="comment">// error</span>
                      <span class="keyword">break</span>;
              }
          }
          <span class="keyword">else</span> <span class="keyword">if</span> (item<span class="operator">.</span>isNode()) {
  <span class="preprocessor">#ifdef qdoc</span>
              <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> i <span class="operator">=</span> item<span class="operator">.</span>toNodeModelIndex();
              <span class="comment">// process node</span>
  <span class="preprocessor">#endif // qdoc</span>
          }
          item <span class="operator">=</span> result<span class="operator">.</span>next();
      }

</pre>
<p>Iterate through the <a href="qxmlresultitems.html">result items</a> and test each <a href="qxmlitem.html">QXmlItem</a> to see if it is an atomic value or a node. If it is an atomic value, convert it to a <a href="../qtcore/qvariant.html">QVariant</a> with <a href="qxmlitem.html#toAtomicValue">toAtomicValue()</a> and switch on its <a href="../qtcore/qvariant.html#type">variant type</a> to handle all the atomic values your <a href="xmlprocessing.html">XQuery</a> might return. The following table shows the <a href="../qtcore/qvariant.html">QVariant</a> type to expect for each atomic value type (or <a href="qxmlname.html">QXmlName</a>):</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th ><a href="xmlprocessing.html">XQuery</a> result item type</th><th ><a href="../qtcore/qvariant.html">QVariant</a> type returned</th></tr></thead>
<tr valign="top" class="odd"><td ><code>xs:QName</code></td><td ><a href="qxmlname.html">QXmlName</a> (see <a href="xmlprocessing.html#handling-qxmlnames">Handling QXmlNames</a> below)</td></tr>
<tr valign="top" class="even"><td ><code>xs:integer</code></td><td >QVariant::LongLong</td></tr>
<tr valign="top" class="odd"><td ><code>xs:string</code></td><td >QVariant::String</td></tr>
<tr valign="top" class="even"><td ><code>xs:string*</code></td><td >QVariant::StringList</td></tr>
<tr valign="top" class="odd"><td ><code>xs:double</code></td><td >QVariant::Double</td></tr>
<tr valign="top" class="even"><td ><code>xs:float</code></td><td >QVariant::Double</td></tr>
<tr valign="top" class="odd"><td ><code>xs:boolean</code></td><td >QVariant::Bool</td></tr>
<tr valign="top" class="even"><td ><code>xs:decimal</code></td><td >QVariant::Double</td></tr>
<tr valign="top" class="odd"><td ><code>xs:hexBinary</code></td><td >QVariant::ByteArray</td></tr>
<tr valign="top" class="even"><td ><code>xs:base64Binary</code></td><td >QVariant::ByteArray</td></tr>
<tr valign="top" class="odd"><td ><code>xs:gYear</code></td><td >QVariant::DateTime</td></tr>
<tr valign="top" class="even"><td ><code>xs:gYearMonth</code></td><td >QVariant::DateTime</td></tr>
<tr valign="top" class="odd"><td ><code>xs:gMonthDay</code></td><td >QVariant::DateTime</td></tr>
<tr valign="top" class="even"><td ><code>xs:gDay</code></td><td >QVariant::DateTime</td></tr>
<tr valign="top" class="odd"><td ><code>xs:gMonth</code></td><td >QVariant::DateTime</td></tr>
<tr valign="top" class="even"><td ><code>xs:anyURI</code></td><td >QVariant::Url</td></tr>
<tr valign="top" class="odd"><td ><code>xs:untypedAtomic</code></td><td >QVariant::String</td></tr>
<tr valign="top" class="even"><td ><code>xs:ENTITY</code></td><td >QVariant::String</td></tr>
<tr valign="top" class="odd"><td ><code>xs:date</code></td><td >QVariant::DateTime</td></tr>
<tr valign="top" class="even"><td ><code>xs:dateTime</code></td><td >QVariant::DateTime</td></tr>
<tr valign="top" class="odd"><td ><code>xs:time</code></td><td >(see <a href="xmlprocessing.html#xstime-not-mapped">No mapping for xs:time</a> below)</td></tr>
</table></div>
<a name="handling-qxmlnames"></a><a name="handling-qxmlnames"></a>
<h4 >Handling QXmlNames</h4>
<p>If your <a href="xmlprocessing.html">XQuery</a> can return atomic value items of type <code>xs:QName</code>, they will appear in your <a href="qxmlresultitems.html">QXmlResultItems</a> as instances of <a href="qxmlname.html">QXmlName</a>. Since the <a href="../qtcore/qvariant.html">QVariant</a> class does not support the <a href="qxmlname.html">QXmlName</a> class directly, extracting them from <a href="qxmlresultitems.html">QXmlResultItems</a> requires a bit of slight-of-hand using the <a href="../qtcore/qmetatype.html">Qt metatype system</a>. We must modify our example to use a couple of template functions, a friend of <a href="../qtcore/qmetatype.html">QMetaType</a> (<a href="../qtcore/qmetatype.html#qMetaTypeId">qMetaTypeId</a>&lt;T&gt;()) and a friend of <a href="../qtcore/qvariant.html">QVariant</a> (<a href="../qtcore/qvariant.html#qvariant_cast">qvariant_cast</a>&lt;T&gt;()):</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qfile.html">QFile</a></span> xq(<span class="string">&quot;myquery.xq&quot;</span>);

      <span class="type"><a href="qxmlquery.html">QXmlQuery</a></span> query;
      query<span class="operator">.</span>setQuery(<span class="operator">&amp;</span>xq<span class="operator">,</span> <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span><span class="operator">::</span>fromLocalFile(xq<span class="operator">.</span>fileName()));

      <span class="type"><a href="qxmlresultitems.html">QXmlResultItems</a></span> result;
      query<span class="operator">.</span>evaluateTo(<span class="operator">&amp;</span>result);
      <span class="type"><a href="qxmlitem.html">QXmlItem</a></span> item(result<span class="operator">.</span>next());
      <span class="keyword">while</span> (<span class="operator">!</span>item<span class="operator">.</span>isNull()) {
          <span class="keyword">if</span> (item<span class="operator">.</span>isAtomicValue()) {
              <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> v <span class="operator">=</span> item<span class="operator">.</span>toAtomicValue();
              <span class="keyword">switch</span> (v<span class="operator">.</span>type()) {
                  <span class="keyword">case</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span><span class="operator">::</span>LongLong:
                      <span class="comment">// xs:integer</span>
                      <span class="keyword">break</span>;
                  <span class="keyword">case</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span><span class="operator">::</span>String:
                      <span class="comment">// xs:string</span>
                      <span class="keyword">break</span>;
                  <span class="keyword">default</span>:
                      <span class="keyword">if</span> (v<span class="operator">.</span>userType() <span class="operator">=</span><span class="operator">=</span> <a href="../qtcore/qmetatype.html#qMetaTypeId">qMetaTypeId</a><span class="operator">&lt;</span><span class="type"><a href="qxmlname.html">QXmlName</a></span><span class="operator">&gt;</span>()) {
  <span class="preprocessor">#ifdef qdoc</span>
                          <span class="type"><a href="qxmlname.html">QXmlName</a></span> n <span class="operator">=</span> qvariant_cast<span class="operator">&lt;</span><span class="type"><a href="qxmlname.html">QXmlName</a></span><span class="operator">&gt;</span>(v);
                          <span class="comment">// process QXmlName n...</span>
  <span class="preprocessor">#endif // qdoc</span>
                      }
                      <span class="keyword">else</span> {
                          <span class="comment">// error</span>
                      }
                      <span class="keyword">break</span>;
              }
          }
          <span class="keyword">else</span> <span class="keyword">if</span> (item<span class="operator">.</span>isNode()) {
  <span class="preprocessor">#ifdef qdoc</span>
              <span class="type"><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></span> i <span class="operator">=</span> item<span class="operator">.</span>toNodeModelIndex();
              <span class="comment">// process node</span>
  <span class="preprocessor">#endif // qdoc</span>
          }
          item <span class="operator">=</span> result<span class="operator">.</span>next();
      }

</pre>
<p>To access the strings in a <a href="qxmlname.html">QXmlName</a> returned by an <a href="qxmlquery.html#evaluateTo">XQuery evaluation</a>, the <a href="qxmlname.html">QXmlName</a> must be accessed with the <a href="qxmlnamepool.html">name pool</a> from the instance of <a href="qxmlquery.html">QXmlQuery</a> that was used for the evaluation.</p>
<a name="xstime-not-mapped"></a><a name="no-mapping-for-xs-time"></a>
<h4 >No mapping for xs:time</h4>
<p>An instance of <code>xs:time</code> can't be represented correctly as an instance of QVariant::Time, unless the <code>xs:time</code> is a UTC time. This is because xs:time has a zone offset (0 for UTC) in addition to the time value, which the <a href="../qtcore/qtime.html">QTime</a> in QVariant::Time does not have. This means that if an <a href="xmlprocessing.html">XQuery</a> tries to return an atomic value of type <code>xs:time</code>, an invalid <a href="../qtcore/qvariant.html">QVariant</a> will be returned. A query can return an atomic value of type xs:time by either converting it to an <code>xs:dateTime</code> with an arbitrary date, or to an <code>xs:string</code>.</p>
<a name="using-xquery-with-non-xml-data"></a>
<h2 id="using-xquery-with-non-xml-data">Using XQuery with Non-XML Data</h2>
<p>Although the <a href="xmlprocessing.html">XQuery</a> language was designed for querying XML, with Qt XML Patterns one can use <a href="xmlprocessing.html">XQuery</a> for querying any data that can be modeled to look like XML. Non-XML data is modeled to look like XML by loading it into a custom subclass of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a>, where it is then presented to the Qt XML Patterns <a href="xmlprocessing.html">XQuery</a> engine via the same API the <a href="xmlprocessing.html">XQuery</a> engine uses for querying XML.</p>
<p>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The <a href="xmlprocessing.html">XQuery</a> below traverses the product orders found in the XML file <i>myOrders.xml</i> to find all the skin care product orders and output them ordered by shipping date.</p>
<pre class="cpp">

  &lt;result&gt;
      &lt;para&gt;The following skin care products have shipped, ordered by shipping date(oldest first):&lt;/para&gt;
      {
          for $i in doc(&quot;myOrders.xml&quot;)/orders/order[@product = &quot;Acme Skin Care&quot;]
          order by xs:date($i/@shippingDate) descending
          return $i
      }
  &lt;/result&gt;

</pre>
<p>Qt XML Patterns can be used out of the box to perform this query, provided <i>myOrders.xml</i> actually contains well-formed XML. It can be loaded directly into the default XML node model and traversed. But suppose we want Qt XML Patterns to perform queries on the hierarchical structure of the local file system. The default XML node model in Qt XML Patterns is not suitable for navigating the file system, because there is no XML file to load that contains a description of it. Such an XML file, if it existed, might look something like this:</p>
<pre class="cpp">

  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;directory name=&quot;home&quot;&gt;

      &lt;file name=&quot;myNote.txt&quot; mimetype=&quot;text/plain&quot; size=&quot;8&quot; extension=&quot;txt&quot; uri=&quot;file:///home/frans/myNote.txt&quot;&gt;
          &lt;content asBase64Binary=&quot;TXkgTm90ZSE=&quot; asStringFromUTF-8=&quot;My Note!&quot;/&gt;
      &lt;/file&gt;

      &lt;directory name=&quot;src&quot;&gt;
          ...
      &lt;/directory&gt;

      ...

  &lt;/directory&gt;

</pre>
<p>The <a href="qtxmlpatterns-filetree-example.html">File System Example</a> does exactly this.</p>
<p>There is no such file to load into the default XML node model, but one can write a subclass of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> to represent the file system. This custom XML node model, once populated with all the directory and file descriptors obtained directly from the system, presents the complete file system hierarchy to the query engine via the same API used by the default XML node model to present the contents of an XML file. In other words, once the custom XML node model is populated, it presents the file system to the query engine as if a description of it had been loaded into the default XML node model from an XML file like the one shown above.</p>
<p>Now we can write an <a href="xmlprocessing.html">XQuery</a> to find all the XML files and parse them to find the ones that don't contain well-formed XML.</p>
<pre class="cpp">

  &lt;html&gt;
      &lt;body&gt;
          {
              $myRoot//file[@mimetype = 'text/xml' or @mimetype = 'application/xml']
              /
              (if(doc-available(@uri))
               then ()
               else &lt;p&gt;Failed to parse file {@uri}.&lt;/p&gt;)
          }
      &lt;/body&gt;
  &lt;/html&gt;

</pre>
<p>Without Qt XML Patterns, there is no simple way to solve this kind of problem. You might do it by writing a C++ program to traverse the file system, sniff out all the XML files, and submit each one to an XML parser to test that it contains valid XML. The C++ code required to write that program will probably be more complex than the C++ code required to subclass <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a>, but even if the two are comparable, your custom C++ program can be used only for that one task, while your custom XML node model can be used by any <a href="xmlprocessing.html">XQuery</a> that must navigate the file system.</p>
<p>The general approach to using <a href="xmlprocessing.html">XQuery</a> to perform queries on non-XML data has been a three step process. In the first step, the data is loaded into a non-XML data model. In the second step, the non-XML data model is serialized as XML and output to XML (text) files. In the final step, an XML tool loads the XML files into a second, XML data model, where the XQueries can be performed. The development cost of implementing this process is often high, and the three step system that results is inefficient because the two data models must be built and maintained separately.</p>
<p>With Qt XML Patterns, subclassing <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> eliminates the transformation required to convert the non-XML data model to the XML data model, because there is only ever one data model required. The non-XML data model presents the non-XML data to the query engine via the XML data model API. Also, since the query engine uses the API to access the <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a>, the data model subclass can construct the elements, attributes and other data on demand, responding to the query's specific requests. This can greatly improve efficiency, because it means the entire model might not have to be built. For example, in the file system model above, it is not necessary to build an instance for a whole XML file representing the whole file system. Instead nodes are created on demand, which also likely is a small subset of the file system.</p>
<p>Examples of other places where <a href="xmlprocessing.html">XQuery</a> could be used in Qt XML Patterns to query non-XML data:</p>
<ul>
<li>The internal representation for word processor documents</li>
<li>The set of dependencies for a software build system</li>
<li>The hierarchy (or graph) that links a set of HTML documents from a web crawler</li>
<li>The images and meta-data in an image collection</li>
<li>The set of D-Bus interfaces available in a system</li>
<li>A <a href="../qtcore/qobject.html">QObject</a> hierarchy.</li>
</ul>
<p>See the <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> documentation for information about how to implement custom XML node models.</p>
<a name="more-on-using-qt-xml-patterns-with-non-xml-data"></a>
<h2 id="more-on-using-qt-xml-patterns-with-non-xml-data">More on Using Qt XML Patterns with Non-XML Data</h2>
<p>Subclassing <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> to let the query engine access non-XML data by the same API it uses for XML is the feature that enables Qt XML Patterns to query non-XML data with <a href="xmlprocessing.html">XQuery</a>. It allows <a href="xmlprocessing.html">XQuery</a> to be used as a mapping layer between different non-XML node models or between a non-XML node model and the built-in XML node model. Once the subclass(es) of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> have been written, <a href="xmlprocessing.html">XQuery</a> can be used to select a set of elements from one node model, transform the selected elements, and then write them out, either as XML using <a href="qxmlquery.html#evaluateTo">QXmlQuery::evaluateTo</a>() and <a href="qxmlserializer.html">QXmlSerializer</a>, or as some other format using a subclass of QAbstractXmlReceiver.</p>
<p>Consider a word processor application that must import and export data in several different formats. Rather than writing a lot of C++ code to convert each input format to an intermediate form, and more C++ code to convert the intermediate form back to each output format, one can implement a solution based on Qt XML Patterns that uses simple XQueries to transform each XML or non-XML format (e.g&#x2e; MathFormula.xml below) to the intermediate form (e.g&#x2e; the DocumentRepresentation node model class below), and more simple XQueries to transform the intermediate form back to each XML or non-XML format.</p>
<p class="centerAlign"><img src="images/patternist-wordProcessor.png" alt="" /></p><p>Because CSV files are not XML, a subclass of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> is used to present the CSV data to the <a href="xmlprocessing.html">XQuery</a> engine as if it were XML. What are not shown are the subclasses of QAbstractXmlReceiver that would then send the selected elements into the DocumentRepresentation node model, and the subclasses of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> that would ultimately write the output files in each format.</p>
<a name="security-considerations"></a>
<h2 id="security-considerations">Security Considerations</h2>
<a name="code-injection"></a>
<h3 >Code Injection</h3>
<p><a href="xmlprocessing.html">XQuery</a> is vulnerable to <a href="http://en.wikipedia.org/wiki/Code_injection">code injection attacks</a> in the same way as the SQL language. If an <a href="xmlprocessing.html">XQuery</a> is constructed by concatenating strings, and the strings come from user input, the constructed <a href="xmlprocessing.html">XQuery</a> could be malevolent. The best way to prevent code injection attacks is to not construct XQueries from user-written strings, but only accept user data input using <a href="../qtcore/qvariant.html">QVariant</a> and variable bindings. See <a href="qxmlquery.html#bindVariable">QXmlQuery::bindVariable</a>().</p>
<p>The articles <a href="http://www.ibm.com/developerworks/xml/library/x-xpathinjection.html">Avoid the dangers of XPath injection</a>, by Robi Sen and <a href="http://www.packetstormsecurity.org/papers/bypass/Blind_XPath_Injection_20040518.pdf">Blind XPath Injection</a>, by Amit Klein, discuss the <a href="xmlprocessing.html">XQuery</a> code injection problem in more detail.</p>
<a name="denial-of-service-attacks"></a>
<h3 >Denial of Service Attacks</h3>
<p>Applications using Qt XML Patterns are subject to the same limitations of software as other systems. Generally, these can not be checked. This means Qt XML Patterns does not prevent rogue queries from consuming too many resources. For example, a query could take too much time to execute or try to transfer too much data. A query could also do too much recursion, which could crash the system. XQueries can do these things accidentally, but they can also be done as deliberate denial of service attacks.</p>
<a name="features-and-conformance"></a>
<h2 id="features-and-conformance">Features and Conformance</h2>
<a name="xquery-1-0"></a>
<h3 >XQuery 1.0</h3>
<p>Qt XML Patterns aims at being a <a href="http://www.w3.org/TR/xquery/#id-xquery-conformance">conformant XQuery processor</a>. It adheres to <a href="http://www.w3.org/TR/xquery/#id-minimal-conformance">Minimal Conformance</a> and supports the <a href="http://www.w3.org/TR/xquery/#id-serialization-feature">Serialization Feature</a> and the <a href="http://www.w3.org/TR/xquery/#id-full-axis-feature">Full Axis Feature</a>. Qt XML Patterns currently passes 97% of the tests in the <a href="http://www.w3.org/XML/Query/test-suite">XML Query Test Suite</a>. Areas where conformance may be questionable and where behavior may be changed in future releases include:</p>
<ul>
<li>Some corner cases involving namespaces and element constructors are incorrect.</li>
<li>XPath is a subset of <a href="xmlprocessing.html">XQuery</a> and the implementation of Qt XML Patterns uses XPath 2.0 with <a href="xmlprocessing.html">XQuery</a> 1.0&#x2e;</li>
</ul>
<p>The specifications discusses conformance further: <a href="http://www.w3.org/TR/xquery/">XQuery 1.0: An XML Query Language</a>. W3C's <a href="xmlprocessing.html">XQuery</a> testing effort can be of interest as well, <a href="http://www.w3.org/XML/Query/test-suite/">XML Query Test Suite</a>.</p>
<p>Currently <code>fn:collection()</code> does not access any data set, and there is no API for providing data through the collection. As a result, evaluating <code>fn:collection()</code> returns the empty sequence. We intend to provide functionality for this in a future release of Qt.</p>
<p>Only queries encoded in UTF-8 are supported.</p>
<a name="xslt-2-0"></a>
<h3 >XSLT 2.0</h3>
<p>Partial support for XSLT was introduced in Qt 4.5&#x2e; Future releases of Qt XML Patterns will aim to support these XSLT features:</p>
<ul>
<li>Basic XSLT 2.0 processor</li>
<li>Serialization feature</li>
<li>Backwards Compatibility feature</li>
</ul>
<p>For details, see <a href="http://www.w3.org/TR/xslt20/#conformance">XSL Transformations (XSLT) Version 2.0, 21 Conformance</a>.</p>
<p><b>Note: </b>In this release, XSLT support is considered experimental.</p><p>Unsupported or partially supported XSLT features are documented in the following table. The implementation of XSLT in Qt 4.5 can be seen as XSLT 1.0 but with the data model of XPath 2.0 and XSLT 2.0, and using the using the functionality of XPath 2.0 and its accompanying function library. When Qt XML Patterns encounters an unsupported or partially support feature, it will either report a syntax error or silently continue, unless otherwise noted in the table.</p>
<p>The implementation currently passes 42% of W3C's XSLT test suite, which focus on features introduced in XSLT 2.0&#x2e;</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >XSL Feature</th><th >Support Status</th></tr></thead>
<tr valign="top" class="odd"><td ><code>xsl:key</code> and <code>fn:key()</code></td><td >not supported</td></tr>
<tr valign="top" class="even"><td ><code>xsl:include</code></td><td >not supported</td></tr>
<tr valign="top" class="odd"><td ><code>xsl:import</code></td><td >not supported</td></tr>
<tr valign="top" class="even"><td ><code>xsl:copy</code></td><td >The <code>copy-namespaces</code> and <code>inherit-namespaces</code> attributes have no effect. For copied comments, attributes and processing instructions, the copy has the same node identity as the original.</td></tr>
<tr valign="top" class="odd"><td ><code>xsl:copy-of</code></td><td >The <code>copy-namespaces</code> attribute has no effect.</td></tr>
<tr valign="top" class="even"><td ><code>fn:format-number()</code></td><td >not supported</td></tr>
<tr valign="top" class="odd"><td ><code>xsl:message</code></td><td >not supported</td></tr>
<tr valign="top" class="even"><td ><code>xsl:use-when</code></td><td >not supported</td></tr>
<tr valign="top" class="odd"><td ><code>Tunnel</code> Parameters</td><td >not supported</td></tr>
<tr valign="top" class="even"><td ><code>xsl:attribute-set</code></td><td >not supported</td></tr>
<tr valign="top" class="odd"><td ><code>xsl:decimal-format</code></td><td >not supported</td></tr>
<tr valign="top" class="even"><td ><code>xsl:fallback</code></td><td >not supported</td></tr>
<tr valign="top" class="odd"><td ><code>xsl:apply-imports</code></td><td >not supported</td></tr>
<tr valign="top" class="even"><td ><code>xsl:character-map</code></td><td >not supported</td></tr>
<tr valign="top" class="odd"><td ><code>xsl:number</code></td><td >not supported</td></tr>
<tr valign="top" class="even"><td ><code>xsl:namespace-alias</code></td><td >not supported</td></tr>
<tr valign="top" class="odd"><td ><code>xsl:output</code></td><td >not supported</td></tr>
<tr valign="top" class="even"><td ><code>xsl:output-character</code></td><td >not supported</td></tr>
<tr valign="top" class="odd"><td ><code>xsl:preserve-space</code></td><td >not supported</td></tr>
<tr valign="top" class="even"><td ><code>xsl:result-document</code></td><td >not supported</td></tr>
<tr valign="top" class="odd"><td >Patterns</td><td >Complex patterns or patterns with predicates have issues.</td></tr>
<tr valign="top" class="even"><td ><code>2.0</code> Compatibility Mode</td><td >Stylesheets are interpreted as XSLT 2.0 stylesheets, even if the <code>version</code> attribute is in the XSLT source is 1.0&#x2e; In other words, the version attribute is ignored.</td></tr>
<tr valign="top" class="odd"><td >Grouping</td><td ><code>fn:current-group()</code>, <code>fn:grouping-key()</code> and <code>xsl:for-each-group</code>.</td></tr>
<tr valign="top" class="even"><td >Regexp elements</td><td ><code>xsl:analyze-string</code>, <code>xsl:matching-substring</code>, <code>xsl:non-matching-substring</code>, and <code>fn:regex-group()</code></td></tr>
<tr valign="top" class="odd"><td >Date &amp; Time formatting</td><td ><code>fn:format-dateTime()</code>, <code>fn:format-date()</code> and fn:format-time().</td></tr>
<tr valign="top" class="even"><td >XPath Conformance</td><td >Since XPath is a subset of XSLT, its issues are in affect too.</td></tr>
</table></div>
<p>The Qt XML Patterns implementation of the XPath Data Model does not include entities (due to <a href="../qtcore/qxmlstreamreader.html">QXmlStreamReader</a> not reporting them). This means that functions <code>unparsed-entity-uri()</code> and <code>unparsed-entity-public-id()</code> always return negatively.</p>
<a name="xpath-2-0"></a>
<h3 >XPath 2.0</h3>
<p>Since XPath 2.0 is a subset of <a href="xmlprocessing.html">XQuery</a> 1.0, XPath 2.0 is supported. Areas where conformance may be questionable and, consequently, where behavior may be changed in future releases include:</p>
<ul>
<li>Regular expression support is currently not conformant but follows Qt's <a href="../qtcore/qregexp.html">QRegExp</a> standard syntax.</li>
<li>Operators for <code>xs:time</code>, <code>xs:date</code>, and <code>xs:dateTime</code> are incomplete.</li>
<li>Formatting of very large or very small <code>xs:double</code>, <code>xs:float</code>, and <code>xs:decimal</code> values may be incorrect.</li>
</ul>
<a name="xml-id"></a>
<h3 >xml:id</h3>
<p>Processing of XML files supports <code>xml:id</code>. This allows elements that have an attribute named <code>xml:id</code> to be looked up efficiently with the <code>fn:id()</code> function. See <a href="http://www.w3.org/TR/xml-id/">xml:id Version 1.0</a> for details.</p>
<a name="xml-schema-1-0"></a>
<h3 >XML Schema 1.0</h3>
<p>There are two ways Qt XML Patterns can be used to validate schemas: You can use the C++ API in your Qt application using the classes <a href="qxmlschema.html">QXmlSchema</a> and <a href="qxmlschemavalidator.html">QXmlSchemaValidator</a>, or you can use the command line utility named xmlpatternsvalidator (located in the &quot;bin&quot; directory of your Qt build).</p>
<p>The Qt XML Patterns implementation of XML Schema validation supports the schema specification version 1.0 in large parts. Known problems of the implementation and areas where conformancy may be questionable are:</p>
<ul>
<li>Large <code>minOccurs</code> or <code>maxOccurs</code> values or deeply nested ones require huge amount of memory which might cause the system to freeze. Such a schema should be rewritten to use <code>unbounded</code> as value instead of large numbers. This restriction will hopefully be fixed in a later release.</li>
<li>Comparison of really small or large floating point values might lead to wrong results in some cases. However such numbers should not be relevant for day-to-day usage.</li>
<li>Regular expression support is currently not conformant but follows Qt's <a href="../qtcore/qregexp.html">QRegExp</a> standard syntax.</li>
<li>Identity constraint checks can not use the values of default or fixed attribute definitions.</li>
</ul>
<a name="resource-loading"></a>
<h3 >Resource Loading</h3>
<p>When Qt XML Patterns loads an XML resource, e.g&#x2e;, using the <code>fn:doc()</code> function, the following schemes are supported:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Scheme Name</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td ><code>file</code></td><td >Local files.</td></tr>
<tr valign="top" class="even"><td ><code>data</code></td><td >The bytes are encoded in the URI itself. e.g&#x2e;, <code>data:application/xml,%3Ce%2F%3E</code> is <code>&lt;e/&gt;</code>.</td></tr>
<tr valign="top" class="odd"><td ><code>ftp</code></td><td >Resources retrieved via FTP.</td></tr>
<tr valign="top" class="even"><td ><code>http</code></td><td >Resources retrieved via HTTP.</td></tr>
<tr valign="top" class="odd"><td ><code>https</code></td><td >Resources retrieved via HTTPS. This will succeed if no SSL errors are encountered.</td></tr>
<tr valign="top" class="even"><td ><code>qrc</code></td><td >Qt Resource files. Expressing it as an empty scheme, :/..&#x2e;, is not supported.</td></tr>
</table></div>
<a name="xml"></a>
<h3 >XML</h3>
<p>XML 1.0 and XML Namespaces 1.0 are supported, as opposed to the 1.1 versions. When a strings is passed to a query as a <a href="../qtcore/qstring.html">QString</a>, the characters must be XML 1.0 characters. Otherwise, the behavior is undefined. This is not checked.</p>
<p>URIs are first passed to <a href="qabstracturiresolver.html">QAbstractUriResolver</a>. Check <a href="qxmlquery.html#setUriResolver">QXmlQuery::setUriResolver</a>() for possible rewrites.</p>
</div>
<!-- @@@xmlprocessing.html -->
<p class="naviNextPrevious footerNavi">
<a class="prevPage" href="../qtxml/xml-dom-tml.html">Working with the DOM Tree</a>
</p>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
