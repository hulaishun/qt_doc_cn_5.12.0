<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qquickwidget.cpp -->
  <title>QQuickWidget Class | Qt Quick 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtquick-index.html">Qt Quick</a></td><td ><a href="qtquick-module.html">C++ Classes</a></td><td >QQuickWidget</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#public-slots">公共槽函数</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">重新实现的保护函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#scene-graph-and-context-persistency">Scene Graph and Context Persistency</a></li>
<li class="level2"><a href="#limitations">Limitations</a></li>
<li class="level2"><a href="#support-when-not-using-opengl">Support when not using OpenGL</a></li>
<li class="level2"><a href="#tab-key-handling">Tab Key Handling</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QQuickWidget Class</h1>
<!-- $$$QQuickWidget-brief -->
<p>The <a href="qquickwidget.html">QQuickWidget</a> class provides a widget for displaying a Qt Quick user interface. <a href="#details">More...</a></p>
<!-- @@@QQuickWidget -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QQuickWidget&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quickwidgets</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.3</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtwidgets/qwidget.html">QWidget</a></td></tr></table></div><ul>
<li><a href="qquickwidget-members.html">List of all members, including inherited members</a></li>
<li><a href="qquickwidget-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#ResizeMode-enum">ResizeMode</a></b> { SizeViewToRootObject, SizeRootObjectToView }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#Status-enum">Status</a></b> { Null, Ready, Loading, Error }</td></tr>
</table></div>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<ul>
<li class="fn"><b><a href="qquickwidget.html#resizeMode-prop">resizeMode</a></b> : ResizeMode</li>
<li class="fn"><b><a href="qquickwidget.html#source-prop">source</a></b> : QUrl</li>
<li class="fn"><b><a href="qquickwidget.html#status-prop">status</a></b> : const Status</li>
</ul>
<ul>
<li class="fn">59 properties inherited from <a href="../qtwidgets/qwidget.html#properties">QWidget</a></li>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#QQuickWidget">QQuickWidget</a></b>(QWidget *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#QQuickWidget-1">QQuickWidget</a></b>(QQmlEngine *<i>engine</i>, QWidget *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#QQuickWidget-2">QQuickWidget</a></b>(const QUrl &amp;<i>source</i>, QWidget *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dtor.QQuickWidget">~QQuickWidget</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlEngine *</td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#engine">engine</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QQmlError&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#errors">errors</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSurfaceFormat </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#format">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#grabFramebuffer">grabFramebuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#initialSize">initialSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickWindow *</td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#quickWindow">quickWindow</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickWidget::ResizeMode </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#resizeMode-prop">resizeMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#rootContext">rootContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#rootObject">rootObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#setClearColor">setClearColor</a></b>(const QColor &amp;<i>color</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#setFormat">setFormat</a></b>(const QSurfaceFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#resizeMode-prop">setResizeMode</a></b>(<i>QQuickWidget::ResizeMode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrl </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#source">source</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickWidget::Status </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#status-prop">status</a></b>() const</td></tr>
</table></div>
<ul>
<li class="fn">216 public functions inherited from <a href="../qtwidgets/qwidget.html#public-functions">QWidget</a></li>
<li class="fn">31 public functions inherited from <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
<li class="fn">14 public functions inherited from <a href="../qtgui/qpaintdevice.html#public-functions">QPaintDevice</a></li>
</ul>
<a name="public-slots"></a>
<h2 id="public-slots">公共槽函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#setSource">setSource</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
</table></div>
<ul>
<li class="fn">19 public slots inherited from <a href="../qtwidgets/qwidget.html#public-slots">QWidget</a></li>
<li class="fn">1 public slot inherited from <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#sceneGraphError">sceneGraphError</a></b>(QQuickWindow::SceneGraphError <i>error</i>, const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#statusChanged">statusChanged</a></b>(QQuickWidget::Status <i>status</i>)</td></tr>
</table></div>
<ul>
<li class="fn">3 signals inherited from <a href="../qtwidgets/qwidget.html#signals">QWidget</a></li>
<li class="fn">2 signals inherited from <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">5 static public members inherited from <a href="../qtwidgets/qwidget.html#static-public-members">QWidget</a></li>
<li class="fn">9 static public members inherited from <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">重新实现的保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dragEnterEvent">dragEnterEvent</a></b>(QDragEnterEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dragLeaveEvent">dragLeaveEvent</a></b>(QDragLeaveEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dragMoveEvent">dragMoveEvent</a></b>(QDragMoveEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#dropEvent">dropEvent</a></b>(QDropEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#event">event</a></b>(QEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#focusInEvent">focusInEvent</a></b>(QFocusEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#focusNextPrevChild">focusNextPrevChild</a></b>(bool <i>next</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#focusOutEvent">focusOutEvent</a></b>(QFocusEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#hideEvent">hideEvent</a></b>(<i>QHideEvent *</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#keyPressEvent">keyPressEvent</a></b>(QKeyEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#keyReleaseEvent">keyReleaseEvent</a></b>(QKeyEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#mouseMoveEvent">mouseMoveEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#mousePressEvent">mousePressEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#mouseReleaseEvent">mouseReleaseEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#paintEvent">paintEvent</a></b>(QPaintEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#showEvent">showEvent</a></b>(<i>QShowEvent *</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickwidget.html#wheelEvent">wheelEvent</a></b>(QWheelEvent *<i>e</i>) override</td></tr>
</table></div>
<ul>
<li class="fn">35 protected functions inherited from <a href="../qtwidgets/qwidget.html#protected-functions">QWidget</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 protected function inherited from <a href="../qtgui/qpaintdevice.html#protected-functions">QPaintDevice</a></li>
</ul>
<h3>其他继承而来的成员</h3>
<ul>
<li class="fn">1 public variable inherited from <a href="../qtwidgets/qwidget.html#public-variables">QWidget</a></li>
<li class="fn">1 public variable inherited from <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">35 protected functions inherited from <a href="../qtwidgets/qwidget.html#protected-functions">QWidget</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 protected function inherited from <a href="../qtgui/qpaintdevice.html#protected-functions">QPaintDevice</a></li>
<li class="fn">1 protected slot inherited from <a href="../qtwidgets/qwidget.html#protected-slots">QWidget</a></li>
<li class="fn">2 protected variables inherited from <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
<li class="fn">1 protected type inherited from <a href="../qtgui/qpaintdevice.html#protected-variables">QPaintDevice</a></li>
</ul>
<a name="details"></a>
<!-- $$$QQuickWidget-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qquickwidget.html">QQuickWidget</a> class provides a widget for displaying a Qt Quick user interface.</p>
<p>This is a convenience wrapper for <a href="qquickwindow.html">QQuickWindow</a> which will automatically load and display a QML scene when given the URL of the main source file. Alternatively, you can instantiate your own objects using <a href="../qtqml/qqmlcomponent.html">QQmlComponent</a> and place them in a manually set up <a href="qquickwidget.html">QQuickWidget</a>.</p>
<p>Typical usage:</p>
<pre class="cpp">

  <span class="type"><a href="qquickwidget.html#QQuickWidget">QQuickWidget</a></span> <span class="operator">*</span>view <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qquickwidget.html#QQuickWidget">QQuickWidget</a></span>;
  view<span class="operator">-</span><span class="operator">&gt;</span>setSource(<span class="type"><a href="../qtcore/qurl.html">QUrl</a></span><span class="operator">::</span>fromLocalFile(<span class="string">&quot;myqmlfile.qml&quot;</span>));
  view<span class="operator">-</span><span class="operator">&gt;</span>show();

</pre>
<p>To receive errors related to loading and executing QML with <a href="qquickwidget.html">QQuickWidget</a>, you can connect to the <a href="qquickwidget.html#statusChanged">statusChanged</a>() signal and monitor for <a href="qquickwidget.html#Status-enum">QQuickWidget::Error</a>. The errors are available via <a href="qquickwidget.html#errors">QQuickWidget::errors</a>().</p>
<p><a href="qquickwidget.html">QQuickWidget</a> also manages sizing of the view and root object. By default, the <a href="qquickwidget.html#resizeMode-prop">resizeMode</a> is <a href="qquickwidget.html#ResizeMode-enum">SizeViewToRootObject</a>, which will load the component and resize it to the size of the view. Alternatively the <a href="qquickwidget.html#resizeMode-prop">resizeMode</a> may be set to <a href="qquickwidget.html#ResizeMode-enum">SizeRootObjectToView</a> which will resize the view to the size of the root object.</p>
<p><b>Note: </b><a href="qquickwidget.html">QQuickWidget</a> is an alternative to using <a href="qquickview.html">QQuickView</a> and <a href="../qtwidgets/qwidget.html#createWindowContainer">QWidget::createWindowContainer</a>(). The restrictions on stacking order do not apply, making <a href="qquickwidget.html">QQuickWidget</a> the more flexible alternative, behaving more like an ordinary widget. This comes at the expense of performance. Unlike <a href="qquickwindow.html">QQuickWindow</a> and <a href="qquickview.html">QQuickView</a>, <a href="qquickwidget.html">QQuickWidget</a> involves rendering into OpenGL framebuffer objects. This will naturally carry a minor performance hit.</p><p><b>Note: </b>Using <a href="qquickwidget.html">QQuickWidget</a> disables the threaded render loop on all platforms. This means that some of the benefits of threaded rendering, for example <a href="qml-qtquick-animator.html">Animator</a> classes and vsync driven animations, will not be available.</p><p><b>Note: </b>Avoid calling <a href="../qtwidgets/qwidget.html#winId">winId</a>() on a <a href="qquickwidget.html">QQuickWidget</a>. This function triggers the creation of a native window, resulting in reduced performance and possibly rendering glitches. The entire purpose of <a href="qquickwidget.html">QQuickWidget</a> is to render Quick scenes without a separate native window, hence making it a native widget should always be avoided.</p><a name="scene-graph-and-context-persistency"></a>
<h3 >Scene Graph and Context Persistency</h3>
<p><a href="qquickwidget.html">QQuickWidget</a> honors <a href="qquickwindow.html#isPersistentSceneGraph">QQuickWindow::isPersistentSceneGraph</a>(), meaning that applications can decide - by calling <a href="qquickwindow.html#setPersistentSceneGraph">QQuickWindow::setPersistentSceneGraph</a>() on the window returned from the <a href="qquickwidget.html#quickWindow">quickWindow</a>() function - to let scenegraph nodes and other Qt Quick scene related resources be released whenever the widget becomes hidden. By default persistency is enabled, just like with <a href="qquickwindow.html">QQuickWindow</a>.</p>
<p>When running with the OpenGL backend of the scene graph, <a href="qquickwindow.html">QQuickWindow</a> offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by <a href="qquickwidget.html">QQuickWidget</a> and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a <a href="qquickwidget.html">QQuickWidget</a> into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the <a href="../qtwidgets/qopenglwidget.html">QOpenGLWidget</a> documentation.</p>
<p><b>Note: </b><a href="qquickwidget.html">QQuickWidget</a> offers less fine-grained control over its internal OpenGL context than <a href="../qtwidgets/qopenglwidget.html">QOpenGLWidget</a>, and there are subtle differences, most notably that disabling the persistent scene graph will lead to destroying the context on a window change regardless of the presence of QCoreApplication::AA_ShareOpenGLContexts.</p><a name="limitations"></a>
<h3 >Limitations</h3>
<p>Putting other widgets underneath and making the <a href="qquickwidget.html">QQuickWidget</a> transparent will not lead to the expected results: the widgets underneath will not be visible. This is because in practice the <a href="qquickwidget.html">QQuickWidget</a> is drawn before all other regular, non-OpenGL widgets, and so see-through types of solutions are not feasible. Other type of layouts, like having widgets on top of the <a href="qquickwidget.html">QQuickWidget</a>, will function as expected.</p>
<p>When absolutely necessary, this limitation can be overcome by setting the <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_AlwaysStackOnTop</a> attribute on the <a href="qquickwidget.html">QQuickWidget</a>. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the <a href="qquickwidget.html">QQuickWidget</a>, so it should only be used in situations where a semi-transparent <a href="qquickwidget.html">QQuickWidget</a> with other widgets visible underneath is required.</p>
<p>This limitation only applies when there are other widgets underneath the <a href="qquickwidget.html">QQuickWidget</a> inside the same window. Making the window semi-transparent, with other applications and the desktop visible in the background, is done in the traditional way: Set <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_TranslucentBackground</a> on the top-level window, request an alpha channel, and change the Qt Quick Scenegraph's clear color to <a href="../qtcore/qt.html#GlobalColor-enum">Qt::transparent</a> via <a href="qquickwidget.html#setClearColor">setClearColor</a>().</p>
<a name="support-when-not-using-opengl"></a>
<h3 >Support when not using OpenGL</h3>
<p>In addition to OpenGL, the <code>software</code> backend of Qt Quick also supports <a href="qquickwidget.html">QQuickWidget</a>. Other backends, for example the Direct 3D 12 one, are not compatible however and attempting to construct a <a href="qquickwidget.html">QQuickWidget</a> will lead to problems.</p>
<a name="tab-key-handling"></a>
<h3 >Tab Key Handling</h3>
<p>On press of the <code>[TAB]</code> key, the item inside the <a href="qquickwidget.html">QQuickWidget</a> gets focus. If this item can handle <code>[TAB]</code> key press, focus will change accordingly within the item, otherwise the next widget in the focus chain gets focus.</p>
</div>
<p><b>See also </b><a href="../qtqml/qtqml-cppintegration-exposecppattributes.html">Exposing Attributes of C++ Types to QML</a>, <a href="qtquick-quickwidgets-quickwidget-example.html">Qt Quick Widgets Example</a>, and <a href="qquickview.html">QQuickView</a>.</p>
<!-- @@@QQuickWidget -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$ResizeMode$$$SizeViewToRootObject$$$SizeRootObjectToView -->
<h3 class="fn" id="ResizeMode-enum"><a name="ResizeMode-enum"></a>enum QQuickWidget::<span class="name">ResizeMode</span></h3>
<p>This enum specifies how to resize the view.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QQuickWidget::SizeViewToRootObject</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">The view resizes with the root item in the QML.</td></tr>
<tr><td class="topAlign"><code>QQuickWidget::SizeRootObjectToView</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">The view will automatically resize the root item to the size of the view.</td></tr>
</table></div>
<!-- @@@ResizeMode -->
<!-- $$$Status$$$Null$$$Ready$$$Loading$$$Error -->
<h3 class="fn" id="Status-enum"><a name="Status-enum"></a>enum QQuickWidget::<span class="name">Status</span></h3>
<p>Specifies the loading status of the <a href="qquickwidget.html">QQuickWidget</a>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QQuickWidget::Null</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">This <a href="qquickwidget.html">QQuickWidget</a> has no source set.</td></tr>
<tr><td class="topAlign"><code>QQuickWidget::Ready</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">This <a href="qquickwidget.html">QQuickWidget</a> has loaded and created the QML component.</td></tr>
<tr><td class="topAlign"><code>QQuickWidget::Loading</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">This <a href="qquickwidget.html">QQuickWidget</a> is loading network data.</td></tr>
<tr><td class="topAlign"><code>QQuickWidget::Error</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">One or more errors occurred. Call <a href="qquickwidget.html#errors">errors</a>() to retrieve a list of errors.</td></tr>
</table></div>
<!-- @@@Status -->
</div>
<div class="prop">
<h2>属性文档</h2>
<!-- $$$resizeMode-prop$$$resizeMode$$$setResizeModeQQuickWidget::ResizeMode -->
<h3 class="fn" id="resizeMode-prop"><a name="resizeMode-prop"></a><span class="name">resizeMode</span> : <span class="type"><a href="qquickwidget.html#ResizeMode-enum">ResizeMode</a></span></h3>
<p>Determines whether the view should resize the window contents.</p>
<p>If this property is set to <a href="qquickwidget.html#ResizeMode-enum">SizeViewToRootObject</a> (the default), the view resizes to the size of the root item in the QML.</p>
<p>If this property is set to <a href="qquickwidget.html#ResizeMode-enum">SizeRootObjectToView</a>, the view will automatically resize the root item to the size of the view.</p>
<p>Regardless of this property, the <a href="../qtwidgets/qwidget.html#sizeHint-prop">sizeHint</a> of the view is the initial size of the root item. Note though that since QML may load dynamically, that size may change.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QQuickWidget::ResizeMode </td><td class="memItemRight bottomAlign"><span class="name"><b>resizeMode</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setResizeMode</b></span>(<i>QQuickWidget::ResizeMode</i>)</td></tr>
</table></div>
<p><b>See also </b><a href="qquickwidget.html#initialSize">initialSize</a>().</p>
<!-- @@@resizeMode -->
<!-- $$$source-prop$$$source$$$setSourceconstQUrl& -->
<h3 class="fn" id="source-prop"><a name="source-prop"></a><span class="name">source</span> : <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span></h3>
<p>This property holds the URL of the source of the QML component.</p>
<p>Ensure that the URL provided is full and correct, in particular, use <a href="../qtcore/qurl.html#fromLocalFile">QUrl::fromLocalFile</a>() when loading a file from the local filesystem.</p>
<p><b>Note: </b>Setting a source URL will result in the QML component being instantiated, even if the URL is unchanged from the current value.</p><p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QUrl </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qquickwidget.html#source">source</a></b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qquickwidget.html#setSource">setSource</a></b></span>(const QUrl &amp;<i>url</i>)</td></tr>
</table></div>
<!-- @@@source -->
<!-- $$$status-prop$$$status$$$statusChangedQQuickWidget::Status -->
<h3 class="fn" id="status-prop"><a name="status-prop"></a><span class="name">status</span> : const <span class="type"><a href="qquickwidget.html#Status-enum">Status</a></span></h3>
<p>The component's current <a href="qquickwidget.html#Status-enum">status</a>.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QQuickWidget::Status </td><td class="memItemRight bottomAlign"><span class="name"><b>status</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qquickwidget.html#statusChanged">statusChanged</a></b></span>(QQuickWidget::Status <i>status</i>)</td></tr>
</table></div>
<!-- @@@status -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QQuickWidget[overload1]$$$QQuickWidgetQWidget* -->
<h3 class="fn" id="QQuickWidget"><a name="QQuickWidget"></a>QQuickWidget::<span class="name">QQuickWidget</span>(<span class="type"><a href="../qtwidgets/qwidget.html#QWidget">QWidget</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a <a href="qquickwidget.html">QQuickWidget</a> with the given <i>parent</i>. The default value of <i>parent</i> is 0.</p>
<!-- @@@QQuickWidget -->
<!-- $$$QQuickWidget$$$QQuickWidgetQQmlEngine*QWidget* -->
<h3 class="fn" id="QQuickWidget-1"><a name="QQuickWidget-1"></a>QQuickWidget::<span class="name">QQuickWidget</span>(<span class="type"><a href="../qtqml/qqmlengine.html">QQmlEngine</a></span> *<i>engine</i>, <span class="type"><a href="../qtwidgets/qwidget.html#QWidget">QWidget</a></span> *<i>parent</i>)</h3>
<p>Constructs a <a href="qquickwidget.html">QQuickWidget</a> with the given QML <i>engine</i> and <i>parent</i>.</p>
<p>Note: In this case, the <a href="qquickwidget.html">QQuickWidget</a> does not own the given <i>engine</i> object; it is the caller's responsibility to destroy the engine. If the <i>engine</i> is deleted before the view, <a href="qquickwidget.html#status-prop">status</a>() will return <a href="qquickwidget.html#Status-enum">QQuickWidget::Error</a>.</p>
<p><b>See also </b><a href="qquickwidget.html#Status-enum">Status</a>, <a href="qquickwidget.html#status-prop">status</a>(), and <a href="qquickwidget.html#errors">errors</a>().</p>
<!-- @@@QQuickWidget -->
<!-- $$$QQuickWidget$$$QQuickWidgetconstQUrl&QWidget* -->
<h3 class="fn" id="QQuickWidget-2"><a name="QQuickWidget-2"></a>QQuickWidget::<span class="name">QQuickWidget</span>(const <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> &amp;<i>source</i>, <span class="type"><a href="../qtwidgets/qwidget.html#QWidget">QWidget</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a <a href="qquickwidget.html">QQuickWidget</a> with the given QML <i>source</i> and <i>parent</i>. The default value of <i>parent</i> is 0.</p>
<!-- @@@QQuickWidget -->
<!-- $$$~QQuickWidget[overload1]$$$~QQuickWidget -->
<h3 class="fn" id="dtor.QQuickWidget"><a name="dtor.QQuickWidget"></a><code>[override virtual] </code>QQuickWidget::<span class="name">~QQuickWidget</span>()</h3>
<p>Destroys the <a href="qquickwidget.html">QQuickWidget</a>.</p>
<!-- @@@~QQuickWidget -->
<!-- $$$dragEnterEvent[overload1]$$$dragEnterEventQDragEnterEvent* -->
<h3 class="fn" id="dragEnterEvent"><a name="dragEnterEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">dragEnterEvent</span>(<span class="type"><a href="../qtgui/qdragenterevent.html">QDragEnterEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#dragEnterEvent">QWidget::dragEnterEvent</a>().</p>
<!-- @@@dragEnterEvent -->
<!-- $$$dragLeaveEvent[overload1]$$$dragLeaveEventQDragLeaveEvent* -->
<h3 class="fn" id="dragLeaveEvent"><a name="dragLeaveEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">dragLeaveEvent</span>(<span class="type"><a href="../qtgui/qdragleaveevent.html">QDragLeaveEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#dragLeaveEvent">QWidget::dragLeaveEvent</a>().</p>
<!-- @@@dragLeaveEvent -->
<!-- $$$dragMoveEvent[overload1]$$$dragMoveEventQDragMoveEvent* -->
<h3 class="fn" id="dragMoveEvent"><a name="dragMoveEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">dragMoveEvent</span>(<span class="type"><a href="../qtgui/qdragmoveevent.html">QDragMoveEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#dragMoveEvent">QWidget::dragMoveEvent</a>().</p>
<!-- @@@dragMoveEvent -->
<!-- $$$dropEvent[overload1]$$$dropEventQDropEvent* -->
<h3 class="fn" id="dropEvent"><a name="dropEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">dropEvent</span>(<span class="type"><a href="../qtgui/qdropevent.html">QDropEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#dropEvent">QWidget::dropEvent</a>().</p>
<!-- @@@dropEvent -->
<!-- $$$engine[overload1]$$$engine -->
<h3 class="fn" id="engine"><a name="engine"></a><span class="type"><a href="../qtqml/qqmlengine.html">QQmlEngine</a></span> *QQuickWidget::<span class="name">engine</span>() const</h3>
<p>Returns a pointer to the <a href="../qtqml/qqmlengine.html">QQmlEngine</a> used for instantiating QML Components.</p>
<!-- @@@engine -->
<!-- $$$errors[overload1]$$$errors -->
<h3 class="fn" id="errors"><a name="errors"></a><span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="../qtqml/qqmlerror.html">QQmlError</a></span>&gt; QQuickWidget::<span class="name">errors</span>() const</h3>
<p>Return the list of errors that occurred during the last compile or create operation. When the status is not <a href="qquickwidget.html#Status-enum">Error</a>, an empty list is returned.</p>
<p><b>See also </b><a href="qquickwidget.html#status-prop">status</a>.</p>
<!-- @@@errors -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event"><a name="event"></a><code>[override virtual protected] </code><span class="type">bool</span> QQuickWidget::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#event">QWidget::event</a>().</p>
<!-- @@@event -->
<!-- $$$focusInEvent[overload1]$$$focusInEventQFocusEvent* -->
<h3 class="fn" id="focusInEvent"><a name="focusInEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">focusInEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html">QFocusEvent</a></span> *<i>event</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#focusInEvent">QWidget::focusInEvent</a>().</p>
<!-- @@@focusInEvent -->
<!-- $$$focusNextPrevChild[overload1]$$$focusNextPrevChildbool -->
<h3 class="fn" id="focusNextPrevChild"><a name="focusNextPrevChild"></a><code>[override virtual protected] </code><span class="type">bool</span> QQuickWidget::<span class="name">focusNextPrevChild</span>(<span class="type">bool</span> <i>next</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#focusNextPrevChild">QWidget::focusNextPrevChild</a>().</p>
<!-- @@@focusNextPrevChild -->
<!-- $$$focusOutEvent[overload1]$$$focusOutEventQFocusEvent* -->
<h3 class="fn" id="focusOutEvent"><a name="focusOutEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">focusOutEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html">QFocusEvent</a></span> *<i>event</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#focusOutEvent">QWidget::focusOutEvent</a>().</p>
<!-- @@@focusOutEvent -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" id="format"><a name="format"></a><span class="type"><a href="../qtgui/qsurfaceformat.html">QSurfaceFormat</a></span> QQuickWidget::<span class="name">format</span>() const</h3>
<p>Returns the actual surface format.</p>
<p>If the widget has not yet been shown, the requested format is returned.</p>
<p><b>See also </b><a href="qquickwidget.html#setFormat">setFormat</a>().</p>
<!-- @@@format -->
<!-- $$$grabFramebuffer[overload1]$$$grabFramebuffer -->
<h3 class="fn" id="grabFramebuffer"><a name="grabFramebuffer"></a><span class="type"><a href="../qtgui/qimage.html">QImage</a></span> QQuickWidget::<span class="name">grabFramebuffer</span>() const</h3>
<p>Renders a frame and reads it back into an image.</p>
<p><b>Note: </b>This is a potentially expensive operation.</p><!-- @@@grabFramebuffer -->
<!-- $$$hideEvent[overload1]$$$hideEventQHideEvent* -->
<h3 class="fn" id="hideEvent"><a name="hideEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">hideEvent</span>(<i>QHideEvent *</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#hideEvent">QWidget::hideEvent</a>().</p>
<!-- @@@hideEvent -->
<!-- $$$initialSize[overload1]$$$initialSize -->
<h3 class="fn" id="initialSize"><a name="initialSize"></a><span class="type"><a href="../qtcore/qsize.html">QSize</a></span> QQuickWidget::<span class="name">initialSize</span>() const</h3>
<p>Returns the initial size of the root object.</p>
<p>If <a href="qquickwidget.html#resizeMode-prop">resizeMode</a> is <a href="qquickwidget.html#ResizeMode-enum">SizeRootObjectToView</a>, the root object will be resized to the size of the view. This function returns the size of the root object before it was resized.</p>
<!-- @@@initialSize -->
<!-- $$$keyPressEvent[overload1]$$$keyPressEventQKeyEvent* -->
<h3 class="fn" id="keyPressEvent"><a name="keyPressEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">keyPressEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html">QKeyEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#keyPressEvent">QWidget::keyPressEvent</a>().</p>
<!-- @@@keyPressEvent -->
<!-- $$$keyReleaseEvent[overload1]$$$keyReleaseEventQKeyEvent* -->
<h3 class="fn" id="keyReleaseEvent"><a name="keyReleaseEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">keyReleaseEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html">QKeyEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#keyReleaseEvent">QWidget::keyReleaseEvent</a>().</p>
<!-- @@@keyReleaseEvent -->
<!-- $$$mouseDoubleClickEvent[overload1]$$$mouseDoubleClickEventQMouseEvent* -->
<h3 class="fn" id="mouseDoubleClickEvent"><a name="mouseDoubleClickEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#mouseDoubleClickEvent">QWidget::mouseDoubleClickEvent</a>().</p>
<!-- @@@mouseDoubleClickEvent -->
<!-- $$$mouseMoveEvent[overload1]$$$mouseMoveEventQMouseEvent* -->
<h3 class="fn" id="mouseMoveEvent"><a name="mouseMoveEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#mouseMoveEvent">QWidget::mouseMoveEvent</a>().</p>
<!-- @@@mouseMoveEvent -->
<!-- $$$mousePressEvent[overload1]$$$mousePressEventQMouseEvent* -->
<h3 class="fn" id="mousePressEvent"><a name="mousePressEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">mousePressEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#mousePressEvent">QWidget::mousePressEvent</a>().</p>
<!-- @@@mousePressEvent -->
<!-- $$$mouseReleaseEvent[overload1]$$$mouseReleaseEventQMouseEvent* -->
<h3 class="fn" id="mouseReleaseEvent"><a name="mouseReleaseEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#mouseReleaseEvent">QWidget::mouseReleaseEvent</a>().</p>
<!-- @@@mouseReleaseEvent -->
<!-- $$$paintEvent[overload1]$$$paintEventQPaintEvent* -->
<h3 class="fn" id="paintEvent"><a name="paintEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">paintEvent</span>(<span class="type"><a href="../qtgui/qpaintevent.html">QPaintEvent</a></span> *<i>event</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#paintEvent">QWidget::paintEvent</a>().</p>
<!-- @@@paintEvent -->
<!-- $$$quickWindow[overload1]$$$quickWindow -->
<h3 class="fn" id="quickWindow"><a name="quickWindow"></a><span class="type"><a href="qquickwindow.html">QQuickWindow</a></span> *QQuickWidget::<span class="name">quickWindow</span>() const</h3>
<p>Returns the offscreen <a href="qquickwindow.html">QQuickWindow</a> which is used by this widget to drive the Qt Quick rendering. This is useful if you want to use <a href="qquickwindow.html">QQuickWindow</a> APIs that are not currently exposed by <a href="qquickwidget.html">QQuickWidget</a>, for instance connecting to the <a href="qquickwindow.html#beforeRendering">QQuickWindow::beforeRendering</a>() signal in order to draw native OpenGL content below Qt Quick's own rendering.</p>
<p><b>Warning:</b> Use the return value of this function with caution. In particular, do not ever attempt to show the <a href="qquickwindow.html">QQuickWindow</a>, and be very careful when using other <a href="../qtgui/qwindow.html">QWindow</a>-only APIs.</p>
<p>This function was introduced in  Qt 5.5.</p>
<!-- @@@quickWindow -->
<!-- $$$rootContext[overload1]$$$rootContext -->
<h3 class="fn" id="rootContext"><a name="rootContext"></a><span class="type"><a href="../qtqml/qqmlcontext.html">QQmlContext</a></span> *QQuickWidget::<span class="name">rootContext</span>() const</h3>
<p>This function returns the root of the context hierarchy. Each QML component is instantiated in a <a href="../qtqml/qqmlcontext.html">QQmlContext</a>. <a href="../qtqml/qqmlcontext.html">QQmlContext</a>'s are essential for passing data to QML components. In QML, contexts are arranged hierarchically and this hierarchy is managed by the <a href="../qtqml/qqmlengine.html">QQmlEngine</a>.</p>
<!-- @@@rootContext -->
<!-- $$$rootObject[overload1]$$$rootObject -->
<h3 class="fn" id="rootObject"><a name="rootObject"></a><span class="type"><a href="qquickitem.html">QQuickItem</a></span> *QQuickWidget::<span class="name">rootObject</span>() const</h3>
<p>Returns the view's root <a href="qquickitem.html">item</a>. Can be null when <a href="qquickwidget.html#setSource">setSource</a>() has not been called, if it was called with broken <a href="qtquick-module.html">QtQuick</a> code or while the <a href="qtquick-module.html">QtQuick</a> contents are being created.</p>
<!-- @@@rootObject -->
<!-- $$$sceneGraphError[overload1]$$$sceneGraphErrorQQuickWindow::SceneGraphErrorconstQString& -->
<h3 class="fn" id="sceneGraphError"><a name="sceneGraphError"></a><code>[signal] </code><span class="type">void</span> QQuickWidget::<span class="name">sceneGraphError</span>(<span class="type"><a href="qquickwindow.html#SceneGraphError-enum">QQuickWindow::SceneGraphError</a></span> <i>error</i>, const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>message</i>)</h3>
<p>This signal is emitted when an <i>error</i> occurred during scene graph initialization.</p>
<p>Applications should connect to this signal if they wish to handle errors, like OpenGL context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the <i>message</i>, or show a message box, and terminate the application.</p>
<p>This signal will be emitted from the gui thread.</p>
<p><b>See also </b><a href="qquickwindow.html#sceneGraphError">QQuickWindow::sceneGraphError</a>().</p>
<!-- @@@sceneGraphError -->
<!-- $$$setClearColor[overload1]$$$setClearColorconstQColor& -->
<h3 class="fn" id="setClearColor"><a name="setClearColor"></a><span class="type">void</span> QQuickWidget::<span class="name">setClearColor</span>(const <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> &amp;<i>color</i>)</h3>
<p>Sets the clear <i>color</i>. By default this is an opaque color.</p>
<p>To get a semi-transparent <a href="qquickwidget.html">QQuickWidget</a>, call this function with <i>color</i> set to <a href="../qtcore/qt.html#GlobalColor-enum">Qt::transparent</a>, set the <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_TranslucentBackground</a> widget attribute on the top-level window, and request an alpha channel via <a href="qquickwidget.html#setFormat">setFormat</a>().</p>
<p><b>See also </b><a href="qquickwindow.html#color-prop">QQuickWindow::setColor</a>().</p>
<!-- @@@setClearColor -->
<!-- $$$setFormat[overload1]$$$setFormatconstQSurfaceFormat& -->
<h3 class="fn" id="setFormat"><a name="setFormat"></a><span class="type">void</span> QQuickWidget::<span class="name">setFormat</span>(const <span class="type"><a href="../qtgui/qsurfaceformat.html">QSurfaceFormat</a></span> &amp;<i>format</i>)</h3>
<p>Sets the surface <i>format</i> for the context and offscreen surface used by this widget.</p>
<p>Call this function when there is a need to request a context for a given OpenGL version or profile. The sizes for depth, stencil and alpha buffers are taken care of automatically and there is no need to request those explicitly.</p>
<p><b>See also </b><a href="../qtgui/qwindow.html#setFormat">QWindow::setFormat</a>(), <a href="../qtgui/qwindow.html#format">QWindow::format</a>(), and <a href="qquickwidget.html#format">format</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setSource -->
<h3 class="fn" id="setSource"><a name="setSource"></a><code>[slot] </code><span class="type">void</span> QQuickWidget::<span class="name">setSource</span>(const <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> &amp;<i>url</i>)</h3>
<p>Sets the source to the <i>url</i>, loads the QML component and instantiates it.</p>
<p>Ensure that the URL provided is full and correct, in particular, use <a href="../qtcore/qurl.html#fromLocalFile">QUrl::fromLocalFile</a>() when loading a file from the local filesystem.</p>
<p>Calling this method multiple times with the same URL will result in the QML component being reinstantiated.</p>
<p><b>Note:</b> Setter function for property <a href="qquickwidget.html#source-prop">source</a>. </p><p><b>See also </b><a href="qquickwidget.html#source">source</a>().</p>
<!-- @@@setSource -->
<!-- $$$showEvent[overload1]$$$showEventQShowEvent* -->
<h3 class="fn" id="showEvent"><a name="showEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">showEvent</span>(<i>QShowEvent *</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#showEvent">QWidget::showEvent</a>().</p>
<!-- @@@showEvent -->
<!-- $$$source -->
<h3 class="fn" id="source"><a name="source"></a><span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> QQuickWidget::<span class="name">source</span>() const</h3>
<p>Returns the source URL, if set.</p>
<p><b>Note:</b> Getter function for property <a href="qquickwidget.html#source-prop">source</a>. </p><p><b>See also </b><a href="qquickwidget.html#setSource">setSource</a>().</p>
<!-- @@@source -->
<!-- $$$statusChanged -->
<h3 class="fn" id="statusChanged"><a name="statusChanged"></a><code>[signal] </code><span class="type">void</span> QQuickWidget::<span class="name">statusChanged</span>(<span class="type"><a href="qquickwidget.html#Status-enum">QQuickWidget::Status</a></span> <i>status</i>)</h3>
<p>This signal is emitted when the component's current <i>status</i> changes.</p>
<p><b>Note:</b> Notifier signal for property <a href="qquickwidget.html#status-prop">status</a>. </p><!-- @@@statusChanged -->
<!-- $$$wheelEvent[overload1]$$$wheelEventQWheelEvent* -->
<h3 class="fn" id="wheelEvent"><a name="wheelEvent"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">wheelEvent</span>(<span class="type"><a href="../qtgui/qwheelevent.html">QWheelEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtwidgets/qwidget.html#wheelEvent">QWidget::wheelEvent</a>().</p>
<!-- @@@wheelEvent -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
