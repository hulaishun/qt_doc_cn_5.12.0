<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>RenderState Class | Qt Quick 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtquick-index.html">Qt Quick</a></td><td ><a href="qtquick-module.html">C++ Classes</a></td><td >RenderState</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">RenderState Class</h1>
<span class="small-subtitle">(<a href="qsgrendernode-renderstate.html">QSGRenderNode::RenderState</a>)<br/></span>
<ul>
<li><a href="qsgrendernode-renderstate-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual const QRegion *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#clipRegion">clipRegion</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#get">get</a></b>(const char *<i>state</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual const QMatrix4x4 *</td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#projectionMatrix">projectionMatrix</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#scissorEnabled">scissorEnabled</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRect </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#scissorRect">scissorRect</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#stencilEnabled">stencilEnabled</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qsgrendernode-renderstate.html#stencilValue">stencilValue</a></b>() const = 0</td></tr>
</table></div>
<a name="details"></a>
<div class="types">
<h2>成员类型文档</h2>
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$clipRegion[overload1]$$$clipRegion -->
<h3 class="fn" id="clipRegion"><a name="clipRegion"></a><code>[pure virtual] </code>const <span class="type"><a href="../qtgui/qregion.html">QRegion</a></span> *RenderState::<span class="name">clipRegion</span>() const</h3>
<p>Returns the current clip region or null for backends where clipping is implemented via stencil or scissoring.</p>
<p>The software backend uses no projection, scissor or stencil, meaning most of the render state is not in use. However, the clip region that can be set on the <a href="../qtgui/qpainter.html">QPainter</a> still has to be communicated since reconstructing this manually in <a href="qsgrendernode.html#render">render</a>() is not reasonable. It can therefore be queried via this function. The region is in world coordinates and can be passed to <a href="../qtgui/qpainter.html#setClipRegion">QPainter::setClipRegion</a>() with <a href="../qtcore/qt.html#ClipOperation-enum">Qt::ReplaceClip</a>. This must be done before calling <a href="../qtgui/qpainter.html#setTransform">QPainter::setTransform</a>() since the clip region is already mapped to the transform provided in <a href="qsgrendernode.html#matrix">QSGRenderNode::matrix</a>().</p>
<!-- @@@clipRegion -->
<!-- $$$get[overload1]$$$getconstchar* -->
<h3 class="fn" id="get"><a name="get"></a><code>[virtual] </code><span class="type">void</span> *RenderState::<span class="name">get</span>(const <span class="type">char</span> *<i>state</i>) const</h3>
<p>Returns pointer to a <i>state</i> value.</p>
<p>Reserved for future use.</p>
<!-- @@@get -->
<!-- $$$projectionMatrix[overload1]$$$projectionMatrix -->
<h3 class="fn" id="projectionMatrix"><a name="projectionMatrix"></a><code>[pure virtual] </code>const <span class="type"><a href="../qtgui/qmatrix4x4.html">QMatrix4x4</a></span> *RenderState::<span class="name">projectionMatrix</span>() const</h3>
<p>Returns pointer to the current projection matrix.</p>
<p>The model-view matrix can be retrieved with <a href="qsgrendernode.html#matrix">QSGRenderNode::matrix</a>(). Typically <code>projection * modelview</code> is the matrix that is then used in the vertex shader to transform the vertices.</p>
<!-- @@@projectionMatrix -->
<!-- $$$scissorEnabled[overload1]$$$scissorEnabled -->
<h3 class="fn" id="scissorEnabled"><a name="scissorEnabled"></a><code>[pure virtual] </code><span class="type">bool</span> RenderState::<span class="name">scissorEnabled</span>() const</h3>
<p>Returns the current state of scissoring.</p>
<p><b>Note: </b>Only relevant for graphics APIs that have a dedicated on/off state of scissoring.</p><!-- @@@scissorEnabled -->
<!-- $$$scissorRect[overload1]$$$scissorRect -->
<h3 class="fn" id="scissorRect"><a name="scissorRect"></a><code>[pure virtual] </code><span class="type"><a href="../qtcore/qrect.html">QRect</a></span> RenderState::<span class="name">scissorRect</span>() const</h3>
<p>Returns the current scissor rectangle when clipping is active.</p>
<p><b>Note: </b>Be aware of the differences between graphics APIs: for some the scissor rect is only active when scissoring is enabled (for example, OpenGL), while for others the scissor rect is equal to the viewport rect when there is no need to scissor away anything (for example, Direct3D 12).</p><!-- @@@scissorRect -->
<!-- $$$stencilEnabled[overload1]$$$stencilEnabled -->
<h3 class="fn" id="stencilEnabled"><a name="stencilEnabled"></a><code>[pure virtual] </code><span class="type">bool</span> RenderState::<span class="name">stencilEnabled</span>() const</h3>
<p>Returns the current state of stencil testing.</p>
<p><b>Note: </b>With graphics APIs where stencil testing is enabled in pipeline state objects, instead of individual state-setting commands, it is up to the implementation of <a href="qsgrendernode.html#render">render</a>() to enable stencil testing with operations <code>KEEP</code>, comparison function <code>EQUAL</code>, and a read and write mask of <code>0xFF</code>.</p><!-- @@@stencilEnabled -->
<!-- $$$stencilValue[overload1]$$$stencilValue -->
<h3 class="fn" id="stencilValue"><a name="stencilValue"></a><code>[pure virtual] </code><span class="type">int</span> RenderState::<span class="name">stencilValue</span>() const</h3>
<p>Returns the current stencil reference value when clipping is active.</p>
<!-- @@@stencilValue -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
