<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qquickframebufferobject.cpp -->
  <title>Renderer Class | Qt Quick 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtquick-index.html">Qt Quick</a></td><td ><a href="qtquick-module.html">C++类</a></td><td >Renderer</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#protected-functions">保护函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Renderer Class</h1>
<span class="small-subtitle">(<a href="qquickframebufferobject-renderer.html">QQuickFramebufferObject::Renderer</a>)<br/></span>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;Renderer&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.2</td></tr></table></div><ul>
<li><a href="qquickframebufferobject-renderer-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="protected-functions"></a>
<h2 id="protected-functions">保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickframebufferobject-renderer.html#Renderer">Renderer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qquickframebufferobject-renderer.html#dtor.Renderer">~Renderer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QOpenGLFramebufferObject *</td><td class="memItemRight bottomAlign"><b><a href="qquickframebufferobject-renderer.html#createFramebufferObject">createFramebufferObject</a></b>(const QSize &amp;<i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLFramebufferObject *</td><td class="memItemRight bottomAlign"><b><a href="qquickframebufferobject-renderer.html#framebufferObject">framebufferObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickframebufferobject-renderer.html#invalidateFramebufferObject">invalidateFramebufferObject</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickframebufferobject-renderer.html#render">render</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickframebufferobject-renderer.html#synchronize">synchronize</a></b>(QQuickFramebufferObject *<i>item</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickframebufferobject-renderer.html#update">update</a></b>()</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$Renderer-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qquickframebufferobject-renderer.html">QQuickFramebufferObject::Renderer</a> class is used to implement the rendering logic of a <a href="qquickframebufferobject.html">QQuickFramebufferObject</a>.</p>
</div>
<!-- @@@Renderer -->
<div class="types">
<h2>成员类型文档</h2>
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$Renderer[overload1]$$$Renderer -->
<h3 class="fn" id="Renderer"><a name="Renderer"></a><code>[protected] </code>Renderer::<span class="name">Renderer</span>()</h3>
<p>Constructs a new renderer.</p>
<p>This function is called during the scene graph sync phase when the GUI thread is blocked.</p>
<!-- @@@Renderer -->
<!-- $$$~Renderer[overload1]$$$~Renderer -->
<h3 class="fn" id="dtor.Renderer"><a name="dtor.Renderer"></a><code>[virtual protected] </code>Renderer::<span class="name">~Renderer</span>()</h3>
<p>The Renderer is automatically deleted when the scene graph resources for the <a href="qquickframebufferobject.html">QQuickFramebufferObject</a> item is cleaned up.</p>
<p>This function is called on the rendering thread.</p>
<!-- @@@~Renderer -->
<!-- $$$createFramebufferObject[overload1]$$$createFramebufferObjectconstQSize& -->
<h3 class="fn" id="createFramebufferObject"><a name="createFramebufferObject"></a><code>[virtual protected] </code><span class="type"><a href="../qtgui/qopenglframebufferobject.html">QOpenGLFramebufferObject</a></span> *Renderer::<span class="name">createFramebufferObject</span>(const <span class="type"><a href="../qtcore/qsize.html">QSize</a></span> &amp;<i>size</i>)</h3>
<p>This function is called when a new FBO is needed. This happens on the initial frame. If <a href="qquickframebufferobject.html#textureFollowsItemSize-prop">QQuickFramebufferObject::textureFollowsItemSize</a> is set to true, it is called again every time the dimensions of the item changes.</p>
<p>The returned FBO can have any attachment. If the <a href="../qtgui/qopenglframebufferobjectformat.html">QOpenGLFramebufferObjectFormat</a> indicates that the FBO should be multisampled, the internal implementation of the Renderer will allocate a second FBO and blit the multisampled FBO into the FBO used to display the texture.</p>
<p><b>Note: </b>Some hardware has issues with small FBO sizes. <i>size</i> takes that into account, so be cautious when overriding the size with a fixed size. A minimal size of 64x64 should always work.</p><p><b>Note: </b><i>size</i> takes the device pixel ratio into account, meaning that it is already multiplied by the correct scale factor. When moving the window containing the <a href="qquickframebufferobject.html">QQuickFramebufferObject</a> item to a screen with different settings, the FBO is automatically recreated and this function is invoked with the correct size.</p><!-- @@@createFramebufferObject -->
<!-- $$$framebufferObject[overload1]$$$framebufferObject -->
<h3 class="fn" id="framebufferObject"><a name="framebufferObject"></a><code>[protected] </code><span class="type"><a href="../qtgui/qopenglframebufferobject.html">QOpenGLFramebufferObject</a></span> *Renderer::<span class="name">framebufferObject</span>() const</h3>
<p>Returns the framebuffer object currently being rendered to.</p>
<!-- @@@framebufferObject -->
<!-- $$$invalidateFramebufferObject[overload1]$$$invalidateFramebufferObject -->
<h3 class="fn" id="invalidateFramebufferObject"><a name="invalidateFramebufferObject"></a><code>[protected] </code><span class="type">void</span> Renderer::<span class="name">invalidateFramebufferObject</span>()</h3>
<p>Call this function during <a href="qquickframebufferobject-renderer.html#synchronize">synchronize</a>() to invalidate the current FBO. This will result in a new FBO being created with <a href="qquickframebufferobject-renderer.html#createFramebufferObject">createFramebufferObject</a>().</p>
<!-- @@@invalidateFramebufferObject -->
<!-- $$$render[overload1]$$$render -->
<h3 class="fn" id="render"><a name="render"></a><code>[pure virtual protected] </code><span class="type">void</span> Renderer::<span class="name">render</span>()</h3>
<p>This function is called when the FBO should be rendered into. The framebuffer is bound at this point and the <code>glViewport</code> has been set up to match the FBO size.</p>
<p>The FBO will be automatically unbound after the function returns.</p>
<p><b>Note: </b>Do not assume that the OpenGL state is all set to the defaults when this function is invoked, or that it is maintained between calls. Both the Qt Quick renderer and the custom rendering code uses the same OpenGL context. This means that the state might have been modified by Quick before invoking this function.</p><p><b>Note: </b>It is recommended to call <a href="qquickwindow.html#resetOpenGLState">QQuickWindow::resetOpenGLState</a>() before returning. This resets OpenGL state used by the Qt Quick renderer and thus avoids interference from the state changes made by the rendering code in this function.</p><!-- @@@render -->
<!-- $$$synchronize[overload1]$$$synchronizeQQuickFramebufferObject* -->
<h3 class="fn" id="synchronize"><a name="synchronize"></a><code>[virtual protected] </code><span class="type">void</span> Renderer::<span class="name">synchronize</span>(<span class="type"><a href="qquickframebufferobject.html#QQuickFramebufferObject">QQuickFramebufferObject</a></span> *<i>item</i>)</h3>
<p>This function is called as a result of <a href="qquickitem.html#update">QQuickFramebufferObject::update</a>().</p>
<p>Use this function to update the renderer with changes that have occurred in the item. <i>item</i> is the item that instantiated this renderer. The function is called once before the FBO is created.</p>
<p><i>For instance, if the item has a color property which is controlled by QML, one should call <a href="qquickitem.html#update">QQuickFramebufferObject::update</a>() and use synchronize() to copy the new color into the renderer so that it can be used to render the next frame.</i></p>
<p>This function is the only place when it is safe for the renderer and the item to read and write each others members.</p>
<!-- @@@synchronize -->
<!-- $$$update[overload1]$$$update -->
<h3 class="fn" id="update"><a name="update"></a><code>[protected] </code><span class="type">void</span> Renderer::<span class="name">update</span>()</h3>
<p>Call this function when the FBO should be rendered again.</p>
<p>This function can be called from <a href="qquickframebufferobject-renderer.html#render">render</a>() to force the FBO to be rendered again before the next frame.</p>
<p><b>Note: </b>This function should be used from inside the renderer. To update the item on the GUI thread, use <a href="qquickitem.html#update">QQuickFramebufferObject::update</a>().</p><!-- @@@update -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
