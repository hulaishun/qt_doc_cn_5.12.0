<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qmake-manual.qdoc -->
  <title>测试函数 | qmake手册</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qmake-manual.html">qmake手册</a></td><td >测试函数</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
  <link rel="prev" href="qmake-function-reference.html" />
<p class="naviNextPrevious headerNavi">
<a class="prevPage" href="qmake-function-reference.html">替换函数</a>
</p><p/>
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#built-in-test-functions">内置测试函数</a></li>
<li class="level2"><a href="#cache-variablename-set-add-sub-transient-super-stash-source-variablename">cache(variablename, [set|add|sub] [transient] [super|stash], [source variablename])</a></li>
<li class="level2"><a href="#config-config">CONFIG(config)</a></li>
<li class="level2"><a href="#contains-variablename-value">contains(variablename, value)</a></li>
<li class="level2"><a href="#count-variablename-number">count(variablename, number)</a></li>
<li class="level2"><a href="#debug-level-message">debug(level, message)</a></li>
<li class="level2"><a href="#defined-name-type">defined(name[, type])</a></li>
<li class="level2"><a href="#equals-variablename-value">equals(variablename, value)</a></li>
<li class="level2"><a href="#error-string">error(string)</a></li>
<li class="level2"><a href="#eval-string">eval(string)</a></li>
<li class="level2"><a href="#exists-filename">exists(filename)</a></li>
<li class="level2"><a href="#export-variablename">export(variablename)</a></li>
<li class="level2"><a href="#for-iterate-list">for(iterate, list)</a></li>
<li class="level2"><a href="#greaterthan-variablename-value">greaterThan(variablename, value)</a></li>
<li class="level2"><a href="#if-condition">if(condition)</a></li>
<li class="level2"><a href="#include-filename">include(filename)</a></li>
<li class="level2"><a href="#infile-filename-var-val">infile(filename, var, val)</a></li>
<li class="level2"><a href="#isactiveconfig">isActiveConfig</a></li>
<li class="level2"><a href="#isempty-variablename">isEmpty(variablename)</a></li>
<li class="level2"><a href="#isequal">isEqual</a></li>
<li class="level2"><a href="#lessthan-variablename-value">lessThan(variablename, value)</a></li>
<li class="level2"><a href="#load-feature">load(feature)</a></li>
<li class="level2"><a href="#log-message">log(message)</a></li>
<li class="level2"><a href="#message-string">message(string)</a></li>
<li class="level2"><a href="#mkpath-dirpath">mkpath(dirPath)</a></li>
<li class="level2"><a href="#requires-condition">requires(condition)</a></li>
<li class="level2"><a href="#system-command">system(command)</a></li>
<li class="level2"><a href="#touch-filename-reference-filename">touch(filename, reference_filename)</a></li>
<li class="level2"><a href="#unset-variablename">unset(variablename)</a></li>
<li class="level2"><a href="#versionatleast-variablename-versionnumber">versionAtLeast(variablename, versionNumber)</a></li>
<li class="level2"><a href="#versionatmost-variablename-versionnumber">versionAtMost(variablename, versionNumber)</a></li>
<li class="level2"><a href="#warning-string">warning(string)</a></li>
<li class="level2"><a href="#write-file-filename-variablename-mode">write_file(filename, [variablename, [mode]])</a></li>
<li class="level1"><a href="#test-function-library">测试函数库</a></li>
<li class="level2"><a href="#packagesexist-packages">packagesExist(packages)</a></li>
<li class="level2"><a href="#preparerecursivetarget-target">prepareRecursiveTarget(target)</a></li>
<li class="level2"><a href="#qtcompiletest-test">qtCompileTest(test)</a></li>
<li class="level2"><a href="#qthavemodule-name">qtHaveModule(name)</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">测试函数</h1>
<span class="subtitle"></span>
<!-- $$$qmake-test-function-reference.html-description -->
<div class="descr"> <a name="details"></a>
<p>Test functions return a boolean value that you can test for in the conditional parts of scopes. Test functions can be divided into built-in functions and function libraries.</p>
<p> 参见 <a href="qmake-function-reference.html">替换函数</a>.</p>
<a name="built-in-test-functions"></a>
<h2 id="built-in-test-functions">内置测试函数</h2>
<p>Basic test functions are implemented as built-in functions.</p>
<a name="cache-variablename-set-add-sub-transient-super-stash-source-variablename"></a>
<h3 >cache(variablename, [set|add|sub] [transient] [super|stash], [source variablename])</h3>
<p>This is an internal function that you will typically not need.</p>
<a name="config-config"></a>
<h3 >CONFIG(config)</h3>
<p>This function can be used to test for variables placed into the <a href="qmake-variable-reference.html#config">CONFIG</a> variable. This is the same as scopes, but has the added advantage that a second parameter can be passed to test for the active config. As the order of values is important in <code>CONFIG</code> variables (that is, the last one set will be considered the active config for mutually exclusive values) a second parameter can be used to specify a set of values to consider. For example:</p>
<pre class="cpp">

  CONFIG = debug
  CONFIG += release
  CONFIG(release, debug|release):message(Release build!) #will print
  CONFIG(debug, debug|release):message(Debug build!) #no print

</pre>
<p>Because release is considered the active setting (for feature parsing) it will be the CONFIG used to generate the build file. In the common case a second parameter is not needed, but for specific mutual exclusive tests it is invaluable.</p>
<a name="contains-variablename-value"></a>
<h3 >contains(variablename, value)</h3>
<p>Succeeds if the variable <code>variablename</code> contains the value <code>value</code>; otherwise fails. It is possible to specify a regular expression for parameter <i>value</i>.</p>
<p>You can check the return value of this function using a scope.</p>
<p>样例如下：</p>
<pre class="cpp">

  contains( drivers, network ) {
      # drivers contains 'network'
      message( &quot;Configuring for network build...&quot; )
      HEADERS += network.h
      SOURCES += network.cpp
  }

</pre>
<p>The contents of the scope are only processed if the <code>drivers</code> variable contains the value <code>network</code>. If this is the case, the appropriate files are added to the <a href="qmake-variable-reference.html#sources">SOURCES</a> 和 <a href="qmake-variable-reference.html#headers">HEADERS</a> variables.</p>
<a name="countfunction"></a><a name="count-variablename-number"></a>
<h3 >count(variablename, number)</h3>
<p>Succeeds if the variable <code>variablename</code> contains a list with the specified <code>number</code> of values; otherwise fails.</p>
<p>This function is used to ensure that declarations inside a scope are only processed if the variable contains the correct number of values. For example:</p>
<pre class="cpp">

  options = $$find(CONFIG, &quot;debug&quot;) $$find(CONFIG, &quot;release&quot;)
  count(options, 2) {
      message(Both release and debug specified.)
  }

</pre>
<a name="debug-level-message"></a>
<h3 >debug(level, message)</h3>
<p>Checks whether qmake runs at the specified debug level. If yes, it returns true and prints a debug message.</p>
<a name="defined-name-type"></a>
<h3 >defined(name[, type])</h3>
<p>Tests whether the function or variable <code>name</code> is defined. If <code>type</code> is omitted, checks all functions. To check only variables or particular type of functions, specify <code>type</code>. It can have the following values:</p>
<ul>
<li><code>test</code> only checks test functions</li>
<li><code>replace</code> only checks replace functions</li>
<li><code>var</code> only checks variables</li>
</ul>
<a name="equals-variablename-value"></a>
<h3 >equals(variablename, value)</h3>
<p>Tests whether <code>variablename</code> equals the string <code>value</code>.</p>
<p>样例如下：</p>
<pre class="cpp">

  TARGET = helloworld
  equals(TARGET, &quot;helloworld&quot;) {
      message(&quot;The target assignment was successful.&quot;)
  }

</pre>
<a name="error-string"></a>
<h3 >error(string)</h3>
<p>This function never returns a value. qmake displays <code>string</code> as an error message to the user and exits. This function should only be used for unrecoverable errors.</p>
<p>样例如下：</p>
<pre class="cpp">

  error(An error has occurred in the configuration process.)

</pre>
<a name="eval-string"></a>
<h3 >eval(string)</h3>
<p>Evaluates the contents of the string using qmake syntax rules and returns true. Definitions and assignments can be used in the string to modify the values of existing variables or create new definitions.</p>
<p>样例如下：</p>
<pre class="cpp">

  eval(TARGET = myapp) {
      message($$TARGET)
  }

</pre>
<p><b>注意： </b>Quotation marks can be used to delimit the string, and the return value can be discarded if it is not needed.</p><a name="exists-filename"></a>
<h3 >exists(filename)</h3>
<p>Tests whether a file with the given <code>filename</code> exists. If the file exists, the function succeeds; otherwise it fails. If a regular expression is specified for the filename, this function succeeds if any file matches the regular expression specified.</p>
<p>样例如下：</p>
<pre class="cpp">

  exists( $(QTDIR)/lib/libqt-mt* ) {
        message( &quot;Configuring for multi-threaded Qt...&quot; )
        CONFIG += thread
  }

</pre>
<p><b>注意： </b>&quot;/&quot; should be used as a directory separator, regardless of the platform in use.</p><a name="export-variablename"></a>
<h3 >export(variablename)</h3>
<p>Exports the current value of <code>variablename</code> from the local context of a function to the global context.</p>
<a name="forfunction"></a><a name="for-iterate-list"></a>
<h3 >for(iterate, list)</h3>
<p>Starts a loop that iterates over all values in <code>list</code>, setting <code>iterate</code> to each value in turn. As a convenience, if <code>list</code> is 1..10 then iterate will iterate over the values 1 through 10.</p>
<p>样例如下：</p>
<pre class="cpp">

  LIST = 1 2 3
  for(a, LIST):exists(file.$${a}):message(I see a file.$${a}!)

</pre>
<a name="greaterthan-variablename-value"></a>
<h3 >greaterThan(variablename, value)</h3>
<p>Tests that the value of <code>variablename</code> is greater than <code>value</code>. First, this function attempts a numerical comparison. If at least one of the operands fails to convert, this function does a string comparison.</p>
<p>样例如下：</p>
<pre class="cpp">

  ANSWER = 42
  greaterThan(ANSWER, 1) {
      message(&quot;The answer might be correct.&quot;)
  }

</pre>
<p>It is impossible to compare two numbers as strings directly. As a workaround, construct temporary values with a non-numeric prefix and compare these.</p>
<p>样例如下：</p>
<pre class="cpp">

  VALUE = 123
  TMP_VALUE = x$$VALUE
  greaterThan(TMP_VALUE, x456): message(&quot;Condition may be true.&quot;)

</pre>
<p> 参见 <a href="qmake-test-function-reference.html#lessthan-variablename-value">lessThan()</a>.</p>
<a name="if-condition"></a>
<h3 >if(condition)</h3>
<p>Evaluates <code>condition</code>. It is used to group boolean expressions.</p>
<p>样例如下：</p>
<pre class="cpp">

  if(linux-g++*|macx-g++*):CONFIG(debug, debug|release) {
      message(&quot;We are on Linux or Mac OS, and we are in debug mode.&quot;)
  }

</pre>
<a name="include-filename"></a>
<h3 >include(filename)</h3>
<p>Includes the contents of the file specified by <code>filename</code> into the current project at the point where it is included. This function succeeds if <code>filename</code> is included; otherwise it fails. The included file is processed immediately.</p>
<p>You can check whether the file was included by using this function as the condition for a scope. For example:</p>
<pre class="cpp">

  include( shared.pri )
  OPTIONS = standard custom
  !include( options.pri ) {
      message( &quot;No custom build options specified&quot; )
  OPTIONS -= custom
  }

</pre>
<a name="infile-filename-var-val"></a>
<h3 >infile(filename, var, val)</h3>
<p>Succeeds if the file <code>filename</code> (when parsed by qmake itself) contains the variable <code>var</code> with a value of <code>val</code>; otherwise fails. If you do not specify <code>val</code>, the function tests whether <code>var</code> has been assigned in the file.</p>
<a name="isactiveconfig"></a>
<h3 >isActiveConfig</h3>
<p>This is an alias for the <code>CONFIG</code> function.</p>
<a name="isempty-variablename"></a>
<h3 >isEmpty(variablename)</h3>
<p>Succeeds if the variable <code>variablename</code> is empty; otherwise fails. This is the equivalent of <code>count( variablename, 0 )</code>.</p>
<p>样例如下：</p>
<pre class="cpp">

  isEmpty( CONFIG ) {
  CONFIG += warn_on debug
  }

</pre>
<a name="isequal"></a>
<h3 >isEqual</h3>
<p>This is an alias for the <code>equals</code> function.</p>
<a name="lessthan-variablename-value"></a>
<h3 >lessThan(variablename, value)</h3>
<p>Tests that the value of <code>variablename</code> is less than <code>value</code>. Works as <a href="qmake-test-function-reference.html#greaterthan-variablename-value">greaterThan()</a>.</p>
<p>样例如下：</p>
<pre class="cpp">

  ANSWER = 42
  lessThan(ANSWER, 1) {
      message(&quot;The answer might be wrong.&quot;)
  }

</pre>
<a name="load-feature"></a>
<h3 >load(feature)</h3>
<p>Loads the feature file (<code>.prf</code>) specified by <code>feature</code>, unless the feature has already been loaded.</p>
<a name="log-message"></a>
<h3 >log(message)</h3>
<p>Prints a message on the console. Unlike the <code>message</code> function, neither prepends text nor appends a line break.</p>
<p> 参见 <a href="qmake-test-function-reference.html#message-string">message()</a>.</p>
<a name="message-string"></a>
<h3 >message(string)</h3>
<p>Always succeeds, and displays <code>string</code> as a general message to the user. Unlike the <code>error()</code> function, this function allows processing to continue.</p>
<pre class="cpp">

  message( &quot;This is a message&quot; )

</pre>
<p>The above line causes &quot;This is a message&quot; to be written to the console. The use of quotation marks is optional, but recommended.</p>
<p><b>注意： </b>By default, messages are written out for each Makefile generated by qmake for a given project. If you want to ensure that messages only appear once for each project, test the <code>build_pass</code> variable <a href="qmake-language.html#scopes">in conjunction with a scope</a> to filter out messages during builds. For example:</p><pre class="cpp">

  !build_pass:message( &quot;This is a message&quot; )

</pre>
<a name="mkpath-dirpath"></a>
<h3 >mkpath(dirPath)</h3>
<p>Creates the directory path <code>dirPath</code>. This function is a wrapper around the <a href="../qtcore/qdir.html#mkpath">QDir::mkpath</a> function.</p>
<a name="requires-condition"></a>
<h3 >requires(condition)</h3>
<p>Evaluates <code>condition</code>. If the condition is false, qmake skips this project (and its <a href="qmake-variable-reference.html#subdirs">SUBDIRS</a>) when building.</p>
<p><b>注意： </b>You can also use the <a href="qmake-variable-reference.html#requires">REQUIRES</a> variable for this purpose. However, we recommend using this function, instead.</p><a name="system-command"></a>
<h3 >system(command)</h3>
<p>Executes the given <code>command</code> in a secondary shell. Succeeds if the command returns with a zero exit status; otherwise fails. You can check the return value of this function using a scope.</p>
<p>样例如下：</p>
<pre class="cpp">

  system(&quot;ls /bin&quot;): HAS_BIN = TRUE

</pre>
<p>See also the replace variant of <a href="qmake-function-reference.html#system-replace">system()</a>.</p>
<a name="touchfunction"></a><a name="touch-filename-reference-filename"></a>
<h3 >touch(filename, reference_filename)</h3>
<p>Updates the time stamp of <code>filename</code> to match the time stamp of <code>reference_filename</code>.</p>
<a name="unset-variablename"></a>
<h3 >unset(variablename)</h3>
<p>Removes <code>variablename</code> from the current context.</p>
<p>样例如下：</p>
<pre class="cpp">

  NARF = zort
  unset(NARF)
  !defined(NARF, var) {
      message(&quot;NARF is not defined.&quot;)
  }

</pre>
<a name="versionatleast-variablename-versionnumber"></a>
<h3 >versionAtLeast(variablename, versionNumber)</h3>
<p>Tests that the version number from <code>variablename</code> is greater than or equal to <code>versionNumber</code>. The version number is considered to be a sequence of non-negative decimal numbers delimited by '.'; any non-numerical tail of the string will be ignored. Comparison is performed segment-wise from left to right; if one version is a prefix of the other, it is considered smaller.</p>
<a name="versionatmost-variablename-versionnumber"></a>
<h3 >versionAtMost(variablename, versionNumber)</h3>
<p>Tests that the version number from <code>variablename</code> is less than or equal to <code>versionNumber</code>. Works as <a href="qmake-test-function-reference.html#versionatleast-variablename-versionnumber">versionAtLeast()</a>.</p>
<a name="warning-string"></a>
<h3 >warning(string)</h3>
<p>Always succeeds, and displays <code>string</code> as a warning message to the user.</p>
<a name="write-file-filename-variablename-mode"></a>
<h3 >write_file(filename, [variablename, [mode]])</h3>
<p>Writes the values of <code>variablename</code> to a file with the name <code>filename</code>, each value on a separate line. If <code>variablename</code> is not specified, creates an empty file. If <code>mode</code> is <code>append</code> and the file already exists, appends to it instead of replacing it.</p>
<a name="test-function-library"></a>
<h2 id="test-function-library">测试函数库</h2>
<p>Complex test functions are implemented in a library of .prf files.</p>
<a name="packagesexist-packages"></a>
<h3 >packagesExist(packages)</h3>
<p>Uses the PKGCONFIG mechanism to determine whether or not the given packages exist at the time of project parsing.</p>
<p>This can be useful to optionally enable or disable features. For example:</p>
<pre class="cpp">

  packagesExist(sqlite3 QtNetwork QtDeclarative) {
      DEFINES += USE_FANCY_UI
  }

</pre>
<p>And then, in the code:</p>
<pre class="cpp">

  #ifdef USE_FANCY_UI
      // Use the fancy UI, as we have extra packages available
  #endif

</pre>
<a name="preparerecursivetarget-target"></a>
<h3 >prepareRecursiveTarget(target)</h3>
<p>Facilitates the creation of project-wide targets similar to the <code>install</code> target by preparing a target that iterates through all subdirectories. For example:</p>
<pre class="cpp">

  TEMPLATE = subdirs
  SUBDIRS = one two three
  prepareRecursiveTarget(check)

</pre>
<p>Subdirs that have <code>have_no_default</code> or <code>no_&lt;target&gt;_target</code> specified in their .CONFIG are excluded from this target:</p>
<pre class="cpp">

  two.CONFIG += no_check_target

</pre>
<p>You must add the prepared target manually to <a href="qmake-variable-reference.html#qmake-extra-targets">QMAKE_EXTRA_TARGETS</a>:</p>
<pre class="cpp">

  QMAKE_EXTRA_TARGETS += check

</pre>
<p>To make the target global, the code above needs to be included into every subdirs subproject. In addition, to make these targets do anything, non-subdirs subprojects need to include respective code. The easiest way to achieve this is creating a custom feature file. For example:</p>
<pre class="cpp">

  # &lt;project root&gt;/features/mycheck.prf
  equals(TEMPLATE, subdirs) {
      prepareRecursiveTarget(check)
  } else {
      check.commands = echo hello user
  }
  QMAKE_EXTRA_TARGETS += check

</pre>
<p>The feature file needs to be injected into each subproject, for example by .qmake.conf:</p>
<pre class="cpp">

  # &lt;project root&gt;/.qmake.conf
  CONFIG += mycheck

</pre>
<a name="qtcompiletest-test"></a>
<h3 >qtCompileTest(test)</h3>
<p>Builds a test project. If the test passes, true is returned and <code>config_&lt;test&gt;</code> is added to the <a href="qmake-variable-reference.html#config">CONFIG</a> variable. Otherwise, false is returned.</p>
<p>To make this function available, you need to load the respective feature file:</p>
<pre class="cpp">

  # &lt;project root&gt;/project.pro
  load(configure)

</pre>
<p>This also sets the variable QMAKE_CONFIG_TESTS_DIR to the <code>config.tests</code> subdirectory of the project's parent directory. It is possible to override this value after loading the feature file.</p>
<p>Inside the tests directory, there has to be one subdirectory per test that contains a simple qmake project. The following code snippet illustrates the .pro file of the project:</p>
<pre class="cpp">

  # &lt;project root&gt;/config.tests/test/test.pro
  SOURCES = main.cpp
  LIBS += -ltheFeature
  # Note that the test project is built without Qt by default.

</pre>
<p>The following code snippet illustrates the main .cpp file of the project:</p>
<pre class="cpp">

  // &lt;project root&gt;/config.tests/test/main.cpp
  #include &lt;TheFeature/MainHeader.h&gt;
  int main() { return featureFunction(); }

</pre>
<p>The following code snippet shows the invocation of the test:</p>
<pre class="cpp">

  # &lt;project root&gt;/project.pro
  qtCompileTest(test)

</pre>
<p>If the test project is built successfully, the test passes.</p>
<p>The test results are automatically cached, which also makes them available to all subprojects. It is therefore recommended to run all configuration tests in the top-level project file.</p>
<p>To suppress the re-use of cached results, pass <code>CONFIG+=recheck</code> to qmake.</p>
<p> 参见 <a href="qmake-test-function-reference.html#load-feature">load()</a>.</p>
<a name="qthavemodule-name"></a>
<h3 >qtHaveModule(name)</h3>
<p>Checks whether the Qt module specified by <code>name</code> is present. For a list of possible values, see <a href="qmake-variable-reference.html#qt">QT</a>.</p>
</div>
<!-- @@@qmake-test-function-reference.html -->
<p class="naviNextPrevious footerNavi">
<a class="prevPage" href="qmake-function-reference.html">替换函数</a>
</p>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
