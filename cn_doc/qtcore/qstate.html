<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qstate.cpp -->
  <title>QState Class | Qt核心模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QState</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">重新实现的保护函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#states-with-child-states">States with Child States</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QState Class</h1>
<!-- $$$QState-brief -->
<p>The <a href="qstate.html">QState</a> class provides a general-purpose state for <a href="qstatemachine.html">QStateMachine</a>. <a href="#details">更多详情...</a></p>
<!-- @@@QState -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QState&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 4.6</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="qabstractstate.html">QAbstractState</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的子类有：</td><td class="memItemRight bottomAlign"> <p><a href="qstatemachine.html">QStateMachine</a></p>
</td></tr></table></div><ul>
<li><a href="qstate-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qstate-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#ChildMode-enum">ChildMode</a></b> { ExclusiveStates, ParallelStates }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#RestorePolicy-enum">RestorePolicy</a></b> { DontRestoreProperties, RestoreProperties }</td></tr>
</table></div>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<ul>
<li class="fn"><b><a href="qstate.html#childMode-prop">childMode</a></b> : ChildMode</li>
<li class="fn"><b><a href="qstate.html#errorState-prop">errorState</a></b> : QAbstractState*</li>
<li class="fn"><b><a href="qstate.html#initialState-prop">initialState</a></b> : QAbstractState*</li>
</ul>
<ul>
<li class="fn">1 个属性继承于 <a href="qabstractstate.html#properties">QAbstractState</a></li>
<li class="fn">1 个属性继承于 <a href="qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#QState">QState</a></b>(QState *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#QState-1">QState</a></b>(QState::ChildMode <i>childMode</i>, QState *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#dtor.QState">~QState</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#addTransition">addTransition</a></b>(QAbstractTransition *<i>transition</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSignalTransition *</td><td class="memItemRight bottomAlign"><b><a href="qstate.html#addTransition-1">addTransition</a></b>(const QObject *<i>sender</i>, const char *<i>signal</i>, QAbstractState *<i>target</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSignalTransition *</td><td class="memItemRight bottomAlign"><b><a href="qstate.html#addTransition-2">addTransition</a></b>(const QObject *<i>sender</i>, PointerToMemberFunction <i>signal</i>, QAbstractState *<i>target</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractTransition *</td><td class="memItemRight bottomAlign"><b><a href="qstate.html#addTransition-3">addTransition</a></b>(QAbstractState *<i>target</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#assignProperty">assignProperty</a></b>(QObject *<i>object</i>, const char *<i>name</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QState::ChildMode </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#childMode">childMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractState *</td><td class="memItemRight bottomAlign"><b><a href="qstate.html#errorState">errorState</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractState *</td><td class="memItemRight bottomAlign"><b><a href="qstate.html#initialState">initialState</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#removeTransition">removeTransition</a></b>(QAbstractTransition *<i>transition</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#setChildMode">setChildMode</a></b>(QState::ChildMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#setErrorState">setErrorState</a></b>(QAbstractState *<i>state</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#setInitialState">setInitialState</a></b>(QAbstractState *<i>state</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QAbstractTransition *&gt; </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#transitions">transitions</a></b>() const</td></tr>
</table></div>
<ul>
<li class="fn">3 个公共函数继承于 <a href="qabstractstate.html#public-functions">QAbstractState</a></li>
<li class="fn">32 个公共函数继承于 <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#childModeChanged">childModeChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#errorStateChanged">errorStateChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#finished">finished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#initialStateChanged">initialStateChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#propertiesAssigned">propertiesAssigned</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">3 个信号继承于 <a href="qabstractstate.html#signals">QAbstractState</a></li>
<li class="fn">2 个信号继承于 <a href="qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">1 个静态公共成员继承于 <a href="qabstractstate.html#static-public-members">QAbstractState</a></li>
<li class="fn">11 个静态公共成员继承于 <a href="qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">重新实现的保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#event">event</a></b>(QEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#onEntry">onEntry</a></b>(QEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qstate.html#onExit">onExit</a></b>(QEvent *<i>event</i>) override</td></tr>
</table></div>
<ul>
<li class="fn">3 个保护函数继承于 <a href="qabstractstate.html#protected-functions">QAbstractState</a></li>
<li class="fn">9 个保护函数继承于 <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<h3>其他继承成员有</h3>
<ul>
<li class="fn">1 个公共槽函数继承于 <a href="qobject.html#public-slots">QObject</a></li>
<li class="fn">3 个保护函数继承于 <a href="qabstractstate.html#protected-functions">QAbstractState</a></li>
<li class="fn">9 个保护函数继承于 <a href="qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 个保护类型继承于 <a href="qobject.html#protected-variables">QObject</a></li>
<li class="fn">1 个静态保护成员继承于 <a href="qobject.html#static-protected-members">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QState-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qstate.html">QState</a> class provides a general-purpose state for <a href="qstatemachine.html">QStateMachine</a>.</p>
<p><a href="qstate.html">QState</a> objects can have child states, and can have transitions to other states. <a href="qstate.html">QState</a> is part of <a href="statemachine-api.html">状态机框架</a>.</p>
<p>The <a href="qstate.html#addTransition">addTransition</a>() function adds a transition. The <a href="qstate.html#removeTransition">removeTransition</a>() function removes a transition. The <a href="qstate.html#transitions">transitions</a>() function returns the state's outgoing transitions.</p>
<p>The <a href="qstate.html#assignProperty">assignProperty</a>() function is used for defining property assignments that should be performed when a state is entered.</p>
<p>Top-level states must be passed a <a href="qstatemachine.html">QStateMachine</a> object as their parent state, or added to a state machine using <a href="qstatemachine.html#addState">QStateMachine::addState</a>().</p>
<a name="states-with-child-states"></a>
<h3 >States with Child States</h3>
<p>The <a href="qstate.html#childMode-prop">childMode</a> property determines how child states are treated. For non-parallel state groups, the <a href="qstate.html#setInitialState">setInitialState</a>() function must be called to set the initial state. The child states are mutually exclusive states, and the state machine needs to know which child state to enter when the parent state is the target of a transition.</p>
<p>The state emits the <a href="qstate.html#finished">QState::finished</a>() signal when a final child state (<a href="qfinalstate.html">QFinalState</a>) is entered.</p>
<p>The <a href="qstate.html#setErrorState">setErrorState</a>() sets the state's error state. The error state is the state that the state machine will transition to if an error is detected when attempting to enter the state (e.g&#x2e; because no initial state has been set).</p>
</div>
<!-- @@@QState -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$ChildMode$$$ExclusiveStates$$$ParallelStates -->
<h3 class="fn" id="ChildMode-enum"><a name="ChildMode-enum"></a>enum QState::<span class="name">ChildMode</span></h3>
<p>This enum specifies how a state's child states are treated.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QState::ExclusiveStates</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">The child states are mutually exclusive and an initial state must be set by calling <a href="qstate.html#setInitialState">QState::setInitialState</a>().</td></tr>
<tr><td class="topAlign"><code>QState::ParallelStates</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">The child states are parallel. When the parent state is entered, all its child states are entered in parallel.</td></tr>
</table></div>
<!-- @@@ChildMode -->
<!-- $$$RestorePolicy$$$DontRestoreProperties$$$RestoreProperties -->
<h3 class="fn" id="RestorePolicy-enum"><a name="RestorePolicy-enum"></a>enum QState::<span class="name">RestorePolicy</span></h3>
<p>This enum specifies the restore policy type. The restore policy takes effect when the machine enters a state which sets one or more properties. If the restore policy is set to RestoreProperties, the state machine will save the original value of the property before the new value is set.</p>
<p>Later, when the machine either enters a state which does not set a value for the given property, the property will automatically be restored to its initial value.</p>
<p>Only one initial value will be saved for any given property. If a value for a property has already been saved by the state machine, it will not be overwritten until the property has been successfully restored.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QState::DontRestoreProperties</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">The state machine should not save the initial values of properties and restore them later.</td></tr>
<tr><td class="topAlign"><code>QState::RestoreProperties</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">The state machine should save the initial values of properties and restore them later.</td></tr>
</table></div>
<p><b> 参见 </b><a href="qstatemachine.html#globalRestorePolicy-prop">QStateMachine::globalRestorePolicy</a> 和 <a href="qstate.html#assignProperty">QState::assignProperty</a>().</p>
<!-- @@@RestorePolicy -->
</div>
<div class="prop">
<h2>属性文档</h2>
<!-- $$$childMode-prop$$$childMode$$$setChildModeQState::ChildMode$$$childModeChanged -->
<h3 class="fn" id="childMode-prop"><a name="childMode-prop"></a><span class="name">childMode</span> : <span class="type"><a href="qstate.html#ChildMode-enum">ChildMode</a></span></h3>
<p>This property holds the child mode of this state</p>
<p>The default value of this property is <a href="qstate.html#ChildMode-enum">QState::ExclusiveStates</a>.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QState::ChildMode </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qstate.html#childMode">childMode</a></b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qstate.html#setChildMode">setChildMode</a></b></span>(QState::ChildMode <i>mode</i>)</td></tr>
</table></div>
<p><b>通知信号：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qstate.html#childModeChanged">childModeChanged</a></b></span>()</td><td class="memItemRight bottomAlign">[see note below]</td></tr>
</table></div>
<p><b>注意： </b>这是个私有信号，它可用于信号连接，但是不能由用户触发。</p>
<!-- @@@childMode -->
<!-- $$$errorState-prop$$$errorState$$$setErrorStateQAbstractState*$$$errorStateChanged -->
<h3 class="fn" id="errorState-prop"><a name="errorState-prop"></a><span class="name">errorState</span> : <span class="type"><a href="qabstractstate.html#QAbstractState">QAbstractState</a></span>*</h3>
<p>This property holds the error state of this state</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QAbstractState *</td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qstate.html#errorState">errorState</a></b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qstate.html#setErrorState">setErrorState</a></b></span>(QAbstractState *<i>state</i>)</td></tr>
</table></div>
<p><b>通知信号：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qstate.html#errorStateChanged">errorStateChanged</a></b></span>()</td><td class="memItemRight bottomAlign">[see note below]</td></tr>
</table></div>
<p><b>注意： </b>这是个私有信号，它可用于信号连接，但是不能由用户触发。</p>
<!-- @@@errorState -->
<!-- $$$initialState-prop$$$initialState$$$setInitialStateQAbstractState*$$$initialStateChanged -->
<h3 class="fn" id="initialState-prop"><a name="initialState-prop"></a><span class="name">initialState</span> : <span class="type"><a href="qabstractstate.html#QAbstractState">QAbstractState</a></span>*</h3>
<p>This property holds the initial state of this state (one of its child states)</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QAbstractState *</td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qstate.html#initialState">initialState</a></b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qstate.html#setInitialState">setInitialState</a></b></span>(QAbstractState *<i>state</i>)</td></tr>
</table></div>
<p><b>通知信号：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qstate.html#initialStateChanged">initialStateChanged</a></b></span>()</td><td class="memItemRight bottomAlign">[see note below]</td></tr>
</table></div>
<p><b>注意： </b>这是个私有信号，它可用于信号连接，但是不能由用户触发。</p>
<!-- @@@initialState -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QState[overload1]$$$QStateQState* -->
<h3 class="fn" id="QState"><a name="QState"></a>QState::<span class="name">QState</span>(<span class="type"><a href="qstate.html#QState">QState</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new state with the given <i>parent</i> state.</p>
<!-- @@@QState -->
<!-- $$$QState$$$QStateQState::ChildModeQState* -->
<h3 class="fn" id="QState-1"><a name="QState-1"></a>QState::<span class="name">QState</span>(<span class="type"><a href="qstate.html#ChildMode-enum">QState::ChildMode</a></span> <i>childMode</i>, <span class="type"><a href="qstate.html#QState">QState</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new state with the given <i>childMode</i> and the given <i>parent</i> state.</p>
<!-- @@@QState -->
<!-- $$$~QState[overload1]$$$~QState -->
<h3 class="fn" id="dtor.QState"><a name="dtor.QState"></a><code>[虚函数] </code>QState::<span class="name">~QState</span>()</h3>
<p>Destroys this state.</p>
<!-- @@@~QState -->
<!-- $$$addTransition[overload1]$$$addTransitionQAbstractTransition* -->
<h3 class="fn" id="addTransition"><a name="addTransition"></a><span class="type">void</span> QState::<span class="name">addTransition</span>(<span class="type"><a href="qabstracttransition.html">QAbstractTransition</a></span> *<i>transition</i>)</h3>
<p>Adds the given <i>transition</i>. The transition has this state as the source. This state takes ownership of the transition.</p>
<!-- @@@addTransition -->
<!-- $$$addTransition$$$addTransitionconstQObject*constchar*QAbstractState* -->
<h3 class="fn" id="addTransition-1"><a name="addTransition-1"></a><span class="type"><a href="qsignaltransition.html">QSignalTransition</a></span> *QState::<span class="name">addTransition</span>(const <span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>sender</i>, const <span class="type">char</span> *<i>signal</i>, <span class="type"><a href="qabstractstate.html#QAbstractState">QAbstractState</a></span> *<i>target</i>)</h3>
<p>Adds a transition associated with the given <i>signal</i> of the given <i>sender</i> object, and returns the new <a href="qsignaltransition.html">QSignalTransition</a> object. The transition has this state as the source, and the given <i>target</i> as the target state.</p>
<!-- @@@addTransition -->
<!-- $$$addTransition$$$addTransitionconstQObject*PointerToMemberFunctionQAbstractState* -->
<h3 class="fn" id="addTransition-2"><a name="addTransition-2"></a><span class="type"><a href="qsignaltransition.html">QSignalTransition</a></span> *QState::<span class="name">addTransition</span>(const <span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>sender</i>, <span class="type">PointerToMemberFunction</span> <i>signal</i>, <span class="type"><a href="qabstractstate.html#QAbstractState">QAbstractState</a></span> *<i>target</i>)</h3>
<p>这是一个重载函数。</p>
<p>Adds a transition associated with the given <i>signal</i> of the given <i>sender</i> object, and returns the new <a href="qsignaltransition.html">QSignalTransition</a> object. The transition has this state as the source, and the given <i>target</i> as the target state.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@addTransition -->
<!-- $$$addTransition$$$addTransitionQAbstractState* -->
<h3 class="fn" id="addTransition-3"><a name="addTransition-3"></a><span class="type"><a href="qabstracttransition.html">QAbstractTransition</a></span> *QState::<span class="name">addTransition</span>(<span class="type"><a href="qabstractstate.html#QAbstractState">QAbstractState</a></span> *<i>target</i>)</h3>
<p>Adds an unconditional transition from this state to the given <i>target</i> state, and returns then new transition object.</p>
<!-- @@@addTransition -->
<!-- $$$assignProperty[overload1]$$$assignPropertyQObject*constchar*constQVariant& -->
<h3 class="fn" id="assignProperty"><a name="assignProperty"></a><span class="type">void</span> QState::<span class="name">assignProperty</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>object</i>, const <span class="type">char</span> *<i>name</i>, const <span class="type"><a href="qvariant.html">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Instructs this state to set the property with the given <i>name</i> of the given <i>object</i> to the given <i>value</i> when the state is entered.</p>
<p><b> 参见 </b><a href="qstate.html#propertiesAssigned">propertiesAssigned</a>().</p>
<!-- @@@assignProperty -->
<!-- $$$childMode -->
<h3 class="fn" id="childMode"><a name="childMode"></a><span class="type"><a href="qstate.html#ChildMode-enum">QState::ChildMode</a></span> QState::<span class="name">childMode</span>() const</h3>
<p>Returns the child mode of this state.</p>
<p><b>注意：</b> 此获取函数来自于属性 <a href="qstate.html#childMode-prop">childMode</a>. </p><p><b> 参见 </b><a href="qstate.html#setChildMode">setChildMode</a>().</p>
<!-- @@@childMode -->
<!-- $$$childModeChanged -->
<h3 class="fn" id="childModeChanged"><a name="childModeChanged"></a><code>[信号] </code><span class="type">void</span> QState::<span class="name">childModeChanged</span>()</h3>
<p>This signal is emitted when the <a href="qstate.html#childMode-prop">childMode</a> property is changed.</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b>注意： </b>这是个私有信号，它可用于信号连接，但是不能由用户触发。</p>
<p><b>注意：</b> 此通知信号来自于属性 <a href="qstate.html#childMode-prop">childMode</a>. </p><p><b> 参见 </b><a href="qstate.html#childMode-prop">QState::childMode</a>.</p>
<!-- @@@childModeChanged -->
<!-- $$$errorState -->
<h3 class="fn" id="errorState"><a name="errorState"></a><span class="type"><a href="qabstractstate.html#QAbstractState">QAbstractState</a></span> *QState::<span class="name">errorState</span>() const</h3>
<p>Returns this state's error state.</p>
<p><b>注意：</b> 此获取函数来自于属性 <a href="qstate.html#errorState-prop">errorState</a>. </p><p><b> 参见 </b><a href="qstate.html#setErrorState">setErrorState</a>() 和 <a href="qstatemachine.html#error">QStateMachine::error</a>().</p>
<!-- @@@errorState -->
<!-- $$$errorStateChanged -->
<h3 class="fn" id="errorStateChanged"><a name="errorStateChanged"></a><code>[信号] </code><span class="type">void</span> QState::<span class="name">errorStateChanged</span>()</h3>
<p>This signal is emitted when the <a href="qstate.html#errorState-prop">errorState</a> property is changed.</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b>注意： </b>这是个私有信号，它可用于信号连接，但是不能由用户触发。</p>
<p><b>注意：</b> 此通知信号来自于属性 <a href="qstate.html#errorState-prop">errorState</a>. </p><p><b> 参见 </b><a href="qstate.html#errorState-prop">QState::errorState</a>.</p>
<!-- @@@errorStateChanged -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event"><a name="event"></a><code>[重载虚保护函数] </code><span class="type">bool</span> QState::<span class="name">event</span>(<span class="type"><a href="qevent.html">QEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractstate.html#event">QAbstractState::event</a>().</p>
<!-- @@@event -->
<!-- $$$finished[overload1]$$$finished -->
<h3 class="fn" id="finished"><a name="finished"></a><code>[信号] </code><span class="type">void</span> QState::<span class="name">finished</span>()</h3>
<p>This signal is emitted when a final child state of this state is entered.</p>
<p><b>注意： </b>这是个私有信号，它可用于信号连接，但是不能由用户触发。</p>
<p><b> 参见 </b><a href="qfinalstate.html">QFinalState</a>.</p>
<!-- @@@finished -->
<!-- $$$initialState -->
<h3 class="fn" id="initialState"><a name="initialState"></a><span class="type"><a href="qabstractstate.html#QAbstractState">QAbstractState</a></span> *QState::<span class="name">initialState</span>() const</h3>
<p>Returns this state's initial state, or 0 if the state has no initial state.</p>
<p><b>注意：</b> 此获取函数来自于属性 <a href="qstate.html#initialState-prop">initialState</a>. </p><p><b> 参见 </b><a href="qstate.html#setInitialState">setInitialState</a>().</p>
<!-- @@@initialState -->
<!-- $$$initialStateChanged -->
<h3 class="fn" id="initialStateChanged"><a name="initialStateChanged"></a><code>[信号] </code><span class="type">void</span> QState::<span class="name">initialStateChanged</span>()</h3>
<p>This signal is emitted when the <a href="qstate.html#initialState-prop">initialState</a> property is changed.</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b>注意： </b>这是个私有信号，它可用于信号连接，但是不能由用户触发。</p>
<p><b>注意：</b> 此通知信号来自于属性 <a href="qstate.html#initialState-prop">initialState</a>. </p><p><b> 参见 </b><a href="qstate.html#initialState-prop">QState::initialState</a>.</p>
<!-- @@@initialStateChanged -->
<!-- $$$onEntry[overload1]$$$onEntryQEvent* -->
<h3 class="fn" id="onEntry"><a name="onEntry"></a><code>[重载虚保护函数] </code><span class="type">void</span> QState::<span class="name">onEntry</span>(<span class="type"><a href="qevent.html">QEvent</a></span> *<i>event</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractstate.html#onEntry">QAbstractState::onEntry</a>().</p>
<!-- @@@onEntry -->
<!-- $$$onExit[overload1]$$$onExitQEvent* -->
<h3 class="fn" id="onExit"><a name="onExit"></a><code>[重载虚保护函数] </code><span class="type">void</span> QState::<span class="name">onExit</span>(<span class="type"><a href="qevent.html">QEvent</a></span> *<i>event</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractstate.html#onExit">QAbstractState::onExit</a>().</p>
<!-- @@@onExit -->
<!-- $$$propertiesAssigned[overload1]$$$propertiesAssigned -->
<h3 class="fn" id="propertiesAssigned"><a name="propertiesAssigned"></a><code>[信号] </code><span class="type">void</span> QState::<span class="name">propertiesAssigned</span>()</h3>
<p>This signal is emitted when all properties have been assigned their final value. If the state assigns a value to one or more properties for which an animation exists (either set on the transition or as a default animation on the state machine), then the signal will not be emitted until all such animations have finished playing.</p>
<p>If there are no relevant animations, or no property assignments defined for the state, then the signal will be emitted immediately before the state is entered.</p>
<p><b>注意： </b>这是个私有信号，它可用于信号连接，但是不能由用户触发。</p>
<p><b> 参见 </b><a href="qstate.html#assignProperty">QState::assignProperty</a>() 和 <a href="qabstracttransition.html#addAnimation">QAbstractTransition::addAnimation</a>().</p>
<!-- @@@propertiesAssigned -->
<!-- $$$removeTransition[overload1]$$$removeTransitionQAbstractTransition* -->
<h3 class="fn" id="removeTransition"><a name="removeTransition"></a><span class="type">void</span> QState::<span class="name">removeTransition</span>(<span class="type"><a href="qabstracttransition.html">QAbstractTransition</a></span> *<i>transition</i>)</h3>
<p>Removes the given <i>transition</i> from this state. The state releases ownership of the transition.</p>
<p><b> 参见 </b><a href="qstate.html#addTransition">addTransition</a>().</p>
<!-- @@@removeTransition -->
<!-- $$$setChildMode -->
<h3 class="fn" id="setChildMode"><a name="setChildMode"></a><span class="type">void</span> QState::<span class="name">setChildMode</span>(<span class="type"><a href="qstate.html#ChildMode-enum">QState::ChildMode</a></span> <i>mode</i>)</h3>
<p>Sets the child <i>mode</i> of this state.</p>
<p><b>注意：</b> 此设置函数来自于属性 <a href="qstate.html#childMode-prop">childMode</a>. </p><p><b> 参见 </b><a href="qstate.html#childMode">childMode</a>().</p>
<!-- @@@setChildMode -->
<!-- $$$setErrorState -->
<h3 class="fn" id="setErrorState"><a name="setErrorState"></a><span class="type">void</span> QState::<span class="name">setErrorState</span>(<span class="type"><a href="qabstractstate.html#QAbstractState">QAbstractState</a></span> *<i>state</i>)</h3>
<p>Sets this state's error state to be the given <i>state</i>. If the error state is not set, or if it is set to 0, the state will inherit its parent's error state recursively. If no error state is set for the state itself or any of its ancestors, an error will cause the machine to stop executing and an error will be printed to the console.</p>
<p><b>注意：</b> 此设置函数来自于属性 <a href="qstate.html#errorState-prop">errorState</a>. </p><p><b> 参见 </b><a href="qstate.html#errorState">errorState</a>().</p>
<!-- @@@setErrorState -->
<!-- $$$setInitialState -->
<h3 class="fn" id="setInitialState"><a name="setInitialState"></a><span class="type">void</span> QState::<span class="name">setInitialState</span>(<span class="type"><a href="qabstractstate.html#QAbstractState">QAbstractState</a></span> *<i>state</i>)</h3>
<p>Sets this state's initial state to be the given <i>state</i>. <i>state</i> has to be a child of this state.</p>
<p><b>注意：</b> 此设置函数来自于属性 <a href="qstate.html#initialState-prop">initialState</a>. </p><p><b> 参见 </b><a href="qstate.html#initialState">initialState</a>().</p>
<!-- @@@setInitialState -->
<!-- $$$transitions[overload1]$$$transitions -->
<h3 class="fn" id="transitions"><a name="transitions"></a><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qabstracttransition.html">QAbstractTransition</a></span> *&gt; QState::<span class="name">transitions</span>() const</h3>
<p>Returns this state's outgoing transitions (i.e&#x2e; transitions where this state is the <a href="qabstracttransition.html#sourceState">source state</a>), or an empty list if this state has no outgoing transitions.</p>
<p>这个函数是在Qt 4.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstate.html#addTransition">addTransition</a>().</p>
<!-- @@@transitions -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
