<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qabstracteventdispatcher.cpp -->
  <title>QAbstractEventDispatcher Class | Qt Core 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QAbstractEventDispatcher</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QAbstractEventDispatcher Class</h1>
<!-- $$$QAbstractEventDispatcher-brief -->
<p>The <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a> class provides an interface to manage Qt's event queue. <a href="#details">More...</a></p>
<!-- @@@QAbstractEventDispatcher -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QAbstractEventDispatcher&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="qobject.html">QObject</a></td></tr></table></div><ul>
<li><a href="qabstracteventdispatcher-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qabstracteventdispatcher-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher-timerinfo.html">TimerInfo</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#QAbstractEventDispatcher">QAbstractEventDispatcher</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#dtor.QAbstractEventDispatcher">~QAbstractEventDispatcher</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#filterNativeEvent">filterNativeEvent</a></b>(const QByteArray &amp;<i>eventType</i>, void *<i>message</i>, long *<i>result</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#installNativeEventFilter">installNativeEventFilter</a></b>(QAbstractNativeEventFilter *<i>filterObj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#interrupt">interrupt</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#processEvents">processEvents</a></b>(QEventLoop::ProcessEventsFlags <i>flags</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#registerEventNotifier">registerEventNotifier</a></b>(QWinEventNotifier *<i>notifier</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#registerSocketNotifier">registerSocketNotifier</a></b>(QSocketNotifier *<i>notifier</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#registerTimer">registerTimer</a></b>(int <i>interval</i>, Qt::TimerType <i>timerType</i>, QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#registerTimer-3">registerTimer</a></b>(int <i>timerId</i>, int <i>interval</i>, Qt::TimerType <i>timerType</i>, QObject *<i>object</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QList&lt;QAbstractEventDispatcher::TimerInfo&gt; </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#registeredTimers">registeredTimers</a></b>(QObject *<i>object</i>) const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#remainingTime">remainingTime</a></b>(int <i>timerId</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#removeNativeEventFilter">removeNativeEventFilter</a></b>(QAbstractNativeEventFilter *<i>filter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#unregisterEventNotifier">unregisterEventNotifier</a></b>(QWinEventNotifier *<i>notifier</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#unregisterSocketNotifier">unregisterSocketNotifier</a></b>(QSocketNotifier *<i>notifier</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#unregisterTimer">unregisterTimer</a></b>(int <i>timerId</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#unregisterTimers">unregisterTimers</a></b>(QObject *<i>object</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#wakeUp">wakeUp</a></b>() = 0</td></tr>
</table></div>
<ul>
<li class="fn">32 个公共函数继承于 <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#aboutToBlock">aboutToBlock</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#awake">awake</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">2 个信号继承于 <a href="qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractEventDispatcher *</td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#instance">instance</a></b>(QThread *<i>thread</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">11 个静态公共成员继承于 <a href="qobject.html#static-public-members">QObject</a></li>
</ul>
<h3>其他继承成员有</h3>
<ul>
<li class="fn">1 个属性继承于 <a href="qobject.html#properties">QObject</a></li>
<li class="fn">1 个公共槽函数继承于 <a href="qobject.html#public-slots">QObject</a></li>
<li class="fn">9 个保护函数继承于 <a href="qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 个保护类型继承于 <a href="qobject.html#protected-variables">QObject</a></li>
<li class="fn">1 个静态保护成员继承于 <a href="qobject.html#static-protected-members">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QAbstractEventDispatcher-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a> class provides an interface to manage Qt's event queue.</p>
<p>An event dispatcher receives events from the window system and other sources. It then sends them to the <a href="qcoreapplication.html">QCoreApplication</a> or <a href="../qtwidgets/qapplication.html">QApplication</a> instance for processing and delivery. <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a> provides fine-grained control over event delivery.</p>
<p>For simple control of event processing use <a href="qcoreapplication.html#processEvents">QCoreApplication::processEvents</a>().</p>
<p>For finer control of the application's event loop, call <a href="qabstracteventdispatcher.html#instance">instance</a>() and call functions on the <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a> object that is returned. If you want to use your own instance of <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a> or of a <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a> subclass, you must install it with <a href="qcoreapplication.html#setEventDispatcher">QCoreApplication::setEventDispatcher</a>() or <a href="qthread.html#setEventDispatcher">QThread::setEventDispatcher</a>() <i>before</i> a default event dispatcher has been installed.</p>
<p>The main event loop is started by calling <a href="qcoreapplication.html#exec">QCoreApplication::exec</a>(), and stopped by calling <a href="qcoreapplication.html#exit">QCoreApplication::exit</a>(). Local event loops can be created using <a href="qeventloop.html">QEventLoop</a>.</p>
<p>Programs that perform long operations can call <a href="qabstracteventdispatcher.html#processEvents">processEvents</a>() with a bitwise OR combination of various <a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::ProcessEventsFlag</a> values to control which events should be delivered.</p>
<p><a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a> also allows the integration of an external event loop with the Qt event loop.</p>
</div>
<p><b> 参见 </b><a href="qeventloop.html">QEventLoop</a>, <a href="qcoreapplication.html">QCoreApplication</a>, 和 <a href="qthread.html">QThread</a>.</p>
<!-- @@@QAbstractEventDispatcher -->
<div class="types">
<h2>成员类型文档</h2>
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QAbstractEventDispatcher[overload1]$$$QAbstractEventDispatcherQObject* -->
<h3 class="fn" id="QAbstractEventDispatcher"><a name="QAbstractEventDispatcher"></a>QAbstractEventDispatcher::<span class="name">QAbstractEventDispatcher</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new event dispatcher with the given <i>parent</i>.</p>
<!-- @@@QAbstractEventDispatcher -->
<!-- $$$~QAbstractEventDispatcher[overload1]$$$~QAbstractEventDispatcher -->
<h3 class="fn" id="dtor.QAbstractEventDispatcher"><a name="dtor.QAbstractEventDispatcher"></a><code>[虚函数] </code>QAbstractEventDispatcher::<span class="name">~QAbstractEventDispatcher</span>()</h3>
<p>Destroys the event dispatcher.</p>
<!-- @@@~QAbstractEventDispatcher -->
<!-- $$$aboutToBlock[overload1]$$$aboutToBlock -->
<h3 class="fn" id="aboutToBlock"><a name="aboutToBlock"></a><code>[信号] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">aboutToBlock</span>()</h3>
<p>This signal is emitted before the event loop calls a function that could block.</p>
<p><b> 参见 </b><a href="qabstracteventdispatcher.html#awake">awake</a>().</p>
<!-- @@@aboutToBlock -->
<!-- $$$awake[overload1]$$$awake -->
<h3 class="fn" id="awake"><a name="awake"></a><code>[信号] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">awake</span>()</h3>
<p>This signal is emitted after the event loop returns from a function that could block.</p>
<p><b> 参见 </b><a href="qabstracteventdispatcher.html#wakeUp">wakeUp</a>() 和 <a href="qabstracteventdispatcher.html#aboutToBlock">aboutToBlock</a>().</p>
<!-- @@@awake -->
<!-- $$$filterNativeEvent[overload1]$$$filterNativeEventconstQByteArray&void*long* -->
<h3 class="fn" id="filterNativeEvent"><a name="filterNativeEvent"></a><span class="type">bool</span> QAbstractEventDispatcher::<span class="name">filterNativeEvent</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>eventType</i>, <span class="type">void</span> *<i>message</i>, <span class="type">long</span> *<i>result</i>)</h3>
<p>Sends <i>message</i> through the event filters that were set by <a href="qabstracteventdispatcher.html#installNativeEventFilter">installNativeEventFilter</a>(). This function returns <code>true</code> as soon as an event filter returns <code>true</code>, and false otherwise to indicate that the processing of the event should continue.</p>
<p>Subclasses of <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a> <i>must</i> call this function for <i>all</i> messages received from the system to ensure compatibility with any extensions that may be used in the application. The type of event <i>eventType</i> is specific to the platform plugin chosen at run-time, and can be used to cast message to the right type. The <i>result</i> pointer is only used on Windows, and corresponds to the LRESULT pointer.</p>
<p>Note that the type of <i>message</i> is platform dependent. See <a href="qabstractnativeeventfilter.html">QAbstractNativeEventFilter</a> for details.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qabstracteventdispatcher.html#installNativeEventFilter">installNativeEventFilter</a>() 和 <a href="qabstractnativeeventfilter.html#nativeEventFilter">QAbstractNativeEventFilter::nativeEventFilter</a>().</p>
<!-- @@@filterNativeEvent -->
<!-- $$$installNativeEventFilter[overload1]$$$installNativeEventFilterQAbstractNativeEventFilter* -->
<h3 class="fn" id="installNativeEventFilter"><a name="installNativeEventFilter"></a><span class="type">void</span> QAbstractEventDispatcher::<span class="name">installNativeEventFilter</span>(<span class="type"><a href="qabstractnativeeventfilter.html">QAbstractNativeEventFilter</a></span> *<i>filterObj</i>)</h3>
<p>Installs an event filter <i>filterObj</i> for all native events received by the application.</p>
<p>The event filter <i>filterObj</i> receives events via its <a href="qabstractnativeeventfilter.html#nativeEventFilter">nativeEventFilter()</a> function, which is called for all events received by all threads.</p>
<p>The <a href="qabstractnativeeventfilter.html#nativeEventFilter">nativeEventFilter()</a> function should return true if the event should be filtered, (in this case, stopped). It should return false to allow normal Qt processing to continue: the native event can then be translated into a <a href="qevent.html">QEvent</a> and handled by the standard Qt <a href="qevent.html">event</a> filtering, e.g&#x2e; <a href="qobject.html#installEventFilter">QObject::installEventFilter</a>().</p>
<p>If multiple event filters are installed, the filter that was installed last is activated first.</p>
<p><b>Note: </b>The filter function set here receives native messages, that is, MSG or XEvent structs.</p><p>For maximum portability, you should always try to use <a href="qevent.html">QEvent</a> objects and <a href="qobject.html#installEventFilter">QObject::installEventFilter</a>() whenever possible.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qobject.html#installEventFilter">QObject::installEventFilter</a>().</p>
<!-- @@@installNativeEventFilter -->
<!-- $$$instance[overload1]$$$instanceQThread* -->
<h3 class="fn" id="instance"><a name="instance"></a><code>[静态函数] </code><span class="type"><a href="qabstracteventdispatcher.html#QAbstractEventDispatcher">QAbstractEventDispatcher</a></span> *QAbstractEventDispatcher::<span class="name">instance</span>(<span class="type"><a href="qthread.html">QThread</a></span> *<i>thread</i> = nullptr)</h3>
<p>Returns a pointer to the event dispatcher object for the specified <i>thread</i>. If <i>thread</i> is zero, the current thread is used. If no event dispatcher exists for the specified thread, this function returns 0.</p>
<p><b>Note:</b> If Qt is built without thread support, the <i>thread</i> argument is ignored.</p>
<!-- @@@instance -->
<!-- $$$interrupt[overload1]$$$interrupt -->
<h3 class="fn" id="interrupt"><a name="interrupt"></a><code>[纯虚函数] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">interrupt</span>()</h3>
<p>Interrupts event dispatching. The event dispatcher will return from <a href="qabstracteventdispatcher.html#processEvents">processEvents</a>() as soon as possible.</p>
<!-- @@@interrupt -->
<!-- $$$processEvents[overload1]$$$processEventsQEventLoop::ProcessEventsFlags -->
<h3 class="fn" id="processEvents"><a name="processEvents"></a><code>[纯虚函数] </code><span class="type">bool</span> QAbstractEventDispatcher::<span class="name">processEvents</span>(<span class="type"><a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::ProcessEventsFlags</a></span> <i>flags</i>)</h3>
<p>Processes pending events that match <i>flags</i> until there are no more events to process. Returns <code>true</code> if an event was processed; otherwise returns <code>false</code>.</p>
<p>This function is especially useful if you have a long running operation, and want to show its progress without allowing user input by using the <a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::ExcludeUserInputEvents</a> flag.</p>
<p>If the <a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::WaitForMoreEvents</a> flag is set in <i>flags</i>, the behavior of this function is as follows:</p>
<ul>
<li>If events are available, this function returns after processing them.</li>
<li>If no events are available, this function will wait until more are available and return after processing newly available events.</li>
</ul>
<p>If the <a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::WaitForMoreEvents</a> flag is not set in <i>flags</i>, and no events are available, this function will return immediately.</p>
<p><b>Note:</b> This function does not process events continuously; it returns after all available events are processed.</p>
<p><b> 参见 </b><a href="qabstracteventdispatcher-obsolete.html#hasPendingEvents">hasPendingEvents</a>().</p>
<!-- @@@processEvents -->
<!-- $$$registerEventNotifier[overload1]$$$registerEventNotifierQWinEventNotifier* -->
<h3 class="fn" id="registerEventNotifier"><a name="registerEventNotifier"></a><code>[纯虚函数] </code><span class="type">bool</span> QAbstractEventDispatcher::<span class="name">registerEventNotifier</span>(<span class="type"><a href="qwineventnotifier.html">QWinEventNotifier</a></span> *<i>notifier</i>)</h3>
<p>This pure virtual method exists on windows only and has to be reimplemented by a Windows specific event dispatcher implementation. <i>notifier</i> is the <a href="qwineventnotifier.html">QWinEventNotifier</a> instance to be registered.</p>
<p>The method should return true if the registration of <i>notifier</i> was successful, otherwise false.</p>
<p><a href="qwineventnotifier.html">QWinEventNotifier</a> calls this method in it's constructor and there should never be a need to call this method directly.</p>
<p><b> 参见 </b><a href="qwineventnotifier.html">QWinEventNotifier</a> 和 <a href="qabstracteventdispatcher.html#unregisterEventNotifier">unregisterEventNotifier</a>().</p>
<!-- @@@registerEventNotifier -->
<!-- $$$registerSocketNotifier[overload1]$$$registerSocketNotifierQSocketNotifier* -->
<h3 class="fn" id="registerSocketNotifier"><a name="registerSocketNotifier"></a><code>[纯虚函数] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">registerSocketNotifier</span>(<span class="type"><a href="qsocketnotifier.html">QSocketNotifier</a></span> *<i>notifier</i>)</h3>
<p>Registers <i>notifier</i> with the event loop. Subclasses must implement this method to tie a socket notifier into another event loop.</p>
<!-- @@@registerSocketNotifier -->
<!-- $$$registerTimer[overload1]$$$registerTimerintQt::TimerTypeQObject* -->
<h3 class="fn" id="registerTimer"><a name="registerTimer"></a><span class="type">int</span> QAbstractEventDispatcher::<span class="name">registerTimer</span>(<span class="type">int</span> <i>interval</i>, <span class="type">Qt::TimerType</span> <i>timerType</i>, <span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>Registers a timer with the specified <i>interval</i> and <i>timerType</i> for the given <i>object</i> and returns the timer id.</p>
<!-- @@@registerTimer -->
<!-- $$$registerTimer$$$registerTimerintintQt::TimerTypeQObject* -->
<h3 class="fn" id="registerTimer-3"><a name="registerTimer-3"></a><code>[纯虚函数] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">registerTimer</span>(<span class="type">int</span> <i>timerId</i>, <span class="type">int</span> <i>interval</i>, <span class="type">Qt::TimerType</span> <i>timerType</i>, <span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>Register a timer with the specified <i>timerId</i>, <i>interval</i>, and <i>timerType</i> for the given <i>object</i>.</p>
<!-- @@@registerTimer -->
<!-- $$$registeredTimers[overload1]$$$registeredTimersQObject* -->
<h3 class="fn" id="registeredTimers"><a name="registeredTimers"></a><code>[纯虚函数] </code><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qabstracteventdispatcher-timerinfo.html">QAbstractEventDispatcher::TimerInfo</a></span>&gt; QAbstractEventDispatcher::<span class="name">registeredTimers</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>object</i>) const</h3>
<p>Returns a list of registered timers for <i>object</i>. The <a href="qabstracteventdispatcher-timerinfo.html">TimerInfo</a> struct has <code>timerId</code>, <code>interval</code>, and <code>timerType</code> members.</p>
<p><b> 参见 </b><a href="qt.html#TimerType-enum">Qt::TimerType</a>.</p>
<!-- @@@registeredTimers -->
<!-- $$$remainingTime[overload1]$$$remainingTimeint -->
<h3 class="fn" id="remainingTime"><a name="remainingTime"></a><code>[纯虚函数] </code><span class="type">int</span> QAbstractEventDispatcher::<span class="name">remainingTime</span>(<span class="type">int</span> <i>timerId</i>)</h3>
<p>Returns the remaining time in milliseconds with the given <i>timerId</i>. If the timer is inactive, the returned value will be -1. If the timer is overdue, the returned value will be 0.</p>
<p><b> 参见 </b><a href="qt.html#TimerType-enum">Qt::TimerType</a>.</p>
<!-- @@@remainingTime -->
<!-- $$$removeNativeEventFilter[overload1]$$$removeNativeEventFilterQAbstractNativeEventFilter* -->
<h3 class="fn" id="removeNativeEventFilter"><a name="removeNativeEventFilter"></a><span class="type">void</span> QAbstractEventDispatcher::<span class="name">removeNativeEventFilter</span>(<span class="type"><a href="qabstractnativeeventfilter.html">QAbstractNativeEventFilter</a></span> *<i>filter</i>)</h3>
<p>Removes the event filter <i>filter</i> from this object. The request is ignored if such an event filter has not been installed.</p>
<p>All event filters for this object are automatically removed when this object is destroyed.</p>
<p>It is always safe to remove an event filter, even during event filter filter activation (that is, even from within the <a href="qabstractnativeeventfilter.html#nativeEventFilter">nativeEventFilter()</a> function).</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qabstracteventdispatcher.html#installNativeEventFilter">installNativeEventFilter</a>() 和 <a href="qabstractnativeeventfilter.html">QAbstractNativeEventFilter</a>.</p>
<!-- @@@removeNativeEventFilter -->
<!-- $$$unregisterEventNotifier[overload1]$$$unregisterEventNotifierQWinEventNotifier* -->
<h3 class="fn" id="unregisterEventNotifier"><a name="unregisterEventNotifier"></a><code>[纯虚函数] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">unregisterEventNotifier</span>(<span class="type"><a href="qwineventnotifier.html">QWinEventNotifier</a></span> *<i>notifier</i>)</h3>
<p>This pure virtual method exists on windows only and has to be reimplemented by a Windows specific event dispatcher implementation. <i>notifier</i> is the <a href="qwineventnotifier.html">QWinEventNotifier</a> instance to be unregistered.</p>
<p><a href="qwineventnotifier.html">QWinEventNotifier</a> calls this method in it's destructor and there should never be a need to call this method directly.</p>
<p><b> 参见 </b><a href="qwineventnotifier.html">QWinEventNotifier</a> 和 <a href="qabstracteventdispatcher.html#registerEventNotifier">registerEventNotifier</a>().</p>
<!-- @@@unregisterEventNotifier -->
<!-- $$$unregisterSocketNotifier[overload1]$$$unregisterSocketNotifierQSocketNotifier* -->
<h3 class="fn" id="unregisterSocketNotifier"><a name="unregisterSocketNotifier"></a><code>[纯虚函数] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">unregisterSocketNotifier</span>(<span class="type"><a href="qsocketnotifier.html">QSocketNotifier</a></span> *<i>notifier</i>)</h3>
<p>Unregisters <i>notifier</i> from the event dispatcher. Subclasses must reimplement this method to tie a socket notifier into another event loop. Reimplementations must call the base implementation.</p>
<!-- @@@unregisterSocketNotifier -->
<!-- $$$unregisterTimer[overload1]$$$unregisterTimerint -->
<h3 class="fn" id="unregisterTimer"><a name="unregisterTimer"></a><code>[纯虚函数] </code><span class="type">bool</span> QAbstractEventDispatcher::<span class="name">unregisterTimer</span>(<span class="type">int</span> <i>timerId</i>)</h3>
<p>Unregisters the timer with the given <i>timerId</i>. Returns <code>true</code> if successful; otherwise returns <code>false</code>.</p>
<p><b> 参见 </b><a href="qabstracteventdispatcher.html#registerTimer">registerTimer</a>() 和 <a href="qabstracteventdispatcher.html#unregisterTimers">unregisterTimers</a>().</p>
<!-- @@@unregisterTimer -->
<!-- $$$unregisterTimers[overload1]$$$unregisterTimersQObject* -->
<h3 class="fn" id="unregisterTimers"><a name="unregisterTimers"></a><code>[纯虚函数] </code><span class="type">bool</span> QAbstractEventDispatcher::<span class="name">unregisterTimers</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>Unregisters all the timers associated with the given <i>object</i>. Returns <code>true</code> if all timers were successful removed; otherwise returns <code>false</code>.</p>
<p><b> 参见 </b><a href="qabstracteventdispatcher.html#unregisterTimer">unregisterTimer</a>() 和 <a href="qabstracteventdispatcher.html#registeredTimers">registeredTimers</a>().</p>
<!-- @@@unregisterTimers -->
<!-- $$$wakeUp[overload1]$$$wakeUp -->
<h3 class="fn" id="wakeUp"><a name="wakeUp"></a><code>[纯虚函数] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">wakeUp</span>()</h3>
<p>Wakes up the event loop.</p>
<p><b>注意：</b> 此函数是 <a href="../qtdoc/threads-reentrancy.html">线程安全的</a>。</p>
<p><b> 参见 </b><a href="qabstracteventdispatcher.html#awake">awake</a>().</p>
<!-- @@@wakeUp -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
