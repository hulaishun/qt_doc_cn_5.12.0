<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qstring.cpp -->
  <title>字符串类 | Qt核心模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QString</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#related-non-members">相关非成员</a></li>
<li class="level1"><a href="#macros">宏定义</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#initializing-a-string">初始化字符串</a></li>
<li class="level2"><a href="#manipulating-string-data">操作字符串</a></li>
<li class="level2"><a href="#querying-string-data">查询字符串数据</a></li>
<li class="level2"><a href="#converting-between-8-bit-strings-and-unicode-strings">在8位字符串和Unicode字符串之间转换</a></li>
<li class="level2"><a href="#distinction-between-null-and-empty-strings">Null字符串和空字符串的比较</a></li>
<li class="level2"><a href="#argument-formats">参数格式化</a></li>
<li class="level2"><a href="#more-efficient-string-construction">更高效的字符串构造</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">字符串类</h1>
<!-- $$$QString-brief -->
<p> <a href="qstring.html">QString</a> 类提供了Unicode字符串。 <a href="#details">更多详情...</a></p>
<!-- @@@QString -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QString&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr></table></div><ul>
<li><a href="qstring-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qstring-obsolete.html">过时的成员</a></li>
</ul>
<p><b>注意：</b> 此类中的所有函数都是 <a href="../qtdoc/threads-reentrancy.html">可重入的。</a></p>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qstring-null.html">Null</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#ConstIterator-typedef">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#Iterator-typedef">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#NormalizationForm-enum">NormalizationForm</a></b> { NormalizationForm_D, NormalizationForm_C, NormalizationForm_KD, NormalizationForm_KC }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#SectionFlag-enum">SectionFlag</a></b> { SectionDefault, SectionSkipEmpty, SectionIncludeLeadingSep, SectionIncludeTrailingSep, SectionCaseInsensitiveSeps }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#SectionFlag-enum">SectionFlags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#SplitBehavior-enum">SplitBehavior</a></b> { KeepEmptyParts, SkipEmptyParts }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#const_iterator-typedef">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#const_pointer-typedef">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#const_reference-typedef">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#const_reverse_iterator-typedef">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#difference_type-typedef">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#iterator-typedefx">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#pointer-typedef">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#reference-typedef">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#reverse_iterator-typedef">reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#size_type-typedef">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#value_type-typedef">value_type</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString">QString</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-1">QString</a></b>(const QChar *<i>unicode</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-2">QString</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-3">QString</a></b>(int <i>size</i>, QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-4">QString</a></b>(QLatin1String <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-5">QString</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-6">QString</a></b>(QString &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-7">QString</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QString-8">QString</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#dtor.QString">~QString</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append">append</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-1">append</a></b>(const QChar *<i>str</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-2">append</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-3">append</a></b>(const QStringRef &amp;<i>reference</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-4">append</a></b>(QLatin1String <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-5">append</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#append-6">append</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg">arg</a></b>(const QString &amp;<i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-1">arg</a></b>(qulonglong <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-2">arg</a></b>(long <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-3">arg</a></b>(ulong <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-4">arg</a></b>(int <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-5">arg</a></b>(uint <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-6">arg</a></b>(short <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-7">arg</a></b>(ushort <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-8">arg</a></b>(double <i>a</i>, int <i>fieldWidth</i> = 0, char <i>format</i> = 'g', int <i>precision</i> = -1, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-9">arg</a></b>(char <i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-10">arg</a></b>(QChar <i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-11">arg</a></b>(qlonglong <i>a</i>, int <i>fieldWidth</i> = 0, int <i>base</i> = 10, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-12">arg</a></b>(QStringView <i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-13">arg</a></b>(QLatin1String <i>a</i>, int <i>fieldWidth</i> = 0, QChar <i>fillChar</i> = QLatin1Char(' ')) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-14">arg</a></b>(const QString &amp;<i>a1</i>, const QString &amp;<i>a2</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-15">arg</a></b>(const QString &amp;<i>a1</i>, const QString &amp;<i>a2</i>, const QString &amp;<i>a3</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-16">arg</a></b>(const QString &amp;<i>a1</i>, const QString &amp;<i>a2</i>, const QString &amp;<i>a3</i>, const QString &amp;<i>a4</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-17">arg</a></b>(const QString &amp;<i>a1</i>, const QString &amp;<i>a2</i>, const QString &amp;<i>a3</i>, const QString &amp;<i>a4</i>, const QString &amp;<i>a5</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-18">arg</a></b>(const QString &amp;<i>a1</i>, const QString &amp;<i>a2</i>, const QString &amp;<i>a3</i>, const QString &amp;<i>a4</i>, const QString &amp;<i>a5</i>, const QString &amp;<i>a6</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-19">arg</a></b>(const QString &amp;<i>a1</i>, const QString &amp;<i>a2</i>, const QString &amp;<i>a3</i>, const QString &amp;<i>a4</i>, const QString &amp;<i>a5</i>, const QString &amp;<i>a6</i>, const QString &amp;<i>a7</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-20">arg</a></b>(const QString &amp;<i>a1</i>, const QString &amp;<i>a2</i>, const QString &amp;<i>a3</i>, const QString &amp;<i>a4</i>, const QString &amp;<i>a5</i>, const QString &amp;<i>a6</i>, const QString &amp;<i>a7</i>, const QString &amp;<i>a8</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#arg-21">arg</a></b>(const QString &amp;<i>a1</i>, const QString &amp;<i>a2</i>, const QString &amp;<i>a3</i>, const QString &amp;<i>a4</i>, const QString &amp;<i>a5</i>, const QString &amp;<i>a6</i>, const QString &amp;<i>a7</i>, const QString &amp;<i>a8</i>, const QString &amp;<i>a9</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#at">at</a></b>(int <i>position</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#back">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCharRef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#back-1">back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#begin">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#begin-1">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#capacity">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#cbegin">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#cend">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#chop">chop</a></b>(int <i>n</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#chopped">chopped</a></b>(int <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#clear">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-1">compare</a></b>(const QStringRef &amp;<i>ref</i>, Qt::CaseSensitivity <i>cs</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-2">compare</a></b>(QLatin1String <i>other</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-3">compare</a></b>(QStringView <i>s</i>, Qt::CaseSensitivity <i>cs</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-4">compare</a></b>(const QString &amp;<i>other</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#constBegin">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#constData">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#constEnd">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains">contains</a></b>(const QString &amp;<i>str</i>, Qt::CaseSensitivity <i>cs</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-1">contains</a></b>(QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-2">contains</a></b>(QLatin1String <i>str</i>, Qt::CaseSensitivity <i>cs</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-3">contains</a></b>(const QStringRef &amp;<i>str</i>, Qt::CaseSensitivity <i>cs</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-4">contains</a></b>(const QRegExp &amp;<i>rx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-5">contains</a></b>(QRegExp &amp;<i>rx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-6">contains</a></b>(const QRegularExpression &amp;<i>re</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#contains-7">contains</a></b>(const QRegularExpression &amp;<i>re</i>, QRegularExpressionMatch *<i>match</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count">count</a></b>(const QString &amp;<i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count-1">count</a></b>(QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count-2">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count-3">count</a></b>(const QStringRef &amp;<i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count-4">count</a></b>(const QRegExp &amp;<i>rx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#count-5">count</a></b>(const QRegularExpression &amp;<i>re</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#crbegin">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#crend">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#data">data</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#data-1">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#end">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#end-1">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#endsWith">endsWith</a></b>(const QString &amp;<i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#endsWith-1">endsWith</a></b>(const QStringRef &amp;<i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#endsWith-2">endsWith</a></b>(QStringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#endsWith-3">endsWith</a></b>(QLatin1String <i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#endsWith-4">endsWith</a></b>(QChar <i>c</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fill">fill</a></b>(QChar <i>ch</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QChar </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#front">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCharRef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#front-1">front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf">indexOf</a></b>(const QString &amp;<i>str</i>, int <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-1">indexOf</a></b>(QChar <i>ch</i>, int <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-2">indexOf</a></b>(QLatin1String <i>str</i>, int <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-3">indexOf</a></b>(const QStringRef &amp;<i>str</i>, int <i>from</i> = 0, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-4">indexOf</a></b>(const QRegExp &amp;<i>rx</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-5">indexOf</a></b>(QRegExp &amp;<i>rx</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-6">indexOf</a></b>(const QRegularExpression &amp;<i>re</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#indexOf-7">indexOf</a></b>(const QRegularExpression &amp;<i>re</i>, int <i>from</i>, QRegularExpressionMatch *<i>rmatch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert">insert</a></b>(int <i>position</i>, const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-1">insert</a></b>(int <i>position</i>, const QChar *<i>unicode</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-2">insert</a></b>(int <i>position</i>, QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-3">insert</a></b>(int <i>position</i>, const QStringRef &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-4">insert</a></b>(int <i>position</i>, QLatin1String <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-5">insert</a></b>(int <i>position</i>, const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#insert-6">insert</a></b>(int <i>position</i>, const QByteArray &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isEmpty">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isLower">isLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isNull">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isRightToLeft">isRightToLeft</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#isUpper">isUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf">lastIndexOf</a></b>(const QString &amp;<i>str</i>, int <i>from</i> = -1, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-1">lastIndexOf</a></b>(QChar <i>ch</i>, int <i>from</i> = -1, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-2">lastIndexOf</a></b>(QLatin1String <i>str</i>, int <i>from</i> = -1, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-3">lastIndexOf</a></b>(const QStringRef &amp;<i>str</i>, int <i>from</i> = -1, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-4">lastIndexOf</a></b>(const QRegExp &amp;<i>rx</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-5">lastIndexOf</a></b>(QRegExp &amp;<i>rx</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-6">lastIndexOf</a></b>(const QRegularExpression &amp;<i>re</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#lastIndexOf-7">lastIndexOf</a></b>(const QRegularExpression &amp;<i>re</i>, int <i>from</i>, QRegularExpressionMatch *<i>rmatch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#left">left</a></b>(int <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#leftJustified">leftJustified</a></b>(int <i>width</i>, QChar <i>fill</i> = QLatin1Char(' '), bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringRef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#leftRef">leftRef</a></b>(int <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#length">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#localeAwareCompare-1">localeAwareCompare</a></b>(const QString &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#localeAwareCompare-2">localeAwareCompare</a></b>(const QStringRef &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#mid">mid</a></b>(int <i>position</i>, int <i>n</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringRef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#midRef">midRef</a></b>(int <i>position</i>, int <i>n</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#normalized">normalized</a></b>(QString::NormalizationForm <i>mode</i>, QChar::UnicodeVersion <i>version</i> = QChar::Unicode_Unassigned) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend">prepend</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-1">prepend</a></b>(const QChar *<i>str</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-2">prepend</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-3">prepend</a></b>(const QStringRef &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-4">prepend</a></b>(QLatin1String <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-5">prepend</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#prepend-6">prepend</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#push_back">push_back</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#push_back-1">push_back</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#push_front">push_front</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#push_front-1">push_front</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rbegin">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rbegin-1">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove">remove</a></b>(int <i>position</i>, int <i>n</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove-1">remove</a></b>(QChar <i>ch</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove-2">remove</a></b>(QLatin1String <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove-3">remove</a></b>(const QString &amp;<i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove-4">remove</a></b>(const QRegExp &amp;<i>rx</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#remove-5">remove</a></b>(const QRegularExpression &amp;<i>re</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rend">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rend-1">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#repeated">repeated</a></b>(int <i>times</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace">replace</a></b>(int <i>position</i>, int <i>n</i>, const QString &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-1">replace</a></b>(int <i>position</i>, int <i>n</i>, const QChar *<i>unicode</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-2">replace</a></b>(int <i>position</i>, int <i>n</i>, QChar <i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-3">replace</a></b>(QChar <i>before</i>, QChar <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-4">replace</a></b>(const QChar *<i>before</i>, int <i>blen</i>, const QChar *<i>after</i>, int <i>alen</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-5">replace</a></b>(QLatin1String <i>before</i>, QLatin1String <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-6">replace</a></b>(QLatin1String <i>before</i>, const QString &amp;<i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-7">replace</a></b>(const QString &amp;<i>before</i>, QLatin1String <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-8">replace</a></b>(const QString &amp;<i>before</i>, const QString &amp;<i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-9">replace</a></b>(QChar <i>ch</i>, const QString &amp;<i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-10">replace</a></b>(QChar <i>c</i>, QLatin1String <i>after</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-11">replace</a></b>(const QRegExp &amp;<i>rx</i>, const QString &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#replace-12">replace</a></b>(const QRegularExpression &amp;<i>re</i>, const QString &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#reserve">reserve</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#resize">resize</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#resize-1">resize</a></b>(int <i>size</i>, QChar <i>fillChar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#right">right</a></b>(int <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rightJustified">rightJustified</a></b>(int <i>width</i>, QChar <i>fill</i> = QLatin1Char(' '), bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringRef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#rightRef">rightRef</a></b>(int <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#section">section</a></b>(QChar <i>sep</i>, int <i>start</i>, int <i>end</i> = ..., QString::SectionFlags <i>flags</i> = SectionDefault) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#section-1">section</a></b>(const QString &amp;<i>sep</i>, int <i>start</i>, int <i>end</i> = -1, QString::SectionFlags <i>flags</i> = SectionDefault) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#section-2">section</a></b>(const QRegExp &amp;<i>reg</i>, int <i>start</i>, int <i>end</i> = -1, QString::SectionFlags <i>flags</i> = SectionDefault) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#section-3">section</a></b>(const QRegularExpression &amp;<i>re</i>, int <i>start</i>, int <i>end</i> = -1, QString::SectionFlags <i>flags</i> = SectionDefault) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum">setNum</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-1">setNum</a></b>(ushort <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-2">setNum</a></b>(short <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-3">setNum</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-4">setNum</a></b>(long <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-5">setNum</a></b>(ulong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-6">setNum</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-7">setNum</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-8">setNum</a></b>(float <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setNum-9">setNum</a></b>(double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setRawData">setRawData</a></b>(const QChar *<i>unicode</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setUnicode">setUnicode</a></b>(const QChar *<i>unicode</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#setUtf16">setUtf16</a></b>(const ushort *<i>unicode</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#shrink_to_fit">shrink_to_fit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#simplified">simplified</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#size">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#split">split</a></b>(const QString &amp;<i>sep</i>, QString::SplitBehavior <i>behavior</i> = KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#split-1">split</a></b>(QChar <i>sep</i>, QString::SplitBehavior <i>behavior</i> = KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#split-2">split</a></b>(const QRegExp &amp;<i>rx</i>, QString::SplitBehavior <i>behavior</i> = KeepEmptyParts) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#split-3">split</a></b>(const QRegularExpression &amp;<i>re</i>, QString::SplitBehavior <i>behavior</i> = KeepEmptyParts) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QStringRef&gt; </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#splitRef">splitRef</a></b>(const QString &amp;<i>sep</i>, QString::SplitBehavior <i>behavior</i> = KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QStringRef&gt; </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#splitRef-1">splitRef</a></b>(QChar <i>sep</i>, QString::SplitBehavior <i>behavior</i> = KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QStringRef&gt; </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#splitRef-2">splitRef</a></b>(const QRegExp &amp;<i>rx</i>, QString::SplitBehavior <i>behavior</i> = KeepEmptyParts) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QStringRef&gt; </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#splitRef-3">splitRef</a></b>(const QRegularExpression &amp;<i>re</i>, QString::SplitBehavior <i>behavior</i> = KeepEmptyParts) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#squeeze">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#startsWith">startsWith</a></b>(const QString &amp;<i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#startsWith-1">startsWith</a></b>(const QStringRef &amp;<i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#startsWith-2">startsWith</a></b>(QStringView <i>str</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#startsWith-3">startsWith</a></b>(QLatin1String <i>s</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#startsWith-4">startsWith</a></b>(QChar <i>c</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#swap">swap</a></b>(QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CFStringRef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toCFString">toCFString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toCaseFolded">toCaseFolded</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toDouble">toDouble</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toFloat">toFloat</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toHtmlEscaped">toHtmlEscaped</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toInt">toInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLatin1">toLatin1</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLocal8Bit">toLocal8Bit</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> long </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLong">toLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qlonglong </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLongLong">toLongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toLower">toLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> NSString *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toNSString">toNSString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> short </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toShort">toShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::string </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toStdString">toStdString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::u16string </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toStdU16String">toStdU16String</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::u32string </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toStdU32String">toStdU32String</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::wstring </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toStdWString">toStdWString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUInt">toUInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ulong </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toULong">toULong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qulonglong </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toULongLong">toULongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ushort </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUShort">toUShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;uint&gt; </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUcs4">toUcs4</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUpper">toUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toUtf8">toUtf8</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#toWCharArray">toWCharArray</a></b>(wchar_t *<i>array</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#trimmed">trimmed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#truncate">truncate</a></b>(int <i>position</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#unicode">unicode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const ushort *</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#utf16">utf16</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq">operator!=</a></b>(QLatin1String <i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq-1">operator!=</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq-2">operator!=</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq">operator+=</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-2">operator+=</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-3">operator+=</a></b>(const QStringRef &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-4">operator+=</a></b>(QLatin1String <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-5">operator+=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-6">operator+=</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-eq-7">operator+=</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt">operator&lt;</a></b>(QLatin1String <i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-1">operator&lt;</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-2">operator&lt;</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq">operator&lt;=</a></b>(QLatin1String <i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq-1">operator&lt;=</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq-2">operator&lt;=</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq">operator=</a></b>(const QString &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-1">operator=</a></b>(QChar <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-2">operator=</a></b>(QLatin1String <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-3">operator=</a></b>(QString &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-4">operator=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-5">operator=</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-6">operator=</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq">operator==</a></b>(QLatin1String <i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-1">operator==</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-2">operator==</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt">operator&gt;</a></b>(QLatin1String <i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-1">operator&gt;</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-2">operator&gt;</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq">operator&gt;=</a></b>(QLatin1String <i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq-1">operator&gt;=</a></b>(const char *<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq-2">operator&gt;=</a></b>(const QByteArray &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCharRef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-5b-5d">operator[]</a></b>(int <i>position</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-5b-5d-1">operator[]</a></b>(int <i>position</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QChar </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-5b-5d-2">operator[]</a></b>(uint <i>position</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCharRef </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-5b-5d-3">operator[]</a></b>(uint <i>position</i>)</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#asprintf">asprintf</a></b>(const char *<i>cformat</i>, <i>...</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare">compare</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-5">compare</a></b>(const QString &amp;<i>s1</i>, QLatin1String <i>s2</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-6">compare</a></b>(QLatin1String <i>s1</i>, const QString &amp;<i>s2</i>, Qt::CaseSensitivity <i>cs</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#compare-7">compare</a></b>(const QString &amp;<i>s1</i>, const QStringRef &amp;<i>s2</i>, Qt::CaseSensitivity <i>cs</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromCFString">fromCFString</a></b>(CFStringRef <i>string</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLatin1">fromLatin1</a></b>(const char *<i>str</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLatin1-1">fromLatin1</a></b>(const QByteArray &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a></b>(const char *<i>str</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromLocal8Bit-1">fromLocal8Bit</a></b>(const QByteArray &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromNSString">fromNSString</a></b>(const NSString *<i>string</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromRawData">fromRawData</a></b>(const QChar *<i>unicode</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromStdString">fromStdString</a></b>(const std::string &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromStdU16String">fromStdU16String</a></b>(const std::u16string &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromStdU32String">fromStdU32String</a></b>(const std::u32string &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromStdWString">fromStdWString</a></b>(const std::wstring &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUcs4">fromUcs4</a></b>(const uint *<i>unicode</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUcs4-1">fromUcs4</a></b>(const char32_t *<i>str</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf8">fromUtf8</a></b>(const char *<i>str</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf8-1">fromUtf8</a></b>(const QByteArray &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf16">fromUtf16</a></b>(const ushort *<i>unicode</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromUtf16-1">fromUtf16</a></b>(const char16_t *<i>str</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#fromWCharArray">fromWCharArray</a></b>(const wchar_t *<i>string</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#localeAwareCompare">localeAwareCompare</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#localeAwareCompare-3">localeAwareCompare</a></b>(const QString &amp;<i>s1</i>, const QStringRef &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QString::Null </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#null-var">null</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number">number</a></b>(long <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-1">number</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-2">number</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-3">number</a></b>(ulong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-4">number</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-5">number</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#number-6">number</a></b>(double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#vasprintf">vasprintf</a></b>(const char *<i>cformat</i>, va_list <i>ap</i>)</td></tr>
</table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">相关非成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq-3">operator!=</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-not-eq-4">operator!=</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b">operator+</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-1">operator+</a></b>(const QString &amp;<i>s1</i>, const char *<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-2">operator+</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-3">operator+</a></b>(const QString &amp;<i>s</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QString </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-2b-4">operator+</a></b>(char <i>ch</i>, const QString &amp;<i>s</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-3">operator&lt;</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-4">operator&lt;</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-lt">operator&lt;&lt;</a></b>(QDataStream &amp;<i>stream</i>, const QString &amp;<i>string</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq-3">operator&lt;=</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-lt-eq-4">operator&lt;=</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-3">operator==</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-eq-eq-4">operator==</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-3">operator&gt;</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-4">operator&gt;</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq-3">operator&gt;=</a></b>(const QString &amp;<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-eq-4">operator&gt;=</a></b>(const char *<i>s1</i>, const QString &amp;<i>s2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qstring.html#operator-gt-gt">operator&gt;&gt;</a></b>(QDataStream &amp;<i>stream</i>, QString &amp;<i>string</i>)</td></tr>
</table></div>
<a name="macros"></a>
<h2 id="macros">宏定义</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QStringLiteral">QStringLiteral</a></b>(<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a></b></td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QString-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p> <a href="qstring.html">QString</a> 类提供了Unicode字符串。</p>
<p><a href="qstring.html">QString</a> stores a string of 16-bit <a href="qchar.html">QChar</a>s, where each <a href="qchar.html">QChar</a> corresponds to one UTF-16 code unit. (Unicode characters with code values above 65535 are stored using surrogate pairs, i.e&#x2e;, two consecutive <a href="qchar.html">QChar</a>s.)</p>
<p><a href="../qtdoc/unicode.html">Unicode</a> is an international standard that supports most of the writing systems in use today. It is a superset of US-ASCII (ANSI X3.4-1986) and Latin-1 (ISO 8859-1), and all the US-ASCII/Latin-1 characters are available at the same code positions.</p>
<p>Behind the scenes, <a href="qstring.html">QString</a> uses <a href="implicit-sharing.html">implicit sharing</a> (copy-on-write) to reduce memory usage and to avoid the needless copying of data. This also helps reduce the inherent overhead of storing 16-bit characters instead of 8-bit characters.</p>
<p>In addition to <a href="qstring.html">QString</a>, Qt also provides the <a href="qbytearray.html">QByteArray</a> class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, <a href="qstring.html">QString</a> is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications will be easy to translate if you want to expand your application's market at some point. The two main cases where <a href="qbytearray.html">QByteArray</a> is appropriate are when you need to store raw binary data, and when memory conservation is critical (like in embedded systems).</p>
<a name="initializing-a-string"></a>
<h3 >初始化字符串</h3>
<p>One way to initialize a <a href="qstring.html">QString</a> is simply to pass a <code>const char *</code> to its constructor. For example, the following code creates a <a href="qstring.html">QString</a> of size 5 containing the data &quot;Hello&quot;:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;

</pre>
<p><a href="qstring.html">QString</a> converts the <code>const char *</code> data into Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>In all of the <a href="qstring.html">QString</a> functions that take <code>const char *</code> parameters, the <code>const char *</code> is interpreted as a classic C-style '\0'-terminated string encoded in UTF-8. It is legal for the <code>const char *</code> parameter to be 0.</p>
<p>You can also provide string data as an array of <a href="qchar.html">QChar</a>s:</p>
<pre class="cpp">

  <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="qchar.html">QChar</a></span> data<span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> { <span class="number">0x0055</span><span class="operator">,</span> <span class="number">0x006e</span><span class="operator">,</span> <span class="number">0x10e3</span><span class="operator">,</span> <span class="number">0x03a3</span> };
  <span class="type"><a href="qstring.html#QString">QString</a></span> str(data<span class="operator">,</span> <span class="number">4</span>);

</pre>
<p><a href="qstring.html">QString</a> makes a deep copy of the <a href="qchar.html">QChar</a> data, so you can modify it later without experiencing side effects. (If for performance reasons you don't want to take a deep copy of the character data, use <a href="qstring.html#fromRawData">QString::fromRawData</a>() instead.)</p>
<p>Another approach is to set the size of the string using <a href="qstring.html#resize">resize</a>() and to initialize the data character per character. <a href="qstring.html">QString</a> uses 0-based indexes, just like C++ arrays. To access the character at a particular index position, you can use <a href="qstring.html#operator-5b-5d">operator[]</a>(). On non-const strings, <a href="qstring.html#operator-5b-5d">operator[]</a>() returns a reference to a character that can be used on the left side of an assignment. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  str<span class="operator">.</span>resize(<span class="number">4</span>);

  str<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html">QChar</a></span>(<span class="char">'U'</span>);
  str<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html">QChar</a></span>(<span class="char">'n'</span>);
  str<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html">QChar</a></span>(<span class="number">0x10e3</span>);
  str<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html">QChar</a></span>(<span class="number">0x03a3</span>);

</pre>
<p>For read-only access, an alternative syntax is to use the <a href="qstring.html#at">at</a>() function:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;

  <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> str<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i) {
      <span class="keyword">if</span> (str<span class="operator">.</span>at(i) <span class="operator">&gt;</span><span class="operator">=</span> <span class="type"><a href="qchar.html">QChar</a></span>(<span class="char">'a'</span>) <span class="operator">&amp;</span><span class="operator">&amp;</span> str<span class="operator">.</span>at(i) <span class="operator">&lt;</span><span class="operator">=</span> <span class="type"><a href="qchar.html">QChar</a></span>(<span class="char">'f'</span>))
          <a href="qtglobal.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Found character in range [a-f]&quot;</span>;
  }

</pre>
<p>The <a href="qstring.html#at">at</a>() function can be faster than <a href="qstring.html#operator-5b-5d">operator[]</a>(), because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur. Alternatively, use the <a href="qstring.html#left">left</a>(), <a href="qstring.html#right">right</a>(), or <a href="qstring.html#mid">mid</a>() functions to extract several characters at a time.</p>
<p>A <a href="qstring.html">QString</a> can embed '\0' characters (<a href="qchar.html#SpecialCharacter-enum">QChar::Null</a>). The <a href="qstring.html#size">size</a>() function always returns the size of the whole string, including embedded '\0' characters.</p>
<p>After a call to the <a href="qstring.html#resize">resize</a>() function, newly allocated characters have undefined values. To set all the characters in the string to a particular value, use the <a href="qstring.html#fill">fill</a>() function.</p>
<p><a href="qstring.html">QString</a> provides dozens of overloads designed to simplify string usage. For example, if you want to compare a <a href="qstring.html">QString</a> with a string literal, you can write code like this and it will work as expected:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;

  <span class="keyword">if</span> (str <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;auto&quot;</span> <span class="operator">|</span><span class="operator">|</span> str <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;extern&quot;</span>
          <span class="operator">|</span><span class="operator">|</span> str <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;static&quot;</span> <span class="operator">|</span><span class="operator">|</span> str <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;register&quot;</span>) {
      <span class="comment">// ...</span>
  }

</pre>
<p>You can also pass string literals to functions that take QStrings as arguments, invoking the <a href="qstring.html">QString</a>(const char *) constructor. Similarly, you can pass a <a href="qstring.html">QString</a> to a function that takes a <code>const char *</code> argument using the <a href="qtglobal.html#qPrintable">qPrintable</a>() macro which returns the given <a href="qstring.html">QString</a> as a <code>const char *</code>. This is equivalent to calling &lt;<a href="qstring.html">QString</a>&gt;.<a href="qstring.html#toLocal8Bit">toLocal8Bit</a>().<a href="qstring.html#constData">constData</a>().</p>
<a name="manipulating-string-data"></a>
<h3 >操作字符串</h3>
<p><a href="qstring.html">QString</a> provides the following basic functions for modifying the character data: <a href="qstring.html#append">append</a>(), <a href="qstring.html#prepend">prepend</a>(), <a href="qstring.html#insert">insert</a>(), <a href="qstring.html#replace">replace</a>(), 和 <a href="qstring.html#remove">remove</a>(). For example:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;and&quot;</span>;
  str<span class="operator">.</span>prepend(<span class="string">&quot;rock &quot;</span>);     <span class="comment">// str == &quot;rock and&quot;</span>
  str<span class="operator">.</span>append(<span class="string">&quot; roll&quot;</span>);        <span class="comment">// str == &quot;rock and roll&quot;</span>
  str<span class="operator">.</span>replace(<span class="number">5</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="string">&quot;&amp;&quot;</span>);   <span class="comment">// str == &quot;rock &amp; roll&quot;</span>

</pre>
<p>If you are building a <a href="qstring.html">QString</a> gradually and know in advance approximately how many characters the <a href="qstring.html">QString</a> will contain, you can call <a href="qstring.html#reserve">reserve</a>(), asking <a href="qstring.html">QString</a> to preallocate a certain amount of memory. You can also call <a href="qstring.html#capacity">capacity</a>() to find out how much memory <a href="qstring.html">QString</a> actually allocated.</p>
<p>The <a href="qstring.html#replace">replace</a>() 和 <a href="qstring.html#remove">remove</a>() functions' first two arguments are the position from which to start erasing and the number of characters that should be erased. If you want to replace all occurrences of a particular substring with another, use one of the two-parameter <a href="qstring.html#replace">replace</a>() overloads.</p>
<p>A frequent requirement is to remove whitespace characters from a string ('\n', '\t', ' ', etc.)&#x2e; If you want to remove whitespace from both ends of a <a href="qstring.html">QString</a>, use the <a href="qstring.html#trimmed">trimmed</a>() function. If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the string, use <a href="qstring.html#simplified">simplified</a>().</p>
<p>If you want to find all occurrences of a particular character or substring in a <a href="qstring.html">QString</a>, use the <a href="qstring.html#indexOf">indexOf</a>() or <a href="qstring.html#lastIndexOf">lastIndexOf</a>() functions. The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;&quot;</span>;
  <span class="type">int</span> j <span class="operator">=</span> <span class="number">0</span>;

  <span class="keyword">while</span> ((j <span class="operator">=</span> str<span class="operator">.</span>indexOf(<span class="string">&quot;&lt;b&gt;&quot;</span><span class="operator">,</span> j)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
      <a href="qtglobal.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Found &lt;b&gt; tag at index position&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> j;
      <span class="operator">+</span><span class="operator">+</span>j;
  }

</pre>
<p><a href="qstring.html">QString</a> provides many functions for converting numbers into strings and strings into numbers. See the <a href="qstring.html#arg">arg</a>() functions, the <a href="qstring.html#setNum">setNum</a>() functions, the <a href="qstring.html#number">number</a>() static functions, and the <a href="qstring.html#toInt">toInt</a>(), <a href="qstring.html#toDouble">toDouble</a>(), and similar functions.</p>
<p>To get an upper- or lowercase version of a string use <a href="qstring.html#toUpper">toUpper</a>() or <a href="qstring.html#toLower">toLower</a>().</p>
<p>Lists of strings are handled by the <a href="qstringlist.html">QStringList</a> class. You can split a string into a list of strings using the <a href="qstring.html#split">split</a>() function, and join a list of strings into a single string with an optional separator using <a href="qstringlist.html#join">QStringList::join</a>(). You can obtain a list of strings from a string list that contain a particular substring or that match a particular <a href="qregexp.html">QRegExp</a> using the <a href="qstringlist.html#filter">QStringList::filter</a>() function.</p>
<a name="querying-string-data"></a>
<h3 >查询字符串数据</h3>
<p>If you want to see if a <a href="qstring.html">QString</a> starts or ends with a particular substring use <a href="qstring.html#startsWith">startsWith</a>() or <a href="qstring.html#endsWith">endsWith</a>(). If you simply want to check whether a <a href="qstring.html">QString</a> contains a particular character or substring, use the <a href="qstring.html#contains">contains</a>() function. If you want to find out how many times a particular character or substring occurs in the string, use <a href="qstring.html#count-2">count</a>().</p>
<p>QStrings can be compared using overloaded operators such as <a href="qstring.html#operator-lt">operator&lt;</a>(), <a href="qstring.html#operator-lt-eq">operator&lt;=</a>(), <a href="qstring.html#operator-eq-eq">operator==</a>(), <a href="qstring.html#operator-gt-eq">operator&gt;=</a>(), and so on. Note that the comparison is based exclusively on the numeric Unicode values of the characters. It is very fast, but is not what a human would expect; the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function is a better choice for sorting user-interface strings.</p>
<p>To obtain a pointer to the actual character data, call <a href="qstring.html#data">data</a>() or <a href="qstring.html#constData">constData</a>(). These functions return a pointer to the beginning of the <a href="qchar.html">QChar</a> data. The pointer is guaranteed to remain valid until a non-const function is called on the <a href="qstring.html">QString</a>.</p>
<a name="converting-between-8-bit-strings-and-unicode-strings"></a>
<h3 >在8位字符串和Unicode字符串之间转换</h3>
<p><a href="qstring.html">QString</a> provides the following three functions that return a <code>const char *</code> version of the string as <a href="qbytearray.html">QByteArray</a>: <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), 和 <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>().</p>
<ul>
<li><a href="qstring.html#toLatin1">toLatin1</a>() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.</li>
<li><a href="qstring.html#toUtf8">toUtf8</a>() returns a UTF-8 encoded 8-bit string. UTF-8 is a superset of US-ASCII (ANSI X3.4-1986) that supports the entire Unicode character set through multibyte sequences.</li>
<li><a href="qstring.html#toLocal8Bit">toLocal8Bit</a>() returns an 8-bit string using the system's local encoding.</li>
</ul>
<p>To convert from one of these encodings, <a href="qstring.html">QString</a> provides <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), 和 <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(). Other encodings are supported through the <a href="qtextcodec.html">QTextCodec</a> class.</p>
<p>As mentioned above, <a href="qstring.html">QString</a> provides a lot of functions and operators that make it easy to interoperate with <code>const char *</code> strings. But this functionality is a double-edged sword: It makes <a href="qstring.html">QString</a> more convenient to use if all strings are US-ASCII or Latin-1, but there is always the risk that an implicit conversion from or to <code>const char *</code> is done using the wrong 8-bit encoding. To minimize these risks, you can turn off these implicit conversions by defining the following two preprocessor symbols:</p>
<ul>
<li><code>QT_NO_CAST_FROM_ASCII</code> disables automatic conversions from C string literals and pointers to Unicode.</li>
<li><code>QT_RESTRICTED_CAST_FROM_ASCII</code> allows automatic conversions from C characters and character arrays, but disables automatic conversions from character pointers to Unicode.</li>
<li><code>QT_NO_CAST_TO_ASCII</code> disables automatic conversion from <a href="qstring.html">QString</a> to C strings.</li>
</ul>
<p>One way to define these preprocessor symbols globally for your application is to add the following entry to your <a href="../qmake/qmake-project-files.html">qmake project file</a>:</p>
<pre class="cpp">

  DEFINES <span class="operator">+</span><span class="operator">=</span> QT_NO_CAST_FROM_ASCII \
             QT_NO_CAST_TO_ASCII

</pre>
<p>You then need to explicitly call <a href="qstring.html#fromUtf8">fromUtf8</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>() to construct a <a href="qstring.html">QString</a> from an 8-bit string, or use the lightweight <a href="qlatin1string.html">QLatin1String</a> class, for example:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> url <span class="operator">=</span> QLatin1String(<span class="string">&quot;http://www.unicode.org/&quot;</span>);

</pre>
<p>Similarly, you must call <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), or <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>() explicitly to convert the <a href="qstring.html">QString</a> to an 8-bit string. (Other encodings are supported through the <a href="qtextcodec.html">QTextCodec</a> class.)</p>
<div class="table"><table class="generic" width="%">
 <thead><tr class="qt-style"><th >Note for C Programmers</th></tr></thead>
<tr valign="top" class="odd"><td >Due to C++'s type system and the fact that <a href="qstring.html">QString</a> is <a href="implicit-sharing.html">implicitly shared</a>, QStrings may be treated like <code>int</code>s or other basic types. For example:<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> Widget<span class="operator">::</span>boolToString(bool b)
  {
      <span class="type"><a href="qstring.html#QString">QString</a></span> result;
      <span class="keyword">if</span> (b)
          result <span class="operator">=</span> <span class="string">&quot;True&quot;</span>;
      <span class="keyword">else</span>
          result <span class="operator">=</span> <span class="string">&quot;False&quot;</span>;
      <span class="keyword">return</span> result;
  }

</pre>
<p>The <code>result</code> variable, is a normal variable allocated on the stack. When <code>return</code> is called, and because we're returning by value, the copy constructor is called and a copy of the string is returned. No actual copying takes place thanks to the implicit sharing.</p>
</td></tr>
</table></div>
<a name="distinction-between-null-and-empty-strings"></a>
<h3 >Null字符串和空字符串的比较</h3>
<p>For historical reasons, <a href="qstring.html">QString</a> distinguishes between a null string and an empty string. A <i>null</i> string is a string that is initialized using <a href="qstring.html">QString</a>'s default constructor or by passing (const char *)0 to the constructor. An <i>empty</i> string is any string with size 0. A null string is always empty, but an empty string isn't necessarily null:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span>()<span class="operator">.</span>isNull();               <span class="comment">// returns true</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span>()<span class="operator">.</span>isEmpty();              <span class="comment">// returns true</span>

  <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isNull();             <span class="comment">// returns false</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isEmpty();            <span class="comment">// returns true</span>

  <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isNull();          <span class="comment">// returns false</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isEmpty();         <span class="comment">// returns false</span>

</pre>
<p>All functions except <a href="qstring.html#isNull">isNull</a>() treat null strings the same as empty strings. For example, <a href="qstring.html#toUtf8">toUtf8</a>().<a href="qstring.html#constData">constData</a>() returns a pointer to a '\0' character for a null string (<i>not</i> a null pointer), and <a href="qstring.html#QString">QString</a>() compares equal to <a href="qstring.html">QString</a>(&quot;&quot;). We recommend that you always use the <a href="qstring.html#isEmpty">isEmpty</a>() function and avoid <a href="qstring.html#isNull">isNull</a>().</p>
<a name="argument-formats"></a>
<h3 >参数格式化</h3>
<p>In member functions where an argument <i>format</i> can be specified (e.g&#x2e;, <a href="qstring.html#arg">arg</a>(), <a href="qstring.html#number">number</a>()), the argument <i>format</i> can be one of the following:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >格式</th><th >Meaning</th></tr></thead>
<tr valign="top" class="odd"><td ><code>e</code></td><td >format as [-]9.9e[+|-]999</td></tr>
<tr valign="top" class="even"><td ><code>E</code></td><td >format as [-]9.9E[+|-]999</td></tr>
<tr valign="top" class="odd"><td ><code>f</code></td><td >format as [-]9.9</td></tr>
<tr valign="top" class="even"><td ><code>g</code></td><td >use <code>e</code> or <code>f</code> format, whichever is the most concise</td></tr>
<tr valign="top" class="odd"><td ><code>G</code></td><td >use <code>E</code> or <code>f</code> format, whichever is the most concise</td></tr>
</table></div>
<p>A <i>precision</i> is also specified with the argument <i>format</i>. For the 'e', 'E', and 'f' formats, the <i>precision</i> represents the number of digits <i>after</i> the decimal point. For the 'g' and 'G' formats, the <i>precision</i> represents the maximum number of significant digits (trailing zeroes are omitted).</p>
<a name="more-efficient-string-construction"></a>
<h3 >更高效的字符串构造</h3>
<p>Many strings are known at compile time. But the trivial constructor <a href="qstring.html">QString</a>(&quot;Hello&quot;), will copy the contents of the string, treating the contents as Latin-1. To avoid this one can use the <a href="qstring.html#QStringLiteral">QStringLiteral</a> macro to directly create the required data at compile time. Constructing a <a href="qstring.html">QString</a> out of the literal does then not cause any overhead at runtime.</p>
<p>A slightly less efficient way is to use <a href="qlatin1string.html">QLatin1String</a>. This class wraps a C string literal, precalculates it length at compile time and can then be used for faster comparison with QStrings and conversion to QStrings than a regular C string literal.</p>
<p>Using the <a href="qstring.html">QString</a> <code>'+'</code> operator, it is easy to construct a complex string from multiple substrings. You will often write code like this:</p>
<pre class="cpp">

      <span class="type"><a href="qstring.html#QString">QString</a></span> foo;
      <span class="type"><a href="qstring.html#QString">QString</a></span> type <span class="operator">=</span> <span class="string">&quot;long&quot;</span>;

      foo<span class="operator">-</span><span class="operator">&gt;</span>setText(QLatin1String(<span class="string">&quot;vector&lt;&quot;</span>) <span class="operator">+</span> type <span class="operator">+</span> QLatin1String(<span class="string">&quot;&gt;::iterator&quot;</span>));

      <span class="keyword">if</span> (foo<span class="operator">.</span>startsWith(<span class="string">&quot;(&quot;</span> <span class="operator">+</span> type <span class="operator">+</span> <span class="string">&quot;) 0x&quot;</span>))
          <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

</pre>
<p>There is nothing wrong with either of these string constructions, but there are a few hidden inefficiencies. Beginning with Qt 4.6, you can eliminate them.</p>
<p>First, multiple uses of the <code>'+'</code> operator usually means multiple memory allocations. When concatenating <i>n</i> substrings, where <i>n &gt; 2</i>, there can be as many as <i>n - 1</i> calls to the memory allocator.</p>
<p>In 4.6, an internal template class <code>QStringBuilder</code> has been added along with a few helper functions. This class is marked internal and does not appear in the documentation, because you aren't meant to instantiate it in your code. Its use will be automatic, as described below. The class is found in <code>src/corelib/tools/qstringbuilder.cpp</code> if you want to have a look at it.</p>
<p><code>QStringBuilder</code> uses expression templates and reimplements the <code>'%'</code> operator so that when you use <code>'%'</code> for string concatenation instead of <code>'+'</code>, multiple substring concatenations will be postponed until the final result is about to be assigned to a <a href="qstring.html">QString</a>. At this point, the amount of memory required for the final result is known. The memory allocator is then called <i>once</i> to get the required space, and the substrings are copied into it one by one.</p>
<p>Additional efficiency is gained by inlining and reduced reference counting (the <a href="qstring.html">QString</a> created from a <code>QStringBuilder</code> typically has a ref count of 1, whereas <a href="qstring.html#append">QString::append</a>() needs an extra test).</p>
<p>There are two ways you can access this improved method of string construction. The straightforward way is to include <code>QStringBuilder</code> wherever you want to use it, and use the <code>'%'</code> operator instead of <code>'+'</code> when concatenating strings:</p>
<pre class="cpp">

      <span class="preprocessor">#include &lt;QStringBuilder&gt;</span>

      <span class="type"><a href="qstring.html#QString">QString</a></span> hello(<span class="string">&quot;hello&quot;</span>);
      <span class="type"><a href="qstringref.html">QStringRef</a></span> el(<span class="operator">&amp;</span>hello<span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span>);
      QLatin1String world(<span class="string">&quot;world&quot;</span>);
      <span class="type"><a href="qstring.html#QString">QString</a></span> message <span class="operator">=</span>  hello <span class="operator">%</span> el <span class="operator">%</span> world <span class="operator">%</span> <span class="type"><a href="qchar.html">QChar</a></span>(<span class="char">'!'</span>);

</pre>
<p>A more global approach which is the most convenient but not entirely source compatible, is to this define in your .pro file:</p>
<pre class="cpp">

      DEFINES <span class="operator">*</span><span class="operator">=</span> QT_USE_QSTRINGBUILDER

</pre>
<p>and the <code>'+'</code> will automatically be performed as the <code>QStringBuilder</code> <code>'%'</code> everywhere.</p>
</div>
<p><b> 参见 </b><a href="qstring.html#fromRawData">fromRawData</a>(), <a href="qchar.html">QChar</a>, <a href="qlatin1string.html">QLatin1String</a>, <a href="qbytearray.html">QByteArray</a>, 和 <a href="qstringref.html">QStringRef</a>.</p>
<!-- @@@QString -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" id="ConstIterator-typedef"><a name="ConstIterator-typedef"></a>typedef QString::<span class="name">ConstIterator</span></h3>
<p>Qt风格的同义词<a href="qstring.html#const_iterator-typedef">QString::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn" id="Iterator-typedef"><a name="Iterator-typedef"></a>typedef QString::<span class="name">Iterator</span></h3>
<p>Qt风格的同义词<a href="qstring.html#iterator-typedefx">QString::iterator</a>.</p>
<!-- @@@Iterator -->
<!-- $$$NormalizationForm$$$NormalizationForm_D$$$NormalizationForm_C$$$NormalizationForm_KD$$$NormalizationForm_KC -->
<h3 class="fn" id="NormalizationForm-enum"><a name="NormalizationForm-enum"></a>enum QString::<span class="name">NormalizationForm</span></h3>
<p>This enum describes the various normalized forms of Unicode text.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QString::NormalizationForm_D</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">Canonical Decomposition</td></tr>
<tr><td class="topAlign"><code>QString::NormalizationForm_C</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">Canonical Decomposition followed by Canonical Composition</td></tr>
<tr><td class="topAlign"><code>QString::NormalizationForm_KD</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">Compatibility Decomposition</td></tr>
<tr><td class="topAlign"><code>QString::NormalizationForm_KC</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">Compatibility Decomposition followed by Canonical Composition</td></tr>
</table></div>
<p><b> 参见 </b><a href="qstring.html#normalized">normalized</a>() 和 <a href="http://www.unicode.org/reports/tr15/">Unicode Standard Annex #15</a>.</p>
<!-- @@@NormalizationForm -->
<!-- $$$SectionFlag$$$SectionDefault$$$SectionSkipEmpty$$$SectionIncludeLeadingSep$$$SectionIncludeTrailingSep$$$SectionCaseInsensitiveSeps -->
<h3 class="flags" id="SectionFlag-enum"><a name="SectionFlag-enum"></a>enum QString::<span class="name">SectionFlag</span><br/>flags QString::<span class="name">SectionFlags</span></h3>
<p>This enum specifies flags that can be used to affect various aspects of the <a href="qstring.html#section">section</a>() function's behavior with respect to separators and empty fields.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QString::SectionDefault</code></td><td class="topAlign tblval"><code>0x00</code></td><td class="topAlign">Empty fields are counted, leading and trailing separators are not included, and the separator is compared case sensitively.</td></tr>
<tr><td class="topAlign"><code>QString::SectionSkipEmpty</code></td><td class="topAlign tblval"><code>0x01</code></td><td class="topAlign">Treat empty fields as if they don't exist, i.e&#x2e; they are not considered as far as <i>start</i> and <i>end</i> are concerned.</td></tr>
<tr><td class="topAlign"><code>QString::SectionIncludeLeadingSep</code></td><td class="topAlign tblval"><code>0x02</code></td><td class="topAlign">Include the leading separator (if any) in the result string.</td></tr>
<tr><td class="topAlign"><code>QString::SectionIncludeTrailingSep</code></td><td class="topAlign tblval"><code>0x04</code></td><td class="topAlign">Include the trailing separator (if any) in the result string.</td></tr>
<tr><td class="topAlign"><code>QString::SectionCaseInsensitiveSeps</code></td><td class="topAlign tblval"><code>0x08</code></td><td class="topAlign">Compare the separator case-insensitively.</td></tr>
</table></div>
<p>The SectionFlags type is a typedef for <a href="qflags.html">QFlags</a>&lt;SectionFlag&gt;. It stores an OR combination of SectionFlag values.</p>
<p><b> 参见 </b><a href="qstring.html#section">section</a>().</p>
<!-- @@@SectionFlag -->
<!-- $$$SplitBehavior$$$KeepEmptyParts$$$SkipEmptyParts -->
<h3 class="fn" id="SplitBehavior-enum"><a name="SplitBehavior-enum"></a>enum QString::<span class="name">SplitBehavior</span></h3>
<p>This enum specifies how the <a href="qstring.html#split">split</a>() function should behave with respect to empty strings.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QString::KeepEmptyParts</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">If a field is empty, keep it in the result.</td></tr>
<tr><td class="topAlign"><code>QString::SkipEmptyParts</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">If a field is empty, don't include it in the result.</td></tr>
</table></div>
<p><b> 参见 </b><a href="qstring.html#split">split</a>().</p>
<!-- @@@SplitBehavior -->
<!-- $$$const_iterator -->
<h3 class="fn" id="const_iterator-typedef"><a name="const_iterator-typedef"></a>typedef QString::<span class="name">const_iterator</span></h3>
<p>This typedef provides an STL-style const iterator for <a href="qstring.html">QString</a>.</p>
<p><b> 参见 </b><a href="qstring.html#iterator-typedefx">QString::iterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" id="const_pointer-typedef"><a name="const_pointer-typedef"></a>typedef QString::<span class="name">const_pointer</span></h3>
<p>The QString::const_pointer typedef provides an STL-style const pointer to a <a href="qstring.html">QString</a> element (<a href="qchar.html">QChar</a>).</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" id="const_reference-typedef"><a name="const_reference-typedef"></a>typedef QString::<span class="name">const_reference</span></h3>
<p>This typedef provides an STL-style const reference for a <a href="qstring.html">QString</a> element (<a href="qchar.html">QChar</a>).</p>
<!-- @@@const_reference -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" id="const_reverse_iterator-typedef"><a name="const_reverse_iterator-typedef"></a>typedef QString::<span class="name">const_reverse_iterator</span></h3>
<p>This typedef provides an STL-style const reverse iterator for <a href="qstring.html">QString</a>.</p>
<p>这个类型定义是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#reverse_iterator-typedef">QString::reverse_iterator</a> 和 <a href="qstring.html#const_iterator-typedef">QString::const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" id="difference_type-typedef"><a name="difference_type-typedef"></a>typedef QString::<span class="name">difference_type</span></h3>
<p>The <a href="qstring.html#size_type-typedef">QString::size_type</a> typedef provides an STL-style type for difference between pointers.</p>
<!-- @@@difference_type -->
<!-- $$$iterator -->
<h3 class="fn" id="iterator-typedefx"><a name="iterator-typedefx"></a>typedef QString::<span class="name">iterator</span></h3>
<p>The QString::iterator typedef provides an STL-style non-const iterator for <a href="qstring.html">QString</a>.</p>
<p><b> 参见 </b><a href="qstring.html#const_iterator-typedef">QString::const_iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$pointer -->
<h3 class="fn" id="pointer-typedef"><a name="pointer-typedef"></a>typedef QString::<span class="name">pointer</span></h3>
<p>The <a href="qstring.html#const_pointer-typedef">QString::const_pointer</a> typedef provides an STL-style pointer to a <a href="qstring.html">QString</a> element (<a href="qchar.html">QChar</a>).</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" id="reference-typedef"><a name="reference-typedef"></a>typedef QString::<span class="name">reference</span></h3>
<p>This typedef provides an STL-style reference for a <a href="qstring.html">QString</a> element (<a href="qchar.html">QChar</a>).</p>
<!-- @@@reference -->
<!-- $$$reverse_iterator -->
<h3 class="fn" id="reverse_iterator-typedef"><a name="reverse_iterator-typedef"></a>typedef QString::<span class="name">reverse_iterator</span></h3>
<p>This typedef provides an STL-style non-const reverse iterator for <a href="qstring.html">QString</a>.</p>
<p>这个类型定义是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#const_reverse_iterator-typedef">QString::const_reverse_iterator</a> 和 <a href="qstring.html#iterator-typedefx">QString::iterator</a>.</p>
<!-- @@@reverse_iterator -->
<!-- $$$size_type -->
<h3 class="fn" id="size_type-typedef"><a name="size_type-typedef"></a>typedef QString::<span class="name">size_type</span></h3>
<p>The QString::size_type typedef provides an STL-style type for sizes (int).</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" id="value_type-typedef"><a name="value_type-typedef"></a>typedef QString::<span class="name">value_type</span></h3>
<p>This typedef provides an STL-style value type for <a href="qstring.html">QString</a>.</p>
<!-- @@@value_type -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QString[overload1]$$$QString -->
<h3 class="fn" id="QString"><a name="QString"></a>QString::<span class="name">QString</span>()</h3>
<p>构造函数，创建一个Null字符串。Null字符串也是个空字符串。</p>
<p><b> 参见 </b><a href="qstring.html#isEmpty">isEmpty</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringconstQChar*int -->
<h3 class="fn" id="QString-1"><a name="QString-1"></a>QString::<span class="name">QString</span>(const <span class="type"><a href="qchar.html">QChar</a></span> *<i>unicode</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Constructs a string initialized with the first <i>size</i> characters of the <a href="qchar.html">QChar</a> array <i>unicode</i>.</p>
<p>If <i>unicode</i> is 0, a null string is constructed.</p>
<p>If <i>size</i> is negative, <i>unicode</i> is assumed to point to a nul-terminated array and its length is determined dynamically. The terminating nul-character is not considered part of the string.</p>
<p><a href="qstring.html">QString</a> makes a deep copy of the string data. The unicode data is copied as is and the Byte Order Mark is preserved if present.</p>
<p><b> 参见 </b><a href="qstring.html#fromRawData">fromRawData</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringQChar -->
<h3 class="fn" id="QString-2"><a name="QString-2"></a>QString::<span class="name">QString</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>)</h3>
<p>Constructs a string of size 1 containing the character <i>ch</i>.</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringintQChar -->
<h3 class="fn" id="QString-3"><a name="QString-3"></a>QString::<span class="name">QString</span>(<span class="type">int</span> <i>size</i>, <span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>)</h3>
<p>Constructs a string of the given <i>size</i> with every character set to <i>ch</i>.</p>
<p><b> 参见 </b><a href="qstring.html#fill">fill</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringQLatin1String -->
<h3 class="fn" id="QString-4"><a name="QString-4"></a>QString::<span class="name">QString</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>)</h3>
<p>Constructs a copy of the Latin-1 string <i>str</i>.</p>
<p><b> 参见 </b><a href="qstring.html#fromLatin1">fromLatin1</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringconstQString& -->
<h3 class="fn" id="QString-5"><a name="QString-5"></a>QString::<span class="name">QString</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>other</i>)</h3>
<p>拷贝构造函数，参数为 <i>other</i>。</p>
<p>This operation takes <a href="containers.html#constant-time">constant time</a>, because <a href="qstring.html">QString</a> is <a href="implicit-sharing.html">implicitly shared</a>. This makes returning a <a href="qstring.html">QString</a> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <a href="containers.html#linear-time">linear time</a>.</p>
<p><b> 参见 </b><a href="qstring.html#operator-eq">operator=</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringQString&& -->
<h3 class="fn" id="QString-6"><a name="QString-6"></a>QString::<span class="name">QString</span>(<span class="type"><a href="qstring.html#QString">QString</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a <a href="qstring.html">QString</a> instance, making it point at the same object that <i>other</i> was pointing to.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringconstchar* -->
<h3 class="fn" id="QString-7"><a name="QString-7"></a>QString::<span class="name">QString</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>Constructs a string initialized with the 8-bit string <i>str</i>. The given const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this constructor by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<p><b>注意： </b>Defining <a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a> also disables this constructor, but enables a <code>QString(const char (&amp;ch)[N])</code> constructor instead. Using non-literal input, or input with embedded NUL characters, or non-7-bit characters is undefined in this case.</p><p><b> 参见 </b><a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), 和 <a href="qstring.html#fromUtf8">fromUtf8</a>().</p>
<!-- @@@QString -->
<!-- $$$QString$$$QStringconstQByteArray& -->
<h3 class="fn" id="QString-8"><a name="QString-8"></a>QString::<span class="name">QString</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Constructs a string initialized with the byte array <i>ba</i>. The given byte array is converted to Unicode using <a href="qstring.html#fromUtf8">fromUtf8</a>(). Stops copying at the first 0 character, otherwise copies the entire byte array.</p>
<p>You can disable this constructor by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<p><b> 参见 </b><a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), 和 <a href="qstring.html#fromUtf8">fromUtf8</a>().</p>
<!-- @@@QString -->
<!-- $$$~QString[overload1]$$$~QString -->
<h3 class="fn" id="dtor.QString"><a name="dtor.QString"></a>QString::<span class="name">~QString</span>()</h3>
<p>析构函数，释放字符串。</p>
<!-- @@@~QString -->
<!-- $$$append[overload1]$$$appendconstQString& -->
<h3 class="fn" id="append"><a name="append"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">append</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>str</i>)</h3>
<p>追加字符串 <i>str</i> 到当前字符串的末尾。</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;free&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;dom&quot;</span>;

  x<span class="operator">.</span>append(y);
  <span class="comment">// x == &quot;freedom&quot;</span>

</pre>
<p>此函数等同于 using the <a href="qstring.html#insert">insert</a>() function:</p>
<pre class="cpp">

  x<span class="operator">.</span>insert(x<span class="operator">.</span>size()<span class="operator">,</span> y);

</pre>
<p>The append() function is typically very fast (<a href="containers.html#constant-time">constant time</a>), because <a href="qstring.html">QString</a> preallocates extra space at the end of the string data so it can grow without reallocating the entire string each time.</p>
<p><b> 参见 </b><a href="qstring.html#operator-2b-eq">operator+=</a>(), <a href="qstring.html#prepend">prepend</a>(), 和 <a href="qstring.html#insert">insert</a>().</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstQChar*int -->
<h3 class="fn" id="append-1"><a name="append-1"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">append</span>(const <span class="type"><a href="qchar.html">QChar</a></span> *<i>str</i>, <span class="type">int</span> <i>len</i>)</h3>
<p>此函数重载了 <a href="qstring.html#append">append</a>().</p>
<p>Appends <i>len</i> characters from the <a href="qchar.html">QChar</a> array <i>str</i> to this string.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@append -->
<!-- $$$append$$$appendQChar -->
<h3 class="fn" id="append-2"><a name="append-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">append</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>)</h3>
<p>此函数重载了 <a href="qstring.html#append">append</a>().</p>
<p>追加字符 <i>ch</i> 到当前字符串的末尾。</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstQStringRef& -->
<h3 class="fn" id="append-3"><a name="append-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">append</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>reference</i>)</h3>
<p>Appends the given string <i>reference</i> to this string and returns the result.</p>
<p>这个函数是在Qt 4.4版本中新增引入的。</p>
<!-- @@@append -->
<!-- $$$append$$$appendQLatin1String -->
<h3 class="fn" id="append-4"><a name="append-4"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">append</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#append">append</a>().</p>
<p>追加Latin-1字符串 <i>str</i> 到当前字符串的末尾。</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstchar* -->
<h3 class="fn" id="append-5"><a name="append-5"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">append</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#append">append</a>().</p>
<p>追加字符串 <i>str</i> 到当前字符串的末尾。 The given const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstQByteArray& -->
<h3 class="fn" id="append-6"><a name="append-6"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">append</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>此函数重载了 <a href="qstring.html#append">append</a>().</p>
<p>追加字节数组 <i>ba</i> 到当前字符串的末尾。 The given byte array is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@append -->
<!-- $$$arg[overload1]$$$argconstQString&intQChar -->
<h3 class="fn" id="arg"><a name="arg"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>Returns a copy of this string with the lowest numbered place marker replaced by string <i>a</i>, i.e&#x2e;, <code>%1</code>, <code>%2</code>, ..&#x2e;, <code>%99</code>.</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that argument <i>a</i> shall occupy. If <i>a</i> requires less space than <i>fieldWidth</i>, it is padded to <i>fieldWidth</i> with character <i>fillChar</i>. A positive <i>fieldWidth</i> produces right-aligned text. A negative <i>fieldWidth</i> produces left-aligned text.</p>
<p>This example shows how we might create a <code>status</code> string for reporting progress while processing a list of files:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> i;           <span class="comment">// current file's number</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span> total;       <span class="comment">// number of files to process</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span> fileName;    <span class="comment">// current file's name</span>

  <span class="type"><a href="qstring.html#QString">QString</a></span> status <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;Processing file %1 of %2: %3&quot;</span>)
                  <span class="operator">.</span>arg(i)<span class="operator">.</span>arg(total)<span class="operator">.</span>arg(fileName);

</pre>
<p>First, <code>arg(i)</code> replaces <code>%1</code>. Then <code>arg(total)</code> replaces <code>%2</code>. Finally, <code>arg(fileName)</code> replaces <code>%3</code>.</p>
<p>One advantage of using arg() over <a href="qstring.html#asprintf">asprintf</a>() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest numbered unreplaced place marker, no matter where it appears. Also, if place marker <code>%i</code> appears more than once in the string, the arg() replaces all of them.</p>
<p>If there is no unreplaced place marker remaining, a warning message is output and the result is undefined. Place marker numbers must be in the range 1 to 99.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argqulonglongintintQChar -->
<h3 class="fn" id="arg-1"><a name="arg-1"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. <i>base</i> must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<!-- @@@arg -->
<!-- $$$arg$$$arglongintintQChar -->
<h3 class="fn" id="arg-2"><a name="arg-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type">long</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>a</i> argument is expressed in the given <i>base</i>, which is 10 by default and must be between 2 and 36.</p>
<p>The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i>a</i>. The conversion uses the default locale. The default locale is determined from the system's locale settings at application startup. It can be changed using <a href="qlocale.html#setDefault">QLocale::setDefault</a>(). The 'L' flag is ignored if <i>base</i> is not 10.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;Decimal 63 is %1 in hexadecimal&quot;</span>)
          <span class="operator">.</span>arg(<span class="number">63</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">16</span>);
  <span class="comment">// str == &quot;Decimal 63 is 3f in hexadecimal&quot;</span>

  <span class="type"><a href="qlocale.html">QLocale</a></span><span class="operator">::</span>setDefault(<span class="type"><a href="qlocale.html">QLocale</a></span>(<span class="type"><a href="qlocale.html">QLocale</a></span><span class="operator">::</span>English<span class="operator">,</span> <span class="type"><a href="qlocale.html">QLocale</a></span><span class="operator">::</span>UnitedStates));
  str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;%1 %L2 %L3&quot;</span>)
          <span class="operator">.</span>arg(<span class="number">12345</span>)
          <span class="operator">.</span>arg(<span class="number">12345</span>)
          <span class="operator">.</span>arg(<span class="number">12345</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">16</span>);
  <span class="comment">// str == &quot;12345 12,345 3039&quot;</span>

</pre>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argulongintintQChar -->
<h3 class="fn" id="arg-3"><a name="arg-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> to a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argintintintQChar -->
<h3 class="fn" id="arg-4"><a name="arg-4"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type">int</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>The <i>a</i> argument is expressed in base <i>base</i>, which is 10 by default and must be between 2 and 36. For bases other than 10, <i>a</i> is treated as an unsigned integer.</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i>a</i>. The conversion uses the default locale, set by <a href="qlocale.html#setDefault">QLocale::setDefault</a>(). If no default locale was specified, the &quot;C&quot; locale is used. The 'L' flag is ignored if <i>base</i> is not 10.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;Decimal 63 is %1 in hexadecimal&quot;</span>)
          <span class="operator">.</span>arg(<span class="number">63</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">16</span>);
  <span class="comment">// str == &quot;Decimal 63 is 3f in hexadecimal&quot;</span>

  <span class="type"><a href="qlocale.html">QLocale</a></span><span class="operator">::</span>setDefault(<span class="type"><a href="qlocale.html">QLocale</a></span>(<span class="type"><a href="qlocale.html">QLocale</a></span><span class="operator">::</span>English<span class="operator">,</span> <span class="type"><a href="qlocale.html">QLocale</a></span><span class="operator">::</span>UnitedStates));
  str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;%1 %L2 %L3&quot;</span>)
          <span class="operator">.</span>arg(<span class="number">12345</span>)
          <span class="operator">.</span>arg(<span class="number">12345</span>)
          <span class="operator">.</span>arg(<span class="number">12345</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">16</span>);
  <span class="comment">// str == &quot;12345 12,345 3039&quot;</span>

</pre>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<!-- @@@arg -->
<!-- $$$arg$$$arguintintintQChar -->
<h3 class="fn" id="arg-5"><a name="arg-5"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argshortintintQChar -->
<h3 class="fn" id="arg-6"><a name="arg-6"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type">short</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argushortintintQChar -->
<h3 class="fn" id="arg-7"><a name="arg-7"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argdoubleintcharintQChar -->
<h3 class="fn" id="arg-8"><a name="arg-8"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type">double</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = -1, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>Argument <i>a</i> is formatted according to the specified <i>format</i> and <i>precision</i>. See <a href="qstring.html#argument-formats">参数格式化</a> for details.</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<pre class="cpp">

  <span class="type">double</span> d <span class="operator">=</span> <span class="number">12.34</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;delta: %1&quot;</span>)<span class="operator">.</span>arg(d<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="char">'E'</span><span class="operator">,</span> <span class="number">3</span>);
  <span class="comment">// str == &quot;delta: 1.234E+01&quot;</span>

</pre>
<p>The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i>a</i>. The conversion uses the default locale, set by <a href="qlocale.html#setDefault">QLocale::setDefault</a>(). If no default locale was specified, the &quot;C&quot; locale is used.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), this function will use the locale's zero to pad. For negative numbers, the zero padding will probably appear before the minus sign.</p>
<p><b> 参见 </b><a href="qlocale.html#toString">QLocale::toString</a>().</p>
<!-- @@@arg -->
<!-- $$$arg$$$argcharintQChar -->
<h3 class="fn" id="arg-9"><a name="arg-9"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type">char</span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>The <i>a</i> argument is interpreted as a Latin-1 character.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argQCharintQChar -->
<h3 class="fn" id="arg-10"><a name="arg-10"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<!-- @@@arg -->
<!-- $$$arg$$$argqlonglongintintQChar -->
<h3 class="fn" id="arg-11"><a name="arg-11"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type">int</span> <i>base</i> = 10, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.</p>
<p>The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.</p>
<p>If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argQStringViewintQChar -->
<h3 class="fn" id="arg-12"><a name="arg-12"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>这是一个重载函数。</p>
<p>Returns a copy of this string with the lowest-numbered place-marker replaced by string <i>a</i>, i.e&#x2e;, <code>%1</code>, <code>%2</code>, ..&#x2e;, <code>%99</code>.</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> shall occupy. If <i>a</i> requires less space than <i>fieldWidth</i>, it is padded to <i>fieldWidth</i> with character <i>fillChar</i>. A positive <i>fieldWidth</i> produces right-aligned text. A negative <i>fieldWidth</i> produces left-aligned text.</p>
<p>This example shows how we might create a <code>status</code> string for reporting progress while processing a list of files:</p>
<pre class="cpp">

  <span class="type">int</span> i;                <span class="comment">// current file's number</span>
  <span class="type">int</span> total;            <span class="comment">// number of files to process</span>
  <span class="type"><a href="qstringview.html">QStringView</a></span> fileName; <span class="comment">// current file's name</span>

  <span class="type"><a href="qstring.html#QString">QString</a></span> status <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;Processing file %1 of %2: %3&quot;</span>)
                  <span class="operator">.</span>arg(i)<span class="operator">.</span>arg(total)<span class="operator">.</span>arg(fileName);

</pre>
<p>First, <code>arg(i)</code> replaces <code>%1</code>. Then <code>arg(total)</code> replaces <code>%2</code>. Finally, <code>arg(fileName)</code> replaces <code>%3</code>.</p>
<p>One advantage of using <a href="qstring.html#arg">arg</a>() over <a href="qstring.html#asprintf">asprintf</a>() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each <a href="qstring.html#arg">arg</a>() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker <code>%i</code> appears more than once in the string, <a href="qstring.html#arg">arg</a>() replaces all of them.</p>
<p>If there is no unreplaced place-marker remaining, a warning message is printed and the result is undefined. Place-marker numbers must be in the range 1 to 99.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<!-- @@@arg -->
<!-- $$$arg$$$argQLatin1StringintQChar -->
<h3 class="fn" id="arg-13"><a name="arg-13"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>a</i>, <span class="type">int</span> <i>fieldWidth</i> = 0, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i> = QLatin1Char(' ')) const</h3>
<p>这是一个重载函数。</p>
<p>Returns a copy of this string with the lowest-numbered place-marker replaced by string <i>a</i>, i.e&#x2e;, <code>%1</code>, <code>%2</code>, ..&#x2e;, <code>%99</code>.</p>
<p><i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> shall occupy. If <i>a</i> requires less space than <i>fieldWidth</i>, it is padded to <i>fieldWidth</i> with character <i>fillChar</i>. A positive <i>fieldWidth</i> produces right-aligned text. A negative <i>fieldWidth</i> produces left-aligned text.</p>
<p>One advantage of using <a href="qstring.html#arg">arg</a>() over <a href="qstring.html#asprintf">asprintf</a>() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each <a href="qstring.html#arg">arg</a>() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker <code>%i</code> appears more than once in the string, <a href="qstring.html#arg">arg</a>() replaces all of them.</p>
<p>If there is no unreplaced place-marker remaining, a warning message is printed and the result is undefined. Place-marker numbers must be in the range 1 to 99.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<!-- @@@arg -->
<!-- $$$arg$$$argconstQString&constQString& -->
<h3 class="fn" id="arg-14"><a name="arg-14"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a2</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>此函数等同于 <code>str.arg(a1).arg(a2)</code>, except that the strings <i>a1</i> and <i>a2</i> are replaced in one pass. This can make a difference if <i>a1</i> contains e.g&#x2e; <code>%1</code>:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  str <span class="operator">=</span> <span class="string">&quot;%1 %2&quot;</span>;

  str<span class="operator">.</span>arg(<span class="string">&quot;%1f&quot;</span><span class="operator">,</span> <span class="string">&quot;Hello&quot;</span>);        <span class="comment">// returns &quot;%1f Hello&quot;</span>
  str<span class="operator">.</span>arg(<span class="string">&quot;%1f&quot;</span>)<span class="operator">.</span>arg(<span class="string">&quot;Hello&quot;</span>);    <span class="comment">// returns &quot;Hellof %2&quot;</span>

</pre>
<p>A similar problem occurs when the numbered place markers are not white space separated:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  str <span class="operator">=</span> <span class="string">&quot;%1%3%2&quot;</span>;
  str<span class="operator">.</span>arg(<span class="string">&quot;Hello&quot;</span>)<span class="operator">.</span>arg(<span class="number">20</span>)<span class="operator">.</span>arg(<span class="number">50</span>); <span class="comment">// returns &quot;Hello500&quot;</span>

  str <span class="operator">=</span> <span class="string">&quot;%1%2%3&quot;</span>;
  str<span class="operator">.</span>arg(<span class="string">&quot;Hello&quot;</span>)<span class="operator">.</span>arg(<span class="number">50</span>)<span class="operator">.</span>arg(<span class="number">20</span>); <span class="comment">// returns &quot;Hello5020&quot;</span>

</pre>
<p>Let's look at the substitutions:</p>
<ul>
<li>First, <code>Hello</code> replaces <code>%1</code> so the string becomes <code>&quot;Hello%3%2&quot;</code>.</li>
<li>Then, <code>20</code> replaces <code>%2</code> so the string becomes <code>&quot;Hello%320&quot;</code>.</li>
<li>Since the maximum numbered place marker value is 99, <code>50</code> replaces <code>%32</code>.</li>
</ul>
<p>Thus the string finally becomes <code>&quot;Hello500&quot;</code>.</p>
<p>In such cases, the following yields the expected results:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  str <span class="operator">=</span> <span class="string">&quot;%1%3%2&quot;</span>;
  str<span class="operator">.</span>arg(<span class="string">&quot;Hello&quot;</span><span class="operator">,</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>number(<span class="number">20</span>)<span class="operator">,</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>number(<span class="number">50</span>)); <span class="comment">// returns &quot;Hello5020&quot;</span>

</pre>
<!-- @@@arg -->
<!-- $$$arg$$$argconstQString&constQString&constQString& -->
<h3 class="fn" id="arg-15"><a name="arg-15"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a2</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a3</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>此函数等同于调用了 <code>str.arg(a1).arg(a2).arg(a3)</code>, except that the strings <i>a1</i>, <i>a2</i> and <i>a3</i> are replaced in one pass.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argconstQString&constQString&constQString&constQString& -->
<h3 class="fn" id="arg-16"><a name="arg-16"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a2</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a3</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a4</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>此函数等同于调用了 <code>str.arg(a1).arg(a2).arg(a3).arg(a4)</code>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i> and <i>a4</i> are replaced in one pass.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argconstQString&constQString&constQString&constQString&constQString& -->
<h3 class="fn" id="arg-17"><a name="arg-17"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a2</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a3</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a4</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a5</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>此函数等同于调用了 <code>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)</code>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, and <i>a5</i> are replaced in one pass.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argconstQString&constQString&constQString&constQString&constQString&constQString& -->
<h3 class="fn" id="arg-18"><a name="arg-18"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a2</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a3</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a4</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a5</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a6</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>此函数等同于调用了 <code>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))</code>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, and <i>a6</i> are replaced in one pass.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argconstQString&constQString&constQString&constQString&constQString&constQString&constQString& -->
<h3 class="fn" id="arg-19"><a name="arg-19"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a2</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a3</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a4</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a5</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a6</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a7</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>此函数等同于调用了 <code>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)</code>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, <i>a6</i>, and <i>a7</i> are replaced in one pass.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argconstQString&constQString&constQString&constQString&constQString&constQString&constQString&constQString& -->
<h3 class="fn" id="arg-20"><a name="arg-20"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a2</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a3</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a4</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a5</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a6</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a7</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a8</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>此函数等同于调用了 <code>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)</code>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, <i>a6</i>, <i>a7</i>, and <i>a8</i> are replaced in one pass.</p>
<!-- @@@arg -->
<!-- $$$arg$$$argconstQString&constQString&constQString&constQString&constQString&constQString&constQString&constQString&constQString& -->
<h3 class="fn" id="arg-21"><a name="arg-21"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">arg</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a2</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a3</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a4</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a5</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a6</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a7</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a8</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>a9</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#arg">arg</a>().</p>
<p>此函数等同于调用了 <code>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)</code>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, <i>a6</i>, <i>a7</i>, <i>a8</i>, and <i>a9</i> are replaced in one pass.</p>
<!-- @@@arg -->
<!-- $$$asprintf[overload1]$$$asprintfconstchar*... -->
<h3 class="fn" id="asprintf"><a name="asprintf"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">asprintf</span>(const <span class="type">char</span> *<i>cformat</i>, <i>...</i>)</h3>
<p>Safely builds a formatted string from the format string <i>cformat</i> and an arbitrary list of arguments.</p>
<p>The format string supports the conversion specifiers, length modifiers, and flags provided by printf() in the standard C++ library. The <i>cformat</i> string and <code>%s</code> arguments must be UTF-8 encoded.</p>
<p><b>注意： </b>The <code>%lc</code> escape sequence expects a unicode character of type <code>char16_t</code>, or <code>ushort</code> (as returned by <a href="qchar.html#unicode">QChar::unicode</a>()). The <code>%ls</code> escape sequence expects a pointer to a zero-terminated array of unicode characters of type <code>char16_t</code>, or ushort (as returned by <a href="qstring.html#utf16">QString::utf16</a>()). This is at odds with the printf() in the standard C++ library, which defines <code>%lc</code> to print a wchar_t and <code>%ls</code> to print a <code>wchar_t*</code>, and might also produce compiler warnings on platforms where the size of <code>wchar_t</code> is not 16 bits.</p><p><b>警告：</b> We do not recommend using QString::asprintf() in new Qt code. Instead, consider using <a href="qtextstream.html">QTextStream</a> or <a href="qstring.html#arg">arg</a>(), both of which support Unicode strings seamlessly and are type-safe. Here's an example that uses <a href="qtextstream.html">QTextStream</a>:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> result;
  <span class="type"><a href="qtextstream.html">QTextStream</a></span>(<span class="operator">&amp;</span>result) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;pi = &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3.14</span>;
  <span class="comment">// result == &quot;pi = 3.14&quot;</span>

</pre>
<p>For <a href="qobject.html#tr">translations</a>, especially if the strings contains more than one escape sequence, you should consider using the <a href="qstring.html#arg">arg</a>() function instead. This allows the order of the replacements to be controlled by the translator.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#arg">arg</a>().</p>
<!-- @@@asprintf -->
<!-- $$$at[overload1]$$$atint -->
<h3 class="fn" id="at"><a name="at"></a>const <span class="type"><a href="qchar.html">QChar</a></span> QString::<span class="name">at</span>(<span class="type">int</span> <i>position</i>) const</h3>
<p>Returns the character at the given index <i>position</i> in the string.</p>
<p>The <i>position</i> must be a valid index position in the string (i.e&#x2e;, 0 &lt;= <i>position</i> &lt; <a href="qstring.html#size">size</a>()).</p>
<p><b> 参见 </b><a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" id="back"><a name="back"></a><span class="type"><a href="qchar.html">QChar</a></span> QString::<span class="name">back</span>() const</h3>
<p>Returns the last character in the string. Same as <code>at(size() - 1)</code>.</p>
<p>此函数用于STL风格的兼容性。</p>
<p><b>警告：</b> Calling this function on an empty string constitutes undefined behavior.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#front">front</a>(), <a href="qstring.html#at">at</a>(), 和 <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$back$$$back -->
<h3 class="fn" id="back-1"><a name="back-1"></a><span class="type">QCharRef</span> QString::<span class="name">back</span>()</h3>
<p>Returns a reference to the last character in the string. Same as <code>operator[](size() - 1)</code>.</p>
<p>此函数用于STL风格的兼容性。</p>
<p><b>警告：</b> Calling this function on an empty string constitutes undefined behavior.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#front">front</a>(), <a href="qstring.html#at">at</a>(), 和 <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin"><a name="begin"></a><span class="type"><a href="qstring.html#iterator-typedefx">QString::iterator</a></span> QString::<span class="name">begin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL样式迭代器</a> pointing to the first character in the string.</p>
<p><b> 参见 </b><a href="qstring.html#constBegin">constBegin</a>() 和 <a href="qstring.html#end">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1"><a name="begin-1"></a><span class="type"><a href="qstring.html#const_iterator-typedef">QString::const_iterator</a></span> QString::<span class="name">begin</span>() const</h3>
<p>此函数重载了 <a href="qstring.html#begin">begin</a>().</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" id="capacity"><a name="capacity"></a><span class="type">int</span> QString::<span class="name">capacity</span>() const</h3>
<p>Returns the maximum number of characters that can be stored in the string without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qstring.html">QString</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many characters are in the string, call <a href="qstring.html#size">size</a>().</p>
<p><b> 参见 </b><a href="qstring.html#reserve">reserve</a>() 和 <a href="qstring.html#squeeze">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin"><a name="cbegin"></a><span class="type"><a href="qstring.html#const_iterator-typedef">QString::const_iterator</a></span> QString::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> pointing to the first character in the string.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#begin">begin</a>() 和 <a href="qstring.html#cend">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend"><a name="cend"></a><span class="type"><a href="qstring.html#const_iterator-typedef">QString::const_iterator</a></span> QString::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> pointing to the imaginary character after the last character in the list.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#cbegin">cbegin</a>() 和 <a href="qstring.html#end">end</a>().</p>
<!-- @@@cend -->
<!-- $$$chop[overload1]$$$chopint -->
<h3 class="fn" id="chop"><a name="chop"></a><span class="type">void</span> QString::<span class="name">chop</span>(<span class="type">int</span> <i>n</i>)</h3>
<p>Removes <i>n</i> characters from the end of the string.</p>
<p>If <i>n</i> is greater than or equal to <a href="qstring.html#size">size</a>(), the result is an empty string; if <i>n</i> is negative, it is equivalent to passing zero.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str(<span class="string">&quot;LOGOUT\r\n&quot;</span>);
  str<span class="operator">.</span>chop(<span class="number">2</span>);
  <span class="comment">// str == &quot;LOGOUT&quot;</span>

</pre>
<p>If you want to remove characters from the <i>beginning</i> of the string, use <a href="qstring.html#remove">remove</a>() instead.</p>
<p><b> 参见 </b><a href="qstring.html#truncate">truncate</a>(), <a href="qstring.html#resize">resize</a>(), <a href="qstring.html#remove">remove</a>(), 和 <a href="qstringref.html#chop">QStringRef::chop</a>().</p>
<!-- @@@chop -->
<!-- $$$chopped[overload1]$$$choppedint -->
<h3 class="fn" id="chopped"><a name="chopped"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">chopped</span>(<span class="type">int</span> <i>len</i>) const</h3>
<p>Returns a substring that contains the <a href="qstring.html#size">size</a>() - <i>len</i> leftmost characters of this string.</p>
<p><b>注意： </b>The behavior is undefined if <i>len</i> is negative or greater than <a href="qstring.html#size">size</a>().</p><p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#endsWith">endsWith</a>(), <a href="qstring.html#left">left</a>(), <a href="qstring.html#right">right</a>(), <a href="qstring.html#mid">mid</a>(), <a href="qstring.html#chop">chop</a>(), 和 <a href="qstring.html#truncate">truncate</a>().</p>
<!-- @@@chopped -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear"><a name="clear"></a><span class="type">void</span> QString::<span class="name">clear</span>()</h3>
<p>Clears the contents of the string and makes it null.</p>
<p><b> 参见 </b><a href="qstring.html#resize">resize</a>() 和 <a href="qstring.html#isNull">isNull</a>().</p>
<!-- @@@clear -->
<!-- $$$compare[overload1]$$$compareconstQString&constQString&Qt::CaseSensitivity -->
<h3 class="fn" id="compare"><a name="compare"></a><code>[静态函数] </code><span class="type">int</span> QString::<span class="name">compare</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>Compares <i>s1</i> with <i>s2</i> and returns an integer less than, equal to, or greater than zero if <i>s1</i> is less than, equal to, or greater than <i>s2</i>.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a>, the comparison is case sensitive; otherwise the comparison is case insensitive.</p>
<p>Case sensitive comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-visible strings with <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<pre class="cpp">

  <span class="type">int</span> x <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>compare(<span class="string">&quot;aUtO&quot;</span><span class="operator">,</span> <span class="string">&quot;AuTo&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseInsensitive);  <span class="comment">// x == 0</span>
  <span class="type">int</span> y <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>compare(<span class="string">&quot;auto&quot;</span><span class="operator">,</span> <span class="string">&quot;Car&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseSensitive);     <span class="comment">// y &gt; 0</span>
  <span class="type">int</span> z <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>compare(<span class="string">&quot;auto&quot;</span><span class="operator">,</span> <span class="string">&quot;Car&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseInsensitive);   <span class="comment">// z &lt; 0</span>

</pre>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#operator-eq-eq">operator==</a>(), <a href="qstring.html#operator-lt">operator&lt;</a>(), 和 <a href="qstring.html#operator-gt">operator&gt;</a>().</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareconstQStringRef&Qt::CaseSensitivity -->
<h3 class="fn" id="compare-1"><a name="compare-1"></a><span class="type">int</span> QString::<span class="name">compare</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>ref</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...) const</h3>
<p>此函数重载了 <a href="qstring.html#compare">compare</a>().</p>
<p>Compares the string reference, <i>ref</i>, with the string and returns an integer less than, equal to, or greater than zero if the string is less than, equal to, or greater than <i>ref</i>.</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareQLatin1StringQt::CaseSensitivity -->
<h3 class="fn" id="compare-2"><a name="compare-2"></a><span class="type">int</span> QString::<span class="name">compare</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>other</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#compare">compare</a>().</p>
<p>Same as compare(*this, <i>other</i>, <i>cs</i>).</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareQStringViewQt::CaseSensitivity -->
<h3 class="fn" id="compare-3"><a name="compare-3"></a><span class="type">int</span> QString::<span class="name">compare</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>s</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...) const</h3>
<p>此函数重载了 <a href="qstring.html#compare">compare</a>().</p>
<p>Performs a comparison of this with <i>s</i>, using the case sensitivity setting <i>cs</i>.</p>
<p>这个函数是在Qt 5.12版本中新增引入的。</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareconstQString&Qt::CaseSensitivity -->
<h3 class="fn" id="compare-4"><a name="compare-4"></a><span class="type">int</span> QString::<span class="name">compare</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>other</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#compare">compare</a>().</p>
<p>Lexically compares this string with the <i>other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the other string.</p>
<p>Same as compare(*this, <i>other</i>, <i>cs</i>).</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareconstQString&QLatin1StringQt::CaseSensitivity -->
<h3 class="fn" id="compare-5"><a name="compare-5"></a><code>[静态函数] </code><span class="type">int</span> QString::<span class="name">compare</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, <span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>s2</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>此函数重载了 <a href="qstring.html#compare">compare</a>().</p>
<p>Performs a comparison of <i>s1</i> and <i>s2</i>, using the case sensitivity setting <i>cs</i>.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareQLatin1StringconstQString&Qt::CaseSensitivity -->
<h3 class="fn" id="compare-6"><a name="compare-6"></a><code>[静态函数] </code><span class="type">int</span> QString::<span class="name">compare</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...)</h3>
<p>此函数重载了 <a href="qstring.html#compare">compare</a>().</p>
<p>Performs a comparison of <i>s1</i> and <i>s2</i>, using the case sensitivity setting <i>cs</i>.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareconstQString&constQStringRef&Qt::CaseSensitivity -->
<h3 class="fn" id="compare-7"><a name="compare-7"></a><code>[静态函数] </code><span class="type">int</span> QString::<span class="name">compare</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>s2</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...)</h3>
<p>此函数重载了 <a href="qstring.html#compare">compare</a>().</p>
<!-- @@@compare -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin"><a name="constBegin"></a><span class="type"><a href="qstring.html#const_iterator-typedef">QString::const_iterator</a></span> QString::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> pointing to the first character in the string.</p>
<p><b> 参见 </b><a href="qstring.html#begin">begin</a>() 和 <a href="qstring.html#constEnd">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constData[overload1]$$$constData -->
<h3 class="fn" id="constData"><a name="constData"></a>const <span class="type"><a href="qchar.html">QChar</a></span> *QString::<span class="name">constData</span>() const</h3>
<p>Returns a pointer to the data stored in the <a href="qstring.html">QString</a>. The pointer can be used to access the characters that compose the string.</p>
<p>Note that the pointer remains valid only as long as the string is not modified.</p>
<p><b>注意： </b>The returned string may not be '\0'-terminated. Use <a href="qstring.html#size">size</a>() to determine the length of the array.</p><p><b> 参见 </b><a href="qstring.html#data">data</a>(), <a href="qstring.html#operator-5b-5d">operator[]</a>(), 和 <a href="qstring.html#fromRawData">fromRawData</a>().</p>
<!-- @@@constData -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd"><a name="constEnd"></a><span class="type"><a href="qstring.html#const_iterator-typedef">QString::const_iterator</a></span> QString::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> pointing to the imaginary character after the last character in the list.</p>
<p><b> 参见 </b><a href="qstring.html#constBegin">constBegin</a>() 和 <a href="qstring.html#end">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$contains[overload1]$$$containsconstQString&Qt::CaseSensitivity -->
<h3 class="fn" id="contains"><a name="contains"></a><span class="type">bool</span> QString::<span class="name">contains</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>str</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...) const</h3>
<p>Returns <code>true</code> if this string contains an occurrence of the string <i>str</i>; 否则则返回 <code>false</code>。</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Peter Pan&quot;</span>;
  str<span class="operator">.</span>contains(<span class="string">&quot;peter&quot;</span><span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseInsensitive);    <span class="comment">// returns true</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#indexOf">indexOf</a>() 和 <a href="qstring.html#count-2">count</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsQCharQt::CaseSensitivity -->
<h3 class="fn" id="contains-1"><a name="contains-1"></a><span class="type">bool</span> QString::<span class="name">contains</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...) const</h3>
<p>此函数重载了 <a href="qstring.html#contains">contains</a>().</p>
<p>Returns <code>true</code> if this string contains an occurrence of the character <i>ch</i>; 否则则返回 <code>false</code>。</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsQLatin1StringQt::CaseSensitivity -->
<h3 class="fn" id="contains-2"><a name="contains-2"></a><span class="type">bool</span> QString::<span class="name">contains</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...) const</h3>
<p>此函数重载了 <a href="qstring.html#contains">contains</a>().</p>
<p>Returns <code>true</code> if this string contains an occurrence of the latin-1 string <i>str</i>; 否则则返回 <code>false</code>。</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQStringRef&Qt::CaseSensitivity -->
<h3 class="fn" id="contains-3"><a name="contains-3"></a><span class="type">bool</span> QString::<span class="name">contains</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>str</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...) const</h3>
<p>Returns <code>true</code> if this string contains an occurrence of the string reference <i>str</i>; 否则则返回 <code>false</code>。</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#indexOf">indexOf</a>() 和 <a href="qstring.html#count-2">count</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQRegExp& -->
<h3 class="fn" id="contains-4"><a name="contains-4"></a><span class="type">bool</span> QString::<span class="name">contains</span>(const <span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#contains">contains</a>().</p>
<p>Returns <code>true</code> if the regular expression <i>rx</i> matches somewhere in this string; 否则则返回 <code>false</code>。</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsQRegExp& -->
<h3 class="fn" id="contains-5"><a name="contains-5"></a><span class="type">bool</span> QString::<span class="name">contains</span>(<span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#contains">contains</a>().</p>
<p>Returns <code>true</code> if the regular expression <i>rx</i> matches somewhere in this string; 否则则返回 <code>false</code>。</p>
<p>If there is a match, the <i>rx</i> regular expression will contain the matched captures (see <a href="qregexp.html#matchedLength">QRegExp::matchedLength</a>, <a href="qregexp.html#cap">QRegExp::cap</a>).</p>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQRegularExpression& -->
<h3 class="fn" id="contains-6"><a name="contains-6"></a><span class="type">bool</span> QString::<span class="name">contains</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#contains">contains</a>().</p>
<p>Returns <code>true</code> if the regular expression <i>re</i> matches somewhere in this string; 否则则返回 <code>false</code>。</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQRegularExpression&QRegularExpressionMatch* -->
<h3 class="fn" id="contains-7"><a name="contains-7"></a><span class="type">bool</span> QString::<span class="name">contains</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type"><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a></span> *<i>match</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#contains">contains</a>().</p>
<p>Returns <code>true</code> if the regular expression <i>re</i> matches somewhere in this string; 否则则返回 <code>false</code>。</p>
<p>If the match is successful and <i>match</i> is not a null pointer, it also writes the results of the match into the <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object pointed to by <i>match</i>.</p>
<p>这个函数是在Qt 5.1版本中新增引入的。</p>
<p><b> 参见 </b><a href="qregularexpression.html#match">QRegularExpression::match</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstQString&Qt::CaseSensitivity -->
<h3 class="fn" id="count"><a name="count"></a><span class="type">int</span> QString::<span class="name">count</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>str</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns the number of (potentially overlapping) occurrences of the string <i>str</i> in this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b> 参见 </b><a href="qstring.html#contains">contains</a>() 和 <a href="qstring.html#indexOf">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countQCharQt::CaseSensitivity -->
<h3 class="fn" id="count-1"><a name="count-1"></a><span class="type">int</span> QString::<span class="name">count</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#count-2">count</a>().</p>
<p>Returns the number of occurrences of character <i>ch</i> in the string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b> 参见 </b><a href="qstring.html#contains">contains</a>() 和 <a href="qstring.html#indexOf">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn" id="count-2"><a name="count-2"></a><span class="type">int</span> QString::<span class="name">count</span>() const</h3>
<p>This function overloads count().</p>
<p>等同于 <a href="qstring.html#size">size</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countconstQStringRef&Qt::CaseSensitivity -->
<h3 class="fn" id="count-3"><a name="count-3"></a><span class="type">int</span> QString::<span class="name">count</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>str</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#count-2">count</a>().</p>
<p>Returns the number of (potentially overlapping) occurrences of the string reference <i>str</i> in this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#contains">contains</a>() 和 <a href="qstring.html#indexOf">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countconstQRegExp& -->
<h3 class="fn" id="count-4"><a name="count-4"></a><span class="type">int</span> QString::<span class="name">count</span>(const <span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#count-2">count</a>().</p>
<p>Returns the number of times the regular expression <i>rx</i> matches in the string.</p>
<p>This function counts overlapping matches, so in the example below, there are four instances of &quot;ana&quot; or &quot;ama&quot;:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;banana and panama&quot;</span>;
  str<span class="operator">.</span>count(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;a[nm]a&quot;</span>));    <span class="comment">// returns 4</span>

</pre>
<!-- @@@count -->
<!-- $$$count$$$countconstQRegularExpression& -->
<h3 class="fn" id="count-5"><a name="count-5"></a><span class="type">int</span> QString::<span class="name">count</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#count-2">count</a>().</p>
<p>Returns the number of times the regular expression <i>re</i> matches in the string.</p>
<p>This function counts overlapping matches, so in the example below, there are four instances of &quot;ana&quot; or &quot;ama&quot;:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;banana and panama&quot;</span>;
  str<span class="operator">.</span>count(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;a[nm]a&quot;</span>));    <span class="comment">// returns 4</span>

</pre>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" id="crbegin"><a name="crbegin"></a><span class="type"><a href="qstring.html#const_reverse_iterator-typedef">QString::const_reverse_iterator</a></span> QString::<span class="name">crbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first character in the string, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#begin">begin</a>(), <a href="qstring.html#rbegin">rbegin</a>(), 和 <a href="qstring.html#rend">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" id="crend"><a name="crend"></a><span class="type"><a href="qstring.html#const_reverse_iterator-typedef">QString::const_reverse_iterator</a></span> QString::<span class="name">crend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to one past the last character in the string, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#end">end</a>(), <a href="qstring.html#rend">rend</a>(), 和 <a href="qstring.html#rbegin">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" id="data"><a name="data"></a><span class="type"><a href="qchar.html">QChar</a></span> *QString::<span class="name">data</span>()</h3>
<p>Returns a pointer to the data stored in the <a href="qstring.html">QString</a>. The pointer can be used to access and modify the characters that compose the string.</p>
<p>Unlike <a href="qstring.html#constData">constData</a>() 和 <a href="qstring.html#unicode">unicode</a>(), the returned data is always '\0'-terminated.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;
  <span class="type"><a href="qchar.html">QChar</a></span> <span class="operator">*</span>data <span class="operator">=</span> str<span class="operator">.</span>data();
  <span class="keyword">while</span> (<span class="operator">!</span>data<span class="operator">-</span><span class="operator">&gt;</span>isNull()) {
      <a href="qtglobal.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> data<span class="operator">-</span><span class="operator">&gt;</span>unicode();
      <span class="operator">+</span><span class="operator">+</span>data;
  }

</pre>
<p>Note that the pointer remains valid only as long as the string is not modified by other means. For read-only access, <a href="qstring.html#constData">constData</a>() is faster because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur.</p>
<p><b> 参见 </b><a href="qstring.html#constData">constData</a>() 和 <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$data -->
<h3 class="fn" id="data-1"><a name="data-1"></a>const <span class="type"><a href="qchar.html">QChar</a></span> *QString::<span class="name">data</span>() const</h3>
<p>这是一个重载函数。</p>
<p><b>注意： </b>The returned string may not be '\0'-terminated. Use <a href="qstring.html#size">size</a>() to determine the length of the array.</p><p><b> 参见 </b><a href="qstring.html#fromRawData">fromRawData</a>().</p>
<!-- @@@data -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end"><a name="end"></a><span class="type"><a href="qstring.html#iterator-typedefx">QString::iterator</a></span> QString::<span class="name">end</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL样式迭代器</a> pointing to the imaginary character after the last character in the string.</p>
<p><b> 参见 </b><a href="qstring.html#begin">begin</a>() 和 <a href="qstring.html#constEnd">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1"><a name="end-1"></a><span class="type"><a href="qstring.html#const_iterator-typedef">QString::const_iterator</a></span> QString::<span class="name">end</span>() const</h3>
<p>此函数重载了 <a href="qstring.html#end">end</a>().</p>
<!-- @@@end -->
<!-- $$$endsWith[overload1]$$$endsWithconstQString&Qt::CaseSensitivity -->
<h3 class="fn" id="endsWith"><a name="endsWith"></a><span class="type">bool</span> QString::<span class="name">endsWith</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns <code>true</code> if the string ends with <i>s</i>; 否则则返回 <code>false</code>。</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Bananas&quot;</span>;
  str<span class="operator">.</span>endsWith(<span class="string">&quot;anas&quot;</span>);         <span class="comment">// returns true</span>
  str<span class="operator">.</span>endsWith(<span class="string">&quot;pple&quot;</span>);         <span class="comment">// returns false</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#startsWith">startsWith</a>().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithconstQStringRef&Qt::CaseSensitivity -->
<h3 class="fn" id="endsWith-1"><a name="endsWith-1"></a><span class="type">bool</span> QString::<span class="name">endsWith</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>s</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#endsWith">endsWith</a>().</p>
<p>Returns <code>true</code> if the string ends with the string reference <i>s</i>; 否则则返回 <code>false</code>。</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#startsWith">startsWith</a>().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithQStringViewQt::CaseSensitivity -->
<h3 class="fn" id="endsWith-2"><a name="endsWith-2"></a><span class="type">bool</span> QString::<span class="name">endsWith</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>str</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#endsWith">endsWith</a>().</p>
<p>Returns <code>true</code> if the string ends with the string view <i>str</i>; 否则则返回 <code>false</code>。</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#startsWith">startsWith</a>().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithQLatin1StringQt::CaseSensitivity -->
<h3 class="fn" id="endsWith-3"><a name="endsWith-3"></a><span class="type">bool</span> QString::<span class="name">endsWith</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>s</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#endsWith">endsWith</a>().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithQCharQt::CaseSensitivity -->
<h3 class="fn" id="endsWith-4"><a name="endsWith-4"></a><span class="type">bool</span> QString::<span class="name">endsWith</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>c</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns <code>true</code> if the string ends with <i>c</i>; 否则则返回 <code>false</code>。</p>
<p>此函数重载了 <a href="qstring.html#endsWith">endsWith</a>().</p>
<!-- @@@endsWith -->
<!-- $$$fill[overload1]$$$fillQCharint -->
<h3 class="fn" id="fill"><a name="fill"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">fill</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Sets every character in the string to character <i>ch</i>. If <i>size</i> is different from -1 (default), the string is resized to <i>size</i> beforehand.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Berlin&quot;</span>;
  str<span class="operator">.</span>fill(<span class="char">'z'</span>);
  <span class="comment">// str == &quot;zzzzzz&quot;</span>

  str<span class="operator">.</span>fill(<span class="char">'A'</span><span class="operator">,</span> <span class="number">2</span>);
  <span class="comment">// str == &quot;AA&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#resize">resize</a>().</p>
<!-- @@@fill -->
<!-- $$$fromCFString[overload1]$$$fromCFStringCFStringRef -->
<h3 class="fn" id="fromCFString"><a name="fromCFString"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromCFString</span>(<span class="type">CFStringRef</span> <i>string</i>)</h3>
<p>Constructs a new <a href="qstring.html">QString</a> containing a copy of the <i>string</i> CFString.</p>
<p><b>注意： </b>this function is only available on OS X and iOS.</p><p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@fromCFString -->
<!-- $$$fromLatin1[overload1]$$$fromLatin1constchar*int -->
<h3 class="fn" id="fromLatin1"><a name="fromLatin1"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromLatin1</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the Latin-1 string <i>str</i>.</p>
<p>If <i>size</i> is -1 (default), it is taken to be strlen(<i>str</i>).</p>
<p><b> 参见 </b><a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), 和 <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>().</p>
<!-- @@@fromLatin1 -->
<!-- $$$fromLatin1$$$fromLatin1constQByteArray& -->
<h3 class="fn" id="fromLatin1-1"><a name="fromLatin1-1"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromLatin1</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>str</i>)</h3>
<p>这是一个重载函数。</p>
<p>Returns a <a href="qstring.html">QString</a> initialized with the Latin-1 string <i>str</i>.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@fromLatin1 -->
<!-- $$$fromLocal8Bit[overload1]$$$fromLocal8Bitconstchar*int -->
<h3 class="fn" id="fromLocal8Bit"><a name="fromLocal8Bit"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromLocal8Bit</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the 8-bit string <i>str</i>.</p>
<p>If <i>size</i> is -1 (default), it is taken to be strlen(<i>str</i>).</p>
<p><a href="qtextcodec.html#codecForLocale">QTextCodec::codecForLocale</a>() is used to perform the conversion.</p>
<p><b> 参见 </b><a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), 和 <a href="qstring.html#fromUtf8">fromUtf8</a>().</p>
<!-- @@@fromLocal8Bit -->
<!-- $$$fromLocal8Bit$$$fromLocal8BitconstQByteArray& -->
<h3 class="fn" id="fromLocal8Bit-1"><a name="fromLocal8Bit-1"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromLocal8Bit</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>str</i>)</h3>
<p>这是一个重载函数。</p>
<p>Returns a <a href="qstring.html">QString</a> initialized with the 8-bit string <i>str</i>.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@fromLocal8Bit -->
<!-- $$$fromNSString[overload1]$$$fromNSStringconstNSString* -->
<h3 class="fn" id="fromNSString"><a name="fromNSString"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromNSString</span>(const <span class="type">NSString</span> *<i>string</i>)</h3>
<p>Constructs a new <a href="qstring.html">QString</a> containing a copy of the <i>string</i> NSString.</p>
<p><b>注意： </b>this function is only available on OS X and iOS.</p><p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@fromNSString -->
<!-- $$$fromRawData[overload1]$$$fromRawDataconstQChar*int -->
<h3 class="fn" id="fromRawData"><a name="fromRawData"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromRawData</span>(const <span class="type"><a href="qchar.html">QChar</a></span> *<i>unicode</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>Constructs a <a href="qstring.html">QString</a> that uses the first <i>size</i> Unicode characters in the array <i>unicode</i>. The data in <i>unicode</i> is <i>not</i> copied. The caller must be able to guarantee that <i>unicode</i> will not be deleted or modified as long as the <a href="qstring.html">QString</a> (or an unmodified copy of it) exists.</p>
<p>Any attempts to modify the <a href="qstring.html">QString</a> or copies of it will cause it to create a deep copy of the data, ensuring that the raw data isn't modified.</p>
<p>Here's an example of how we can use a <a href="qregularexpression.html">QRegularExpression</a> on raw data in memory without requiring to copy the data into a <a href="qstring.html">QString</a>:</p>
<pre class="cpp">

  <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> pattern(<span class="string">&quot;\u00A4&quot;</span>);
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="qchar.html">QChar</a></span> unicode<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
          <span class="number">0x005A</span><span class="operator">,</span> <span class="number">0x007F</span><span class="operator">,</span> <span class="number">0x00A4</span><span class="operator">,</span> <span class="number">0x0060</span><span class="operator">,</span>
          <span class="number">0x1009</span><span class="operator">,</span> <span class="number">0x0020</span><span class="operator">,</span> <span class="number">0x0020</span>};
  <span class="type">int</span> size <span class="operator">=</span> <span class="keyword">sizeof</span>(unicode) <span class="operator">/</span> <span class="keyword">sizeof</span>(<span class="type"><a href="qchar.html">QChar</a></span>);

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>fromRawData(unicode<span class="operator">,</span> size);
  <span class="keyword">if</span> (str<span class="operator">.</span>contains(pattern) {
      <span class="comment">// ...</span>
  }

</pre>
<p><b>警告：</b> A string created with fromRawData() is <i>not</i> '\0'-terminated, unless the raw data contains a '\0' character at position <i>size</i>. This means <a href="qstring.html#unicode">unicode</a>() will <i>not</i> return a '\0'-terminated string (although <a href="qstring.html#utf16">utf16</a>() does, at the cost of copying the raw data).</p>
<p><b> 参见 </b><a href="qstring.html#fromUtf16">fromUtf16</a>() 和 <a href="qstring.html#setRawData">setRawData</a>().</p>
<!-- @@@fromRawData -->
<!-- $$$fromStdString[overload1]$$$fromStdStringconststd::string& -->
<h3 class="fn" id="fromStdString"><a name="fromStdString"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromStdString</span>(const <span class="type">std::string</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i>str</i> string. The given string is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p><b> 参见 </b><a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), 和 <a href="qbytearray.html#fromStdString">QByteArray::fromStdString</a>().</p>
<!-- @@@fromStdString -->
<!-- $$$fromStdU16String[overload1]$$$fromStdU16Stringconststd::u16string& -->
<h3 class="fn" id="fromStdU16String"><a name="fromStdU16String"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromStdU16String</span>(const <span class="type">std::u16string</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i>str</i> string. The given string is assumed to be encoded in UTF-16.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#fromUtf16">fromUtf16</a>(), <a href="qstring.html#fromStdWString">fromStdWString</a>(), 和 <a href="qstring.html#fromStdU32String">fromStdU32String</a>().</p>
<!-- @@@fromStdU16String -->
<!-- $$$fromStdU32String[overload1]$$$fromStdU32Stringconststd::u32string& -->
<h3 class="fn" id="fromStdU32String"><a name="fromStdU32String"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromStdU32String</span>(const <span class="type">std::u32string</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i>str</i> string. The given string is assumed to be encoded in UCS-4.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#fromUcs4">fromUcs4</a>(), <a href="qstring.html#fromStdWString">fromStdWString</a>(), 和 <a href="qstring.html#fromStdU16String">fromStdU16String</a>().</p>
<!-- @@@fromStdU32String -->
<!-- $$$fromStdWString[overload1]$$$fromStdWStringconststd::wstring& -->
<h3 class="fn" id="fromStdWString"><a name="fromStdWString"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromStdWString</span>(const <span class="type">std::wstring</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i>str</i> string. The given string is assumed to be encoded in utf16 if the size of wchar_t is 2 bytes (e.g&#x2e; on windows) and ucs4 if the size of wchar_t is 4 bytes (most Unix systems).</p>
<p><b> 参见 </b><a href="qstring.html#fromUtf16">fromUtf16</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), <a href="qstring.html#fromUcs4">fromUcs4</a>(), <a href="qstring.html#fromStdU16String">fromStdU16String</a>(), 和 <a href="qstring.html#fromStdU32String">fromStdU32String</a>().</p>
<!-- @@@fromStdWString -->
<!-- $$$fromUcs4[overload1]$$$fromUcs4constuint*int -->
<h3 class="fn" id="fromUcs4"><a name="fromUcs4"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromUcs4</span>(const <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> *<i>unicode</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the Unicode string <i>unicode</i> (ISO-10646-UCS-4 encoded).</p>
<p>If <i>size</i> is -1 (default), <i>unicode</i> must be terminated with a 0.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#toUcs4">toUcs4</a>(), <a href="qstring.html#fromUtf16">fromUtf16</a>(), <a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#setUtf16">setUtf16</a>(), <a href="qstring.html#fromWCharArray">fromWCharArray</a>(), 和 <a href="qstring.html#fromStdU32String">fromStdU32String</a>().</p>
<!-- @@@fromUcs4 -->
<!-- $$$fromUcs4$$$fromUcs4constchar32_t*int -->
<h3 class="fn" id="fromUcs4-1"><a name="fromUcs4-1"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromUcs4</span>(const <span class="type">char32_t</span> *<i>str</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the Unicode string <i>str</i> (ISO-10646-UCS-4 encoded).</p>
<p>If <i>size</i> is -1 (default), <i>str</i> must be terminated with a 0.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#toUcs4">toUcs4</a>(), <a href="qstring.html#fromUtf16">fromUtf16</a>(), <a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#setUtf16">setUtf16</a>(), <a href="qstring.html#fromWCharArray">fromWCharArray</a>(), 和 <a href="qstring.html#fromStdU32String">fromStdU32String</a>().</p>
<!-- @@@fromUcs4 -->
<!-- $$$fromUtf8[overload1]$$$fromUtf8constchar*int -->
<h3 class="fn" id="fromUtf8"><a name="fromUtf8"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromUtf8</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> bytes of the UTF-8 string <i>str</i>.</p>
<p>If <i>size</i> is -1 (default), it is taken to be strlen(<i>str</i>).</p>
<p>UTF-8 is a Unicode codec and can represent all characters in a Unicode string like <a href="qstring.html">QString</a>. However, invalid sequences are possible with UTF-8 and, if any such are found, they will be replaced with one or more &quot;replacement characters&quot;, or suppressed. These include non-Unicode sequences, non-characters, overlong sequences or surrogate codepoints encoded into UTF-8.</p>
<p>This function can be used to process incoming data incrementally as long as all UTF-8 characters are terminated within the incoming data. Any unterminated characters at the end of the string will be replaced or suppressed. In order to do stateful decoding, please use <a href="qtextdecoder.html">QTextDecoder</a>.</p>
<p><b> 参见 </b><a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), 和 <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>().</p>
<!-- @@@fromUtf8 -->
<!-- $$$fromUtf8$$$fromUtf8constQByteArray& -->
<h3 class="fn" id="fromUtf8-1"><a name="fromUtf8-1"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromUtf8</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>str</i>)</h3>
<p>这是一个重载函数。</p>
<p>Returns a <a href="qstring.html">QString</a> initialized with the UTF-8 string <i>str</i>.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@fromUtf8 -->
<!-- $$$fromUtf16[overload1]$$$fromUtf16constushort*int -->
<h3 class="fn" id="fromUtf16"><a name="fromUtf16"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromUtf16</span>(const <span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> *<i>unicode</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the Unicode string <i>unicode</i> (ISO-10646-UTF-16 encoded).</p>
<p>If <i>size</i> is -1 (default), <i>unicode</i> must be terminated with a 0.</p>
<p>This function checks for a Byte Order Mark (BOM). If it is missing, host byte order is assumed.</p>
<p>This function is slow compared to the other Unicode conversions. Use <a href="qstring.html">QString</a>(const <a href="qchar.html">QChar</a> *, int) or <a href="qstring.html">QString</a>(const <a href="qchar.html">QChar</a> *) if possible.</p>
<p><a href="qstring.html">QString</a> makes a deep copy of the Unicode data.</p>
<p><b> 参见 </b><a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#setUtf16">setUtf16</a>(), 和 <a href="qstring.html#fromStdU16String">fromStdU16String</a>().</p>
<!-- @@@fromUtf16 -->
<!-- $$$fromUtf16$$$fromUtf16constchar16_t*int -->
<h3 class="fn" id="fromUtf16-1"><a name="fromUtf16-1"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromUtf16</span>(const <span class="type">char16_t</span> *<i>str</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Returns a <a href="qstring.html">QString</a> initialized with the first <i>size</i> characters of the Unicode string <i>str</i> (ISO-10646-UTF-16 encoded).</p>
<p>If <i>size</i> is -1 (default), <i>str</i> must be terminated with a 0.</p>
<p>This function checks for a Byte Order Mark (BOM). If it is missing, host byte order is assumed.</p>
<p>This function is slow compared to the other Unicode conversions. Use <a href="qstring.html">QString</a>(const <a href="qchar.html">QChar</a> *, int) or <a href="qstring.html">QString</a>(const <a href="qchar.html">QChar</a> *) if possible.</p>
<p><a href="qstring.html">QString</a> makes a deep copy of the Unicode data.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#setUtf16">setUtf16</a>(), 和 <a href="qstring.html#fromStdU16String">fromStdU16String</a>().</p>
<!-- @@@fromUtf16 -->
<!-- $$$fromWCharArray[overload1]$$$fromWCharArrayconstwchar_t*int -->
<h3 class="fn" id="fromWCharArray"><a name="fromWCharArray"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">fromWCharArray</span>(const <span class="type">wchar_t</span> *<i>string</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Returns a copy of the <i>string</i>, where the encoding of <i>string</i> depends on the size of wchar. If wchar is 4 bytes, the <i>string</i> is interpreted as UCS-4, if wchar is 2 bytes it is interpreted as UTF-16.</p>
<p>If <i>size</i> is -1 (default), the <i>string</i> has to be 0 terminated.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#fromUtf16">fromUtf16</a>(), <a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), <a href="qstring.html#fromUtf8">fromUtf8</a>(), <a href="qstring.html#fromUcs4">fromUcs4</a>(), 和 <a href="qstring.html#fromStdWString">fromStdWString</a>().</p>
<!-- @@@fromWCharArray -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" id="front"><a name="front"></a><span class="type"><a href="qchar.html">QChar</a></span> QString::<span class="name">front</span>() const</h3>
<p>Returns the first character in the string. Same as <code>at(0)</code>.</p>
<p>此函数用于STL风格的兼容性。</p>
<p><b>警告：</b> Calling this function on an empty string constitutes undefined behavior.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#back">back</a>(), <a href="qstring.html#at">at</a>(), 和 <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$front$$$front -->
<h3 class="fn" id="front-1"><a name="front-1"></a><span class="type">QCharRef</span> QString::<span class="name">front</span>()</h3>
<p>Returns a reference to the first character in the string. Same as <code>operator[](0)</code>.</p>
<p>此函数用于STL风格的兼容性。</p>
<p><b>警告：</b> Calling this function on an empty string constitutes undefined behavior.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#back">back</a>(), <a href="qstring.html#at">at</a>(), 和 <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$indexOf[overload1]$$$indexOfconstQString&intQt::CaseSensitivity -->
<h3 class="fn" id="indexOf"><a name="indexOf"></a><span class="type">int</span> QString::<span class="name">indexOf</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>str</i>, <span class="type">int</span> <i>from</i> = 0, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns the index position of the first occurrence of the string <i>str</i> in this string, searching forward from index position <i>from</i>. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;sticky question&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;sti&quot;</span>;
  x<span class="operator">.</span>indexOf(y);               <span class="comment">// returns 0</span>
  x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">1</span>);            <span class="comment">// returns 10</span>
  x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">10</span>);           <span class="comment">// returns 10</span>
  x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">11</span>);           <span class="comment">// returns -1</span>

</pre>
<p>If <i>from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p><b> 参见 </b><a href="qstring.html#lastIndexOf">lastIndexOf</a>(), <a href="qstring.html#contains">contains</a>(), 和 <a href="qstring.html#count-2">count</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfQCharintQt::CaseSensitivity -->
<h3 class="fn" id="indexOf-1"><a name="indexOf-1"></a><span class="type">int</span> QString::<span class="name">indexOf</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>, <span class="type">int</span> <i>from</i> = 0, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#indexOf">indexOf</a>().</p>
<p>Returns the index position of the first occurrence of the character <i>ch</i> in the string, searching forward from index position <i>from</i>. Returns -1 if <i>ch</i> could not be found.</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfQLatin1StringintQt::CaseSensitivity -->
<h3 class="fn" id="indexOf-2"><a name="indexOf-2"></a><span class="type">int</span> QString::<span class="name">indexOf</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>, <span class="type">int</span> <i>from</i> = 0, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns the index position of the first occurrence of the string <i>str</i> in this string, searching forward from index position <i>from</i>. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;sticky question&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;sti&quot;</span>;
  x<span class="operator">.</span>indexOf(y);               <span class="comment">// returns 0</span>
  x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">1</span>);            <span class="comment">// returns 10</span>
  x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">10</span>);           <span class="comment">// returns 10</span>
  x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">11</span>);           <span class="comment">// returns -1</span>

</pre>
<p>If <i>from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#lastIndexOf">lastIndexOf</a>(), <a href="qstring.html#contains">contains</a>(), 和 <a href="qstring.html#count-2">count</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfconstQStringRef&intQt::CaseSensitivity -->
<h3 class="fn" id="indexOf-3"><a name="indexOf-3"></a><span class="type">int</span> QString::<span class="name">indexOf</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>str</i>, <span class="type">int</span> <i>from</i> = 0, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#indexOf">indexOf</a>().</p>
<p>Returns the index position of the first occurrence of the string reference <i>str</i> in this string, searching forward from index position <i>from</i>. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfconstQRegExp&int -->
<h3 class="fn" id="indexOf-4"><a name="indexOf-4"></a><span class="type">int</span> QString::<span class="name">indexOf</span>(const <span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>, <span class="type">int</span> <i>from</i> = 0) const</h3>
<p>此函数重载了 <a href="qstring.html#indexOf">indexOf</a>().</p>
<p>Returns the index position of the first match of the regular expression <i>rx</i> in the string, searching forward from index position <i>from</i>. Returns -1 if <i>rx</i> didn't match anywhere.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
  str<span class="operator">.</span>indexOf(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>)<span class="operator">,</span> <span class="number">0</span>);       <span class="comment">// returns 4</span>

</pre>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfQRegExp&int -->
<h3 class="fn" id="indexOf-5"><a name="indexOf-5"></a><span class="type">int</span> QString::<span class="name">indexOf</span>(<span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>, <span class="type">int</span> <i>from</i> = 0) const</h3>
<p>此函数重载了 <a href="qstring.html#indexOf">indexOf</a>().</p>
<p>Returns the index position of the first match of the regular expression <i>rx</i> in the string, searching forward from index position <i>from</i>. Returns -1 if <i>rx</i> didn't match anywhere.</p>
<p>If there is a match, the <i>rx</i> regular expression will contain the matched captures (see <a href="qregexp.html#matchedLength">QRegExp::matchedLength</a>, <a href="qregexp.html#cap">QRegExp::cap</a>).</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
  str<span class="operator">.</span>indexOf(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>)<span class="operator">,</span> <span class="number">0</span>);       <span class="comment">// returns 4</span>

</pre>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfconstQRegularExpression&int -->
<h3 class="fn" id="indexOf-6"><a name="indexOf-6"></a><span class="type">int</span> QString::<span class="name">indexOf</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type">int</span> <i>from</i> = 0) const</h3>
<p>此函数重载了 <a href="qstring.html#indexOf">indexOf</a>().</p>
<p>Returns the index position of the first match of the regular expression <i>re</i> in the string, searching forward from index position <i>from</i>. Returns -1 if <i>re</i> didn't match anywhere.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
  str<span class="operator">.</span>indexOf(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>)<span class="operator">,</span> <span class="number">0</span>);       <span class="comment">// returns 4</span>

</pre>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfconstQRegularExpression&intQRegularExpressionMatch* -->
<h3 class="fn" id="indexOf-7"><a name="indexOf-7"></a><span class="type">int</span> QString::<span class="name">indexOf</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type">int</span> <i>from</i>, <span class="type"><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a></span> *<i>rmatch</i>) const</h3>
<p>这是一个重载函数。</p>
<p>Returns the index position of the first match of the regular expression <i>re</i> in the string, searching forward from index position <i>from</i>. Returns -1 if <i>re</i> didn't match anywhere.</p>
<p>If the match is successful and <i>rmatch</i> is not a null pointer, it also writes the results of the match into the <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object pointed to by <i>rmatch</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
  <span class="type"><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a></span> match;
  str<span class="operator">.</span>indexOf(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>)<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">&amp;</span>match);       <span class="comment">// returns 4</span>
  <span class="comment">// match.captured() == mi</span>

</pre>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@indexOf -->
<!-- $$$insert[overload1]$$$insertintconstQString& -->
<h3 class="fn" id="insert"><a name="insert"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">int</span> <i>position</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>str</i>)</h3>
<p>Inserts the string <i>str</i> at the given index <i>position</i> and returns a reference to this string.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Meal&quot;</span>;
  str<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;ontr&quot;</span>));
  <span class="comment">// str == &quot;Montreal&quot;</span>

</pre>
<p>If the given <i>position</i> is greater than <a href="qstring.html#size">size</a>(), the array is first extended using <a href="qstring.html#resize">resize</a>().</p>
<p><b> 参见 </b><a href="qstring.html#append">append</a>(), <a href="qstring.html#prepend">prepend</a>(), <a href="qstring.html#replace">replace</a>(), 和 <a href="qstring.html#remove">remove</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintconstQChar*int -->
<h3 class="fn" id="insert-1"><a name="insert-1"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">int</span> <i>position</i>, const <span class="type"><a href="qchar.html">QChar</a></span> *<i>unicode</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>此函数重载了 <a href="qstring.html#insert">insert</a>().</p>
<p>Inserts the first <i>size</i> characters of the <a href="qchar.html">QChar</a> array <i>unicode</i> at the given index <i>position</i> in the string.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintQChar -->
<h3 class="fn" id="insert-2"><a name="insert-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">int</span> <i>position</i>, <span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>)</h3>
<p>此函数重载了 <a href="qstring.html#insert">insert</a>().</p>
<p>Inserts <i>ch</i> at the given index <i>position</i> in the string.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintconstQStringRef& -->
<h3 class="fn" id="insert-3"><a name="insert-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">int</span> <i>position</i>, const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#insert">insert</a>().</p>
<p>Inserts the string reference <i>str</i> at the given index <i>position</i> and returns a reference to this string.</p>
<p>If the given <i>position</i> is greater than <a href="qstring.html#size">size</a>(), the array is first extended using <a href="qstring.html#resize">resize</a>().</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintQLatin1String -->
<h3 class="fn" id="insert-4"><a name="insert-4"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">int</span> <i>position</i>, <span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#insert">insert</a>().</p>
<p>Inserts the Latin-1 string <i>str</i> at the given index <i>position</i>.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintconstchar* -->
<h3 class="fn" id="insert-5"><a name="insert-5"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">int</span> <i>position</i>, const <span class="type">char</span> *<i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#insert">insert</a>().</p>
<p>Inserts the C string <i>str</i> at the given index <i>position</i> and returns a reference to this string.</p>
<p>If the given <i>position</i> is greater than <a href="qstring.html#size">size</a>(), the array is first extended using <a href="qstring.html#resize">resize</a>().</p>
<p>This function is not available when <a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> is defined.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintconstQByteArray& -->
<h3 class="fn" id="insert-6"><a name="insert-6"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">insert</span>(<span class="type">int</span> <i>position</i>, const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#insert">insert</a>().</p>
<p>Inserts the byte array <i>str</i> at the given index <i>position</i> and returns a reference to this string.</p>
<p>If the given <i>position</i> is greater than <a href="qstring.html#size">size</a>(), the array is first extended using <a href="qstring.html#resize">resize</a>().</p>
<p>This function is not available when <a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> is defined.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty"><a name="isEmpty"></a><span class="type">bool</span> QString::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code>true</code> if the string has no characters; 否则则返回 <code>false</code>。</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span>()<span class="operator">.</span>isEmpty();            <span class="comment">// returns true</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isEmpty();          <span class="comment">// returns true</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;x&quot;</span>)<span class="operator">.</span>isEmpty();         <span class="comment">// returns false</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns false</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#size">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$isLower[overload1]$$$isLower -->
<h3 class="fn" id="isLower"><a name="isLower"></a><span class="type">bool</span> QString::<span class="name">isLower</span>() const</h3>
<p>Returns <code>true</code> if the string only contains lowercase letters, 否则则返回 <code>false</code>。</p>
<p>这个函数是在Qt 5.12版本中新增引入的。</p>
<p><b> 参见 </b><a href="qchar.html#isLower">QChar::isLower</a>() 和 <a href="qstring.html#isUpper">isUpper</a>().</p>
<!-- @@@isLower -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" id="isNull"><a name="isNull"></a><span class="type">bool</span> QString::<span class="name">isNull</span>() const</h3>
<p>Returns <code>true</code> if this string is null; 否则则返回 <code>false</code>。</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span>()<span class="operator">.</span>isNull();             <span class="comment">// returns true</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isNull();           <span class="comment">// returns false</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>

</pre>
<p>Qt makes a distinction between null strings and empty strings for historical reasons. For most applications, what matters is whether or not a string contains any data, and this can be determined using the <a href="qstring.html#isEmpty">isEmpty</a>() function.</p>
<p><b> 参见 </b><a href="qstring.html#isEmpty">isEmpty</a>().</p>
<!-- @@@isNull -->
<!-- $$$isRightToLeft[overload1]$$$isRightToLeft -->
<h3 class="fn" id="isRightToLeft"><a name="isRightToLeft"></a><span class="type">bool</span> QString::<span class="name">isRightToLeft</span>() const</h3>
<p>Returns <code>true</code> if the string is read right to left.</p>
<p><b> 参见 </b><a href="qstringref.html#isRightToLeft">QStringRef::isRightToLeft</a>().</p>
<!-- @@@isRightToLeft -->
<!-- $$$isUpper[overload1]$$$isUpper -->
<h3 class="fn" id="isUpper"><a name="isUpper"></a><span class="type">bool</span> QString::<span class="name">isUpper</span>() const</h3>
<p>Returns <code>true</code> if the string only contains uppercase letters, 否则则返回 <code>false</code>。</p>
<p>这个函数是在Qt 5.12版本中新增引入的。</p>
<p><b> 参见 </b><a href="qchar.html#isUpper">QChar::isUpper</a>() 和 <a href="qstring.html#isLower">isLower</a>().</p>
<!-- @@@isUpper -->
<!-- $$$lastIndexOf[overload1]$$$lastIndexOfconstQString&intQt::CaseSensitivity -->
<h3 class="fn" id="lastIndexOf"><a name="lastIndexOf"></a><span class="type">int</span> QString::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>str</i>, <span class="type">int</span> <i>from</i> = -1, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns the index position of the last occurrence of the string <i>str</i> in this string, searching backward from index position <i>from</i>. If <i>from</i> is -1 (default), the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;crazy azimuths&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;az&quot;</span>;
  x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
  x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
  x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
  x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#contains">contains</a>(), 和 <a href="qstring.html#count-2">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQCharintQt::CaseSensitivity -->
<h3 class="fn" id="lastIndexOf-1"><a name="lastIndexOf-1"></a><span class="type">int</span> QString::<span class="name">lastIndexOf</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>, <span class="type">int</span> <i>from</i> = -1, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#lastIndexOf">lastIndexOf</a>().</p>
<p>Returns the index position of the last occurrence of the character <i>ch</i>, searching backward from position <i>from</i>.</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQLatin1StringintQt::CaseSensitivity -->
<h3 class="fn" id="lastIndexOf-2"><a name="lastIndexOf-2"></a><span class="type">int</span> QString::<span class="name">lastIndexOf</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>, <span class="type">int</span> <i>from</i> = -1, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#lastIndexOf">lastIndexOf</a>().</p>
<p>Returns the index position of the last occurrence of the string <i>str</i> in this string, searching backward from index position <i>from</i>. If <i>from</i> is -1 (default), the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;crazy azimuths&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;az&quot;</span>;
  x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
  x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
  x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
  x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>

</pre>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#contains">contains</a>(), 和 <a href="qstring.html#count-2">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstQStringRef&intQt::CaseSensitivity -->
<h3 class="fn" id="lastIndexOf-3"><a name="lastIndexOf-3"></a><span class="type">int</span> QString::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>str</i>, <span class="type">int</span> <i>from</i> = -1, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#lastIndexOf">lastIndexOf</a>().</p>
<p>Returns the index position of the last occurrence of the string reference <i>str</i> in this string, searching backward from index position <i>from</i>. If <i>from</i> is -1 (default), the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1 if <i>str</i> is not found.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#contains">contains</a>(), 和 <a href="qstring.html#count-2">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstQRegExp&int -->
<h3 class="fn" id="lastIndexOf-4"><a name="lastIndexOf-4"></a><span class="type">int</span> QString::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>, <span class="type">int</span> <i>from</i> = -1) const</h3>
<p>此函数重载了 <a href="qstring.html#lastIndexOf">lastIndexOf</a>().</p>
<p>Returns the index position of the last match of the regular expression <i>rx</i> in the string, searching backward from index position <i>from</i>. Returns -1 if <i>rx</i> didn't match anywhere.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
  str<span class="operator">.</span>lastIndexOf(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>));      <span class="comment">// returns 8</span>

</pre>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQRegExp&int -->
<h3 class="fn" id="lastIndexOf-5"><a name="lastIndexOf-5"></a><span class="type">int</span> QString::<span class="name">lastIndexOf</span>(<span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>, <span class="type">int</span> <i>from</i> = -1) const</h3>
<p>此函数重载了 <a href="qstring.html#lastIndexOf">lastIndexOf</a>().</p>
<p>Returns the index position of the last match of the regular expression <i>rx</i> in the string, searching backward from index position <i>from</i>. Returns -1 if <i>rx</i> didn't match anywhere.</p>
<p>If there is a match, the <i>rx</i> regular expression will contain the matched captures (see <a href="qregexp.html#matchedLength">QRegExp::matchedLength</a>, <a href="qregexp.html#cap">QRegExp::cap</a>).</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
  str<span class="operator">.</span>lastIndexOf(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>));      <span class="comment">// returns 8</span>

</pre>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstQRegularExpression&int -->
<h3 class="fn" id="lastIndexOf-6"><a name="lastIndexOf-6"></a><span class="type">int</span> QString::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type">int</span> <i>from</i> = -1) const</h3>
<p>此函数重载了 <a href="qstring.html#lastIndexOf">lastIndexOf</a>().</p>
<p>Returns the index position of the last match of the regular expression <i>re</i> in the string, which starts before the index position <i>from</i>. Returns -1 if <i>re</i> didn't match anywhere.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
  str<span class="operator">.</span>lastIndexOf(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>));      <span class="comment">// returns 8</span>

</pre>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstQRegularExpression&intQRegularExpressionMatch* -->
<h3 class="fn" id="lastIndexOf-7"><a name="lastIndexOf-7"></a><span class="type">int</span> QString::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type">int</span> <i>from</i>, <span class="type"><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a></span> *<i>rmatch</i>) const</h3>
<p>这是一个重载函数。</p>
<p>Returns the index position of the last match of the regular expression <i>re</i> in the string, which starts before the index position <i>from</i>. Returns -1 if <i>re</i> didn't match anywhere.</p>
<p>If the match is successful and <i>rmatch</i> is not a null pointer, it also writes the results of the match into the <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object pointed to by <i>rmatch</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;the minimum&quot;</span>;
  <span class="type"><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a></span> match;
  str<span class="operator">.</span>lastIndexOf(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;m[aeiou]&quot;</span>)<span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">&amp;</span>match);      <span class="comment">// returns 8</span>
  <span class="comment">// match.captured() == mu</span>

</pre>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@lastIndexOf -->
<!-- $$$left[overload1]$$$leftint -->
<h3 class="fn" id="left"><a name="left"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">left</span>(<span class="type">int</span> <i>n</i>) const</h3>
<p>Returns a substring that contains the <i>n</i> leftmost characters of the string.</p>
<p>The entire string is returned if <i>n</i> is greater than or equal to <a href="qstring.html#size">size</a>(), or less than zero.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> x<span class="operator">.</span>left(<span class="number">4</span>);      <span class="comment">// y == &quot;Pine&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#right">right</a>(), <a href="qstring.html#mid">mid</a>(), <a href="qstring.html#startsWith">startsWith</a>(), <a href="qstring.html#chopped">chopped</a>(), <a href="qstring.html#chop">chop</a>(), 和 <a href="qstring.html#truncate">truncate</a>().</p>
<!-- @@@left -->
<!-- $$$leftJustified[overload1]$$$leftJustifiedintQCharbool -->
<h3 class="fn" id="leftJustified"><a name="leftJustified"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">leftJustified</span>(<span class="type">int</span> <i>width</i>, <span class="type"><a href="qchar.html">QChar</a></span> <i>fill</i> = QLatin1Char(' '), <span class="type">bool</span> <i>truncate</i> = false) const</h3>
<p>Returns a string of size <i>width</i> that contains this string padded by the <i>fill</i> character.</p>
<p>If <i>truncate</i> is <code>false</code> and the <a href="qstring.html#size">size</a>() of the string is more than <i>width</i>, then the returned string is a copy of the string.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> t <span class="operator">=</span> s<span class="operator">.</span>leftJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);    <span class="comment">// t == &quot;apple...&quot;</span>

</pre>
<p>If <i>truncate</i> is <code>true</code> and the <a href="qstring.html#size">size</a>() of the string is more than <i>width</i>, then any characters in a copy of the string after position <i>width</i> are removed, and the copy is returned.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
  str <span class="operator">=</span> str<span class="operator">.</span>leftJustified(<span class="number">5</span><span class="operator">,</span> <span class="char">'.'</span><span class="operator">,</span> <span class="keyword">true</span>);    <span class="comment">// str == &quot;Pinea&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#rightJustified">rightJustified</a>().</p>
<!-- @@@leftJustified -->
<!-- $$$leftRef[overload1]$$$leftRefint -->
<h3 class="fn" id="leftRef"><a name="leftRef"></a><span class="type"><a href="qstringref.html">QStringRef</a></span> QString::<span class="name">leftRef</span>(<span class="type">int</span> <i>n</i>) const</h3>
<p>Returns a substring reference to the <i>n</i> leftmost characters of the string.</p>
<p>If <i>n</i> is greater than or equal to <a href="qstring.html#size">size</a>(), or less than zero, a reference to the entire string is returned.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
  <span class="type"><a href="qstringref.html">QStringRef</a></span> y <span class="operator">=</span> x<span class="operator">.</span>leftRef(<span class="number">4</span>);        <span class="comment">// y == &quot;Pine&quot;</span>

</pre>
<p>这个函数是在Qt 4.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#left">left</a>(), <a href="qstring.html#rightRef">rightRef</a>(), <a href="qstring.html#midRef">midRef</a>(), 和 <a href="qstring.html#startsWith">startsWith</a>().</p>
<!-- @@@leftRef -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" id="length"><a name="length"></a><span class="type">int</span> QString::<span class="name">length</span>() const</h3>
<p>Returns the number of characters in this string. Equivalent to <a href="qstring.html#size">size</a>().</p>
<p><b> 参见 </b><a href="qstring.html#resize">resize</a>().</p>
<!-- @@@length -->
<!-- $$$localeAwareCompare[overload1]$$$localeAwareCompareconstQString&constQString& -->
<h3 class="fn" id="localeAwareCompare"><a name="localeAwareCompare"></a><code>[静态函数] </code><span class="type">int</span> QString::<span class="name">localeAwareCompare</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Compares <i>s1</i> with <i>s2</i> and returns an integer less than, equal to, or greater than zero if <i>s1</i> is less than, equal to, or greater than <i>s2</i>.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>On <a href="../qtdoc/internationalization.html#macos">macOS</a> and iOS this function compares according the &quot;Order for sorted lists&quot; setting in the International preferences panel.</p>
<p><b> 参见 </b><a href="qstring.html#compare">compare</a>() 和 <a href="qlocale.html">QLocale</a>.</p>
<!-- @@@localeAwareCompare -->
<!-- $$$localeAwareCompare$$$localeAwareCompareconstQString& -->
<h3 class="fn" id="localeAwareCompare-1"><a name="localeAwareCompare-1"></a><span class="type">int</span> QString::<span class="name">localeAwareCompare</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<p>Compares this string with the <i>other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the <i>other</i> string.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>等同于 <code>localeAwareCompare(*this, other)</code>.</p>
<!-- @@@localeAwareCompare -->
<!-- $$$localeAwareCompare$$$localeAwareCompareconstQStringRef& -->
<h3 class="fn" id="localeAwareCompare-2"><a name="localeAwareCompare-2"></a><span class="type">int</span> QString::<span class="name">localeAwareCompare</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<p>Compares this string with the <i>other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the <i>other</i> string.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>等同于 <code>localeAwareCompare(*this, other)</code>.</p>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@localeAwareCompare -->
<!-- $$$localeAwareCompare$$$localeAwareCompareconstQString&constQStringRef& -->
<h3 class="fn" id="localeAwareCompare-3"><a name="localeAwareCompare-3"></a><code>[静态函数] </code><span class="type">int</span> QString::<span class="name">localeAwareCompare</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>s2</i>)</h3>
<p>此函数重载了 <a href="qstring.html#localeAwareCompare">localeAwareCompare</a>().</p>
<p>Compares <i>s1</i> with <i>s2</i> and returns an integer less than, equal to, or greater than zero if <i>s1</i> is less than, equal to, or greater than <i>s2</i>.</p>
<p>The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.</p>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@localeAwareCompare -->
<!-- $$$mid[overload1]$$$midintint -->
<h3 class="fn" id="mid"><a name="mid"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">mid</span>(<span class="type">int</span> <i>position</i>, <span class="type">int</span> <i>n</i> = -1) const</h3>
<p>Returns a string that contains <i>n</i> characters of this string, starting at the specified <i>position</i> index.</p>
<p>Returns a null string if the <i>position</i> index exceeds the length of the string. If there are less than <i>n</i> characters available in the string starting at the given <i>position</i>, or if <i>n</i> is -1 (default), the function returns all characters that are available from the specified <i>position</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Nine pineapples&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> x<span class="operator">.</span>mid(<span class="number">5</span><span class="operator">,</span> <span class="number">4</span>);            <span class="comment">// y == &quot;pine&quot;</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span> z <span class="operator">=</span> x<span class="operator">.</span>mid(<span class="number">5</span>);               <span class="comment">// z == &quot;pineapples&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#left">left</a>(), <a href="qstring.html#right">right</a>(), <a href="qstring.html#chopped">chopped</a>(), <a href="qstring.html#chop">chop</a>(), 和 <a href="qstring.html#truncate">truncate</a>().</p>
<!-- @@@mid -->
<!-- $$$midRef[overload1]$$$midRefintint -->
<h3 class="fn" id="midRef"><a name="midRef"></a><span class="type"><a href="qstringref.html">QStringRef</a></span> QString::<span class="name">midRef</span>(<span class="type">int</span> <i>position</i>, <span class="type">int</span> <i>n</i> = -1) const</h3>
<p>Returns a substring reference to <i>n</i> characters of this string, starting at the specified <i>position</i>.</p>
<p>If the <i>position</i> exceeds the length of the string, a null reference is returned.</p>
<p>If there are less than <i>n</i> characters available in the string, starting at the given <i>position</i>, or if <i>n</i> is -1 (default), the function returns all characters from the specified <i>position</i> onwards.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Nine pineapples&quot;</span>;
  <span class="type"><a href="qstringref.html">QStringRef</a></span> y <span class="operator">=</span> x<span class="operator">.</span>midRef(<span class="number">5</span><span class="operator">,</span> <span class="number">4</span>);      <span class="comment">// y == &quot;pine&quot;</span>
  <span class="type"><a href="qstringref.html">QStringRef</a></span> z <span class="operator">=</span> x<span class="operator">.</span>midRef(<span class="number">5</span>);         <span class="comment">// z == &quot;pineapples&quot;</span>

</pre>
<p>这个函数是在Qt 4.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#mid">mid</a>(), <a href="qstring.html#leftRef">leftRef</a>(), 和 <a href="qstring.html#rightRef">rightRef</a>().</p>
<!-- @@@midRef -->
<!-- $$$normalized[overload1]$$$normalizedQString::NormalizationFormQChar::UnicodeVersion -->
<h3 class="fn" id="normalized"><a name="normalized"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">normalized</span>(<span class="type"><a href="qstring.html#NormalizationForm-enum">QString::NormalizationForm</a></span> <i>mode</i>, <span class="type"><a href="qchar.html#UnicodeVersion-enum">QChar::UnicodeVersion</a></span> <i>version</i> = QChar::Unicode_Unassigned) const</h3>
<p>Returns the string in the given Unicode normalization <i>mode</i>, according to the given <i>version</i> of the Unicode standard.</p>
<!-- @@@normalized -->
<!-- $$$number[overload1]$$$numberlongint -->
<h3 class="fn" id="number"><a name="number"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">number</span>(<span class="type">long</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>Returns a string equivalent of the number <i>n</i> according to the specified <i>base</i>.</p>
<p>The base is 10 by default and must be between 2 and 36. For bases other than 10, <i>n</i> is treated as an unsigned integer.</p>
<p>The formatting always uses <a href="qlocale.html#Language-enum">QLocale::C</a>, i.e&#x2e;, English/UnitedStates. To get a localized string representation of a number, use <a href="qlocale.html#toString">QLocale::toString</a>() with the appropriate locale.</p>
<pre class="cpp">

  <span class="type">long</span> a <span class="operator">=</span> <span class="number">63</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> s <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>number(a<span class="operator">,</span> <span class="number">16</span>);             <span class="comment">// s == &quot;3f&quot;</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span> t <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>number(a<span class="operator">,</span> <span class="number">16</span>)<span class="operator">.</span>toUpper();     <span class="comment">// t == &quot;3F&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#setNum">setNum</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberuintint -->
<h3 class="fn" id="number-1"><a name="number-1"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@number -->
<!-- $$$number$$$numberintint -->
<h3 class="fn" id="number-2"><a name="number-2"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">number</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@number -->
<!-- $$$number$$$numberulongint -->
<h3 class="fn" id="number-3"><a name="number-3"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@number -->
<!-- $$$number$$$numberqlonglongint -->
<h3 class="fn" id="number-4"><a name="number-4"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@number -->
<!-- $$$number$$$numberqulonglongint -->
<h3 class="fn" id="number-5"><a name="number-5"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@number -->
<!-- $$$number$$$numberdoublecharint -->
<h3 class="fn" id="number-6"><a name="number-6"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">number</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = 6)</h3>
<p>Returns a string equivalent of the number <i>n</i>, formatted according to the specified <i>format</i> and <i>precision</i>. See <a href="qstring.html#argument-formats">参数格式化</a> for details.</p>
<p>Unlike <a href="qlocale.html#toString">QLocale::toString</a>(), this function does not honor the user's locale settings.</p>
<p><b> 参见 </b><a href="qstring.html#setNum">setNum</a>() 和 <a href="qlocale.html#toString">QLocale::toString</a>().</p>
<!-- @@@number -->
<!-- $$$prepend[overload1]$$$prependconstQString& -->
<h3 class="fn" id="prepend"><a name="prepend"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">prepend</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>str</i>)</h3>
<p>Prepends the string <i>str</i> to the beginning of this string and returns a reference to this string.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;ship&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;air&quot;</span>;
  x<span class="operator">.</span>prepend(y);
  <span class="comment">// x == &quot;airship&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#append">append</a>() 和 <a href="qstring.html#insert">insert</a>().</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstQChar*int -->
<h3 class="fn" id="prepend-1"><a name="prepend-1"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">prepend</span>(const <span class="type"><a href="qchar.html">QChar</a></span> *<i>str</i>, <span class="type">int</span> <i>len</i>)</h3>
<p>此函数重载了 <a href="qstring.html#prepend">prepend</a>().</p>
<p>Prepends <i>len</i> characters from the <a href="qchar.html">QChar</a> array <i>str</i> to this string and returns a reference to this string.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependQChar -->
<h3 class="fn" id="prepend-2"><a name="prepend-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">prepend</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>)</h3>
<p>此函数重载了 <a href="qstring.html#prepend">prepend</a>().</p>
<p>添加字符 <i>ch</i> 到当前字符串的前面。</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstQStringRef& -->
<h3 class="fn" id="prepend-3"><a name="prepend-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">prepend</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#prepend">prepend</a>().</p>
<p>添加字符串 <i>str</i> 到当前字符串的前面，并返回当前字符串。</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependQLatin1String -->
<h3 class="fn" id="prepend-4"><a name="prepend-4"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">prepend</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#prepend">prepend</a>().</p>
<p>添加Latin-1字符串 <i>str</i> 到当前字符串的前面。</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstchar* -->
<h3 class="fn" id="prepend-5"><a name="prepend-5"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">prepend</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#prepend">prepend</a>().</p>
<p>Prepends the string <i>str</i> to this string. The const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstQByteArray& -->
<h3 class="fn" id="prepend-6"><a name="prepend-6"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">prepend</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>此函数重载了 <a href="qstring.html#prepend">prepend</a>().</p>
<p>添加字节数组 <i>ba</i> 到当前字符串的前面。 The byte array is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@prepend -->
<!-- $$$push_back[overload1]$$$push_backconstQString& -->
<h3 class="fn" id="push_back"><a name="push_back"></a><span class="type">void</span> QString::<span class="name">push_back</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>other</i>)</h3>
<p>This function is provided for STL compatibility，追加字符串 <i>other</i> 到当前字符串的末尾。 It 等同于 <code>append(other)</code>.</p>
<p><b> 参见 </b><a href="qstring.html#append">append</a>().</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backQChar -->
<h3 class="fn" id="push_back-1"><a name="push_back-1"></a><span class="type">void</span> QString::<span class="name">push_back</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>)</h3>
<p>这是一个重载函数。</p>
<p>追加字符 <i>ch</i> 到当前字符串的末尾。</p>
<!-- @@@push_back -->
<!-- $$$push_front[overload1]$$$push_frontconstQString& -->
<h3 class="fn" id="push_front"><a name="push_front"></a><span class="type">void</span> QString::<span class="name">push_front</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>other</i>)</h3>
<p>This function is provided for STL compatibility, prepending the given <i>other</i> string to the beginning of this string. It 等同于 <code>prepend(other)</code>.</p>
<p><b> 参见 </b><a href="qstring.html#prepend">prepend</a>().</p>
<!-- @@@push_front -->
<!-- $$$push_front$$$push_frontQChar -->
<h3 class="fn" id="push_front-1"><a name="push_front-1"></a><span class="type">void</span> QString::<span class="name">push_front</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>)</h3>
<p>这是一个重载函数。</p>
<p>添加字符 <i>ch</i> 到当前字符串的前面。</p>
<!-- @@@push_front -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" id="rbegin"><a name="rbegin"></a><span class="type"><a href="qstring.html#reverse_iterator-typedef">QString::reverse_iterator</a></span> QString::<span class="name">rbegin</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first character in the string, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#begin">begin</a>(), <a href="qstring.html#crbegin">crbegin</a>(), 和 <a href="qstring.html#rend">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" id="rbegin-1"><a name="rbegin-1"></a><span class="type"><a href="qstring.html#const_reverse_iterator-typedef">QString::const_reverse_iterator</a></span> QString::<span class="name">rbegin</span>() const</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@rbegin -->
<!-- $$$remove[overload1]$$$removeintint -->
<h3 class="fn" id="remove"><a name="remove"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">remove</span>(<span class="type">int</span> <i>position</i>, <span class="type">int</span> <i>n</i>)</h3>
<p>Removes <i>n</i> characters from the string, starting at the given <i>position</i> index, and returns a reference to the string.</p>
<p>If the specified <i>position</i> index is within the string, but <i>position</i> + <i>n</i> is beyond the end of the string, the string is truncated at the specified <i>position</i>.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;Montreal&quot;</span>;
  s<span class="operator">.</span>remove(<span class="number">1</span><span class="operator">,</span> <span class="number">4</span>);
  <span class="comment">// s == &quot;Meal&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#insert">insert</a>() 和 <a href="qstring.html#replace">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeQCharQt::CaseSensitivity -->
<h3 class="fn" id="remove-1"><a name="remove-1"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">remove</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>Removes every occurrence of the character <i>ch</i> in this string, and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> t <span class="operator">=</span> <span class="string">&quot;Ali Baba&quot;</span>;
  t<span class="operator">.</span>remove(<span class="type"><a href="qchar.html">QChar</a></span>(<span class="char">'a'</span>)<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>CaseInsensitive);
  <span class="comment">// t == &quot;li Bb&quot;</span>

</pre>
<p>此函数等同于 <code>replace(ch, &quot;&quot;, cs)</code>.</p>
<p><b> 参见 </b><a href="qstring.html#replace">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeQLatin1StringQt::CaseSensitivity -->
<h3 class="fn" id="remove-2"><a name="remove-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">remove</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>这是一个重载函数。</p>
<p>Removes every occurrence of the given <i>str</i> string in this string, and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>此函数等同于 <code>replace(str, &quot;&quot;, cs)</code>.</p>
<p>这个函数是在Qt 5.11版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#replace">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstQString&Qt::CaseSensitivity -->
<h3 class="fn" id="remove-3"><a name="remove-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">remove</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>str</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>Removes every occurrence of the given <i>str</i> string in this string, and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>此函数等同于 <code>replace(str, &quot;&quot;, cs)</code>.</p>
<p><b> 参见 </b><a href="qstring.html#replace">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstQRegExp& -->
<h3 class="fn" id="remove-4"><a name="remove-4"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">remove</span>(const <span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>)</h3>
<p>Removes every occurrence of the regular expression <i>rx</i> in the string, and returns a reference to the string. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> r <span class="operator">=</span> <span class="string">&quot;Telephone&quot;</span>;
  r<span class="operator">.</span>remove(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;[aeiou].&quot;</span>));
  <span class="comment">// r == &quot;The&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#lastIndexOf">lastIndexOf</a>(), 和 <a href="qstring.html#replace">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstQRegularExpression& -->
<h3 class="fn" id="remove-5"><a name="remove-5"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">remove</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>)</h3>
<p>Removes every occurrence of the regular expression <i>re</i> in the string, and returns a reference to the string. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> r <span class="operator">=</span> <span class="string">&quot;Telephone&quot;</span>;
  r<span class="operator">.</span>remove(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;[aeiou].&quot;</span>));
  <span class="comment">// r == &quot;The&quot;</span>

</pre>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#lastIndexOf">lastIndexOf</a>(), 和 <a href="qstring.html#replace">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" id="rend"><a name="rend"></a><span class="type"><a href="qstring.html#reverse_iterator-typedef">QString::reverse_iterator</a></span> QString::<span class="name">rend</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to one past the last character in the string, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#end">end</a>(), <a href="qstring.html#crend">crend</a>(), 和 <a href="qstring.html#rbegin">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" id="rend-1"><a name="rend-1"></a><span class="type"><a href="qstring.html#const_reverse_iterator-typedef">QString::const_reverse_iterator</a></span> QString::<span class="name">rend</span>() const</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@rend -->
<!-- $$$repeated[overload1]$$$repeatedint -->
<h3 class="fn" id="repeated"><a name="repeated"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">repeated</span>(<span class="type">int</span> <i>times</i>) const</h3>
<p>Returns a copy of this string repeated the specified number of <i>times</i>.</p>
<p>If <i>times</i> is less than 1, an empty string is returned.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str(<span class="string">&quot;ab&quot;</span>);
  str<span class="operator">.</span>repeated(<span class="number">4</span>);            <span class="comment">// returns &quot;abababab&quot;</span>

</pre>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@repeated -->
<!-- $$$replace[overload1]$$$replaceintintconstQString& -->
<h3 class="fn" id="replace"><a name="replace"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type">int</span> <i>position</i>, <span class="type">int</span> <i>n</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>after</i>)</h3>
<p>Replaces <i>n</i> characters beginning at index <i>position</i> with the string <i>after</i> and returns a reference to this string.</p>
<p><b>注意： </b>If the specified <i>position</i> index is within the string, but <i>position</i> + <i>n</i> goes outside the strings range, then <i>n</i> will be adjusted to stop at the end of the string.</p><p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Say yes!&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;no&quot;</span>;
  x<span class="operator">.</span>replace(<span class="number">4</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> y);
  <span class="comment">// x == &quot;Say no!&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#insert">insert</a>() 和 <a href="qstring.html#remove">remove</a>().</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceintintconstQChar*int -->
<h3 class="fn" id="replace-1"><a name="replace-1"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type">int</span> <i>position</i>, <span class="type">int</span> <i>n</i>, const <span class="type"><a href="qchar.html">QChar</a></span> *<i>unicode</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces <i>n</i> characters beginning at index <i>position</i> with the first <i>size</i> characters of the <a href="qchar.html">QChar</a> array <i>unicode</i> and returns a reference to this string.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceintintQChar -->
<h3 class="fn" id="replace-2"><a name="replace-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type">int</span> <i>position</i>, <span class="type">int</span> <i>n</i>, <span class="type"><a href="qchar.html">QChar</a></span> <i>after</i>)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces <i>n</i> characters beginning at index <i>position</i> with the character <i>after</i> and returns a reference to this string.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQCharQCharQt::CaseSensitivity -->
<h3 class="fn" id="replace-3"><a name="replace-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>before</i>, <span class="type"><a href="qchar.html">QChar</a></span> <i>after</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the character <i>before</i> with the character <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQChar*intconstQChar*intQt::CaseSensitivity -->
<h3 class="fn" id="replace-4"><a name="replace-4"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(const <span class="type"><a href="qchar.html">QChar</a></span> *<i>before</i>, <span class="type">int</span> <i>blen</i>, const <span class="type"><a href="qchar.html">QChar</a></span> *<i>after</i>, <span class="type">int</span> <i>alen</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces each occurrence in this string of the first <i>blen</i> characters of <i>before</i> with the first <i>alen</i> characters of <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQLatin1StringQLatin1StringQt::CaseSensitivity -->
<h3 class="fn" id="replace-5"><a name="replace-5"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>before</i>, <span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>after</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b>注意： </b>The text is not rescanned after a replacement.</p><p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQLatin1StringconstQString&Qt::CaseSensitivity -->
<h3 class="fn" id="replace-6"><a name="replace-6"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>before</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>after</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b>注意： </b>The text is not rescanned after a replacement.</p><p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQString&QLatin1StringQt::CaseSensitivity -->
<h3 class="fn" id="replace-7"><a name="replace-7"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>before</i>, <span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>after</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b>注意： </b>The text is not rescanned after a replacement.</p><p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQString&constQString&Qt::CaseSensitivity -->
<h3 class="fn" id="replace-8"><a name="replace-8"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>before</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>after</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;colour behaviour flavour neighbour&quot;</span>;
  str<span class="operator">.</span>replace(<span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;ou&quot;</span>)<span class="operator">,</span> <span class="type"><a href="qstring.html#QString">QString</a></span>(<span class="string">&quot;o&quot;</span>));
  <span class="comment">// str == &quot;color behavior flavor neighbor&quot;</span>

</pre>
<p><b>注意： </b>The replacement text is not rescanned after it is inserted.</p><p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> equis <span class="operator">=</span> <span class="string">&quot;xxxxxx&quot;</span>;
  equis<span class="operator">.</span>replace(<span class="string">&quot;xx&quot;</span><span class="operator">,</span> <span class="string">&quot;x&quot;</span>);
  <span class="comment">// equis == &quot;xxx&quot;</span>

</pre>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQCharconstQString&Qt::CaseSensitivity -->
<h3 class="fn" id="replace-9"><a name="replace-9"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>after</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the character <i>ch</i> in the string with <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQCharQLatin1StringQt::CaseSensitivity -->
<h3 class="fn" id="replace-10"><a name="replace-10"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>c</i>, <span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>after</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the character <i>c</i> with the string <i>after</i> and returns a reference to this string.</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p><b>注意： </b>The text is not rescanned after a replacement.</p><p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQRegExp&constQString& -->
<h3 class="fn" id="replace-11"><a name="replace-11"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(const <span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>after</i>)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the regular expression <i>rx</i> in the string with <i>after</i>. Returns a reference to the string. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;Banana&quot;</span>;
  s<span class="operator">.</span>replace(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;a[mn]&quot;</span>)<span class="operator">,</span> <span class="string">&quot;ox&quot;</span>);
  <span class="comment">// s == &quot;Boxoxa&quot;</span>

</pre>
<p>For regular expressions containing <a href="qregexp.html#capturing-parentheses">capturing parentheses</a>, occurrences of <b>\1</b>, <b>\2</b>, ..&#x2e;, in <i>after</i> are replaced with <i>rx</i>.cap(1), cap(2), ..&#x2e;</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> t <span class="operator">=</span> <span class="string">&quot;A &lt;i&gt;bon mot&lt;/i&gt;.&quot;</span>;
  t<span class="operator">.</span>replace(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;&lt;i&gt;([^&lt;]*)&lt;/i&gt;&quot;</span>)<span class="operator">,</span> <span class="string">&quot;\\emph{\\1}&quot;</span>);
  <span class="comment">// t == &quot;A \\emph{bon mot}.&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#lastIndexOf">lastIndexOf</a>(), <a href="qstring.html#remove">remove</a>(), 和 <a href="qregexp.html#cap">QRegExp::cap</a>().</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQRegularExpression&constQString& -->
<h3 class="fn" id="replace-12"><a name="replace-12"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">replace</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>after</i>)</h3>
<p>此函数重载了 <a href="qstring.html#replace">replace</a>().</p>
<p>Replaces every occurrence of the regular expression <i>re</i> in the string with <i>after</i>. Returns a reference to the string. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;Banana&quot;</span>;
  s<span class="operator">.</span>replace(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;a[mn]&quot;</span>)<span class="operator">,</span> <span class="string">&quot;ox&quot;</span>);
  <span class="comment">// s == &quot;Boxoxa&quot;</span>

</pre>
<p>For regular expressions containing capturing groups, occurrences of <b>\1</b>, <b>\2</b>, ..&#x2e;, in <i>after</i> are replaced with the string captured by the corresponding capturing group.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> t <span class="operator">=</span> <span class="string">&quot;A &lt;i&gt;bon mot&lt;/i&gt;.&quot;</span>;
  t<span class="operator">.</span>replace(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;&lt;i&gt;([^&lt;]*)&lt;/i&gt;&quot;</span>)<span class="operator">,</span> <span class="string">&quot;\\emph{\\1}&quot;</span>);
  <span class="comment">// t == &quot;A \\emph{bon mot}.&quot;</span>

</pre>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#indexOf">indexOf</a>(), <a href="qstring.html#lastIndexOf">lastIndexOf</a>(), <a href="qstring.html#remove">remove</a>(), <a href="qregularexpression.html">QRegularExpression</a>, 和 <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a>.</p>
<!-- @@@replace -->
<!-- $$$reserve[overload1]$$$reserveint -->
<h3 class="fn" id="reserve"><a name="reserve"></a><span class="type">void</span> QString::<span class="name">reserve</span>(<span class="type">int</span> <i>size</i>)</h3>
<p>Attempts to allocate memory for at least <i>size</i> characters. If you know in advance how large the string will be, you can call this function, and if you resize the string often you are likely to get better performance. If <i>size</i> is an underestimate, the worst that will happen is that the <a href="qstring.html">QString</a> will be a bit slower.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qstring.html">QString</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the string, call <a href="qstring.html#resize">resize</a>().</p>
<p>This function is useful for code that needs to build up a long string and wants to avoid repeated reallocation. In this example, we want to add to the string until some condition is <code>true</code>, and we're fairly sure that size is large enough to make a call to reserve() worthwhile:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> result;
  <span class="type">int</span> maxSize;
  bool condition;
  <span class="type"><a href="qchar.html">QChar</a></span> nextChar;

  result<span class="operator">.</span>reserve(maxSize);

  <span class="keyword">while</span> (condition)
      result<span class="operator">.</span>append(nextChar);

  result<span class="operator">.</span>squeeze();

</pre>
<p><b> 参见 </b><a href="qstring.html#squeeze">squeeze</a>() 和 <a href="qstring.html#capacity">capacity</a>().</p>
<!-- @@@reserve -->
<!-- $$$resize[overload1]$$$resizeint -->
<h3 class="fn" id="resize"><a name="resize"></a><span class="type">void</span> QString::<span class="name">resize</span>(<span class="type">int</span> <i>size</i>)</h3>
<p>Sets the size of the string to <i>size</i> characters.</p>
<p>If <i>size</i> is greater than the current size, the string is extended to make it <i>size</i> characters long with the extra characters added to the end. The new characters are uninitialized.</p>
<p>If <i>size</i> is less than the current size, characters are removed from the end.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;
  s<span class="operator">.</span>resize(<span class="number">5</span>);
  <span class="comment">// s == &quot;Hello&quot;</span>

  s<span class="operator">.</span>resize(<span class="number">8</span>);
  <span class="comment">// s == &quot;Hello???&quot; (where ? stands for any character)</span>

</pre>
<p>If you want to append a certain number of identical characters to the string, use the <a href="qstring.html#resize-1">resize</a>(int, <a href="qchar.html">QChar</a>) overload.</p>
<p>If you want to expand the string so that it reaches a certain width and fill the new positions with a particular character, use the <a href="qstring.html#leftJustified">leftJustified</a>() function:</p>
<p>If <i>size</i> is negative, it is equivalent to passing zero.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> r <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;
  r <span class="operator">=</span> r<span class="operator">.</span>leftJustified(<span class="number">10</span><span class="operator">,</span> <span class="char">' '</span>);
  <span class="comment">// r == &quot;Hello     &quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#truncate">truncate</a>() 和 <a href="qstring.html#reserve">reserve</a>().</p>
<!-- @@@resize -->
<!-- $$$resize$$$resizeintQChar -->
<h3 class="fn" id="resize-1"><a name="resize-1"></a><span class="type">void</span> QString::<span class="name">resize</span>(<span class="type">int</span> <i>size</i>, <span class="type"><a href="qchar.html">QChar</a></span> <i>fillChar</i>)</h3>
<p>这是一个重载函数。</p>
<p>Unlike <a href="qstring.html#resize">resize</a>(int), this overload initializes the new characters to <i>fillChar</i>:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> t <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;
  r<span class="operator">.</span>resize(t<span class="operator">.</span>size() <span class="operator">+</span> <span class="number">10</span><span class="operator">,</span> <span class="char">'X'</span>);
  <span class="comment">// t == &quot;HelloXXXXXXXXXX&quot;</span>

</pre>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<!-- @@@resize -->
<!-- $$$right[overload1]$$$rightint -->
<h3 class="fn" id="right"><a name="right"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">right</span>(<span class="type">int</span> <i>n</i>) const</h3>
<p>Returns a substring that contains the <i>n</i> rightmost characters of the string.</p>
<p>The entire string is returned if <i>n</i> is greater than or equal to <a href="qstring.html#size">size</a>(), or less than zero.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> x<span class="operator">.</span>right(<span class="number">5</span>);      <span class="comment">// y == &quot;apple&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#left">left</a>(), <a href="qstring.html#mid">mid</a>(), <a href="qstring.html#endsWith">endsWith</a>(), <a href="qstring.html#chopped">chopped</a>(), <a href="qstring.html#chop">chop</a>(), 和 <a href="qstring.html#truncate">truncate</a>().</p>
<!-- @@@right -->
<!-- $$$rightJustified[overload1]$$$rightJustifiedintQCharbool -->
<h3 class="fn" id="rightJustified"><a name="rightJustified"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">rightJustified</span>(<span class="type">int</span> <i>width</i>, <span class="type"><a href="qchar.html">QChar</a></span> <i>fill</i> = QLatin1Char(' '), <span class="type">bool</span> <i>truncate</i> = false) const</h3>
<p>Returns a string of <a href="qstring.html#size">size</a>() <i>width</i> that contains the <i>fill</i> character followed by the string. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> s <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> t <span class="operator">=</span> s<span class="operator">.</span>rightJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);    <span class="comment">// t == &quot;...apple&quot;</span>

</pre>
<p>If <i>truncate</i> is <code>false</code> and the <a href="qstring.html#size">size</a>() of the string is more than <i>width</i>, then the returned string is a copy of the string.</p>
<p>If <i>truncate</i> is true and the <a href="qstring.html#size">size</a>() of the string is more than <i>width</i>, then the resulting string is truncated at position <i>width</i>.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
  str <span class="operator">=</span> str<span class="operator">.</span>rightJustified(<span class="number">5</span><span class="operator">,</span> <span class="char">'.'</span><span class="operator">,</span> <span class="keyword">true</span>);    <span class="comment">// str == &quot;Pinea&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#leftJustified">leftJustified</a>().</p>
<!-- @@@rightJustified -->
<!-- $$$rightRef[overload1]$$$rightRefint -->
<h3 class="fn" id="rightRef"><a name="rightRef"></a><span class="type"><a href="qstringref.html">QStringRef</a></span> QString::<span class="name">rightRef</span>(<span class="type">int</span> <i>n</i>) const</h3>
<p>Returns a substring reference to the <i>n</i> rightmost characters of the string.</p>
<p>If <i>n</i> is greater than or equal to <a href="qstring.html#size">size</a>(), or less than zero, a reference to the entire string is returned.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;Pineapple&quot;</span>;
  <span class="type"><a href="qstringref.html">QStringRef</a></span> y <span class="operator">=</span> x<span class="operator">.</span>rightRef(<span class="number">5</span>);       <span class="comment">// y == &quot;apple&quot;</span>

</pre>
<p>这个函数是在Qt 4.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#right">right</a>(), <a href="qstring.html#leftRef">leftRef</a>(), <a href="qstring.html#midRef">midRef</a>(), 和 <a href="qstring.html#endsWith">endsWith</a>().</p>
<!-- @@@rightRef -->
<!-- $$$section[overload1]$$$sectionQCharintintQString::SectionFlags -->
<h3 class="fn" id="section"><a name="section"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">section</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>sep</i>, <span class="type">int</span> <i>start</i>, <span class="type">int</span> <i>end</i> = ..., <span class="type"><a href="qstring.html#SectionFlag-enum">QString::SectionFlags</a></span> <i>flags</i> = SectionDefault) const</h3>
<p>This function returns a section of the string.</p>
<p>This string is treated as a sequence of fields separated by the character, <i>sep</i>. The returned string consists of the fields from position <i>start</i> to position <i>end</i> inclusive. If <i>end</i> is not specified, all fields from position <i>start</i> to the end of the string are included. Fields are numbered 0, 1, 2, etc., counting from the left, and -1, -2, etc., counting from right to left.</p>
<p>The <i>flags</i> argument can be used to affect some aspects of the function's behavior, e.g&#x2e; whether to be case sensitive, whether to skip empty fields and how to deal with leading and trailing separators; see <a href="qstring.html#SectionFlag-enum">SectionFlags</a>.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  <span class="type"><a href="qstring.html#QString">QString</a></span> csv <span class="operator">=</span> <span class="string">&quot;forename,middlename,surname,phone&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> path <span class="operator">=</span> <span class="string">&quot;/usr/local/bin/myapp&quot;</span>; <span class="comment">// First field is empty</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>SectionFlag flag <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>SectionSkipEmpty;

  str <span class="operator">=</span> csv<span class="operator">.</span>section(<span class="char">','</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span>);   <span class="comment">// str == &quot;surname&quot;</span>
  str <span class="operator">=</span> path<span class="operator">.</span>section(<span class="char">'/'</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">4</span>);  <span class="comment">// str == &quot;bin/myapp&quot;</span>
  str <span class="operator">=</span> path<span class="operator">.</span>section(<span class="char">'/'</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> flag); <span class="comment">// str == &quot;myapp&quot;</span>

</pre>
<p>If <i>start</i> or <i>end</i> is negative, we count fields from the right of the string, the right-most field being -1, the one from right-most field being -2, and so on.</p>
<pre class="cpp">

  str <span class="operator">=</span> csv<span class="operator">.</span>section(<span class="char">','</span><span class="operator">,</span> <span class="operator">-</span><span class="number">3</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span>);  <span class="comment">// str == &quot;middlename,surname&quot;</span>
  str <span class="operator">=</span> path<span class="operator">.</span>section(<span class="char">'/'</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span>); <span class="comment">// str == &quot;myapp&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#split">split</a>().</p>
<!-- @@@section -->
<!-- $$$section$$$sectionconstQString&intintQString::SectionFlags -->
<h3 class="fn" id="section-1"><a name="section-1"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">section</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>sep</i>, <span class="type">int</span> <i>start</i>, <span class="type">int</span> <i>end</i> = -1, <span class="type"><a href="qstring.html#SectionFlag-enum">QString::SectionFlags</a></span> <i>flags</i> = SectionDefault) const</h3>
<p>此函数重载了 <a href="qstring.html#section">section</a>().</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  <span class="type"><a href="qstring.html#QString">QString</a></span> data <span class="operator">=</span> <span class="string">&quot;forename**middlename**surname**phone&quot;</span>;

  str <span class="operator">=</span> data<span class="operator">.</span>section(<span class="string">&quot;**&quot;</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span>); <span class="comment">// str == &quot;surname&quot;</span>
  str <span class="operator">=</span> data<span class="operator">.</span>section(<span class="string">&quot;**&quot;</span><span class="operator">,</span> <span class="operator">-</span><span class="number">3</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span>); <span class="comment">// str == &quot;middlename**surname&quot;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#split">split</a>().</p>
<!-- @@@section -->
<!-- $$$section$$$sectionconstQRegExp&intintQString::SectionFlags -->
<h3 class="fn" id="section-2"><a name="section-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">section</span>(const <span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>reg</i>, <span class="type">int</span> <i>start</i>, <span class="type">int</span> <i>end</i> = -1, <span class="type"><a href="qstring.html#SectionFlag-enum">QString::SectionFlags</a></span> <i>flags</i> = SectionDefault) const</h3>
<p>此函数重载了 <a href="qstring.html#section">section</a>().</p>
<p>This string is treated as a sequence of fields separated by the regular expression, <i>reg</i>.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> line <span class="operator">=</span> <span class="string">&quot;forename\tmiddlename  surname \t \t phone&quot;</span>;
  <span class="type"><a href="qregexp.html">QRegExp</a></span> sep(<span class="string">&quot;\\s+&quot;</span>);
  str <span class="operator">=</span> line<span class="operator">.</span>section(sep<span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span>); <span class="comment">// str == &quot;surname&quot;</span>
  str <span class="operator">=</span> line<span class="operator">.</span>section(sep<span class="operator">,</span> <span class="operator">-</span><span class="number">3</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span>); <span class="comment">// str == &quot;middlename  surname&quot;</span>

</pre>
<p><b>警告：</b> Using this <a href="qregexp.html">QRegExp</a> version is much more expensive than the overloaded string and character versions.</p>
<p><b> 参见 </b><a href="qstring.html#split">split</a>() 和 <a href="qstring.html#simplified">simplified</a>().</p>
<!-- @@@section -->
<!-- $$$section$$$sectionconstQRegularExpression&intintQString::SectionFlags -->
<h3 class="fn" id="section-3"><a name="section-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">section</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type">int</span> <i>start</i>, <span class="type">int</span> <i>end</i> = -1, <span class="type"><a href="qstring.html#SectionFlag-enum">QString::SectionFlags</a></span> <i>flags</i> = SectionDefault) const</h3>
<p>此函数重载了 <a href="qstring.html#section">section</a>().</p>
<p>This string is treated as a sequence of fields separated by the regular expression, <i>re</i>.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> line <span class="operator">=</span> <span class="string">&quot;forename\tmiddlename  surname \t \t phone&quot;</span>;
  <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> sep(<span class="string">&quot;\\s+&quot;</span>);
  str <span class="operator">=</span> line<span class="operator">.</span>section(sep<span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span>); <span class="comment">// str == &quot;surname&quot;</span>
  str <span class="operator">=</span> line<span class="operator">.</span>section(sep<span class="operator">,</span> <span class="operator">-</span><span class="number">3</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span>); <span class="comment">// str == &quot;middlename  surname&quot;</span>

</pre>
<p><b>警告：</b> Using this <a href="qregularexpression.html">QRegularExpression</a> version is much more expensive than the overloaded string and character versions.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#split">split</a>() 和 <a href="qstring.html#simplified">simplified</a>().</p>
<!-- @@@section -->
<!-- $$$setNum[overload1]$$$setNumintint -->
<h3 class="fn" id="setNum"><a name="setNum"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>Sets the string to the printed value of <i>n</i> in the specified <i>base</i>, and returns a reference to the string.</p>
<p>The base is 10 by default and must be between 2 and 36. For bases other than 10, <i>n</i> is treated as an unsigned integer.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  str<span class="operator">.</span>setNum(<span class="number">1234</span>);       <span class="comment">// str == &quot;1234&quot;</span>

</pre>
<p>The formatting always uses <a href="qlocale.html#Language-enum">QLocale::C</a>, i.e&#x2e;, English/UnitedStates. To get a localized string representation of a number, use <a href="qlocale.html#toString">QLocale::toString</a>() with the appropriate locale.</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumushortint -->
<h3 class="fn" id="setNum-1"><a name="setNum-1"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumshortint -->
<h3 class="fn" id="setNum-2"><a name="setNum-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">short</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumuintint -->
<h3 class="fn" id="setNum-3"><a name="setNum-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumlongint -->
<h3 class="fn" id="setNum-4"><a name="setNum-4"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">long</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumulongint -->
<h3 class="fn" id="setNum-5"><a name="setNum-5"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqlonglongint -->
<h3 class="fn" id="setNum-6"><a name="setNum-6"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqulonglongint -->
<h3 class="fn" id="setNum-7"><a name="setNum-7"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>这是一个重载函数。</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumfloatcharint -->
<h3 class="fn" id="setNum-8"><a name="setNum-8"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">float</span> <i>n</i>, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = 6)</h3>
<p>这是一个重载函数。</p>
<p>Sets the string to the printed value of <i>n</i>, formatted according to the given <i>format</i> and <i>precision</i>, and returns a reference to the string.</p>
<p>The formatting always uses <a href="qlocale.html#Language-enum">QLocale::C</a>, i.e&#x2e;, English/UnitedStates. To get a localized string representation of a number, use <a href="qlocale.html#toString">QLocale::toString</a>() with the appropriate locale.</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumdoublecharint -->
<h3 class="fn" id="setNum-9"><a name="setNum-9"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setNum</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = 6)</h3>
<p>这是一个重载函数。</p>
<p>Sets the string to the printed value of <i>n</i>, formatted according to the given <i>format</i> and <i>precision</i>, and returns a reference to the string.</p>
<p>The <i>format</i> can be 'e', 'E', 'f', 'g' or 'G' (see <a href="qstring.html#argument-formats">参数格式化</a> for an explanation of the formats).</p>
<p>The formatting always uses <a href="qlocale.html#Language-enum">QLocale::C</a>, i.e&#x2e;, English/UnitedStates. To get a localized string representation of a number, use <a href="qlocale.html#toString">QLocale::toString</a>() with the appropriate locale.</p>
<!-- @@@setNum -->
<!-- $$$setRawData[overload1]$$$setRawDataconstQChar*int -->
<h3 class="fn" id="setRawData"><a name="setRawData"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setRawData</span>(const <span class="type"><a href="qchar.html">QChar</a></span> *<i>unicode</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>Resets the <a href="qstring.html">QString</a> to use the first <i>size</i> Unicode characters in the array <i>unicode</i>. The data in <i>unicode</i> is <i>not</i> copied. The caller must be able to guarantee that <i>unicode</i> will not be deleted or modified as long as the <a href="qstring.html">QString</a> (or an unmodified copy of it) exists.</p>
<p>This function can be used instead of <a href="qstring.html#fromRawData">fromRawData</a>() to re-use existings <a href="qstring.html">QString</a> objects to save memory re-allocations.</p>
<p>这个函数是在Qt 4.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#fromRawData">fromRawData</a>().</p>
<!-- @@@setRawData -->
<!-- $$$setUnicode[overload1]$$$setUnicodeconstQChar*int -->
<h3 class="fn" id="setUnicode"><a name="setUnicode"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setUnicode</span>(const <span class="type"><a href="qchar.html">QChar</a></span> *<i>unicode</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>Resizes the string to <i>size</i> characters and copies <i>unicode</i> into the string.</p>
<p>If <i>unicode</i> is 0, nothing is copied, but the string is still resized to <i>size</i>.</p>
<p><b> 参见 </b><a href="qstring.html#unicode">unicode</a>() 和 <a href="qstring.html#setUtf16">setUtf16</a>().</p>
<!-- @@@setUnicode -->
<!-- $$$setUtf16[overload1]$$$setUtf16constushort*int -->
<h3 class="fn" id="setUtf16"><a name="setUtf16"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">setUtf16</span>(const <span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> *<i>unicode</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>Resizes the string to <i>size</i> characters and copies <i>unicode</i> into the string.</p>
<p>If <i>unicode</i> is 0, nothing is copied, but the string is still resized to <i>size</i>.</p>
<p>Note that unlike <a href="qstring.html#fromUtf16">fromUtf16</a>(), this function does not consider BOMs and possibly differing byte ordering.</p>
<p><b> 参见 </b><a href="qstring.html#utf16">utf16</a>() 和 <a href="qstring.html#setUnicode">setUnicode</a>().</p>
<!-- @@@setUtf16 -->
<!-- $$$shrink_to_fit[overload1]$$$shrink_to_fit -->
<h3 class="fn" id="shrink_to_fit"><a name="shrink_to_fit"></a><span class="type">void</span> QString::<span class="name">shrink_to_fit</span>()</h3>
<p>此函数用于STL风格的兼容性，它相当于 <a href="qstring.html#squeeze">squeeze</a>().</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#squeeze">squeeze</a>().</p>
<!-- @@@shrink_to_fit -->
<!-- $$$simplified[overload1]$$$simplified -->
<h3 class="fn" id="simplified"><a name="simplified"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">simplified</span>() const</h3>
<p>Returns a string that has whitespace removed from the start and the end, and that has each sequence of internal whitespace replaced with a single space.</p>
<p>Whitespace means any character for which <a href="qchar.html#isSpace">QChar::isSpace</a>() returns <code>true</code>. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;  lots\t of\nwhitespace\r\n &quot;</span>;
  str <span class="operator">=</span> str<span class="operator">.</span>simplified();
  <span class="comment">// str == &quot;lots of whitespace&quot;;</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#trimmed">trimmed</a>().</p>
<!-- @@@simplified -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><a name="size"></a><span class="type">int</span> QString::<span class="name">size</span>() const</h3>
<p>Returns the number of characters in this string.</p>
<p>The last character in the string is at position size() - 1.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;
  <span class="type">int</span> n <span class="operator">=</span> str<span class="operator">.</span>size();         <span class="comment">// n == 5</span>
  str<span class="operator">.</span>data()<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;              <span class="comment">// returns 'W'</span>
  str<span class="operator">.</span>data()<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;              <span class="comment">// returns 'd'</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#isEmpty">isEmpty</a>() 和 <a href="qstring.html#resize">resize</a>().</p>
<!-- @@@size -->
<!-- $$$split[overload1]$$$splitconstQString&QString::SplitBehaviorQt::CaseSensitivity -->
<h3 class="fn" id="split"><a name="split"></a><span class="type"><a href="qstringlist.html">QStringList</a></span> QString::<span class="name">split</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>sep</i>, <span class="type"><a href="qstring.html#SplitBehavior-enum">QString::SplitBehavior</a></span> <i>behavior</i> = KeepEmptyParts, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Splits the string into substrings wherever <i>sep</i> occurs, and returns the list of those strings. If <i>sep</i> does not match anywhere in the string, split() returns a single-element list containing this string.</p>
<p><i>cs</i> specifies whether <i>sep</i> should be matched case sensitively or case insensitively.</p>
<p>If <i>behavior</i> is <a href="qstring.html#SplitBehavior-enum">QString::SkipEmptyParts</a>, empty entries don't appear in the result. By default, empty entries are kept.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;a,,b,c&quot;</span>;

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list1 <span class="operator">=</span> str<span class="operator">.</span>split(<span class="char">','</span>);
  <span class="comment">// list1: [ &quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot; ]</span>

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list2 <span class="operator">=</span> str<span class="operator">.</span>split(<span class="char">','</span><span class="operator">,</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>SkipEmptyParts);
  <span class="comment">// list2: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span>

</pre>
<p>If <i>sep</i> is empty, split() returns an empty string, followed by each of the string's characters, followed by another empty string:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;
  <span class="keyword">auto</span> parts <span class="operator">=</span> str<span class="operator">.</span>split(<span class="string">&quot;&quot;</span>);
  <span class="comment">// parts: {&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;}</span>

</pre>
<p>To understand this behavior, recall that the empty string matches everywhere, so the above is qualitatively the same as:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;/a/b/c/&quot;</span>;
  <span class="keyword">auto</span> parts <span class="operator">=</span> str<span class="operator">.</span>split(<span class="char">'/'</span>);
  <span class="comment">// parts: {&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;}</span>

</pre>
<p><b> 参见 </b><a href="qstringlist.html#join">QStringList::join</a>() 和 <a href="qstring.html#section">section</a>().</p>
<!-- @@@split -->
<!-- $$$split$$$splitQCharQString::SplitBehaviorQt::CaseSensitivity -->
<h3 class="fn" id="split-1"><a name="split-1"></a><span class="type"><a href="qstringlist.html">QStringList</a></span> QString::<span class="name">split</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>sep</i>, <span class="type"><a href="qstring.html#SplitBehavior-enum">QString::SplitBehavior</a></span> <i>behavior</i> = KeepEmptyParts, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>这是一个重载函数。</p>
<!-- @@@split -->
<!-- $$$split$$$splitconstQRegExp&QString::SplitBehavior -->
<h3 class="fn" id="split-2"><a name="split-2"></a><span class="type"><a href="qstringlist.html">QStringList</a></span> QString::<span class="name">split</span>(const <span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>, <span class="type"><a href="qstring.html#SplitBehavior-enum">QString::SplitBehavior</a></span> <i>behavior</i> = KeepEmptyParts) const</h3>
<p>这是一个重载函数。</p>
<p>Splits the string into substrings wherever the regular expression <i>rx</i> matches, and returns the list of those strings. If <i>rx</i> does not match anywhere in the string, <a href="qstring.html#split">split</a>() returns a single-element list containing this string.</p>
<p>Here's an example where we extract the words in a sentence using one or more whitespace characters as the separator:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;

  str <span class="operator">=</span> <span class="string">&quot;Some  text\n\twith  strange whitespace.&quot;</span>;
  list <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;\\s+&quot;</span>));
  <span class="comment">// list: [ &quot;Some&quot;, &quot;text&quot;, &quot;with&quot;, &quot;strange&quot;, &quot;whitespace.&quot; ]</span>

</pre>
<p>Here's a similar example, but this time we use any sequence of non-word characters as the separator:</p>
<pre class="cpp">

  str <span class="operator">=</span> <span class="string">&quot;This time, a normal English sentence.&quot;</span>;
  list <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;\\W+&quot;</span>)<span class="operator">,</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>SkipEmptyParts);
  <span class="comment">// list: [ &quot;This&quot;, &quot;time&quot;, &quot;a&quot;, &quot;normal&quot;, &quot;English&quot;, &quot;sentence&quot; ]</span>

</pre>
<p>Here's a third example where we use a zero-length assertion, <b>\b</b> (word boundary), to split the string into an alternating sequence of non-word and word tokens:</p>
<pre class="cpp">

  str <span class="operator">=</span> <span class="string">&quot;Now: this sentence fragment.&quot;</span>;
  list <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qregexp.html">QRegExp</a></span>(<span class="string">&quot;\\b&quot;</span>));
  <span class="comment">// list: [ &quot;&quot;, &quot;Now&quot;, &quot;: &quot;, &quot;this&quot;, &quot; &quot;, &quot;sentence&quot;, &quot; &quot;, &quot;fragment&quot;, &quot;.&quot; ]</span>

</pre>
<p><b> 参见 </b><a href="qstringlist.html#join">QStringList::join</a>() 和 <a href="qstring.html#section">section</a>().</p>
<!-- @@@split -->
<!-- $$$split$$$splitconstQRegularExpression&QString::SplitBehavior -->
<h3 class="fn" id="split-3"><a name="split-3"></a><span class="type"><a href="qstringlist.html">QStringList</a></span> QString::<span class="name">split</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type"><a href="qstring.html#SplitBehavior-enum">QString::SplitBehavior</a></span> <i>behavior</i> = KeepEmptyParts) const</h3>
<p>这是一个重载函数。</p>
<p>Splits the string into substrings wherever the regular expression <i>re</i> matches, and returns the list of those strings. If <i>re</i> does not match anywhere in the string, <a href="qstring.html#split">split</a>() returns a single-element list containing this string.</p>
<p>Here's an example where we extract the words in a sentence using one or more whitespace characters as the separator:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;
  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;

  str <span class="operator">=</span> <span class="string">&quot;Some  text\n\twith  strange whitespace.&quot;</span>;
  list <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;\\s+&quot;</span>));
  <span class="comment">// list: [ &quot;Some&quot;, &quot;text&quot;, &quot;with&quot;, &quot;strange&quot;, &quot;whitespace.&quot; ]</span>

</pre>
<p>Here's a similar example, but this time we use any sequence of non-word characters as the separator:</p>
<pre class="cpp">

  str <span class="operator">=</span> <span class="string">&quot;This time, a normal English sentence.&quot;</span>;
  list <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;\\W+&quot;</span>)<span class="operator">,</span> <span class="type"><a href="qstring.html#QString">QString</a></span><span class="operator">::</span>SkipEmptyParts);
  <span class="comment">// list: [ &quot;This&quot;, &quot;time&quot;, &quot;a&quot;, &quot;normal&quot;, &quot;English&quot;, &quot;sentence&quot; ]</span>

</pre>
<p>Here's a third example where we use a zero-length assertion, <b>\b</b> (word boundary), to split the string into an alternating sequence of non-word and word tokens:</p>
<pre class="cpp">

  str <span class="operator">=</span> <span class="string">&quot;Now: this sentence fragment.&quot;</span>;
  list <span class="operator">=</span> str<span class="operator">.</span>split(<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span>(<span class="string">&quot;\\b&quot;</span>));
  <span class="comment">// list: [ &quot;&quot;, &quot;Now&quot;, &quot;: &quot;, &quot;this&quot;, &quot; &quot;, &quot;sentence&quot;, &quot; &quot;, &quot;fragment&quot;, &quot;.&quot; ]</span>

</pre>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstringlist.html#join">QStringList::join</a>() 和 <a href="qstring.html#section">section</a>().</p>
<!-- @@@split -->
<!-- $$$splitRef[overload1]$$$splitRefconstQString&QString::SplitBehaviorQt::CaseSensitivity -->
<h3 class="fn" id="splitRef"><a name="splitRef"></a><span class="type"><a href="qvector.html">QVector</a></span>&lt;<span class="type"><a href="qstringref.html">QStringRef</a></span>&gt; QString::<span class="name">splitRef</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>sep</i>, <span class="type"><a href="qstring.html#SplitBehavior-enum">QString::SplitBehavior</a></span> <i>behavior</i> = KeepEmptyParts, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Splits the string into substring references wherever <i>sep</i> occurs, and returns the list of those strings.</p>
<p>See <a href="qstring.html#split">QString::split</a>() for how <i>sep</i>, <i>behavior</i> and <i>cs</i> interact to form the result.</p>
<p><b>注意： </b>All references are valid as long this string is alive. Destroying this string will cause all references be dangling pointers.</p><p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstringref.html">QStringRef</a> 和 <a href="qstring.html#split">split</a>().</p>
<!-- @@@splitRef -->
<!-- $$$splitRef$$$splitRefQCharQString::SplitBehaviorQt::CaseSensitivity -->
<h3 class="fn" id="splitRef-1"><a name="splitRef-1"></a><span class="type"><a href="qvector.html">QVector</a></span>&lt;<span class="type"><a href="qstringref.html">QStringRef</a></span>&gt; QString::<span class="name">splitRef</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>sep</i>, <span class="type"><a href="qstring.html#SplitBehavior-enum">QString::SplitBehavior</a></span> <i>behavior</i> = KeepEmptyParts, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<!-- @@@splitRef -->
<!-- $$$splitRef$$$splitRefconstQRegExp&QString::SplitBehavior -->
<h3 class="fn" id="splitRef-2"><a name="splitRef-2"></a><span class="type"><a href="qvector.html">QVector</a></span>&lt;<span class="type"><a href="qstringref.html">QStringRef</a></span>&gt; QString::<span class="name">splitRef</span>(const <span class="type"><a href="qregexp.html">QRegExp</a></span> &amp;<i>rx</i>, <span class="type"><a href="qstring.html#SplitBehavior-enum">QString::SplitBehavior</a></span> <i>behavior</i> = KeepEmptyParts) const</h3>
<p>这是一个重载函数。</p>
<p>Splits the string into substring references wherever the regular expression <i>rx</i> matches, and returns the list of those strings. If <i>rx</i> does not match anywhere in the string, <a href="qstring.html#splitRef">splitRef</a>() returns a single-element vector containing this string reference.</p>
<p><b>注意： </b>All references are valid as long this string is alive. Destroying this string will cause all references be dangling pointers.</p><p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstringref.html">QStringRef</a> 和 <a href="qstring.html#split">split</a>().</p>
<!-- @@@splitRef -->
<!-- $$$splitRef$$$splitRefconstQRegularExpression&QString::SplitBehavior -->
<h3 class="fn" id="splitRef-3"><a name="splitRef-3"></a><span class="type"><a href="qvector.html">QVector</a></span>&lt;<span class="type"><a href="qstringref.html">QStringRef</a></span>&gt; QString::<span class="name">splitRef</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>re</i>, <span class="type"><a href="qstring.html#SplitBehavior-enum">QString::SplitBehavior</a></span> <i>behavior</i> = KeepEmptyParts) const</h3>
<p>这是一个重载函数。</p>
<p>Splits the string into substring references wherever the regular expression <i>re</i> matches, and returns the list of those strings. If <i>re</i> does not match anywhere in the string, <a href="qstring.html#splitRef">splitRef</a>() returns a single-element vector containing this string reference.</p>
<p><b>注意： </b>All references are valid as long this string is alive. Destroying this string will cause all references be dangling pointers.</p><p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#split">split</a>() 和 <a href="qstringref.html">QStringRef</a>.</p>
<!-- @@@splitRef -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" id="squeeze"><a name="squeeze"></a><span class="type">void</span> QString::<span class="name">squeeze</span>()</h3>
<p>Releases any memory not required to store the character data.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qstring.html">QString</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b> 参见 </b><a href="qstring.html#reserve">reserve</a>() 和 <a href="qstring.html#capacity">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$startsWith[overload1]$$$startsWithconstQString&Qt::CaseSensitivity -->
<h3 class="fn" id="startsWith"><a name="startsWith"></a><span class="type">bool</span> QString::<span class="name">startsWith</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns <code>true</code> if the string starts with <i>s</i>; 否则则返回 <code>false</code>。</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Bananas&quot;</span>;
  str<span class="operator">.</span>startsWith(<span class="string">&quot;Ban&quot;</span>);     <span class="comment">// returns true</span>
  str<span class="operator">.</span>startsWith(<span class="string">&quot;Car&quot;</span>);     <span class="comment">// returns false</span>

</pre>
<p><b> 参见 </b><a href="qstring.html#endsWith">endsWith</a>().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithconstQStringRef&Qt::CaseSensitivity -->
<h3 class="fn" id="startsWith-1"><a name="startsWith-1"></a><span class="type">bool</span> QString::<span class="name">startsWith</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>s</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>这是一个重载函数。</p>
<p>Returns <code>true</code> if the string starts with the string reference <i>s</i>; 否则则返回 <code>false</code>。</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case sensitive; otherwise the search is case insensitive.</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#endsWith">endsWith</a>().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithQStringViewQt::CaseSensitivity -->
<h3 class="fn" id="startsWith-2"><a name="startsWith-2"></a><span class="type">bool</span> QString::<span class="name">startsWith</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>str</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>这是一个重载函数。</p>
<p>Returns <code>true</code> if the string starts with the string-view <i>str</i>; 否则则返回 <code>false</code>。</p>
<p>If <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> (default), the search is case-sensitive; otherwise the search is case insensitive.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#endsWith">endsWith</a>().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithQLatin1StringQt::CaseSensitivity -->
<h3 class="fn" id="startsWith-3"><a name="startsWith-3"></a><span class="type">bool</span> QString::<span class="name">startsWith</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>s</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#startsWith">startsWith</a>().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithQCharQt::CaseSensitivity -->
<h3 class="fn" id="startsWith-4"><a name="startsWith-4"></a><span class="type">bool</span> QString::<span class="name">startsWith</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>c</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>此函数重载了 <a href="qstring.html#startsWith">startsWith</a>().</p>
<p>Returns <code>true</code> if the string starts with <i>c</i>; 否则则返回 <code>false</code>。</p>
<!-- @@@startsWith -->
<!-- $$$swap[overload1]$$$swapQString& -->
<h3 class="fn" id="swap"><a name="swap"></a><span class="type">void</span> QString::<span class="name">swap</span>(<span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>other</i>)</h3>
<p>Swaps string <i>other</i> with this string. 此操作巨快，且从未失手失败过。</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<!-- @@@swap -->
<!-- $$$toCFString[overload1]$$$toCFString -->
<h3 class="fn" id="toCFString"><a name="toCFString"></a><span class="type">CFStringRef</span> QString::<span class="name">toCFString</span>() const</h3>
<p>Creates a CFString from a <a href="qstring.html">QString</a>. The caller owns the CFString and is responsible for releasing it.</p>
<p><b>注意： </b>this function is only available on OS X and iOS.</p><p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@toCFString -->
<!-- $$$toCaseFolded[overload1]$$$toCaseFolded -->
<h3 class="fn" id="toCaseFolded"><a name="toCaseFolded"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">toCaseFolded</span>() const</h3>
<p>Returns the case folded equivalent of the string. For most Unicode characters this is the same as <a href="qstring.html#toLower">toLower</a>().</p>
<!-- @@@toCaseFolded -->
<!-- $$$toDouble[overload1]$$$toDoublebool* -->
<h3 class="fn" id="toDouble"><a name="toDouble"></a><span class="type">double</span> QString::<span class="name">toDouble</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the string converted to a <code>double</code> value.</p>
<p>Returns 0.0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;1234.56&quot;</span>;
  <span class="type">double</span> val <span class="operator">=</span> str<span class="operator">.</span>toDouble();   <span class="comment">// val == 1234.56</span>

</pre>
<p><b>警告：</b> The <a href="qstring.html">QString</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
<pre class="cpp">

  bool ok;
  <span class="type">double</span> d;

  d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>( <span class="string">&quot;1234.56e-02&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == true, d == 12.3456</span>

  d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>( <span class="string">&quot;1234.56e-02 Volt&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == false, d == 0</span>

</pre>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toDouble">QLocale::toDouble</a>()</p>
<pre class="cpp">

  d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>( <span class="string">&quot;1234,56&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == false</span>
  d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>( <span class="string">&quot;1234.56&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == true, d == 1234.56</span>

</pre>
<p>For historical reasons, this function does not handle thousands group separators. If you need to convert such numbers, use <a href="qlocale.html#toDouble">QLocale::toDouble</a>().</p>
<pre class="cpp">

  d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>( <span class="string">&quot;1,234,567.89&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == false</span>
  d <span class="operator">=</span> <span class="type"><a href="qstring.html#QString">QString</a></span>( <span class="string">&quot;1234567.89&quot;</span> )<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok); <span class="comment">// ok == true</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>(), <a href="qlocale.html#setDefault">QLocale::setDefault</a>(), <a href="qlocale.html#toDouble">QLocale::toDouble</a>(), 和 <a href="qstring.html#trimmed">trimmed</a>().</p>
<!-- @@@toDouble -->
<!-- $$$toFloat[overload1]$$$toFloatbool* -->
<h3 class="fn" id="toFloat"><a name="toFloat"></a><span class="type">float</span> QString::<span class="name">toFloat</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the string converted to a <code>float</code> value.</p>
<p>Returns 0.0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p><b>警告：</b> The <a href="qstring.html">QString</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toFloat">QLocale::toFloat</a>()</p>
<p>For historical reasons, this function does not handle thousands group separators. If you need to convert such numbers, use <a href="qlocale.html#toFloat">QLocale::toFloat</a>().</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str1 <span class="operator">=</span> <span class="string">&quot;1234.56&quot;</span>;
  str1<span class="operator">.</span>toFloat();             <span class="comment">// returns 1234.56</span>

  bool ok;
  <span class="type"><a href="qstring.html#QString">QString</a></span> str2 <span class="operator">=</span> <span class="string">&quot;R2D2&quot;</span>;
  str2<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);          <span class="comment">// returns 0.0, sets ok to false</span>

  <span class="type"><a href="qstring.html#QString">QString</a></span> str3 <span class="operator">=</span> <span class="string">&quot;1234.56 Volt&quot;</span>;
  str3<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);          <span class="comment">// returns 0.0, sets ok to false</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>(), <a href="qstring.html#toDouble">toDouble</a>(), <a href="qstring.html#toInt">toInt</a>(), <a href="qlocale.html#toFloat">QLocale::toFloat</a>(), 和 <a href="qstring.html#trimmed">trimmed</a>().</p>
<!-- @@@toFloat -->
<!-- $$$toHtmlEscaped[overload1]$$$toHtmlEscaped -->
<h3 class="fn" id="toHtmlEscaped"><a name="toHtmlEscaped"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">toHtmlEscaped</span>() const</h3>
<p>Converts a plain text string to an HTML string with HTML metacharacters <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, and <code>&quot;</code> replaced by HTML entities.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> plain <span class="operator">=</span> <span class="string">&quot;#include &lt;QtCore&gt;&quot;</span>
  <span class="type"><a href="qstring.html#QString">QString</a></span> html <span class="operator">=</span> plain<span class="operator">.</span>toHtmlEscaped();
  <span class="comment">// html == &quot;#include &amp;lt;QtCore&amp;gt;&quot;</span>

</pre>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@toHtmlEscaped -->
<!-- $$$toInt[overload1]$$$toIntbool*int -->
<h3 class="fn" id="toInt"><a name="toInt"></a><span class="type">int</span> QString::<span class="name">toInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code>int</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toInt">QLocale::toInt</a>()</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
  bool ok;
  <span class="type">int</span> hex <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);       <span class="comment">// hex == 255, ok == true</span>
  <span class="type">int</span> dec <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);       <span class="comment">// dec == 0, ok == false</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>(), <a href="qstring.html#toUInt">toUInt</a>(), <a href="qstring.html#toDouble">toDouble</a>(), 和 <a href="qlocale.html#toInt">QLocale::toInt</a>().</p>
<!-- @@@toInt -->
<!-- $$$toLatin1[overload1]$$$toLatin1 -->
<h3 class="fn" id="toLatin1"><a name="toLatin1"></a><span class="type"><a href="qbytearray.html">QByteArray</a></span> QString::<span class="name">toLatin1</span>() const</h3>
<p>Returns a Latin-1 representation of the string as a <a href="qbytearray.html">QByteArray</a>.</p>
<p>The returned byte array is undefined if the string contains non-Latin1 characters. Those characters may be suppressed or replaced with a question mark.</p>
<p><b> 参见 </b><a href="qstring.html#fromLatin1">fromLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), 和 <a href="qtextcodec.html">QTextCodec</a>.</p>
<!-- @@@toLatin1 -->
<!-- $$$toLocal8Bit[overload1]$$$toLocal8Bit -->
<h3 class="fn" id="toLocal8Bit"><a name="toLocal8Bit"></a><span class="type"><a href="qbytearray.html">QByteArray</a></span> QString::<span class="name">toLocal8Bit</span>() const</h3>
<p>Returns the local 8-bit representation of the string as a <a href="qbytearray.html">QByteArray</a>. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.</p>
<p><a href="qtextcodec.html#codecForLocale">QTextCodec::codecForLocale</a>() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as <a href="qstring.html#toLatin1">toLatin1</a>().</p>
<p>If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.</p>
<p><b> 参见 </b><a href="qstring.html#fromLocal8Bit">fromLocal8Bit</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), 和 <a href="qtextcodec.html">QTextCodec</a>.</p>
<!-- @@@toLocal8Bit -->
<!-- $$$toLong[overload1]$$$toLongbool*int -->
<h3 class="fn" id="toLong"><a name="toLong"></a><span class="type">long</span> QString::<span class="name">toLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to a <code>long</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toLongLong">QLocale::toLongLong</a>()</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
  bool ok;

  <span class="type">long</span> hex <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
  <span class="type">long</span> dec <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>(), <a href="qstring.html#toULong">toULong</a>(), <a href="qstring.html#toInt">toInt</a>(), 和 <a href="qlocale.html#toInt">QLocale::toInt</a>().</p>
<!-- @@@toLong -->
<!-- $$$toLongLong[overload1]$$$toLongLongbool*int -->
<h3 class="fn" id="toLongLong"><a name="toLongLong"></a><span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> QString::<span class="name">toLongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to a <code>long long</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toLongLong">QLocale::toLongLong</a>()</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
  bool ok;

  <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toLongLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);      <span class="comment">// hex == 255, ok == true</span>
  <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toLongLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);      <span class="comment">// dec == 0, ok == false</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>(), <a href="qstring.html#toULongLong">toULongLong</a>(), <a href="qstring.html#toInt">toInt</a>(), 和 <a href="qlocale.html#toLongLong">QLocale::toLongLong</a>().</p>
<!-- @@@toLongLong -->
<!-- $$$toLower[overload1]$$$toLower -->
<h3 class="fn" id="toLower"><a name="toLower"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">toLower</span>() const</h3>
<p>Returns a lowercase copy of the string.</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;The Qt PROJECT&quot;</span>;
  str <span class="operator">=</span> str<span class="operator">.</span>toLower();        <span class="comment">// str == &quot;the qt project&quot;</span>

</pre>
<p>The case conversion will always happen in the 'C' locale. For locale dependent case folding use <a href="qlocale.html#toLower">QLocale::toLower</a>()</p>
<p><b> 参见 </b><a href="qstring.html#toUpper">toUpper</a>() 和 <a href="qlocale.html#toLower">QLocale::toLower</a>().</p>
<!-- @@@toLower -->
<!-- $$$toNSString[overload1]$$$toNSString -->
<h3 class="fn" id="toNSString"><a name="toNSString"></a><span class="type">NSString</span> *QString::<span class="name">toNSString</span>() const</h3>
<p>Creates a NSString from a <a href="qstring.html">QString</a>. The NSString is autoreleased.</p>
<p><b>注意： </b>this function is only available on OS X and iOS.</p><p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@toNSString -->
<!-- $$$toShort[overload1]$$$toShortbool*int -->
<h3 class="fn" id="toShort"><a name="toShort"></a><span class="type">short</span> QString::<span class="name">toShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to a <code>short</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toShort">QLocale::toShort</a>()</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
  bool ok;

  <span class="type">short</span> hex <span class="operator">=</span> str<span class="operator">.</span>toShort(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);   <span class="comment">// hex == 255, ok == true</span>
  <span class="type">short</span> dec <span class="operator">=</span> str<span class="operator">.</span>toShort(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);   <span class="comment">// dec == 0, ok == false</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>(), <a href="qstring.html#toUShort">toUShort</a>(), <a href="qstring.html#toInt">toInt</a>(), 和 <a href="qlocale.html#toShort">QLocale::toShort</a>().</p>
<!-- @@@toShort -->
<!-- $$$toStdString[overload1]$$$toStdString -->
<h3 class="fn" id="toStdString"><a name="toStdString"></a><span class="type">std::string</span> QString::<span class="name">toStdString</span>() const</h3>
<p>Returns a std::string object with the data contained in this <a href="qstring.html">QString</a>. The Unicode data is converted into 8-bit characters using the <a href="qstring.html#toUtf8">toUtf8</a>() function.</p>
<p>This method is mostly useful to pass a <a href="qstring.html">QString</a> to a function that accepts a std::string object.</p>
<p><b> 参见 </b><a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), 和 <a href="qbytearray.html#toStdString">QByteArray::toStdString</a>().</p>
<!-- @@@toStdString -->
<!-- $$$toStdU16String[overload1]$$$toStdU16String -->
<h3 class="fn" id="toStdU16String"><a name="toStdU16String"></a><span class="type">std::u16string</span> QString::<span class="name">toStdU16String</span>() const</h3>
<p>Returns a std::u16string object with the data contained in this <a href="qstring.html">QString</a>. The Unicode data is the same as returned by the <a href="qstring.html#utf16">utf16</a>() method.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#toStdWString">toStdWString</a>(), 和 <a href="qstring.html#toStdU32String">toStdU32String</a>().</p>
<!-- @@@toStdU16String -->
<!-- $$$toStdU32String[overload1]$$$toStdU32String -->
<h3 class="fn" id="toStdU32String"><a name="toStdU32String"></a><span class="type">std::u32string</span> QString::<span class="name">toStdU32String</span>() const</h3>
<p>Returns a std::u32string object with the data contained in this <a href="qstring.html">QString</a>. The Unicode data is the same as returned by the <a href="qstring.html#toUcs4">toUcs4</a>() method.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#toUcs4">toUcs4</a>(), <a href="qstring.html#toStdWString">toStdWString</a>(), 和 <a href="qstring.html#toStdU16String">toStdU16String</a>().</p>
<!-- @@@toStdU32String -->
<!-- $$$toStdWString[overload1]$$$toStdWString -->
<h3 class="fn" id="toStdWString"><a name="toStdWString"></a><span class="type">std::wstring</span> QString::<span class="name">toStdWString</span>() const</h3>
<p>Returns a std::wstring object with the data contained in this <a href="qstring.html">QString</a>. The std::wstring is encoded in utf16 on platforms where wchar_t is 2 bytes wide (e.g&#x2e; windows) and in ucs4 on platforms where wchar_t is 4 bytes wide (most Unix systems).</p>
<p>This method is mostly useful to pass a <a href="qstring.html">QString</a> to a function that accepts a std::wstring object.</p>
<p><b> 参见 </b><a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), <a href="qstring.html#toStdU16String">toStdU16String</a>(), 和 <a href="qstring.html#toStdU32String">toStdU32String</a>().</p>
<!-- @@@toStdWString -->
<!-- $$$toUInt[overload1]$$$toUIntbool*int -->
<h3 class="fn" id="toUInt"><a name="toUInt"></a><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> QString::<span class="name">toUInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code>unsigned int</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toUInt">QLocale::toUInt</a>()</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
  bool ok;

  <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toUInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
  <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toUInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>(), <a href="qstring.html#toInt">toInt</a>(), 和 <a href="qlocale.html#toUInt">QLocale::toUInt</a>().</p>
<!-- @@@toUInt -->
<!-- $$$toULong[overload1]$$$toULongbool*int -->
<h3 class="fn" id="toULong"><a name="toULong"></a><span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> QString::<span class="name">toULong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code>unsigned long</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toULongLong">QLocale::toULongLong</a>()</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
  bool ok;

  <span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toULong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);   <span class="comment">// hex == 255, ok == true</span>
  <span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toULong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);   <span class="comment">// dec == 0, ok == false</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>() 和 <a href="qlocale.html#toUInt">QLocale::toUInt</a>().</p>
<!-- @@@toULong -->
<!-- $$$toULongLong[overload1]$$$toULongLongbool*int -->
<h3 class="fn" id="toULongLong"><a name="toULongLong"></a><span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> QString::<span class="name">toULongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code>unsigned long long</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toULongLong">QLocale::toULongLong</a>()</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
  bool ok;

  <span class="type"><a href="qtglobal.html#quint64-typedef">quint64</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toULongLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);    <span class="comment">// hex == 255, ok == true</span>
  <span class="type"><a href="qtglobal.html#quint64-typedef">quint64</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toULongLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);    <span class="comment">// dec == 0, ok == false</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>(), <a href="qstring.html#toLongLong">toLongLong</a>(), 和 <a href="qlocale.html#toULongLong">QLocale::toULongLong</a>().</p>
<!-- @@@toULongLong -->
<!-- $$$toUShort[overload1]$$$toUShortbool*int -->
<h3 class="fn" id="toUShort"><a name="toUShort"></a><span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> QString::<span class="name">toUShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the string converted to an <code>unsigned short</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p>If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.</p>
<p>The string conversion will always happen in the 'C' locale. For locale dependent conversion use <a href="qlocale.html#toUShort">QLocale::toUShort</a>()</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;FF&quot;</span>;
  bool ok;

  <span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> hex <span class="operator">=</span> str<span class="operator">.</span>toUShort(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
  <span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> dec <span class="operator">=</span> str<span class="operator">.</span>toUShort(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>

</pre>
<p>This function ignores leading and trailing whitespace.</p>
<p><b> 参见 </b><a href="qstring.html#number">number</a>(), <a href="qstring.html#toShort">toShort</a>(), 和 <a href="qlocale.html#toUShort">QLocale::toUShort</a>().</p>
<!-- @@@toUShort -->
<!-- $$$toUcs4[overload1]$$$toUcs4 -->
<h3 class="fn" id="toUcs4"><a name="toUcs4"></a><span class="type"><a href="qvector.html">QVector</a></span>&lt;<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span>&gt; QString::<span class="name">toUcs4</span>() const</h3>
<p>Returns a UCS-4/UTF-32 representation of the string as a <a href="qvector.html">QVector</a>&lt;uint&gt;.</p>
<p>UCS-4 is a Unicode codec and therefore it is lossless. All characters from this string will be encoded in UCS-4. Any invalid sequence of code units in this string is replaced by the Unicode's replacement character (<a href="qchar.html#SpecialCharacter-enum">QChar::ReplacementCharacter</a>, which corresponds to <code>U+FFFD</code>).</p>
<p>The returned vector is not NUL terminated.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#fromUtf8">fromUtf8</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), <a href="qtextcodec.html">QTextCodec</a>, <a href="qstring.html#fromUcs4">fromUcs4</a>(), 和 <a href="qstring.html#toWCharArray">toWCharArray</a>().</p>
<!-- @@@toUcs4 -->
<!-- $$$toUpper[overload1]$$$toUpper -->
<h3 class="fn" id="toUpper"><a name="toUpper"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">toUpper</span>() const</h3>
<p>返回当前字符串的大写形式。</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;TeXt&quot;</span>;
  str <span class="operator">=</span> str<span class="operator">.</span>toUpper();        <span class="comment">// str == &quot;TEXT&quot;</span>

</pre>
<p>The case conversion will always happen in the 'C' locale. For locale dependent case folding use <a href="qlocale.html#toUpper">QLocale::toUpper</a>()</p>
<p><b> 参见 </b><a href="qstring.html#toLower">toLower</a>() 和 <a href="qlocale.html#toLower">QLocale::toLower</a>().</p>
<!-- @@@toUpper -->
<!-- $$$toUtf8[overload1]$$$toUtf8 -->
<h3 class="fn" id="toUtf8"><a name="toUtf8"></a><span class="type"><a href="qbytearray.html">QByteArray</a></span> QString::<span class="name">toUtf8</span>() const</h3>
<p>Returns a UTF-8 representation of the string as a <a href="qbytearray.html">QByteArray</a>.</p>
<p>UTF-8 is a Unicode codec and can represent all characters in a Unicode string like <a href="qstring.html">QString</a>.</p>
<p><b> 参见 </b><a href="qstring.html#fromUtf8">fromUtf8</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), 和 <a href="qtextcodec.html">QTextCodec</a>.</p>
<!-- @@@toUtf8 -->
<!-- $$$toWCharArray[overload1]$$$toWCharArraywchar_t* -->
<h3 class="fn" id="toWCharArray"><a name="toWCharArray"></a><span class="type">int</span> QString::<span class="name">toWCharArray</span>(<span class="type">wchar_t</span> *<i>array</i>) const</h3>
<p>Fills the <i>array</i> with the data contained in this <a href="qstring.html">QString</a> object. The array is encoded in UTF-16 on platforms where wchar_t is 2 bytes wide (e.g&#x2e; windows) and in UCS-4 on platforms where wchar_t is 4 bytes wide (most Unix systems).</p>
<p><i>array</i> has to be allocated by the caller and contain enough space to hold the complete string (allocating the array with the same length as the string is always sufficient).</p>
<p>This function returns the actual length of the string in <i>array</i>.</p>
<p><b>注意： </b>This function does not append a null character to the array.</p><p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#utf16">utf16</a>(), <a href="qstring.html#toUcs4">toUcs4</a>(), <a href="qstring.html#toLatin1">toLatin1</a>(), <a href="qstring.html#toUtf8">toUtf8</a>(), <a href="qstring.html#toLocal8Bit">toLocal8Bit</a>(), 和 <a href="qstring.html#toStdWString">toStdWString</a>().</p>
<!-- @@@toWCharArray -->
<!-- $$$trimmed[overload1]$$$trimmed -->
<h3 class="fn" id="trimmed"><a name="trimmed"></a><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">trimmed</span>() const</h3>
<p>Returns a string that has whitespace removed from the start and the end.</p>
<p>Whitespace means any character for which <a href="qchar.html#isSpace">QChar::isSpace</a>() returns <code>true</code>. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;  lots\t of\nwhitespace\r\n &quot;</span>;
  str <span class="operator">=</span> str<span class="operator">.</span>trimmed();
  <span class="comment">// str == &quot;lots\t of\nwhitespace&quot;</span>

</pre>
<p>Unlike <a href="qstring.html#simplified">simplified</a>(), trimmed() leaves internal whitespace alone.</p>
<p><b> 参见 </b><a href="qstring.html#simplified">simplified</a>().</p>
<!-- @@@trimmed -->
<!-- $$$truncate[overload1]$$$truncateint -->
<h3 class="fn" id="truncate"><a name="truncate"></a><span class="type">void</span> QString::<span class="name">truncate</span>(<span class="type">int</span> <i>position</i>)</h3>
<p>Truncates the string at the given <i>position</i> index.</p>
<p>If the specified <i>position</i> index is beyond the end of the string, nothing happens.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Vladivostok&quot;</span>;
  str<span class="operator">.</span>truncate(<span class="number">4</span>);
  <span class="comment">// str == &quot;Vlad&quot;</span>

</pre>
<p>If <i>position</i> is negative, it is equivalent to passing zero.</p>
<p><b> 参见 </b><a href="qstring.html#chop">chop</a>(), <a href="qstring.html#resize">resize</a>(), <a href="qstring.html#left">left</a>(), 和 <a href="qstringref.html#truncate">QStringRef::truncate</a>().</p>
<!-- @@@truncate -->
<!-- $$$unicode[overload1]$$$unicode -->
<h3 class="fn" id="unicode"><a name="unicode"></a>const <span class="type"><a href="qchar.html">QChar</a></span> *QString::<span class="name">unicode</span>() const</h3>
<p>Returns a Unicode representation of the string. The result remains valid until the string is modified.</p>
<p><b>注意： </b>The returned string may not be '\0'-terminated. Use <a href="qstring.html#size">size</a>() to determine the length of the array.</p><p><b> 参见 </b><a href="qstring.html#setUnicode">setUnicode</a>(), <a href="qstring.html#utf16">utf16</a>(), 和 <a href="qstring.html#fromRawData">fromRawData</a>().</p>
<!-- @@@unicode -->
<!-- $$$utf16[overload1]$$$utf16 -->
<h3 class="fn" id="utf16"><a name="utf16"></a>const <span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> *QString::<span class="name">utf16</span>() const</h3>
<p>Returns the <a href="qstring.html">QString</a> as a '\0'-terminated array of unsigned shorts. The result remains valid until the string is modified.</p>
<p>The returned string is in host byte order.</p>
<p><b> 参见 </b><a href="qstring.html#setUtf16">setUtf16</a>() 和 <a href="qstring.html#unicode">unicode</a>().</p>
<!-- @@@utf16 -->
<!-- $$$vasprintf[overload1]$$$vasprintfconstchar*va_list -->
<h3 class="fn" id="vasprintf"><a name="vasprintf"></a><code>[静态函数] </code><span class="type"><a href="qstring.html#QString">QString</a></span> QString::<span class="name">vasprintf</span>(const <span class="type">char</span> *<i>cformat</i>, <span class="type">va_list</span> <i>ap</i>)</h3>
<p>Equivalent method to <a href="qstring.html#asprintf">asprintf</a>(), but takes a va_list <i>ap</i> instead a list of variable arguments. See the <a href="qstring.html#asprintf">asprintf</a>() documentation for an explanation of <i>cformat</i>.</p>
<p>This method does not call the va_end macro, the caller is responsible to call va_end on <i>ap</i>.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qstring.html#asprintf">asprintf</a>().</p>
<!-- @@@vasprintf -->
<!-- $$$operator!=[overload1]$$$operator!=QLatin1String -->
<h3 class="fn" id="operator-not-eq"><a name="operator-not-eq"></a><span class="type">bool</span> QString::<span class="name">operator!=</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>other</i>) const</h3>
<p>Returns <code>true</code> if this string is not equal to parameter string <i>other</i>。 否则返回 <code>false</code>。</p>
<p>此函数重载了 operator!=().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constchar* -->
<h3 class="fn" id="operator-not-eq-1"><a name="operator-not-eq-1"></a><span class="type">bool</span> QString::<span class="name">operator!=</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-not-eq">operator!=</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQByteArray& -->
<h3 class="fn" id="operator-not-eq-2"><a name="operator-not-eq-2"></a><span class="type">bool</span> QString::<span class="name">operator!=</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-not-eq">operator!=</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator!= -->
<!-- $$$operator+=[overload1]$$$operator+=constQString& -->
<h3 class="fn" id="operator-2b-eq"><a name="operator-2b-eq"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator+=</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>other</i>)</h3>
<p>追加字符串 <i>other</i> 到当前字符串的末尾，并返回当前字符串。</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> x <span class="operator">=</span> <span class="string">&quot;free&quot;</span>;
  <span class="type"><a href="qstring.html#QString">QString</a></span> y <span class="operator">=</span> <span class="string">&quot;dom&quot;</span>;
  x <span class="operator">+</span><span class="operator">=</span> y;
  <span class="comment">// x == &quot;freedom&quot;</span>

</pre>
<p>This operation is typically very fast (<a href="containers.html#constant-time">constant time</a>), because <a href="qstring.html">QString</a> preallocates extra space at the end of the string data so it can grow without reallocating the entire string each time.</p>
<p><b> 参见 </b><a href="qstring.html#append">append</a>() 和 <a href="qstring.html#prepend">prepend</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=QChar -->
<h3 class="fn" id="operator-2b-eq-2"><a name="operator-2b-eq-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator+=</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>追加字符 <i>ch</i> 到当前字符串的末尾。</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constQStringRef& -->
<h3 class="fn" id="operator-2b-eq-3"><a name="operator-2b-eq-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator+=</span>(const <span class="type"><a href="qstringref.html">QStringRef</a></span> &amp;<i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>Appends the string section referenced by <i>str</i> to this string.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=QLatin1String -->
<h3 class="fn" id="operator-2b-eq-4"><a name="operator-2b-eq-4"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator+=</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>追加Latin-1字符串 <i>str</i> 到当前字符串的末尾。</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constchar* -->
<h3 class="fn" id="operator-2b-eq-5"><a name="operator-2b-eq-5"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator+=</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>追加字符串 <i>str</i> 到当前字符串的末尾。 The const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this function by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constQByteArray& -->
<h3 class="fn" id="operator-2b-eq-6"><a name="operator-2b-eq-6"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator+=</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>追加字节数组 <i>ba</i> 到当前字符串的末尾。 The byte array is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the <i>ba</i> byte array, they will be included in the transformation.</p>
<p>You can disable this function by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=char -->
<h3 class="fn" id="operator-2b-eq-7"><a name="operator-2b-eq-7"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator+=</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-2b-eq">operator+=</a>().</p>
<p>Appends the character <i>ch</i> to this string. Note that the character is converted to Unicode using the <a href="qstring.html#fromLatin1">fromLatin1</a>() function, unlike other 8-bit functions that operate on UTF-8 data.</p>
<p>You can disable this function by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator+= -->
<!-- $$$operator<[overload1]$$$operator<QLatin1String -->
<h3 class="fn" id="operator-lt"><a name="operator-lt"></a><span class="type">bool</span> QString::<span class="name">operator&lt;</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>other</i>) const</h3>
<p>此函数重载了 operator&lt;().</p>
<p>Returns <code>true</code> if this string is lexically less than the parameter string called <i>other</i>; 否则则返回 <code>false</code>。</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constchar* -->
<h3 class="fn" id="operator-lt-1"><a name="operator-lt-1"></a><span class="type">bool</span> QString::<span class="name">operator&lt;</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>Returns <code>true</code> if this string is lexically less than string <i>other</i>。 否则返回 <code>false</code>。</p>
<p>此函数重载了 <a href="qstring.html#operator-lt">operator&lt;</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constQByteArray& -->
<h3 class="fn" id="operator-lt-2"><a name="operator-lt-2"></a><span class="type">bool</span> QString::<span class="name">operator&lt;</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-lt">operator&lt;</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator< -->
<!-- $$$operator<=[overload1]$$$operator<=QLatin1String -->
<h3 class="fn" id="operator-lt-eq"><a name="operator-lt-eq"></a><span class="type">bool</span> QString::<span class="name">operator&lt;=</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>other</i>) const</h3>
<p>Returns <code>true</code> if this string is lexically less than or equal to parameter string <i>other</i>。 否则返回 <code>false</code>。</p>
<p>此函数重载了 operator&lt;=().</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constchar* -->
<h3 class="fn" id="operator-lt-eq-1"><a name="operator-lt-eq-1"></a><span class="type">bool</span> QString::<span class="name">operator&lt;=</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-lt-eq">operator&lt;=</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constQByteArray& -->
<h3 class="fn" id="operator-lt-eq-2"><a name="operator-lt-eq-2"></a><span class="type">bool</span> QString::<span class="name">operator&lt;=</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-lt-eq">operator&lt;=</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator<= -->
<!-- $$$operator=[overload1]$$$operator=constQString& -->
<h3 class="fn" id="operator-eq"><a name="operator-eq"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator=</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>other</i>)</h3>
<p>Assigns <i>other</i> to this string and returns a reference to this string.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QChar -->
<h3 class="fn" id="operator-eq-1"><a name="operator-eq-1"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator=</span>(<span class="type"><a href="qchar.html">QChar</a></span> <i>ch</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Sets the string to contain the single character <i>ch</i>.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QLatin1String -->
<h3 class="fn" id="operator-eq-2"><a name="operator-eq-2"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator=</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Assigns the Latin-1 string <i>str</i> to this string.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QString&& -->
<h3 class="fn" id="operator-eq-3"><a name="operator-eq-3"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator=</span>(<span class="type"><a href="qstring.html#QString">QString</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i>other</i> to this <a href="qstring.html">QString</a> instance.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=constchar* -->
<h3 class="fn" id="operator-eq-4"><a name="operator-eq-4"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator=</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Assigns <i>str</i> to this string. The const char pointer is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> or <code>QT_RESTRICTED_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=constQByteArray& -->
<h3 class="fn" id="operator-eq-5"><a name="operator-eq-5"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator=</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Assigns <i>ba</i> to this string. The byte array is converted to Unicode using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function. This function stops conversion at the first NUL character found, or the end of the <i>ba</i> byte array.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=char -->
<h3 class="fn" id="operator-eq-6"><a name="operator-eq-6"></a><span class="type"><a href="qstring.html#QString">QString</a></span> &amp;QString::<span class="name">operator=</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-eq">operator=</a>().</p>
<p>Assigns character <i>ch</i> to this string. Note that the character is converted to Unicode using the <a href="qstring.html#fromLatin1">fromLatin1</a>() function, unlike other 8-bit functions that operate on UTF-8 data.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==QLatin1String -->
<h3 class="fn" id="operator-eq-eq"><a name="operator-eq-eq"></a><span class="type">bool</span> QString::<span class="name">operator==</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>other</i>) const</h3>
<p>此函数重载了 operator==().</p>
<p>Returns <code>true</code> if this string is equal to <i>other</i>; 否则则返回 <code>false</code>。</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constchar* -->
<h3 class="fn" id="operator-eq-eq-1"><a name="operator-eq-eq-1"></a><span class="type">bool</span> QString::<span class="name">operator==</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-eq-eq">operator==</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQByteArray& -->
<h3 class="fn" id="operator-eq-eq-2"><a name="operator-eq-eq-2"></a><span class="type">bool</span> QString::<span class="name">operator==</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-eq-eq">operator==</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function. This function stops conversion at the first NUL character found, or the end of the byte array.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<p>Returns <code>true</code> if this string is lexically equal to the parameter string <i>other</i>。 否则返回 <code>false</code>。</p>
<!-- @@@operator== -->
<!-- $$$operator>[overload1]$$$operator>QLatin1String -->
<h3 class="fn" id="operator-gt"><a name="operator-gt"></a><span class="type">bool</span> QString::<span class="name">operator&gt;</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>other</i>) const</h3>
<p>此函数重载了 operator&gt;().</p>
<p>Returns <code>true</code> if this string is lexically greater than the parameter string <i>other</i>; 否则则返回 <code>false</code>。</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constchar* -->
<h3 class="fn" id="operator-gt-1"><a name="operator-gt-1"></a><span class="type">bool</span> QString::<span class="name">operator&gt;</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-gt">operator&gt;</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constQByteArray& -->
<h3 class="fn" id="operator-gt-2"><a name="operator-gt-2"></a><span class="type">bool</span> QString::<span class="name">operator&gt;</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-gt">operator&gt;</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator> -->
<!-- $$$operator>=[overload1]$$$operator>=QLatin1String -->
<h3 class="fn" id="operator-gt-eq"><a name="operator-gt-eq"></a><span class="type">bool</span> QString::<span class="name">operator&gt;=</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>other</i>) const</h3>
<p>Returns <code>true</code> if this string is lexically greater than or equal to parameter string <i>other</i>。 否则返回 <code>false</code>。</p>
<p>此函数重载了 operator&gt;=().</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constchar* -->
<h3 class="fn" id="operator-gt-eq-1"><a name="operator-gt-eq-1"></a><span class="type">bool</span> QString::<span class="name">operator&gt;=</span>(const <span class="type">char</span> *<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-gt-eq">operator&gt;=</a>().</p>
<p>The <i>other</i> const char pointer is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constQByteArray& -->
<h3 class="fn" id="operator-gt-eq-2"><a name="operator-gt-eq-2"></a><span class="type">bool</span> QString::<span class="name">operator&gt;=</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>other</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-gt-eq">operator&gt;=</a>().</p>
<p>The <i>other</i> byte array is converted to a <a href="qstring.html">QString</a> using the <a href="qstring.html#fromUtf8">fromUtf8</a>() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <a href="qobject.html#tr">QObject::tr</a>(), for example.</p>
<!-- @@@operator>= -->
<!-- $$$operator[][overload1]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d"><a name="operator-5b-5d"></a><span class="type">QCharRef</span> QString::<span class="name">operator[]</span>(<span class="type">int</span> <i>position</i>)</h3>
<p>Returns the character at the specified <i>position</i> in the string as a modifiable reference.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html#QString">QString</a></span> str;

  <span class="keyword">if</span> (str<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qchar.html">QChar</a></span>(<span class="char">'?'</span>))
      str<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="qchar.html">QChar</a></span>(<span class="char">'_'</span>);

</pre>
<p>The return value is of type QCharRef, a helper class for <a href="qstring.html">QString</a>. When you get an object of type QCharRef, you can use it as if it were a <a href="qchar.html">QChar</a> &amp;. If you assign to it, the assignment will apply to the character in the <a href="qstring.html">QString</a> from which you got the reference.</p>
<p><b> 参见 </b><a href="qstring.html#at">at</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d-1"><a name="operator-5b-5d-1"></a>const <span class="type"><a href="qchar.html">QChar</a></span> QString::<span class="name">operator[]</span>(<span class="type">int</span> <i>position</i>) const</h3>
<p>此函数重载了 <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]uint -->
<h3 class="fn" id="operator-5b-5d-2"><a name="operator-5b-5d-2"></a>const <span class="type"><a href="qchar.html">QChar</a></span> QString::<span class="name">operator[]</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>position</i>) const</h3>
<p>等同于 <code>at(position)</code>. <p>此函数重载了 <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]uint -->
<h3 class="fn" id="operator-5b-5d-3"><a name="operator-5b-5d-3"></a><span class="type">QCharRef</span> QString::<span class="name">operator[]</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>position</i>)</h3>
<p>此函数重载了 <a href="qstring.html#operator-5b-5d">operator[]</a>().</p>
<p>Returns the character at the specified <i>position</i> in the string as a modifiable reference.</p>
<!-- @@@operator[] -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
<!-- $$$operator!=$$$operator!=constQString&constQString& -->
<h3 class="fn" id="operator-not-eq-3"><a name="operator-not-eq-3"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>若字符串 <i>s1</i> 不等于字符串 <i>s2</i>，则返回<code>true</code>； 否则则返回 <code>false</code>。</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constchar*constQString& -->
<h3 class="fn" id="operator-not-eq-4"><a name="operator-not-eq-4"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if <i>s1</i> is not equal to <i>s2</i>; 否则则返回 <code>false</code>。</p>
<p>For <i>s1</i> != 0, this 等同于 <code>compare(</code> <i>s1</i>, <i>s2</i> <code>) != 0</code>. Note that no string is equal to <i>s1</i> being 0.</p>
<!-- @@@operator!= -->
<!-- $$$operator+[overload1]$$$operator+constQString&constQString& -->
<h3 class="fn" id="operator-2b"><a name="operator-2b"></a>const <span class="type"><a href="qstring.html#QString">QString</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns a string which is the result of concatenating <i>s1</i> and <i>s2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constQString&constchar* -->
<h3 class="fn" id="operator-2b-1"><a name="operator-2b-1"></a>const <span class="type"><a href="qstring.html#QString">QString</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type">char</span> *<i>s2</i>)</h3>
<p>Returns a string which is the result of concatenating <i>s1</i> and <i>s2</i> (<i>s2</i> is converted to Unicode using the <a href="qstring.html#fromUtf8">QString::fromUtf8</a>() function).</p>
<p><b> 参见 </b><a href="qstring.html#fromUtf8">QString::fromUtf8</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constchar*constQString& -->
<h3 class="fn" id="operator-2b-2"><a name="operator-2b-2"></a>const <span class="type"><a href="qstring.html#QString">QString</a></span> <span class="name">operator+</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns a string which is the result of concatenating <i>s1</i> and <i>s2</i> (<i>s1</i> is converted to Unicode using the <a href="qstring.html#fromUtf8">QString::fromUtf8</a>() function).</p>
<p><b> 参见 </b><a href="qstring.html#fromUtf8">QString::fromUtf8</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constQString&char -->
<h3 class="fn" id="operator-2b-3"><a name="operator-2b-3"></a>const <span class="type"><a href="qstring.html#QString">QString</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>Returns a string which is the result of concatenating the string <i>s</i> and the character <i>ch</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+charconstQString& -->
<h3 class="fn" id="operator-2b-4"><a name="operator-2b-4"></a>const <span class="type"><a href="qstring.html#QString">QString</a></span> <span class="name">operator+</span>(<span class="type">char</span> <i>ch</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s</i>)</h3>
<p>Returns a string which is the result of concatenating the character <i>ch</i> and the string <i>s</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator<$$$operator<constQString&constQString& -->
<h3 class="fn" id="operator-lt-3"><a name="operator-lt-3"></a><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if string <i>s1</i> is lexically less than string <i>s2</i>; 否则则返回 <code>false</code>。</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function.</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constchar*constQString& -->
<h3 class="fn" id="operator-lt-4"><a name="operator-lt-4"></a><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if <i>s1</i> is lexically less than <i>s2</i>；否则则返回 <code>false</code>。 For <i>s1</i> != 0, this 等同于 <code>compare(s1, s2) &lt; 0</code>.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function.</p>
<!-- @@@operator< -->
<!-- $$$operator<<[overload1]$$$operator<<QDataStream&constQString& -->
<h3 class="fn" id="operator-lt-lt"><a name="operator-lt-lt"></a><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>stream</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>string</i>)</h3>
<p>Writes the given <i>string</i> to the specified <i>stream</i>.</p>
<p><b> 参见 </b><a href="datastreamformat.html">序列化Qt数据类型</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator<=$$$operator<=constQString&constQString& -->
<h3 class="fn" id="operator-lt-eq-3"><a name="operator-lt-eq-3"></a><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if string <i>s1</i> is lexically less than or equal to string <i>s2</i>; 否则则返回 <code>false</code>。</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constchar*constQString& -->
<h3 class="fn" id="operator-lt-eq-4"><a name="operator-lt-eq-4"></a><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if <i>s1</i> is lexically less than or equal to <i>s2</i>；否则则返回 <code>false</code>。 For <i>s1</i> != 0, this 等同于 <code>compare(s1, s2) &lt;= 0</code>.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator==$$$operator==constQString&constQString& -->
<h3 class="fn" id="operator-eq-eq-3"><a name="operator-eq-eq-3"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if string <i>s1</i> is equal to string <i>s2</i>; 否则则返回 <code>false</code>。</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constchar*constQString& -->
<h3 class="fn" id="operator-eq-eq-4"><a name="operator-eq-eq-4"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>此函数重载了 <a href="qchar.html#operator-eq-eq">operator==</a>().</p>
<p>Returns <code>true</code> if <i>s1</i> is equal to <i>s2</i>；否则则返回 <code>false</code>。 Note that no string is equal to <i>s1</i> being 0.</p>
<p>等同于 <code>s1 != 0 &amp;&amp; compare(s1, s2) == 0</code>.</p>
<!-- @@@operator== -->
<!-- $$$operator>$$$operator>constQString&constQString& -->
<h3 class="fn" id="operator-gt-3"><a name="operator-gt-3"></a><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if string <i>s1</i> is lexically greater than string <i>s2</i>; 否则则返回 <code>false</code>。</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constchar*constQString& -->
<h3 class="fn" id="operator-gt-4"><a name="operator-gt-4"></a><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if <i>s1</i> is lexically greater than <i>s2</i>；否则则返回 <code>false</code>。 Equivalent to <code>compare(s1, s2) &gt; 0</code>.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function.</p>
<!-- @@@operator> -->
<!-- $$$operator>=$$$operator>=constQString&constQString& -->
<h3 class="fn" id="operator-gt-eq-3"><a name="operator-gt-eq-3"></a><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if string <i>s1</i> is lexically greater than or equal to string <i>s2</i>; 否则则返回 <code>false</code>。</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constchar*constQString& -->
<h3 class="fn" id="operator-gt-eq-4"><a name="operator-gt-eq-4"></a><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type">char</span> *<i>s1</i>, const <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>s2</i>)</h3>
<p>Returns <code>true</code> if <i>s1</i> is lexically greater than or equal to <i>s2</i>；否则则返回 <code>false</code>。 For <i>s1</i> != 0, this 等同于 <code>compare(s1, s2) &gt;= 0</code>.</p>
<p>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() function.</p>
<!-- @@@operator>= -->
<!-- $$$operator>>[overload1]$$$operator>>QDataStream&QString& -->
<h3 class="fn" id="operator-gt-gt"><a name="operator-gt-gt"></a><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>stream</i>, <span class="type"><a href="qstring.html#QString">QString</a></span> &amp;<i>string</i>)</h3>
<p>Reads a string from the specified <i>stream</i> into the given <i>string</i>.</p>
<p><b> 参见 </b><a href="datastreamformat.html">序列化Qt数据类型</a>.</p>
<!-- @@@operator>> -->
</div>
<div class="macros">
<h2>宏定义文档</h2>
<!-- $$$QStringLiteral[overload1]$$$QStringLiteral -->
<h3 class="fn" id="QStringLiteral"><a name="QStringLiteral"></a><span class="name">QStringLiteral</span>(<i>str</i>)</h3>
<p>The macro generates the data for a <a href="qstring.html">QString</a> out of the string literal <i>str</i> at compile time. Creating a <a href="qstring.html">QString</a> from it is free in this case, and the generated string data is stored in the read-only segment of the compiled object file.</p>
<p>If you have code that looks like this:</p>
<pre class="cpp">

  <span class="comment">// hasAttribute takes a QString argument</span>
  <span class="keyword">if</span> (node<span class="operator">.</span>hasAttribute(<span class="string">&quot;http-contents-length&quot;</span>)) <span class="comment">//...</span>

</pre>
<p>then a temporary <a href="qstring.html">QString</a> will be created to be passed as the <code>hasAttribute</code> function parameter. This can be quite expensive, as it involves a memory allocation and the copy/conversion of the data into <a href="qstring.html">QString</a>'s internal encoding.</p>
<p>This cost can be avoided by using QStringLiteral instead:</p>
<pre class="cpp">

  <span class="keyword">if</span> (node<span class="operator">.</span>hasAttribute(<span class="type">QStringLiteral</span>(u<span class="string">&quot;http-contents-length&quot;</span>))) <span class="comment">//...</span>

</pre>
<p>In this case, <a href="qstring.html">QString</a>'s internal data will be generated at compile time; no conversion or allocation will occur at runtime.</p>
<p>Using QStringLiteral instead of a double quoted plain C++ string literal can significantly speed up creation of <a href="qstring.html">QString</a> instances from data known at compile time.</p>
<p><b>注意： </b><a href="qlatin1string.html">QLatin1String</a> can still be more efficient than QStringLiteral when the string is passed to a function that has an overload taking <a href="qlatin1string.html">QLatin1String</a> and this overload avoids conversion to <a href="qstring.html">QString</a>. For instance, QString::operator==() can compare to a <a href="qlatin1string.html">QLatin1String</a> directly:</p><pre class="cpp">

  <span class="keyword">if</span> (attribute<span class="operator">.</span>name() <span class="operator">=</span><span class="operator">=</span> QLatin1String(<span class="string">&quot;http-contents-length&quot;</span>)) <span class="comment">//...</span>

</pre>
<p><b>注意： </b>Some compilers have bugs encoding strings containing characters outside the US-ASCII character set. Make sure you prefix your string with <code>u</code> in those cases. It is optional otherwise.</p><p><b> 参见 </b><a href="qbytearray.html#QByteArrayLiteral">QByteArrayLiteral</a>.</p>
<!-- @@@QStringLiteral -->
<!-- $$$QT_NO_CAST_FROM_ASCII[overload1]$$$QT_NO_CAST_FROM_ASCII -->
<h3 class="fn" id="QT_NO_CAST_FROM_ASCII"><a name="QT_NO_CAST_FROM_ASCII"></a><span class="name">QT_NO_CAST_FROM_ASCII</span></h3>
<p>Disables automatic conversions from 8-bit strings (char *) to unicode QStrings</p>
<p><b> 参见 </b><a href="qstring.html#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a>, <a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a>, 和 <a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY">QT_NO_CAST_FROM_BYTEARRAY</a>.</p>
<!-- @@@QT_NO_CAST_FROM_ASCII -->
<!-- $$$QT_NO_CAST_TO_ASCII[overload1]$$$QT_NO_CAST_TO_ASCII -->
<h3 class="fn" id="QT_NO_CAST_TO_ASCII"><a name="QT_NO_CAST_TO_ASCII"></a><span class="name">QT_NO_CAST_TO_ASCII</span></h3>
<p>disables automatic conversion from <a href="qstring.html">QString</a> to 8-bit strings (char *)</p>
<p><b> 参见 </b><a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a>, <a href="qstring.html#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a>, 和 <a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY">QT_NO_CAST_FROM_BYTEARRAY</a>.</p>
<!-- @@@QT_NO_CAST_TO_ASCII -->
<!-- $$$QT_RESTRICTED_CAST_FROM_ASCII[overload1]$$$QT_RESTRICTED_CAST_FROM_ASCII -->
<h3 class="fn" id="QT_RESTRICTED_CAST_FROM_ASCII"><a name="QT_RESTRICTED_CAST_FROM_ASCII"></a><span class="name">QT_RESTRICTED_CAST_FROM_ASCII</span></h3>
<p>Defining this macro disables most automatic conversions from source literals and 8-bit data to unicode QStrings, but allows the use of the <code>QChar(char)</code> and <code>QString(const char (&amp;ch)[N]</code> constructors, and the <code>QString::operator=(const char (&amp;ch)[N])</code> assignment operator giving most of the type-safety benefits of <a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> but does not require user code to wrap character and string literals with <a href="qlatin1char.html">QLatin1Char</a>, <a href="qlatin1string.html">QLatin1String</a> or similar.</p>
<p>Using this macro together with source strings outside the 7-bit range, non-literals, or literals with embedded NUL characters is undefined.</p>
<p><b> 参见 </b><a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 和 <a href="qstring.html#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a>.</p>
<!-- @@@QT_RESTRICTED_CAST_FROM_ASCII -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
