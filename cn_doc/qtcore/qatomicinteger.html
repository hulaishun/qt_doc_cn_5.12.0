<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qatomic.cpp -->
  <title>QAtomicInteger Class | Qt Core 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QAtomicInteger</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#macros">宏定义</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#the-atomic-api">The Atomic API</a></li>
<li class="level2"><a href="#feature-tests-for-the-atomic-api">Feature Tests for the Atomic API</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QAtomicInteger Class</h1>
<!-- $$$QAtomicInteger-brief -->
<p>The <a href="qatomicinteger.html">QAtomicInteger</a> class provides platform-independent atomic operations on integers. <a href="#details">More...</a></p>
<!-- @@@QAtomicInteger -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QAtomicInteger&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.3</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> QBasicAtomicInteger</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的子类有：</td><td class="memItemRight bottomAlign"> <p><a href="qatomicint.html">QAtomicInt</a></p>
</td></tr></table></div><ul>
<li><a href="qatomicinteger-members.html">所有成员清单，包括继承而来的成员</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#QAtomicInteger">QAtomicInteger</a></b>(T <i>value</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#QAtomicInteger-1">QAtomicInteger</a></b>(const QAtomicInteger&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#deref">deref</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndAddAcquire">fetchAndAddAcquire</a></b>(T <i>valueToAdd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndAddOrdered">fetchAndAddOrdered</a></b>(T <i>valueToAdd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndAddRelaxed">fetchAndAddRelaxed</a></b>(T <i>valueToAdd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndAddRelease">fetchAndAddRelease</a></b>(T <i>valueToAdd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndAndAcquire">fetchAndAndAcquire</a></b>(T <i>valueToAnd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndAndOrdered">fetchAndAndOrdered</a></b>(T <i>valueToAnd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndAndRelaxed">fetchAndAndRelaxed</a></b>(T <i>valueToAnd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndAndRelease">fetchAndAndRelease</a></b>(T <i>valueToAnd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndOrAcquire">fetchAndOrAcquire</a></b>(T <i>valueToOr</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndOrOrdered">fetchAndOrOrdered</a></b>(T <i>valueToOr</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndOrRelaxed">fetchAndOrRelaxed</a></b>(T <i>valueToOr</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndOrRelease">fetchAndOrRelease</a></b>(T <i>valueToOr</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndStoreAcquire">fetchAndStoreAcquire</a></b>(T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndStoreOrdered">fetchAndStoreOrdered</a></b>(T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndStoreRelaxed">fetchAndStoreRelaxed</a></b>(T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndStoreRelease">fetchAndStoreRelease</a></b>(T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndSubAcquire">fetchAndSubAcquire</a></b>(T <i>valueToSub</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndSubOrdered">fetchAndSubOrdered</a></b>(T <i>valueToSub</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndSubRelaxed">fetchAndSubRelaxed</a></b>(T <i>valueToSub</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndSubRelease">fetchAndSubRelease</a></b>(T <i>valueToSub</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndXorAcquire">fetchAndXorAcquire</a></b>(T <i>valueToXor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndXorOrdered">fetchAndXorOrdered</a></b>(T <i>valueToXor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndXorRelaxed">fetchAndXorRelaxed</a></b>(T <i>valueToXor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#fetchAndXorRelease">fetchAndXorRelease</a></b>(T <i>valueToXor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#load">load</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#loadAcquire">loadAcquire</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#ref">ref</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#store">store</a></b>(T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#storeRelease">storeRelease</a></b>(T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#testAndSetAcquire">testAndSetAcquire</a></b>(T <i>expectedValue</i>, T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#testAndSetOrdered">testAndSetOrdered</a></b>(T <i>expectedValue</i>, T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#testAndSetRelaxed">testAndSetRelaxed</a></b>(T <i>expectedValue</i>, T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#testAndSetRelease">testAndSetRelease</a></b>(T <i>expectedValue</i>, T <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator-T">operator T</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator-and-eq">operator&amp;=</a></b>(T <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator-2b-2b">operator++</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator-2b-2b-1">operator++</a></b>(<i>int</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator-2b-eq">operator+=</a></b>(T <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator--">operator--</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator---1">operator--</a></b>(<i>int</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator--eq">operator-=</a></b>(T <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAtomicInteger&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator-eq">operator=</a></b>(const QAtomicInteger&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAtomicInteger&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator-eq-1">operator=</a></b>(<i>T</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator-5e-eq">operator^=</a></b>(T <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#operator-7c-eq">operator|=</a></b>(T <i>value</i>)</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#isFetchAndAddNative">isFetchAndAddNative</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#isFetchAndAddWaitFree">isFetchAndAddWaitFree</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#isFetchAndStoreNative">isFetchAndStoreNative</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#isFetchAndStoreWaitFree">isFetchAndStoreWaitFree</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#isReferenceCountingNative">isReferenceCountingNative</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#isReferenceCountingWaitFree">isReferenceCountingWaitFree</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#isTestAndSetNative">isTestAndSetNative</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#isTestAndSetWaitFree">isTestAndSetWaitFree</a></b>()</td></tr>
</table></div>
<a name="macros"></a>
<h2 id="macros">宏定义</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_IS_SUPPORTED">Q_ATOMIC_INTnn_IS_SUPPORTED</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE">Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE">Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qatomicinteger.html#Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE">Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE</a></b></td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QAtomicInteger-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qatomicinteger.html">QAtomicInteger</a> class provides platform-independent atomic operations on integers.</p>
<p>For atomic operations on pointers, see the <a href="qatomicpointer.html">QAtomicPointer</a> class.</p>
<p>An <i>atomic</i> operation is a complex operation that completes without interruption. The <a href="qatomicinteger.html">QAtomicInteger</a> class provides atomic reference counting, test-and-set, fetch-and-store, and fetch-and-add for integers.</p>
<p>The template parameter <code>T</code> must be a C++ integer type:</p>
<ul>
<li>8-bit: char, signed char, unsigned char, qint8, quint8</li>
<li>16-bit: short, unsigned short, qint16, quint16, char16_t (C++11)</li>
<li>32-bit: int, unsigned int, qint32, quint32, char32_t (C++11)</li>
<li>64-bit: long long, unsigned long long, qint64, quint64</li>
<li>platform-specific size: long, unsigned long</li>
<li>pointer size: qintptr, quintptr, qptrdiff</li>
</ul>
<p>Of the list above, only the 32-bit- and pointer-sized instantiations are guaranteed to work on all platforms. Support for other sizes depends on the compiler and processor architecture the code is being compiled for. To test whether the other types are supported, check the macro <code>Q_ATOMIC_INT\e{nn}_IS_SUPPORTED</code>, where <code>\e{nn}</code> is the number of bits desired.</p>
<a name="the-atomic-api"></a>
<h3 >The Atomic API</h3>
<a name="reference-counting"></a>
<h4 >Reference counting</h4>
<p>The <a href="qatomicinteger.html#ref">ref</a>() 和 <a href="qatomicinteger.html#deref">deref</a>() functions provide an efficient reference counting API. The return value of these functions are used to indicate when the last reference has been released. These functions allow you to implement your own implicitly shared classes.</p>
<pre class="cpp">

  MySharedType <span class="operator">&amp;</span>MySharedType<span class="operator">::</span><span class="keyword">operator</span><span class="operator">=</span>(<span class="keyword">const</span> MySharedType <span class="operator">&amp;</span>other)
  {
      (<span class="type">void</span>) other<span class="operator">.</span>data<span class="operator">-</span><span class="operator">&gt;</span>atomicInt<span class="operator">.</span>ref();
      <span class="keyword">if</span> (<span class="operator">!</span>data<span class="operator">-</span><span class="operator">&gt;</span>atomicInt<span class="operator">.</span>deref()) {
          <span class="comment">// The last reference has been released</span>
          <span class="keyword">delete</span> d;
      }
      d <span class="operator">=</span> other<span class="operator">.</span>d;
      <span class="keyword">return</span> <span class="operator">*</span><span class="keyword">this</span>;
  }

</pre>
<a name="memory-ordering"></a>
<h4 >Memory ordering</h4>
<p><a href="qatomicinteger.html">QAtomicInteger</a> provides several implementations of the atomic test-and-set, fetch-and-store, and fetch-and-add functions. Each implementation defines a memory ordering semantic that describes how memory accesses surrounding the atomic instruction are executed by the processor. Since many modern architectures allow out-of-order execution and memory ordering, using the correct semantic is necessary to ensure that your application functions properly on all processors.</p>
<ul>
<li>Relaxed - memory ordering is unspecified, leaving the compiler and processor to freely reorder memory accesses.</li>
<li>Acquire - memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</li>
<li>Release - memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</li>
<li>Ordered - the same Acquire and Release semantics combined.</li>
</ul>
<a name="test-and-set"></a>
<h4 >Test-and-set</h4>
<p>If the current value of the <a href="qatomicinteger.html">QAtomicInteger</a> is an expected value, the test-and-set functions assign a new value to the <a href="qatomicinteger.html">QAtomicInteger</a> and return true. If values are <i>not</i> the same, these functions do nothing and return false. This operation equates to the following code:</p>
<pre class="cpp">

  <span class="keyword">if</span> (currentValue <span class="operator">=</span><span class="operator">=</span> expectedValue) {
      currentValue <span class="operator">=</span> newValue;
      <span class="keyword">return</span> <span class="keyword">true</span>;
  }
  <span class="keyword">return</span> <span class="keyword">false</span>;

</pre>
<p>There are 4 test-and-set functions: <a href="qatomicinteger.html#testAndSetRelaxed">testAndSetRelaxed</a>(), <a href="qatomicinteger.html#testAndSetAcquire">testAndSetAcquire</a>(), <a href="qatomicinteger.html#testAndSetRelease">testAndSetRelease</a>(), 和 <a href="qatomicinteger.html#testAndSetOrdered">testAndSetOrdered</a>(). See above for an explanation of the different memory ordering semantics.</p>
<a name="fetch-and-store"></a>
<h4 >Fetch-and-store</h4>
<p>The atomic fetch-and-store functions read the current value of the <a href="qatomicinteger.html">QAtomicInteger</a> and then assign a new value, returning the original value. This operation equates to the following code:</p>
<pre class="cpp">

  <span class="type">int</span> originalValue <span class="operator">=</span> currentValue;
  currentValue <span class="operator">=</span> newValue;
  <span class="keyword">return</span> originalValue;

</pre>
<p>There are 4 fetch-and-store functions: <a href="qatomicinteger.html#fetchAndStoreRelaxed">fetchAndStoreRelaxed</a>(), <a href="qatomicinteger.html#fetchAndStoreAcquire">fetchAndStoreAcquire</a>(), <a href="qatomicinteger.html#fetchAndStoreRelease">fetchAndStoreRelease</a>(), 和 <a href="qatomicinteger.html#fetchAndStoreOrdered">fetchAndStoreOrdered</a>(). See above for an explanation of the different memory ordering semantics.</p>
<a name="fetch-and-add"></a>
<h4 >Fetch-and-add</h4>
<p>The atomic fetch-and-add functions read the current value of the <a href="qatomicinteger.html">QAtomicInteger</a> and then add the given value to the current value, returning the original value. This operation equates to the following code:</p>
<pre class="cpp">

  <span class="type">int</span> originalValue <span class="operator">=</span> currentValue;
  currentValue <span class="operator">+</span><span class="operator">=</span> valueToAdd;
  <span class="keyword">return</span> originalValue;

</pre>
<p>There are 4 fetch-and-add functions: <a href="qatomicinteger.html#fetchAndAddRelaxed">fetchAndAddRelaxed</a>(), <a href="qatomicinteger.html#fetchAndAddAcquire">fetchAndAddAcquire</a>(), <a href="qatomicinteger.html#fetchAndAddRelease">fetchAndAddRelease</a>(), 和 <a href="qatomicinteger.html#fetchAndAddOrdered">fetchAndAddOrdered</a>(). See above for an explanation of the different memory ordering semantics.</p>
<a name="feature-tests-for-the-atomic-api"></a>
<h3 >Feature Tests for the Atomic API</h3>
<p>Providing a platform-independent atomic API that works on all processors is challenging. The API provided by <a href="qatomicinteger.html">QAtomicInteger</a> is guaranteed to work atomically on all processors. However, since not all processors implement support for every operation provided by <a href="qatomicinteger.html">QAtomicInteger</a>, it is necessary to expose information about the processor.</p>
<p>You can check at compile time which features are supported on your hardware using various macros. These will tell you if your hardware always, sometimes, or does not support a particular operation. The macros have the form Q_ATOMIC_INT<i>nn</i>_<i>OPERATION</i>_IS_<i>HOW</i>_NATIVE. <i>nn</i> is the size of the integer (in bits), <i>OPERATION</i> is one of <a href="implicit-sharing.html">REFERENCE_COUNTING</a>, <a href="qatomicpointer.html#test-and-set">TEST_AND_SET</a>, <a href="qatomicpointer.html#fetch-and-store">FETCH_AND_STORE</a>, or <a href="qatomicpointer.html#fetch-and-add">FETCH_AND_ADD</a>, and <i>HOW</i> is one of ALWAYS, SOMETIMES, or NOT. There will always be exactly one defined macro per operation. For example, if Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_ALWAYS_NATIVE is defined, neither Q_ATOMIC_INT_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE nor Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_NOT_NATIVE will be defined.</p>
<p>An operation that completes in constant time is said to be wait-free. Such operations are not implemented using locks or loops of any kind. For atomic operations that are always supported, and that are wait-free, Qt defines the Q_ATOMIC_INT<i>nn</i>_<i>OPERATION</i>_IS_WAIT_FREE in addition to the Q_ATOMIC_INT<i>nn</i>_<i>OPERATION</i>_IS_ALWAYS_NATIVE.</p>
<p>In cases where an atomic operation is only supported in newer generations of the processor, <a href="qatomicinteger.html">QAtomicInteger</a> also provides a way to check at runtime what your hardware supports with the <a href="qatomicinteger.html#isReferenceCountingNative">isReferenceCountingNative</a>(), <a href="qatomicinteger.html#isTestAndSetNative">isTestAndSetNative</a>(), <a href="qatomicinteger.html#isFetchAndStoreNative">isFetchAndStoreNative</a>(), 和 <a href="qatomicinteger.html#isFetchAndAddNative">isFetchAndAddNative</a>() functions. Wait-free implementations can be detected using the <a href="qatomicinteger.html#isReferenceCountingWaitFree">isReferenceCountingWaitFree</a>(), <a href="qatomicinteger.html#isTestAndSetWaitFree">isTestAndSetWaitFree</a>(), <a href="qatomicinteger.html#isFetchAndStoreWaitFree">isFetchAndStoreWaitFree</a>(), 和 <a href="qatomicinteger.html#isFetchAndAddWaitFree">isFetchAndAddWaitFree</a>() functions.</p>
<p>Below is a complete list of all feature macros for <a href="qatomicinteger.html">QAtomicInteger</a>:</p>
<ul>
<li>Q_ATOMIC_INT<i>nn</i>_REFERENCE_COUNTING_IS_ALWAYS_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_REFERENCE_COUNTING_IS_NOT_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_REFERENCE_COUNTING_IS_WAIT_FREE</li>
<li>Q_ATOMIC_INT<i>nn</i>_TEST_AND_SET_IS_ALWAYS_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_TEST_AND_SET_IS_SOMETIMES_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_TEST_AND_SET_IS_NOT_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_TEST_AND_SET_IS_WAIT_FREE</li>
<li>Q_ATOMIC_INT<i>nn</i>_FETCH_AND_STORE_IS_ALWAYS_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_FETCH_AND_STORE_IS_NOT_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_FETCH_AND_STORE_IS_WAIT_FREE</li>
<li>Q_ATOMIC_INT<i>nn</i>_FETCH_AND_ADD_IS_ALWAYS_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_FETCH_AND_ADD_IS_NOT_NATIVE</li>
<li>Q_ATOMIC_INT<i>nn</i>_FETCH_AND_ADD_IS_WAIT_FREE</li>
</ul>
<p>For compatibility with previous versions of Qt, macros with an empty <i>nn</i> are equivalent to the 32-bit macros. For example, Q_ATOMIC_INT_REFERENCE_COUNTING_IS_WAIT_FREE is the same as Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_WAIT_FREE.</p>
</div>
<p><b> 参见 </b><a href="qatomicpointer.html">QAtomicPointer</a>.</p>
<!-- @@@QAtomicInteger -->
<div class="types">
<h2>成员类型文档</h2>
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QAtomicInteger[overload1]$$$QAtomicIntegerT -->
<h3 class="fn" id="QAtomicInteger"><a name="QAtomicInteger"></a>QAtomicInteger::<span class="name">QAtomicInteger</span>(<span class="type">T</span> <i>value</i> = 0)</h3>
<p>Default constructs an instance of QAtomicInteger.</p><!-- @@@QAtomicInteger -->
<!-- $$$QAtomicInteger$$$QAtomicIntegerconstQAtomicInteger<T>& -->
<h3 class="fn" id="QAtomicInteger-1"><a name="QAtomicInteger-1"></a>QAtomicInteger::<span class="name">QAtomicInteger</span>(const <span class="type"><a href="qatomicinteger.html#QAtomicInteger">QAtomicInteger</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>拷贝构造函数，参数为 <i>other</i>。</p>
<!-- @@@QAtomicInteger -->
<!-- $$$deref[overload1]$$$deref -->
<h3 class="fn" id="deref"><a name="deref"></a><span class="type">bool</span> QAtomicInteger::<span class="name">deref</span>()</h3>
<p>Atomically decrements the value of this <a href="qatomicinteger.html">QAtomicInteger</a>. Returns <code>true</code> if the new value is non-zero, false otherwise.</p>
<p>This function uses <i>ordered</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#ref">ref</a>() 和 <a href="qatomicinteger.html#operator--">operator--</a>().</p>
<!-- @@@deref -->
<!-- $$$fetchAndAddAcquire[overload1]$$$fetchAndAddAcquireT -->
<h3 class="fn" id="fetchAndAddAcquire"><a name="fetchAndAddAcquire"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndAddAcquire</span>(<span class="type">T</span> <i>valueToAdd</i>)</h3>
<p>Atomic fetch-and-add.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then adds <i>valueToAdd</i> to the current value, returning the original value.</p>
<p>This function uses <i>acquire</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-2b-eq">operator+=</a>() 和 <a href="qatomicinteger.html#fetchAndSubAcquire">fetchAndSubAcquire</a>().</p>
<!-- @@@fetchAndAddAcquire -->
<!-- $$$fetchAndAddOrdered[overload1]$$$fetchAndAddOrderedT -->
<h3 class="fn" id="fetchAndAddOrdered"><a name="fetchAndAddOrdered"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndAddOrdered</span>(<span class="type">T</span> <i>valueToAdd</i>)</h3>
<p>Atomic fetch-and-add.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then adds <i>valueToAdd</i> to the current value, returning the original value.</p>
<p>This function uses <i>ordered</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-2b-eq">operator+=</a>() 和 <a href="qatomicinteger.html#fetchAndSubOrdered">fetchAndSubOrdered</a>().</p>
<!-- @@@fetchAndAddOrdered -->
<!-- $$$fetchAndAddRelaxed[overload1]$$$fetchAndAddRelaxedT -->
<h3 class="fn" id="fetchAndAddRelaxed"><a name="fetchAndAddRelaxed"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndAddRelaxed</span>(<span class="type">T</span> <i>valueToAdd</i>)</h3>
<p>Atomic fetch-and-add.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then adds <i>valueToAdd</i> to the current value, returning the original value.</p>
<p>This function uses <i>relaxed</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-2b-eq">operator+=</a>() 和 <a href="qatomicinteger.html#fetchAndSubRelaxed">fetchAndSubRelaxed</a>().</p>
<!-- @@@fetchAndAddRelaxed -->
<!-- $$$fetchAndAddRelease[overload1]$$$fetchAndAddReleaseT -->
<h3 class="fn" id="fetchAndAddRelease"><a name="fetchAndAddRelease"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndAddRelease</span>(<span class="type">T</span> <i>valueToAdd</i>)</h3>
<p>Atomic fetch-and-add.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then adds <i>valueToAdd</i> to the current value, returning the original value.</p>
<p>This function uses <i>release</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-2b-eq">operator+=</a>() 和 <a href="qatomicinteger.html#fetchAndSubRelease">fetchAndSubRelease</a>().</p>
<!-- @@@fetchAndAddRelease -->
<!-- $$$fetchAndAndAcquire[overload1]$$$fetchAndAndAcquireT -->
<h3 class="fn" id="fetchAndAndAcquire"><a name="fetchAndAndAcquire"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndAndAcquire</span>(<span class="type">T</span> <i>valueToAnd</i>)</h3>
<p>Atomic fetch-and-and.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ANDs <i>valueToAnd</i> to the current value, returning the original value.</p>
<p>This function uses <i>acquire</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-and-eq">operator&amp;=</a>().</p>
<!-- @@@fetchAndAndAcquire -->
<!-- $$$fetchAndAndOrdered[overload1]$$$fetchAndAndOrderedT -->
<h3 class="fn" id="fetchAndAndOrdered"><a name="fetchAndAndOrdered"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndAndOrdered</span>(<span class="type">T</span> <i>valueToAnd</i>)</h3>
<p>Atomic fetch-and-and.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ANDs <i>valueToAnd</i> to the current value, returning the original value.</p>
<p>This function uses <i>ordered</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-and-eq">operator&amp;=</a>().</p>
<!-- @@@fetchAndAndOrdered -->
<!-- $$$fetchAndAndRelaxed[overload1]$$$fetchAndAndRelaxedT -->
<h3 class="fn" id="fetchAndAndRelaxed"><a name="fetchAndAndRelaxed"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndAndRelaxed</span>(<span class="type">T</span> <i>valueToAnd</i>)</h3>
<p>Atomic fetch-and-and.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ANDs <i>valueToAnd</i> to the current value, returning the original value.</p>
<p>This function uses <i>relaxed</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-and-eq">operator&amp;=</a>().</p>
<!-- @@@fetchAndAndRelaxed -->
<!-- $$$fetchAndAndRelease[overload1]$$$fetchAndAndReleaseT -->
<h3 class="fn" id="fetchAndAndRelease"><a name="fetchAndAndRelease"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndAndRelease</span>(<span class="type">T</span> <i>valueToAnd</i>)</h3>
<p>Atomic fetch-and-and.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ANDs <i>valueToAnd</i> to the current value, returning the original value.</p>
<p>This function uses <i>release</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-and-eq">operator&amp;=</a>().</p>
<!-- @@@fetchAndAndRelease -->
<!-- $$$fetchAndOrAcquire[overload1]$$$fetchAndOrAcquireT -->
<h3 class="fn" id="fetchAndOrAcquire"><a name="fetchAndOrAcquire"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndOrAcquire</span>(<span class="type">T</span> <i>valueToOr</i>)</h3>
<p>Atomic fetch-and-or.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ORs <i>valueToOr</i> to the current value, returning the original value.</p>
<p>This function uses <i>acquire</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-7c-eq">operator|=</a>().</p>
<!-- @@@fetchAndOrAcquire -->
<!-- $$$fetchAndOrOrdered[overload1]$$$fetchAndOrOrderedT -->
<h3 class="fn" id="fetchAndOrOrdered"><a name="fetchAndOrOrdered"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndOrOrdered</span>(<span class="type">T</span> <i>valueToOr</i>)</h3>
<p>Atomic fetch-and-or.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ORs <i>valueToOr</i> to the current value, returning the original value.</p>
<p>This function uses <i>ordered</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-7c-eq">operator|=</a>().</p>
<!-- @@@fetchAndOrOrdered -->
<!-- $$$fetchAndOrRelaxed[overload1]$$$fetchAndOrRelaxedT -->
<h3 class="fn" id="fetchAndOrRelaxed"><a name="fetchAndOrRelaxed"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndOrRelaxed</span>(<span class="type">T</span> <i>valueToOr</i>)</h3>
<p>Atomic fetch-and-or.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ORs <i>valueToOr</i> to the current value, returning the original value.</p>
<p>This function uses <i>relaxed</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-7c-eq">operator|=</a>().</p>
<!-- @@@fetchAndOrRelaxed -->
<!-- $$$fetchAndOrRelease[overload1]$$$fetchAndOrReleaseT -->
<h3 class="fn" id="fetchAndOrRelease"><a name="fetchAndOrRelease"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndOrRelease</span>(<span class="type">T</span> <i>valueToOr</i>)</h3>
<p>Atomic fetch-and-or.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ORs <i>valueToOr</i> to the current value, returning the original value.</p>
<p>This function uses <i>release</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-7c-eq">operator|=</a>().</p>
<!-- @@@fetchAndOrRelease -->
<!-- $$$fetchAndStoreAcquire[overload1]$$$fetchAndStoreAcquireT -->
<h3 class="fn" id="fetchAndStoreAcquire"><a name="fetchAndStoreAcquire"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndStoreAcquire</span>(<span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomic fetch-and-store.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then assigns it the <i>newValue</i>, returning the original value.</p>
<p>This function uses <i>acquire</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<!-- @@@fetchAndStoreAcquire -->
<!-- $$$fetchAndStoreOrdered[overload1]$$$fetchAndStoreOrderedT -->
<h3 class="fn" id="fetchAndStoreOrdered"><a name="fetchAndStoreOrdered"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndStoreOrdered</span>(<span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomic fetch-and-store.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then assigns it the <i>newValue</i>, returning the original value.</p>
<p>This function uses <i>ordered</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<!-- @@@fetchAndStoreOrdered -->
<!-- $$$fetchAndStoreRelaxed[overload1]$$$fetchAndStoreRelaxedT -->
<h3 class="fn" id="fetchAndStoreRelaxed"><a name="fetchAndStoreRelaxed"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndStoreRelaxed</span>(<span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomic fetch-and-store.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then assigns it the <i>newValue</i>, returning the original value.</p>
<p>This function uses <i>relaxed</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<!-- @@@fetchAndStoreRelaxed -->
<!-- $$$fetchAndStoreRelease[overload1]$$$fetchAndStoreReleaseT -->
<h3 class="fn" id="fetchAndStoreRelease"><a name="fetchAndStoreRelease"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndStoreRelease</span>(<span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomic fetch-and-store.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then assigns it the <i>newValue</i>, returning the original value.</p>
<p>This function uses <i>release</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<!-- @@@fetchAndStoreRelease -->
<!-- $$$fetchAndSubAcquire[overload1]$$$fetchAndSubAcquireT -->
<h3 class="fn" id="fetchAndSubAcquire"><a name="fetchAndSubAcquire"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndSubAcquire</span>(<span class="type">T</span> <i>valueToSub</i>)</h3>
<p>Atomic fetch-and-sub.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then subtracts <i>valueToSub</i> to the current value, returning the original value.</p>
<p>This function uses <i>acquire</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator--eq">operator-=</a>() 和 <a href="qatomicinteger.html#fetchAndAddAcquire">fetchAndAddAcquire</a>().</p>
<!-- @@@fetchAndSubAcquire -->
<!-- $$$fetchAndSubOrdered[overload1]$$$fetchAndSubOrderedT -->
<h3 class="fn" id="fetchAndSubOrdered"><a name="fetchAndSubOrdered"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndSubOrdered</span>(<span class="type">T</span> <i>valueToSub</i>)</h3>
<p>Atomic fetch-and-sub.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then subtracts <i>valueToSub</i> to the current value, returning the original value.</p>
<p>This function uses <i>ordered</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator--eq">operator-=</a>() 和 <a href="qatomicinteger.html#fetchAndAddOrdered">fetchAndAddOrdered</a>().</p>
<!-- @@@fetchAndSubOrdered -->
<!-- $$$fetchAndSubRelaxed[overload1]$$$fetchAndSubRelaxedT -->
<h3 class="fn" id="fetchAndSubRelaxed"><a name="fetchAndSubRelaxed"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndSubRelaxed</span>(<span class="type">T</span> <i>valueToSub</i>)</h3>
<p>Atomic fetch-and-sub.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then subtracts <i>valueToSub</i> to the current value, returning the original value.</p>
<p>This function uses <i>relaxed</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator--eq">operator-=</a>() 和 <a href="qatomicinteger.html#fetchAndAddRelaxed">fetchAndAddRelaxed</a>().</p>
<!-- @@@fetchAndSubRelaxed -->
<!-- $$$fetchAndSubRelease[overload1]$$$fetchAndSubReleaseT -->
<h3 class="fn" id="fetchAndSubRelease"><a name="fetchAndSubRelease"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndSubRelease</span>(<span class="type">T</span> <i>valueToSub</i>)</h3>
<p>Atomic fetch-and-sub.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then subtracts <i>valueToSub</i> to the current value, returning the original value.</p>
<p>This function uses <i>release</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator--eq">operator-=</a>() 和 <a href="qatomicinteger.html#fetchAndAddRelease">fetchAndAddRelease</a>().</p>
<!-- @@@fetchAndSubRelease -->
<!-- $$$fetchAndXorAcquire[overload1]$$$fetchAndXorAcquireT -->
<h3 class="fn" id="fetchAndXorAcquire"><a name="fetchAndXorAcquire"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndXorAcquire</span>(<span class="type">T</span> <i>valueToXor</i>)</h3>
<p>Atomic fetch-and-xor.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-XORs <i>valueToXor</i> to the current value, returning the original value.</p>
<p>This function uses <i>acquire</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-5e-eq">operator^=</a>().</p>
<!-- @@@fetchAndXorAcquire -->
<!-- $$$fetchAndXorOrdered[overload1]$$$fetchAndXorOrderedT -->
<h3 class="fn" id="fetchAndXorOrdered"><a name="fetchAndXorOrdered"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndXorOrdered</span>(<span class="type">T</span> <i>valueToXor</i>)</h3>
<p>Atomic fetch-and-xor.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-XORs <i>valueToXor</i> to the current value, returning the original value.</p>
<p>This function uses <i>ordered</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-5e-eq">operator^=</a>().</p>
<!-- @@@fetchAndXorOrdered -->
<!-- $$$fetchAndXorRelaxed[overload1]$$$fetchAndXorRelaxedT -->
<h3 class="fn" id="fetchAndXorRelaxed"><a name="fetchAndXorRelaxed"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndXorRelaxed</span>(<span class="type">T</span> <i>valueToXor</i>)</h3>
<p>Atomic fetch-and-xor.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-XORs <i>valueToXor</i> to the current value, returning the original value.</p>
<p>This function uses <i>relaxed</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-5e-eq">operator^=</a>().</p>
<!-- @@@fetchAndXorRelaxed -->
<!-- $$$fetchAndXorRelease[overload1]$$$fetchAndXorReleaseT -->
<h3 class="fn" id="fetchAndXorRelease"><a name="fetchAndXorRelease"></a><span class="type">T</span> QAtomicInteger::<span class="name">fetchAndXorRelease</span>(<span class="type">T</span> <i>valueToXor</i>)</h3>
<p>Atomic fetch-and-xor.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-XORs <i>valueToXor</i> to the current value, returning the original value.</p>
<p>This function uses <i>release</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#operator-5e-eq">operator^=</a>().</p>
<!-- @@@fetchAndXorRelease -->
<!-- $$$isFetchAndAddNative[overload1]$$$isFetchAndAddNative -->
<h3 class="fn" id="isFetchAndAddNative"><a name="isFetchAndAddNative"></a><code>[static] </code><span class="type">bool</span> QAtomicInteger::<span class="name">isFetchAndAddNative</span>()</h3>
<p>Returns <code>true</code> if fetch-and-add is implemented using atomic processor instructions, false otherwise.</p>
<!-- @@@isFetchAndAddNative -->
<!-- $$$isFetchAndAddWaitFree[overload1]$$$isFetchAndAddWaitFree -->
<h3 class="fn" id="isFetchAndAddWaitFree"><a name="isFetchAndAddWaitFree"></a><code>[static] </code><span class="type">bool</span> QAtomicInteger::<span class="name">isFetchAndAddWaitFree</span>()</h3>
<p>Returns <code>true</code> if atomic fetch-and-add is wait-free, false otherwise.</p>
<!-- @@@isFetchAndAddWaitFree -->
<!-- $$$isFetchAndStoreNative[overload1]$$$isFetchAndStoreNative -->
<h3 class="fn" id="isFetchAndStoreNative"><a name="isFetchAndStoreNative"></a><code>[static] </code><span class="type">bool</span> QAtomicInteger::<span class="name">isFetchAndStoreNative</span>()</h3>
<p>Returns <code>true</code> if fetch-and-store is implemented using atomic processor instructions, false otherwise.</p>
<!-- @@@isFetchAndStoreNative -->
<!-- $$$isFetchAndStoreWaitFree[overload1]$$$isFetchAndStoreWaitFree -->
<h3 class="fn" id="isFetchAndStoreWaitFree"><a name="isFetchAndStoreWaitFree"></a><code>[static] </code><span class="type">bool</span> QAtomicInteger::<span class="name">isFetchAndStoreWaitFree</span>()</h3>
<p>Returns <code>true</code> if atomic fetch-and-store is wait-free, false otherwise.</p>
<!-- @@@isFetchAndStoreWaitFree -->
<!-- $$$isReferenceCountingNative[overload1]$$$isReferenceCountingNative -->
<h3 class="fn" id="isReferenceCountingNative"><a name="isReferenceCountingNative"></a><code>[static] </code><span class="type">bool</span> QAtomicInteger::<span class="name">isReferenceCountingNative</span>()</h3>
<p>Returns <code>true</code> if reference counting is implemented using atomic processor instructions, false otherwise.</p>
<!-- @@@isReferenceCountingNative -->
<!-- $$$isReferenceCountingWaitFree[overload1]$$$isReferenceCountingWaitFree -->
<h3 class="fn" id="isReferenceCountingWaitFree"><a name="isReferenceCountingWaitFree"></a><code>[static] </code><span class="type">bool</span> QAtomicInteger::<span class="name">isReferenceCountingWaitFree</span>()</h3>
<p>Returns <code>true</code> if atomic reference counting is wait-free, false otherwise.</p>
<!-- @@@isReferenceCountingWaitFree -->
<!-- $$$isTestAndSetNative[overload1]$$$isTestAndSetNative -->
<h3 class="fn" id="isTestAndSetNative"><a name="isTestAndSetNative"></a><code>[static] </code><span class="type">bool</span> QAtomicInteger::<span class="name">isTestAndSetNative</span>()</h3>
<p>Returns <code>true</code> if test-and-set is implemented using atomic processor instructions, false otherwise.</p>
<!-- @@@isTestAndSetNative -->
<!-- $$$isTestAndSetWaitFree[overload1]$$$isTestAndSetWaitFree -->
<h3 class="fn" id="isTestAndSetWaitFree"><a name="isTestAndSetWaitFree"></a><code>[static] </code><span class="type">bool</span> QAtomicInteger::<span class="name">isTestAndSetWaitFree</span>()</h3>
<p>Returns <code>true</code> if atomic test-and-set is wait-free, false otherwise.</p>
<!-- @@@isTestAndSetWaitFree -->
<!-- $$$load[overload1]$$$load -->
<h3 class="fn" id="load"><a name="load"></a><span class="type">T</span> QAtomicInteger::<span class="name">load</span>() const</h3>
<p>Atomically loads the value of this <a href="qatomicinteger.html">QAtomicInteger</a> using relaxed memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#store">store</a>() 和 <a href="qatomicinteger.html#loadAcquire">loadAcquire</a>().</p>
<!-- @@@load -->
<!-- $$$loadAcquire[overload1]$$$loadAcquire -->
<h3 class="fn" id="loadAcquire"><a name="loadAcquire"></a><span class="type">T</span> QAtomicInteger::<span class="name">loadAcquire</span>() const</h3>
<p>Atomically loads the value of this <a href="qatomicinteger.html">QAtomicInteger</a> using the &quot;Acquire&quot; memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#store">store</a>() 和 <a href="qatomicinteger.html#load">load</a>().</p>
<!-- @@@loadAcquire -->
<!-- $$$ref[overload1]$$$ref -->
<h3 class="fn" id="ref"><a name="ref"></a><span class="type">bool</span> QAtomicInteger::<span class="name">ref</span>()</h3>
<p>Atomically increments the value of this <a href="qatomicinteger.html">QAtomicInteger</a>. Returns <code>true</code> if the new value is non-zero, false otherwise.</p>
<p>This function uses <i>ordered</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#deref">deref</a>() 和 <a href="qatomicinteger.html#operator-2b-2b">operator++</a>().</p>
<!-- @@@ref -->
<!-- $$$store[overload1]$$$storeT -->
<h3 class="fn" id="store"><a name="store"></a><span class="type">void</span> QAtomicInteger::<span class="name">store</span>(<span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomically stores the <i>newValue</i> value into this atomic type, using relaxed memory ordering.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#storeRelease">storeRelease</a>() 和 <a href="qatomicinteger.html#load">load</a>().</p>
<!-- @@@store -->
<!-- $$$storeRelease[overload1]$$$storeReleaseT -->
<h3 class="fn" id="storeRelease"><a name="storeRelease"></a><span class="type">void</span> QAtomicInteger::<span class="name">storeRelease</span>(<span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomically stores the <i>newValue</i> value into this atomic type, using the &quot;Release&quot; memory ordering.</p>
<p><b> 参见 </b><a href="qatomicinteger.html#store">store</a>() 和 <a href="qatomicinteger.html#load">load</a>().</p>
<!-- @@@storeRelease -->
<!-- $$$testAndSetAcquire[overload1]$$$testAndSetAcquireTT -->
<h3 class="fn" id="testAndSetAcquire"><a name="testAndSetAcquire"></a><span class="type">bool</span> QAtomicInteger::<span class="name">testAndSetAcquire</span>(<span class="type">T</span> <i>expectedValue</i>, <span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomic test-and-set.</p>
<p>If the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> is the <i>expectedValue</i>, the test-and-set functions assign the <i>newValue</i> to this <a href="qatomicinteger.html">QAtomicInteger</a> and return true. If the values are <i>not</i> the same, this function does nothing and returns <code>false</code>.</p>
<p>This function uses <i>acquire</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<!-- @@@testAndSetAcquire -->
<!-- $$$testAndSetOrdered[overload1]$$$testAndSetOrderedTT -->
<h3 class="fn" id="testAndSetOrdered"><a name="testAndSetOrdered"></a><span class="type">bool</span> QAtomicInteger::<span class="name">testAndSetOrdered</span>(<span class="type">T</span> <i>expectedValue</i>, <span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomic test-and-set.</p>
<p>If the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> is the <i>expectedValue</i>, the test-and-set functions assign the <i>newValue</i> to this <a href="qatomicinteger.html">QAtomicInteger</a> and return true. If the values are <i>not</i> the same, this function does nothing and returns <code>false</code>.</p>
<p>This function uses <i>ordered</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<!-- @@@testAndSetOrdered -->
<!-- $$$testAndSetRelaxed[overload1]$$$testAndSetRelaxedTT -->
<h3 class="fn" id="testAndSetRelaxed"><a name="testAndSetRelaxed"></a><span class="type">bool</span> QAtomicInteger::<span class="name">testAndSetRelaxed</span>(<span class="type">T</span> <i>expectedValue</i>, <span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomic test-and-set.</p>
<p>If the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> is the <i>expectedValue</i>, the test-and-set functions assign the <i>newValue</i> to this <a href="qatomicinteger.html">QAtomicInteger</a> and return true. If the values are <i>not</i> the same, this function does nothing and returns <code>false</code>.</p>
<p>This function uses <i>relaxed</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<!-- @@@testAndSetRelaxed -->
<!-- $$$testAndSetRelease[overload1]$$$testAndSetReleaseTT -->
<h3 class="fn" id="testAndSetRelease"><a name="testAndSetRelease"></a><span class="type">bool</span> QAtomicInteger::<span class="name">testAndSetRelease</span>(<span class="type">T</span> <i>expectedValue</i>, <span class="type">T</span> <i>newValue</i>)</h3>
<p>Atomic test-and-set.</p>
<p>If the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> is the <i>expectedValue</i>, the test-and-set functions assign the <i>newValue</i> to this <a href="qatomicinteger.html">QAtomicInteger</a> and return true. If the values are <i>not</i> the same, this function does nothing and returns <code>false</code>.</p>
<p>This function uses <i>release</i> <a href="qatomicinteger.html#memory-ordering">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<!-- @@@testAndSetRelease -->
<!-- $$$operator T[overload1]$$$operator T -->
<h3 class="fn" id="operator-T"><a name="operator-T"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator T</span>() const</h3>
<p>Atomically loads the value of this <a href="qatomicinteger.html">QAtomicInteger</a> using a sequentially consistent memory ordering if possible; or &quot;Acquire&quot; ordering if not. The value is not modified in any way, but note that there's no guarantee that it remains so.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#load">load</a>() 和 <a href="qatomicinteger.html#loadAcquire">loadAcquire</a>().</p>
<!-- @@@operator T -->
<!-- $$$operator&=[overload1]$$$operator&=T -->
<h3 class="fn" id="operator-and-eq"><a name="operator-and-eq"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator&amp;=</span>(<span class="type">T</span> <i>value</i>)</h3>
<p>Atomic add-and-fetch.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ANDs <i>value</i> to the current value, returning the new value.</p>
<p>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#fetchAndAndOrdered">fetchAndAndOrdered</a>().</p>
<!-- @@@operator&= -->
<!-- $$$operator++[overload1]$$$operator++ -->
<h3 class="fn" id="operator-2b-2b"><a name="operator-2b-2b"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator++</span>()</h3>
<p>Atomically pre-increments the value of this <a href="qatomicinteger.html">QAtomicInteger</a>. Returns the new value of this atomic.</p>
<p>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#ref">ref</a>(), <a href="qatomicinteger.html#operator-2b-2b-1">operator++</a>(int), and <a href="qatomicinteger.html#operator--">operator--</a>().</p>
<!-- @@@operator++ -->
<!-- $$$operator++$$$operator++int -->
<h3 class="fn" id="operator-2b-2b-1"><a name="operator-2b-2b-1"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator++</span>(<i>int</i>)</h3>
<p>Atomically post-increments the value of this <a href="qatomicinteger.html">QAtomicInteger</a>. Returns the old value of this atomic.</p>
<p>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#ref">ref</a>(), <a href="qatomicinteger.html#operator-2b-2b">operator++</a>(), 和 <a href="qatomicinteger.html#operator---1">operator--</a>(int).</p>
<!-- @@@operator++ -->
<!-- $$$operator+=[overload1]$$$operator+=T -->
<h3 class="fn" id="operator-2b-eq"><a name="operator-2b-eq"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator+=</span>(<span class="type">T</span> <i>value</i>)</h3>
<p>Atomic add-and-fetch.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then adds <i>value</i> to the current value, returning the new value.</p>
<p>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#fetchAndAddOrdered">fetchAndAddOrdered</a>() 和 <a href="qatomicinteger.html#operator--eq">operator-=</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator--[overload1]$$$operator-- -->
<h3 class="fn" id="operator--"><a name="operator--"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator--</span>()</h3>
<p>Atomically pre-decrements the value of this <a href="qatomicinteger.html">QAtomicInteger</a>. Returns the new value of this atomic.</p>
<p>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#deref">deref</a>(), <a href="qatomicinteger.html#operator---1">operator--</a>(int), and <a href="qatomicinteger.html#operator-2b-2b">operator++</a>().</p>
<!-- @@@operator-- -->
<!-- $$$operator--$$$operator--int -->
<h3 class="fn" id="operator---1"><a name="operator---1"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator--</span>(<i>int</i>)</h3>
<p>Atomically post-decrements the value of this <a href="qatomicinteger.html">QAtomicInteger</a>. Returns the old value of this atomic.</p>
<p>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#deref">deref</a>(), <a href="qatomicinteger.html#operator--">operator--</a>(), 和 <a href="qatomicinteger.html#operator-2b-2b-1">operator++</a>(int).</p>
<!-- @@@operator-- -->
<!-- $$$operator-=[overload1]$$$operator-=T -->
<h3 class="fn" id="operator--eq"><a name="operator--eq"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator-=</span>(<span class="type">T</span> <i>value</i>)</h3>
<p>Atomic sub-and-fetch.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then subtracts <i>value</i> to the current value, returning the new value.</p>
<p>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#fetchAndSubOrdered">fetchAndSubOrdered</a>() 和 <a href="qatomicinteger.html#operator-2b-eq">operator+=</a>().</p>
<!-- @@@operator-= -->
<!-- $$$operator=[overload1]$$$operator=constQAtomicInteger<T>& -->
<h3 class="fn" id="operator-eq"><a name="operator-eq"></a><span class="type"><a href="qatomicinteger.html#QAtomicInteger">QAtomicInteger</a></span>&lt;<span class="type">T</span>&gt; &amp;QAtomicInteger::<span class="name">operator=</span>(const <span class="type"><a href="qatomicinteger.html#QAtomicInteger">QAtomicInteger</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Assigns <i>other</i> to this <a href="qatomicinteger.html">QAtomicInteger</a> and returns a reference to this <a href="qatomicinteger.html">QAtomicInteger</a>.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=T -->
<h3 class="fn" id="operator-eq-1"><a name="operator-eq-1"></a><span class="type"><a href="qatomicinteger.html#QAtomicInteger">QAtomicInteger</a></span>&lt;<span class="type">T</span>&gt; &amp;QAtomicInteger::<span class="name">operator=</span>(<i>T</i>)</h3>
<p>Atomically stores the other value into this atomic type using a sequentially consistent memory ordering if possible; or &quot;Release&quot; ordering if not. This function returns a reference to this object.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#store">store</a>() 和 <a href="qatomicinteger.html#storeRelease">storeRelease</a>().</p>
<!-- @@@operator= -->
<!-- $$$operator^=[overload1]$$$operator^=T -->
<h3 class="fn" id="operator-5e-eq"><a name="operator-5e-eq"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator^=</span>(<span class="type">T</span> <i>value</i>)</h3>
<p>Atomic xor-and-fetch.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-XORs <i>value</i> to the current value, returning the new value.</p>
<p>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#fetchAndXorOrdered">fetchAndXorOrdered</a>().</p>
<!-- @@@operator^= -->
<!-- $$$operator|=[overload1]$$$operator|=T -->
<h3 class="fn" id="operator-7c-eq"><a name="operator-7c-eq"></a><span class="type">T</span> QAtomicInteger::<span class="name">operator|=</span>(<span class="type">T</span> <i>value</i>)</h3>
<p>Atomic or-and-fetch.</p>
<p>Reads the current value of this <a href="qatomicinteger.html">QAtomicInteger</a> and then bitwise-ORs <i>value</i> to the current value, returning the new value.</p>
<p>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b> 参见 </b><a href="qatomicinteger.html#fetchAndOrOrdered">fetchAndOrOrdered</a>().</p>
<!-- @@@operator|= -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
<!-- $$$Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE[overload1]$$$Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE"><a name="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE</span></h3>
<p>This macro is defined if and only if your processor supports atomic fetch-and-add on integers.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE[overload1]$$$Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE"><a name="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE</span></h3>
<p>This macro is defined when the hardware does not support atomic fetch-and-add on integers.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE[overload1]$$$Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE"><a name="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</span></h3>
<p>This macro is defined when only certain generations of the processor support atomic fetch-and-add on integers. Use the <a href="qatomicinteger.html">QAtomicInteger</a>&lt;T&gt;::isFetchAndAddNative() function to check what your processor supports.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE[overload1]$$$Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE"><a name="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE"></a><span class="name">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE</span></h3>
<p>This macro is defined together with <a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE</a> to indicate that the atomic fetch-and-add on integers is wait-free.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE -->
<!-- $$$Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE[overload1]$$$Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE"><a name="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE</span></h3>
<p>This macro is defined if and only if your processor supports atomic fetch-and-store on integers.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE[overload1]$$$Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE"><a name="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE</span></h3>
<p>This macro is defined when the hardware does not support atomic fetch-and-store on integers.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE[overload1]$$$Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE"><a name="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</span></h3>
<p>This macro is defined when only certain generations of the processor support atomic fetch-and-store on integers. Use the <a href="qatomicinteger.html">QAtomicInteger</a>&lt;T&gt;::isFetchAndStoreNative() function to check what your processor supports.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE[overload1]$$$Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE"><a name="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE"></a><span class="name">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE</span></h3>
<p>This macro is defined together with <a href="qatomicinteger.html#Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE</a> to indicate that the atomic fetch-and-store on integers is wait-free.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE -->
<!-- $$$Q_ATOMIC_INTnn_IS_SUPPORTED[overload1]$$$Q_ATOMIC_INTnn_IS_SUPPORTED -->
<h3 class="fn" id="Q_ATOMIC_INTnn_IS_SUPPORTED"><a name="Q_ATOMIC_INTnn_IS_SUPPORTED"></a><span class="name">Q_ATOMIC_INTnn_IS_SUPPORTED</span></h3>
<p>This macro is defined if atomic integers of size <i>nn</i> (in bits) are supported in this compiler / architecture combination. Q_ATOMIC_INT32_IS_SUPPORTED is always defined.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_IS_SUPPORTED -->
<!-- $$$Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE[overload1]$$$Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE"><a name="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE</span></h3>
<p>This macro is defined if and only if all generations of your processor support atomic reference counting.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE[overload1]$$$Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE"><a name="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE</span></h3>
<p>This macro is defined when the hardware does not support atomic reference counting.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE[overload1]$$$Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE"><a name="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE</span></h3>
<p>This macro is defined when only certain generations of the processor support atomic reference counting. Use the <a href="qatomicinteger.html">QAtomicInteger</a>&lt;T&gt;::isReferenceCountingNative() function to check what your processor supports.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE[overload1]$$$Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE"><a name="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE"></a><span class="name">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE</span></h3>
<p>This macro is defined together with <a href="qatomicinteger.html#Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE</a> to indicate that the reference counting is wait-free.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE -->
<!-- $$$Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE[overload1]$$$Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE"><a name="Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE</span></h3>
<p>This macro is defined if and only if your processor supports atomic test-and-set on integers.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE[overload1]$$$Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE"><a name="Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE</span></h3>
<p>This macro is defined when the hardware does not support atomic test-and-set on integers.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE[overload1]$$$Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE"><a name="Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE"></a><span class="name">Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE</span></h3>
<p>This macro is defined when only certain generations of the processor support atomic test-and-set on integers. Use the <a href="qatomicinteger.html">QAtomicInteger</a>&lt;T&gt;::isTestAndSetNative() function to check what your processor supports.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE -->
<!-- $$$Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE[overload1]$$$Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE -->
<h3 class="fn" id="Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE"><a name="Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE"></a><span class="name">Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE</span></h3>
<p>This macro is defined together with <a href="qatomicinteger.html#Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE</a> to indicate that the atomic test-and-set on integers is wait-free.</p>
<p><i>nn</i> is the size of the integer, in bits (8, 16, 32 or 64).</p>
<!-- @@@Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
