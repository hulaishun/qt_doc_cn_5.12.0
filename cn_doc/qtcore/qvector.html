<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qvector.qdoc -->
  <title>QVector Class | Qt核心模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QVector</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#related-non-members">相关非成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#more-information-on-using-qt-containers">有关使用Qt容器的更多信息</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QVector Class</h1>
<!-- $$$QVector-brief -->
<p>The <a href="qvector.html">QVector</a> class is a template class that provides a dynamic array. <a href="#details">更多详情...</a></p>
<!-- @@@QVector -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QVector&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的子类有：</td><td class="memItemRight bottomAlign"> <p><a href="qstack.html">QStack</a></p>
</td></tr></table></div><ul>
<li><a href="qvector-members.html">所有成员清单，包括继承而来的成员</a></li>
</ul>
<p><b>注意：</b> 此类中的所有函数都是 <a href="../qtdoc/threads-reentrancy.html">可重入的。</a></p>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#ConstIterator-typedef">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#Iterator-typedef">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#const_iterator-typedef">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#const_pointer-typedef">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#const_reference-typedef">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#const_reverse_iterator-typedef">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#difference_type-typedef">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#iterator-typedefx">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#pointer-typedef">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#reference-typedef">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#reverse_iterator-typedef">reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#size_type-typedef">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#value_type-typedef">value_type</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#QVector">QVector</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#QVector-1">QVector</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#QVector-2">QVector</a></b>(int <i>size</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#QVector-3">QVector</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#QVector-4">QVector</a></b>(QVector&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#QVector-5">QVector</a></b>(std::initializer_list&lt;T&gt; <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#dtor.QVector">~QVector</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#append">append</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#append-1">append</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#append-2">append</a></b>(const QVector&lt;T&gt; &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#at">at</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::reference </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#back">back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reference </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#back-1">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#begin">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#begin-1">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#capacity">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#cbegin">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#cend">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#clear">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#constBegin">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T *</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#constData">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#constEnd">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#constFirst">constFirst</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#constLast">constLast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#contains">contains</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#count">count</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#count-1">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#crbegin">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#crend">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#data">data</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T *</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#data-1">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#empty">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#end">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#end-1">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#endsWith">endsWith</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#erase">erase</a></b>(QVector::iterator <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#erase-1">erase</a></b>(QVector::iterator <i>begin</i>, QVector::iterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#fill">fill</a></b>(const T &amp;<i>value</i>, int <i>size</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#first">first</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#first-1">first</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#front">front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reference </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#front-1">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#indexOf">indexOf</a></b>(const T &amp;<i>value</i>, int <i>from</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#insert">insert</a></b>(int <i>i</i>, T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#insert-1">insert</a></b>(int <i>i</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#insert-2">insert</a></b>(int <i>i</i>, int <i>count</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#insert-3">insert</a></b>(QVector::iterator <i>before</i>, int <i>count</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#insert-4">insert</a></b>(QVector::iterator <i>before</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#insert-5">insert</a></b>(QVector::iterator <i>before</i>, T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#isEmpty">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#last">last</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#last-1">last</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#lastIndexOf">lastIndexOf</a></b>(const T &amp;<i>value</i>, int <i>from</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#length">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#mid">mid</a></b>(int <i>pos</i>, int <i>length</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#move">move</a></b>(int <i>from</i>, int <i>to</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#pop_back">pop_back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#pop_front">pop_front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#prepend">prepend</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#prepend-1">prepend</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#push_back">push_back</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#push_back-1">push_back</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#push_front">push_front</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#push_front-1">push_front</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#rbegin">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#rbegin-1">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#remove">remove</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#remove-1">remove</a></b>(int <i>i</i>, int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#removeAll">removeAll</a></b>(const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#removeAt">removeAt</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#removeFirst">removeFirst</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#removeLast">removeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#removeOne">removeOne</a></b>(const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#rend">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#rend-1">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#replace">replace</a></b>(int <i>i</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#reserve">reserve</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#resize">resize</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#shrink_to_fit">shrink_to_fit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#size">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#squeeze">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#startsWith">startsWith</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#swap">swap</a></b>(QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#takeAt">takeAt</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#takeFirst">takeFirst</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#takeLast">takeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#toList">toList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::vector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#toStdVector">toStdVector</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#value">value</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#value-1">value</a></b>(int <i>i</i>, const T &amp;<i>defaultValue</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-not-eq">operator!=</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-2b">operator+</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-2b-eq">operator+=</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-2b-eq-1">operator+=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-2b-eq-2">operator+=</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-lt-lt">operator&lt;&lt;</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-lt-lt-1">operator&lt;&lt;</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-lt-lt-2">operator&lt;&lt;</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-eq">operator=</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-eq-1">operator=</a></b>(QVector&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-eq-eq">operator==</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-5b-5d">operator[]</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-5b-5d-1">operator[]</a></b>(int <i>i</i>) const</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#fromList">fromList</a></b>(const QList&lt;T&gt; &amp;<i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#fromStdVector">fromStdVector</a></b>(const std::vector&lt;T&gt; &amp;<i>vector</i>)</td></tr>
</table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">相关非成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#qHash">qHash</a></b>(const QVector&lt;T&gt; &amp;<i>key</i>, uint <i>seed</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-lt">operator&lt;</a></b>(const QVector&lt;T&gt; &amp;<i>lhs</i>, const QVector&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-lt-lt-3">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QVector&lt;T&gt; &amp;<i>vector</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-lt-eq">operator&lt;=</a></b>(const QVector&lt;T&gt; &amp;<i>lhs</i>, const QVector&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-gt">operator&gt;</a></b>(const QVector&lt;T&gt; &amp;<i>lhs</i>, const QVector&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-gt-eq">operator&gt;=</a></b>(const QVector&lt;T&gt; &amp;<i>lhs</i>, const QVector&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qvector.html#operator-gt-gt">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QVector&lt;T&gt; &amp;<i>vector</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QVector-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qvector.html">QVector</a> class is a template class that provides a dynamic array.</p>
<p><a href="qvector.html">QVector</a>&lt;T&gt; is one of Qt's generic <a href="containers.html">container classes</a>. It stores its items in adjacent memory locations and provides fast index-based access.</p>
<p><a href="qlist.html">QList</a>&lt;T&gt;, <a href="qlinkedlist.html">QLinkedList</a>&lt;T&gt;, <a href="qvector.html">QVector</a>&lt;T&gt;, and <a href="qvarlengtharray.html">QVarLengthArray</a>&lt;T&gt; provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:</p>
<ul>
<li><a href="qvector.html">QVector</a> should be your default first choice. <a href="qvector.html">QVector</a>&lt;T&gt; will usually give better performance than <a href="qlist.html">QList</a>&lt;T&gt;, because <a href="qvector.html">QVector</a>&lt;T&gt; always stores its items sequentially in memory, where <a href="qlist.html">QList</a>&lt;T&gt; will allocate its items on the heap unless <code>sizeof(T) &lt;= sizeof(void*)</code> and T has been declared to be either a <code>Q_MOVABLE_TYPE</code> or a <code>Q_PRIMITIVE_TYPE</code> using <a href="qtglobal.html#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</a>. See the <a href="http://marcmutz.wordpress.com/effective-qt/containers/#containers-qlist">Pros and Cons of Using QList</a> for an explanation.</li>
<li>However, <a href="qlist.html">QList</a> is used throughout the Qt APIs for passing parameters and for returning values. Use <a href="qlist.html">QList</a> to interface with those APIs.</li>
<li>If you need a real linked list, which guarantees <a href="containers.html#algorithmic-complexity">常量级时间</a> insertions mid-list and uses iterators to items rather than indexes, use <a href="qlinkedlist.html">QLinkedList</a>.</li>
</ul>
<p><b>注意： </b><a href="qvector.html">QVector</a> 和 <a href="qvarlengtharray.html">QVarLengthArray</a> both guarantee C-compatible array layout. <a href="qlist.html">QList</a> does not. This might be important if your application must interface with a C API.</p><p><b>注意： </b>Iterators into a <a href="qlinkedlist.html">QLinkedList</a> and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a <a href="qvector.html">QVector</a> and non-heap-allocating QLists.</p><p>Here's an example of a <a href="qvector.html">QVector</a> that stores integers and a <a href="qvector.html">QVector</a> that stores <a href="qstring.html">QString</a> values:</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> integerVector;
  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> stringVector;

</pre>
<p><a href="qvector.html">QVector</a> stores its items in a vector (array). Typically, vectors are created with an initial size. For example, the following code constructs a <a href="qvector.html">QVector</a> with 200 elements:</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vector(<span class="number">200</span>);

</pre>
<p>The elements are automatically initialized with a <a href="containers.html#default-constructed-value">default-constructed value</a>. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vector(<span class="number">200</span><span class="operator">,</span> <span class="string">&quot;Pass&quot;</span>);

</pre>
<p>You can also call <a href="qvector.html#fill">fill</a>() at any time to fill the vector with a value.</p>
<p><a href="qvector.html">QVector</a> uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:</p>
<pre class="cpp">

  <span class="keyword">if</span> (vector<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;Liz&quot;</span>)
      vector<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;Elizabeth&quot;</span>;

</pre>
<p>For read-only access, an alternative syntax is to use <a href="qvector.html#at">at</a>():</p>
<pre class="cpp">

  <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> vector<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i) {
      <span class="keyword">if</span> (vector<span class="operator">.</span>at(i) <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;Alfonso&quot;</span>)
          cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Found Alfonso at position &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
  }

</pre>
<p><a href="qvector.html#at">at</a>() can be faster than operator[](), because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur.</p>
<p>Another way to access the data stored in a <a href="qvector.html">QVector</a> is to call <a href="qvector.html#data">data</a>(). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a <a href="qvector.html">QVector</a> to a function that accepts a plain C++ array.</p>
<p>If you want to find all occurrences of a particular value in a vector, use <a href="qvector.html#indexOf">indexOf</a>() or <a href="qvector.html#lastIndexOf">lastIndexOf</a>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</p>
<pre class="cpp">

  <span class="type">int</span> i <span class="operator">=</span> vector<span class="operator">.</span>indexOf(<span class="string">&quot;Harumi&quot;</span>);
  <span class="keyword">if</span> (i <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>)
      cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;First occurrence of Harumi is at position &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;

</pre>
<p>If you simply want to check whether a vector contains a particular value, use <a href="qvector.html#contains">contains</a>(). If you want to find out how many times a particular value occurs in the vector, use <a href="qvector.html#count-1">count</a>().</p>
<p><a href="qvector.html">QVector</a> provides these basic functions to add, move, and remove items: <a href="qvector.html#insert">insert</a>(), <a href="qvector.html#replace">replace</a>(), <a href="qvector.html#remove">remove</a>(), <a href="qvector.html#prepend">prepend</a>(), <a href="qvector.html#append">append</a>(). With the exception of <a href="qvector.html#append">append</a>() 和 <a href="qvector.html#replace">replace</a>(), these functions can be slow (<a href="containers.html#linear-time">linear time</a>) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use <a href="qlist.html">QList</a> or <a href="qlinkedlist.html">QLinkedList</a> instead.</p>
<p>Unlike plain C++ arrays, QVectors can be resized at any time by calling <a href="qvector.html#resize">resize</a>(). If the new size is larger than the old size, <a href="qvector.html">QVector</a> might need to reallocate the whole vector. <a href="qvector.html">QVector</a> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.</p>
<p>If you know in advance approximately how many items the <a href="qvector.html">QVector</a> will contain, you can call <a href="qvector.html#reserve">reserve</a>(), asking <a href="qvector.html">QVector</a> to preallocate a certain amount of memory. You can also call <a href="qvector.html#capacity">capacity</a>() to find out how much memory <a href="qvector.html">QVector</a> actually allocated.</p>
<p>Note that using non-const operators and functions can cause <a href="qvector.html">QVector</a> to do a deep copy of the data. This is due to <a href="implicit-sharing.html">implicit sharing</a>.</p>
<p><a href="qvector.html">QVector</a>'s value type must be an <a href="containers.html#assignable-data-type">assignable data type</a>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <a href="../qtwidgets/qwidget.html">QWidget</a> as a value; instead, store a <a href="../qtwidgets/qwidget.html">QWidget</a> *. A few functions have additional requirements; for example, <a href="qvector.html#indexOf">indexOf</a>() 和 <a href="qvector.html#lastIndexOf">lastIndexOf</a>() expect the value type to support <code>operator==()</code>. These requirements are documented on a per-function basis.</p>
<p>Like the other container classes, <a href="qvector.html">QVector</a> provides <a href="containers.html#java-style-iterators">Java-style iterators</a> (<a href="qvectoriterator.html">QVectorIterator</a> 和 <a href="qmutablevectoriterator.html">QMutableVectorIterator</a>) and <a href="containers.html#stl-style-iterators">STL-style iterators</a> (<a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a> 和 <a href="qvector.html#iterator-typedefx">QVector::iterator</a>). In practice, these are rarely used, because you can use indexes into the <a href="qvector.html">QVector</a>.</p>
<p>In addition to <a href="qvector.html">QVector</a>, Qt also provides <a href="qvarlengtharray.html">QVarLengthArray</a>, a very low-level class with little functionality that is optimized for speed.</p>
<p><a href="qvector.html">QVector</a> does <i>not</i> support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</p>
<a name="more-information-on-using-qt-containers"></a>
<h4 >有关使用Qt容器的更多信息</h4>
<p>For a detailed discussion comparing Qt containers with each other and with STL containers, see <a href="http://marcmutz.wordpress.com/effective-qt/containers/">Understand the Qt Containers</a>.</p>
</div>
<p><b> 参见 </b><a href="qvectoriterator.html">QVectorIterator</a>, <a href="qmutablevectoriterator.html">QMutableVectorIterator</a>, <a href="qlist.html">QList</a>, 和 <a href="qlinkedlist.html">QLinkedList</a>.</p>
<!-- @@@QVector -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" id="ConstIterator-typedef"><a name="ConstIterator-typedef"></a>typedef QVector::<span class="name">ConstIterator</span></h3>
<p>Qt风格的同义词<a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn" id="Iterator-typedef"><a name="Iterator-typedef"></a>typedef QVector::<span class="name">Iterator</span></h3>
<p>Qt风格的同义词<a href="qvector.html#iterator-typedefx">QVector::iterator</a>.</p>
<!-- @@@Iterator -->
<!-- $$$const_iterator -->
<h3 class="fn" id="const_iterator-typedef"><a name="const_iterator-typedef"></a>typedef QVector::<span class="name">const_iterator</span></h3>
<p>The QVector::const_iterator typedef provides an STL-style const iterator for <a href="qvector.html">QVector</a> 和 <a href="qstack.html">QStack</a>.</p>
<p><a href="qvector.html">QVector</a> provides both <a href="containers.html#stl-style-iterators">STL-style iterators</a> 和 <a href="containers.html#java-style-iterators">Java-style iterators</a>. The STL-style const iterator is simply a typedef for &quot;const T *&quot; (pointer to const T).</p>
<p><b>警告：</b> Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="containers.html#implicit-sharing-iterator-problem">Implicit sharing iterator problem</a>.</p>
<p><b> 参见 </b><a href="qvector.html#constBegin">QVector::constBegin</a>(), <a href="qvector.html#constEnd">QVector::constEnd</a>(), <a href="qvector.html#iterator-typedefx">QVector::iterator</a>, 和 <a href="qvectoriterator.html">QVectorIterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" id="const_pointer-typedef"><a name="const_pointer-typedef"></a>typedef QVector::<span class="name">const_pointer</span></h3>
<p>const T *的常量指针类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" id="const_reference-typedef"><a name="const_reference-typedef"></a>typedef QVector::<span class="name">const_reference</span></h3>
<p>T &amp;的引用类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@const_reference -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" id="const_reverse_iterator-typedef"><a name="const_reverse_iterator-typedef"></a>typedef QVector::<span class="name">const_reverse_iterator</span></h3>
<p>The QVector::const_reverse_iterator typedef provides an STL-style const reverse iterator for <a href="qvector.html">QVector</a>.</p>
<p>它只是简单类型重定义，方便使用于 <code>std::reverse_iterator&lt;const T*&gt;</code>.</p>
<p><b>警告：</b> Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="containers.html#implicit-sharing-iterator-problem">Implicit sharing iterator problem</a>.</p>
<p>这个类型定义是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#rbegin">QVector::rbegin</a>(), <a href="qvector.html#rend">QVector::rend</a>(), <a href="qvector.html#reverse_iterator-typedef">QVector::reverse_iterator</a>, 和 <a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" id="difference_type-typedef"><a name="difference_type-typedef"></a>typedef QVector::<span class="name">difference_type</span></h3>
<p>ptrdiff_t的类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@difference_type -->
<!-- $$$iterator -->
<h3 class="fn" id="iterator-typedefx"><a name="iterator-typedefx"></a>typedef QVector::<span class="name">iterator</span></h3>
<p>The QVector::iterator typedef provides an STL-style non-const iterator for <a href="qvector.html">QVector</a> 和 <a href="qstack.html">QStack</a>.</p>
<p><a href="qvector.html">QVector</a> provides both <a href="containers.html#stl-style-iterators">STL-style iterators</a> 和 <a href="containers.html#java-style-iterators">Java-style iterators</a>. The STL-style non-const iterator is simply a typedef for &quot;T *&quot; (pointer to T).</p>
<p><b>警告：</b> Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="containers.html#implicit-sharing-iterator-problem">Implicit sharing iterator problem</a>.</p>
<p><b> 参见 </b><a href="qvector.html#begin">QVector::begin</a>(), <a href="qvector.html#end">QVector::end</a>(), <a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a>, 和 <a href="qmutablevectoriterator.html">QMutableVectorIterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$pointer -->
<h3 class="fn" id="pointer-typedef"><a name="pointer-typedef"></a>typedef QVector::<span class="name">pointer</span></h3>
<p>T *的指针类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" id="reference-typedef"><a name="reference-typedef"></a>typedef QVector::<span class="name">reference</span></h3>
<p>T &amp;的引用类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@reference -->
<!-- $$$reverse_iterator -->
<h3 class="fn" id="reverse_iterator-typedef"><a name="reverse_iterator-typedef"></a>typedef QVector::<span class="name">reverse_iterator</span></h3>
<p>The QVector::reverse_iterator typedef provides an STL-style non-const reverse iterator for <a href="qvector.html">QVector</a>.</p>
<p>它只是简单类型重定义，方便使用于 <code>std::reverse_iterator&lt;T*&gt;</code>.</p>
<p><b>警告：</b> Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="containers.html#implicit-sharing-iterator-problem">Implicit sharing iterator problem</a>.</p>
<p>这个类型定义是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#rbegin">QVector::rbegin</a>(), <a href="qvector.html#rend">QVector::rend</a>(), <a href="qvector.html#const_reverse_iterator-typedef">QVector::const_reverse_iterator</a>, 和 <a href="qvector.html#iterator-typedefx">QVector::iterator</a>.</p>
<!-- @@@reverse_iterator -->
<!-- $$$size_type -->
<h3 class="fn" id="size_type-typedef"><a name="size_type-typedef"></a>typedef QVector::<span class="name">size_type</span></h3>
<p>int的类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" id="value_type-typedef"><a name="value_type-typedef"></a>typedef QVector::<span class="name">value_type</span></h3>
<p>T的值类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@value_type -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="push_front-1"><a name="push_front-1"></a><span class="type">void</span> QVector::<span class="name">push_front</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3><h3 class="fn fngroupitem" id="push_front"><a name="push_front"></a><span class="type">void</span> QVector::<span class="name">push_front</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3></div>
<p>此函数支持STL风格的兼容性，它等同于 prepend(<i>value</i>).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="insert-4"><a name="insert-4"></a><span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> QVector::<span class="name">insert</span>(<span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> <i>before</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3><h3 class="fn fngroupitem" id="insert-5"><a name="insert-5"></a><span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> QVector::<span class="name">insert</span>(<span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> <i>before</i>, <span class="type">T</span> &amp;&amp;<i>value</i>)</h3></div>
<p>这是一个重载函数。</p>
<p>Inserts <i>value</i> in front of the item pointed to by the iterator <i>before</i>. Returns an iterator pointing at the inserted item.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="insert-1"><a name="insert-1"></a><span class="type">void</span> QVector::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3><h3 class="fn fngroupitem" id="insert"><a name="insert"></a><span class="type">void</span> QVector::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, <span class="type">T</span> &amp;&amp;<i>value</i>)</h3></div>
<p>Inserts <i>value</i> at index position <i>i</i> in the vector. If <i>i</i> is 0, the value is prepended to the vector. If <i>i</i> is <a href="qvector.html#size">size</a>(), the value is appended to the vector.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vector;
  vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;alpha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beta&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;delta&quot;</span>;
  vector<span class="operator">.</span>insert(<span class="number">2</span><span class="operator">,</span> <span class="string">&quot;gamma&quot;</span>);
  <span class="comment">// vector: [&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;]</span>

</pre>
<p>For large vectors, this operation can be slow (<a href="containers.html#linear-time">linear time</a>), because it requires moving all the items at indexes <i>i</i> and above by one position further in memory. If you want a container class that provides a fast <a href="qvector.html#insert">insert</a>() function, use <a href="qlinkedlist.html">QLinkedList</a> instead.</p>
<p><b> 参见 </b><a href="qvector.html#append">append</a>(), <a href="qvector.html#prepend">prepend</a>(), 和 <a href="qvector.html#remove">remove</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="prepend-1"><a name="prepend-1"></a><span class="type">void</span> QVector::<span class="name">prepend</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3><h3 class="fn fngroupitem" id="prepend"><a name="prepend"></a><span class="type">void</span> QVector::<span class="name">prepend</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3></div>
<p>Inserts <i>value</i> at the beginning of the vector.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vector;
  vector<span class="operator">.</span>prepend(<span class="string">&quot;one&quot;</span>);
  vector<span class="operator">.</span>prepend(<span class="string">&quot;two&quot;</span>);
  vector<span class="operator">.</span>prepend(<span class="string">&quot;three&quot;</span>);
  <span class="comment">// vector: [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]</span>

</pre>
<p>此函数等同于 vector.insert(0, <i>value</i>).</p>
<p>For large vectors, this operation can be slow (<a href="containers.html#linear-time">linear time</a>), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast <a href="qvector.html#prepend">prepend</a>() function, use <a href="qlist.html">QList</a> or <a href="qlinkedlist.html">QLinkedList</a> instead.</p>
<p><b> 参见 </b><a href="qvector.html#append">append</a>() 和 <a href="qvector.html#insert">insert</a>().</p>
<!-- @@@ -->
<!-- $$$QVector[overload1]$$$QVector -->
<h3 class="fn" id="QVector"><a name="QVector"></a>QVector::<span class="name">QVector</span>()</h3>
<p>构造函数，创建一个空向量表。</p>
<p><b> 参见 </b><a href="qvector.html#resize">resize</a>().</p>
<!-- @@@QVector -->
<!-- $$$QVector$$$QVectorint -->
<h3 class="fn" id="QVector-1"><a name="QVector-1"></a>QVector::<span class="name">QVector</span>(<span class="type">int</span> <i>size</i>)</h3>
<p>Constructs a vector with an initial size of <i>size</i> elements.</p>
<p>The elements are initialized with a <a href="containers.html#default-constructed-value">default-constructed value</a>.</p>
<p><b> 参见 </b><a href="qvector.html#resize">resize</a>().</p>
<!-- @@@QVector -->
<!-- $$$QVector$$$QVectorintconstT& -->
<h3 class="fn" id="QVector-2"><a name="QVector-2"></a>QVector::<span class="name">QVector</span>(<span class="type">int</span> <i>size</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Constructs a vector with an initial size of <i>size</i> elements. Each element is initialized with <i>value</i>.</p>
<p><b> 参见 </b><a href="qvector.html#resize">resize</a>() 和 <a href="qvector.html#fill">fill</a>().</p>
<!-- @@@QVector -->
<!-- $$$QVector$$$QVectorconstQVector<T>& -->
<h3 class="fn" id="QVector-3"><a name="QVector-3"></a>QVector::<span class="name">QVector</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>拷贝构造函数，参数为 <i>other</i>。</p>
<p>This operation takes <a href="containers.html#algorithmic-complexity">常量级时间</a>, because <a href="qvector.html">QVector</a> is <a href="implicit-sharing.html">implicitly shared</a>. This makes returning a <a href="qvector.html">QVector</a> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <a href="containers.html#algorithmic-complexity">linear time</a>.</p>
<p><b> 参见 </b><a href="qvector.html#operator-eq">operator=</a>().</p>
<!-- @@@QVector -->
<!-- $$$QVector$$$QVectorQVector<T>&& -->
<h3 class="fn" id="QVector-4"><a name="QVector-4"></a>QVector::<span class="name">QVector</span>(<span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a <a href="qvector.html">QVector</a> instance, making it point at the same object that <i>other</i> was pointing to.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@QVector -->
<!-- $$$QVector$$$QVectorstd::initializer_list<T> -->
<h3 class="fn" id="QVector-5"><a name="QVector-5"></a>QVector::<span class="name">QVector</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">T</span>&gt; <i>args</i>)</h3>
<p>Constructs a vector from the std::initializer_list given by <i>args</i>.</p>
<p>仅当编译器支持C++11初始化列表时，该构造函数才有效。</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<!-- @@@QVector -->
<!-- $$$~QVector[overload1]$$$~QVector -->
<h3 class="fn" id="dtor.QVector"><a name="dtor.QVector"></a>QVector::<span class="name">~QVector</span>()</h3>
<p>Destroys the vector.</p>
<!-- @@@~QVector -->
<!-- $$$append[overload1]$$$appendconstT& -->
<h3 class="fn" id="append"><a name="append"></a><span class="type">void</span> QVector::<span class="name">append</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>增加新值 <i>value</i> 到向量表的尾部。</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vector;
  vector<span class="operator">.</span>append(<span class="string">&quot;one&quot;</span>);
  vector<span class="operator">.</span>append(<span class="string">&quot;two&quot;</span>);
  <span class="type"><a href="qstring.html">QString</a></span> three <span class="operator">=</span> <span class="string">&quot;three&quot;</span>;
  vector<span class="operator">.</span>append(three);
  <span class="comment">// vector: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span>
  <span class="comment">// three: &quot;three&quot;</span>

</pre>
<p>此函数等同于 calling resize(<a href="qvector.html#size">size</a>() + 1) and assigning <i>value</i> to the new last element in the vector.</p>
<p>This operation is relatively fast, because <a href="qvector.html">QVector</a> typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.</p>
<p><b> 参见 </b><a href="qvector.html#operator-lt-lt">operator&lt;&lt;</a>(), <a href="qvector.html#prepend">prepend</a>(), 和 <a href="qvector.html#insert">insert</a>().</p>
<!-- @@@append -->
<!-- $$$append$$$appendT&& -->
<h3 class="fn" id="append-1"><a name="append-1"></a><span class="type">void</span> QVector::<span class="name">append</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>这是一个重载函数。</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vector;
  vector<span class="operator">.</span>append(<span class="string">&quot;one&quot;</span>);
  vector<span class="operator">.</span>append(<span class="string">&quot;two&quot;</span>);
  <span class="type"><a href="qstring.html">QString</a></span> three <span class="operator">=</span> <span class="string">&quot;three&quot;</span>;
  vector<span class="operator">.</span>append(std<span class="operator">::</span>move(three));
  <span class="comment">// vector: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span>
  <span class="comment">// three: &quot;&quot;</span>

</pre>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstQVector<T>& -->
<h3 class="fn" id="append-2"><a name="append-2"></a><span class="type">void</span> QVector::<span class="name">append</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>value</i>)</h3>
<p>这是一个重载函数。</p>
<p>Appends the items of the <i>value</i> vector to this vector.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#operator-lt-lt">operator&lt;&lt;</a>() 和 <a href="qvector.html#operator-2b-eq">operator+=</a>().</p>
<!-- @@@append -->
<!-- $$$at[overload1]$$$atint -->
<h3 class="fn" id="at"><a name="at"></a>const <span class="type">T</span> &amp;QVector::<span class="name">at</span>(<span class="type">int</span> <i>i</i>) const</h3>
<p>Returns the item at index position <i>i</i> in the vector.</p>
<p><i>i</i> must be a valid index position in the vector (i.e&#x2e;, 0 &lt;= <i>i</i> &lt; <a href="qvector.html#size">size</a>()).</p>
<p><b> 参见 </b><a href="qvector.html#value">value</a>() 和 <a href="qvector.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" id="back"><a name="back"></a><span class="type"><a href="qvector.html#reference-typedef">QVector::reference</a></span> QVector::<span class="name">back</span>()</h3>
<p>此函数用于STL风格的兼容性，它相当于 <a href="qvector.html#last">last</a>().</p>
<!-- @@@back -->
<!-- $$$back$$$back -->
<h3 class="fn" id="back-1"><a name="back-1"></a><span class="type"><a href="qvector.html#const_reference-typedef">QVector::const_reference</a></span> QVector::<span class="name">back</span>() const</h3>
<p>这是一个重载函数。</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin"><a name="begin"></a><span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> QVector::<span class="name">begin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the vector.</p>
<p><b> 参见 </b><a href="qvector.html#constBegin">constBegin</a>() 和 <a href="qvector.html#end">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1"><a name="begin-1"></a><span class="type"><a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a></span> QVector::<span class="name">begin</span>() const</h3>
<p>这是一个重载函数。</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" id="capacity"><a name="capacity"></a><span class="type">int</span> QVector::<span class="name">capacity</span>() const</h3>
<p>Returns the maximum number of items that can be stored in the vector without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qvector.html">QVector</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call <a href="qvector.html#size">size</a>().</p>
<p><b> 参见 </b><a href="qvector.html#reserve">reserve</a>() 和 <a href="qvector.html#squeeze">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin"><a name="cbegin"></a><span class="type"><a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a></span> QVector::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the vector.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#begin">begin</a>() 和 <a href="qvector.html#cend">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend"><a name="cend"></a><span class="type"><a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a></span> QVector::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the vector.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#cbegin">cbegin</a>() 和 <a href="qvector.html#end">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear"><a name="clear"></a><span class="type">void</span> QVector::<span class="name">clear</span>()</h3>
<p>Removes all the elements from the vector.</p>
<p><b>注意： </b>Until Qt 5.6, this also released the memory used by the vector. From Qt 5.7, the capacity is preserved. To shed all capacity, swap with a default-constructed vector:</p><pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span>T<span class="operator">&gt;</span> v <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span>T<span class="operator">&gt;</span>()<span class="operator">.</span>swap(v);
  Q_ASSERT(v<span class="operator">.</span>capacity() <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>);

</pre>
<p>or call <a href="qvector.html#squeeze">squeeze</a>().</p>
<p><b> 参见 </b><a href="qvector.html#squeeze">squeeze</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin"><a name="constBegin"></a><span class="type"><a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a></span> QVector::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the vector.</p>
<p><b> 参见 </b><a href="qvector.html#begin">begin</a>() 和 <a href="qvector.html#constEnd">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constData[overload1]$$$constData -->
<h3 class="fn" id="constData"><a name="constData"></a>const <span class="type">T</span> *QVector::<span class="name">constData</span>() const</h3>
<p>Returns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn't reallocated.</p>
<p>This function is mostly useful to pass a vector to a function that accepts a plain C++ array.</p>
<p><b> 参见 </b><a href="qvector.html#data">data</a>() 和 <a href="qvector.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@constData -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd"><a name="constEnd"></a><span class="type"><a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a></span> QVector::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the vector.</p>
<p><b> 参见 </b><a href="qvector.html#constBegin">constBegin</a>() 和 <a href="qvector.html#end">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFirst[overload1]$$$constFirst -->
<h3 class="fn" id="constFirst"><a name="constFirst"></a>const <span class="type">T</span> &amp;QVector::<span class="name">constFirst</span>() const</h3>
<p>Returns a const reference to the first item in the vector. This function assumes that the vector isn't empty.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#constLast">constLast</a>(), <a href="qvector.html#isEmpty">isEmpty</a>(), 和 <a href="qvector.html#first">first</a>().</p>
<!-- @@@constFirst -->
<!-- $$$constLast[overload1]$$$constLast -->
<h3 class="fn" id="constLast"><a name="constLast"></a>const <span class="type">T</span> &amp;QVector::<span class="name">constLast</span>() const</h3>
<p>Returns a const reference to the last item in the vector. This function assumes that the vector isn't empty.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#constFirst">constFirst</a>(), <a href="qvector.html#isEmpty">isEmpty</a>(), 和 <a href="qvector.html#last">last</a>().</p>
<!-- @@@constLast -->
<!-- $$$contains[overload1]$$$containsconstT& -->
<h3 class="fn" id="contains"><a name="contains"></a><span class="type">bool</span> QVector::<span class="name">contains</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns <code>true</code> if the vector contains an occurrence of <i>value</i>; otherwise returns <code>false</code>.</p>
<p>该函数邀请值类型的列表元素实现了 <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qvector.html#indexOf">indexOf</a>() 和 <a href="qvector.html#count-1">count</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstT& -->
<h3 class="fn" id="count"><a name="count"></a><span class="type">int</span> QVector::<span class="name">count</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns the number of occurrences of <i>value</i> in the vector.</p>
<p>该函数邀请值类型的列表元素实现了 <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qvector.html#contains">contains</a>() 和 <a href="qvector.html#indexOf">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn" id="count-1"><a name="count-1"></a><span class="type">int</span> QVector::<span class="name">count</span>() const</h3>
<p>这是一个重载函数。</p>
<p>等同于 <a href="qvector.html#size">size</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" id="crbegin"><a name="crbegin"></a><span class="type"><a href="qvector.html#const_reverse_iterator-typedef">QVector::const_reverse_iterator</a></span> QVector::<span class="name">crbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first item in the vector, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#begin">begin</a>(), <a href="qvector.html#rbegin">rbegin</a>(), 和 <a href="qvector.html#rend">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" id="crend"><a name="crend"></a><span class="type"><a href="qvector.html#const_reverse_iterator-typedef">QVector::const_reverse_iterator</a></span> QVector::<span class="name">crend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to one past the last item in the vector, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#end">end</a>(), <a href="qvector.html#rend">rend</a>(), 和 <a href="qvector.html#rbegin">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" id="data"><a name="data"></a><span class="type">T</span> *QVector::<span class="name">data</span>()</h3>
<p>Returns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vector(<span class="number">10</span>);
  <span class="type">int</span> <span class="operator">*</span>data <span class="operator">=</span> vector<span class="operator">.</span>data();
  <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">10</span>; <span class="operator">+</span><span class="operator">+</span>i)
      data<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> i;

</pre>
<p>The pointer remains valid as long as the vector isn't reallocated.</p>
<p>This function is mostly useful to pass a vector to a function that accepts a plain C++ array.</p>
<p><b> 参见 </b><a href="qvector.html#constData">constData</a>() 和 <a href="qvector.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$data -->
<h3 class="fn" id="data-1"><a name="data-1"></a>const <span class="type">T</span> *QVector::<span class="name">data</span>() const</h3>
<p>这是一个重载函数。</p>
<!-- @@@data -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" id="empty"><a name="empty"></a><span class="type">bool</span> QVector::<span class="name">empty</span>() const</h3>
<p>此函数用于STL风格的兼容性，它相当于 <a href="qvector.html#isEmpty">isEmpty</a>(), returning <code>true</code> if the vector is empty; otherwise returns <code>false</code>.</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end"><a name="end"></a><span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> QVector::<span class="name">end</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the vector.</p>
<p><b> 参见 </b><a href="qvector.html#begin">begin</a>() 和 <a href="qvector.html#constEnd">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1"><a name="end-1"></a><span class="type"><a href="qvector.html#const_iterator-typedef">QVector::const_iterator</a></span> QVector::<span class="name">end</span>() const</h3>
<p>这是一个重载函数。</p>
<!-- @@@end -->
<!-- $$$endsWith[overload1]$$$endsWithconstT& -->
<h3 class="fn" id="endsWith"><a name="endsWith"></a><span class="type">bool</span> QVector::<span class="name">endsWith</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns <code>true</code> if this vector is not empty and its last item is equal to <i>value</i>; otherwise returns <code>false</code>.</p>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#isEmpty">isEmpty</a>() 和 <a href="qvector.html#last">last</a>().</p>
<!-- @@@endsWith -->
<!-- $$$erase[overload1]$$$eraseQVector::iterator -->
<h3 class="fn" id="erase"><a name="erase"></a><span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> QVector::<span class="name">erase</span>(<span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> <i>pos</i>)</h3>
<p>Removes the item pointed to by the iterator <i>pos</i> from the vector, and returns an iterator to the next item in the vector (which may be <a href="qvector.html#end">end</a>()).</p>
<p><b> 参见 </b><a href="qvector.html#insert">insert</a>() 和 <a href="qvector.html#remove">remove</a>().</p>
<!-- @@@erase -->
<!-- $$$erase$$$eraseQVector::iteratorQVector::iterator -->
<h3 class="fn" id="erase-1"><a name="erase-1"></a><span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> QVector::<span class="name">erase</span>(<span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> <i>begin</i>, <span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> <i>end</i>)</h3>
<p>这是一个重载函数。</p>
<p>Removes all the items from <i>begin</i> up to (but not including) <i>end</i>. Returns an iterator to the same item that <i>end</i> referred to before the call.</p>
<!-- @@@erase -->
<!-- $$$fill[overload1]$$$fillconstT&int -->
<h3 class="fn" id="fill"><a name="fill"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">fill</span>(const <span class="type">T</span> &amp;<i>value</i>, <span class="type">int</span> <i>size</i> = ...)</h3>
<p>Assigns <i>value</i> to all items in the vector. If <i>size</i> is different from -1 (the default), the vector is resized to size <i>size</i> beforehand.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vector(<span class="number">3</span>);
  vector<span class="operator">.</span>fill(<span class="string">&quot;Yes&quot;</span>);
  <span class="comment">// vector: [&quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;]</span>

  vector<span class="operator">.</span>fill(<span class="string">&quot;oh&quot;</span><span class="operator">,</span> <span class="number">5</span>);
  <span class="comment">// vector: [&quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;]</span>

</pre>
<p><b> 参见 </b><a href="qvector.html#resize">resize</a>().</p>
<!-- @@@fill -->
<!-- $$$first[overload1]$$$first -->
<h3 class="fn" id="first"><a name="first"></a><span class="type">T</span> &amp;QVector::<span class="name">first</span>()</h3>
<p>Returns a reference to the first item in the vector. This function assumes that the vector isn't empty.</p>
<p><b> 参见 </b><a href="qvector.html#last">last</a>(), <a href="qvector.html#isEmpty">isEmpty</a>(), 和 <a href="qvector.html#constFirst">constFirst</a>().</p>
<!-- @@@first -->
<!-- $$$first$$$first -->
<h3 class="fn" id="first-1"><a name="first-1"></a>const <span class="type">T</span> &amp;QVector::<span class="name">first</span>() const</h3>
<p>这是一个重载函数。</p>
<!-- @@@first -->
<!-- $$$fromList[overload1]$$$fromListconstQList<T>& -->
<h3 class="fn" id="fromList"><a name="fromList"></a><code>[静态函数] </code><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">fromList</span>(const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>list</i>)</h3>
<p>Returns a <a href="qvector.html">QVector</a> object with the data contained in <i>list</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Sven&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Kim&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Ola&quot;</span>;

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect <span class="operator">=</span> <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span><span class="operator">::</span>fromList(list);
  <span class="comment">// vect: [&quot;Sven&quot;, &quot;Kim&quot;, &quot;Ola&quot;]</span>

</pre>
<p><b> 参见 </b><a href="qvector.html#toList">toList</a>() 和 <a href="qlist.html#toVector">QList::toVector</a>().</p>
<!-- @@@fromList -->
<!-- $$$fromStdVector[overload1]$$$fromStdVectorconststd::vector<T>& -->
<h3 class="fn" id="fromStdVector"><a name="fromStdVector"></a><code>[静态函数] </code><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">fromStdVector</span>(const <span class="type">std::vector</span>&lt;<span class="type">T</span>&gt; &amp;<i>vector</i>)</h3>
<p>Returns a <a href="qvector.html">QVector</a> object with the data contained in <i>vector</i>. The order of the elements in the <a href="qvector.html">QVector</a> is the same as in <i>vector</i>.</p>
<p>样例：</p>
<pre class="cpp">

  std<span class="operator">::</span>vector<span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> stdvector;
  vector<span class="operator">.</span>push_back(<span class="number">1.2</span>);
  vector<span class="operator">.</span>push_back(<span class="number">0.5</span>);
  vector<span class="operator">.</span>push_back(<span class="number">3.14</span>);

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> vector <span class="operator">=</span> <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span><span class="operator">::</span>fromStdVector(stdvector);

</pre>
<p><b> 参见 </b><a href="qvector.html#toStdVector">toStdVector</a>() 和 <a href="qlist.html#fromStdList">QList::fromStdList</a>().</p>
<!-- @@@fromStdVector -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" id="front"><a name="front"></a><span class="type">T</span> &amp;QVector::<span class="name">front</span>()</h3>
<p>此函数用于STL风格的兼容性，它相当于 <a href="qvector.html#first">first</a>().</p>
<!-- @@@front -->
<!-- $$$front$$$front -->
<h3 class="fn" id="front-1"><a name="front-1"></a><span class="type"><a href="qvector.html#const_reference-typedef">QVector::const_reference</a></span> QVector::<span class="name">front</span>() const</h3>
<p>这是一个重载函数。</p>
<!-- @@@front -->
<!-- $$$indexOf[overload1]$$$indexOfconstT&int -->
<h3 class="fn" id="indexOf"><a name="indexOf"></a><span class="type">int</span> QVector::<span class="name">indexOf</span>(const <span class="type">T</span> &amp;<i>value</i>, <span class="type">int</span> <i>from</i> = ...) const</h3>
<p>Returns the index position of the first occurrence of <i>value</i> in the vector, searching forward from index position <i>from</i>. Returns -1 if no item matched.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vector;
  vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;A&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;B&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;C&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;B&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;A&quot;</span>;
  vector<span class="operator">.</span>indexOf(<span class="string">&quot;B&quot;</span>);            <span class="comment">// returns 1</span>
  vector<span class="operator">.</span>indexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">1</span>);         <span class="comment">// returns 1</span>
  vector<span class="operator">.</span>indexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">2</span>);         <span class="comment">// returns 3</span>
  vector<span class="operator">.</span>indexOf(<span class="string">&quot;X&quot;</span>);            <span class="comment">// returns -1</span>

</pre>
<p>该函数邀请值类型的列表元素实现了 <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qvector.html#lastIndexOf">lastIndexOf</a>() 和 <a href="qvector.html#contains">contains</a>().</p>
<!-- @@@indexOf -->
<!-- $$$insert$$$insertintintconstT& -->
<h3 class="fn" id="insert-2"><a name="insert-2"></a><span class="type">void</span> QVector::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, <span class="type">int</span> <i>count</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>这是一个重载函数。</p>
<p>Inserts <i>count</i> copies of <i>value</i> at index position <i>i</i> in the vector.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> vector;
  vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">2.718</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1.442</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">0.4342</span>;
  vector<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">9.9</span>);
  <span class="comment">// vector: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342]</span>

</pre>
<!-- @@@insert -->
<!-- $$$insert$$$insertQVector::iteratorintconstT& -->
<h3 class="fn" id="insert-3"><a name="insert-3"></a><span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> QVector::<span class="name">insert</span>(<span class="type"><a href="qvector.html#iterator-typedefx">QVector::iterator</a></span> <i>before</i>, <span class="type">int</span> <i>count</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts <i>count</i> copies of <i>value</i> in front of the item pointed to by the iterator <i>before</i>. Returns an iterator pointing at the first of the inserted items.</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty"><a name="isEmpty"></a><span class="type">bool</span> QVector::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code>true</code> if the vector has size 0; otherwise returns <code>false</code>.</p>
<p><b> 参见 </b><a href="qvector.html#size">size</a>() 和 <a href="qvector.html#resize">resize</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$last[overload1]$$$last -->
<h3 class="fn" id="last"><a name="last"></a><span class="type">T</span> &amp;QVector::<span class="name">last</span>()</h3>
<p>Returns a reference to the last item in the vector. This function assumes that the vector isn't empty.</p>
<p><b> 参见 </b><a href="qvector.html#first">first</a>(), <a href="qvector.html#isEmpty">isEmpty</a>(), 和 <a href="qvector.html#constLast">constLast</a>().</p>
<!-- @@@last -->
<!-- $$$last$$$last -->
<h3 class="fn" id="last-1"><a name="last-1"></a>const <span class="type">T</span> &amp;QVector::<span class="name">last</span>() const</h3>
<p>这是一个重载函数。</p>
<!-- @@@last -->
<!-- $$$lastIndexOf[overload1]$$$lastIndexOfconstT&int -->
<h3 class="fn" id="lastIndexOf"><a name="lastIndexOf"></a><span class="type">int</span> QVector::<span class="name">lastIndexOf</span>(const <span class="type">T</span> &amp;<i>value</i>, <span class="type">int</span> <i>from</i> = ...) const</h3>
<p>Returns the index position of the last occurrence of the value <i>value</i> in the vector, searching backward from index position <i>from</i>. If <i>from</i> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vector;
  vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;A&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;B&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;C&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;B&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;A&quot;</span>;
  vector<span class="operator">.</span>lastIndexOf(<span class="string">&quot;B&quot;</span>);        <span class="comment">// returns 3</span>
  vector<span class="operator">.</span>lastIndexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">3</span>);     <span class="comment">// returns 3</span>
  vector<span class="operator">.</span>lastIndexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">2</span>);     <span class="comment">// returns 1</span>
  vector<span class="operator">.</span>lastIndexOf(<span class="string">&quot;X&quot;</span>);        <span class="comment">// returns -1</span>

</pre>
<p>该函数邀请值类型的列表元素实现了 <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qvector.html#indexOf">indexOf</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" id="length"><a name="length"></a><span class="type">int</span> QVector::<span class="name">length</span>() const</h3>
<p>等同于 <a href="qvector.html#size">size</a>() 和 <a href="qvector.html#count-1">count</a>().</p>
<p>Provided for compatibility with <a href="qlist.html">QList</a>.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#size">size</a>(), <a href="qvector.html#count-1">count</a>(), 和 <a href="qlist.html#length">QList::length</a>().</p>
<!-- @@@length -->
<!-- $$$mid[overload1]$$$midintint -->
<h3 class="fn" id="mid"><a name="mid"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">mid</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>length</i> = ...) const</h3>
<p>Returns a sub-vector which contains elements from this vector, starting at position <i>pos</i>. If <i>length</i> is -1 (the default), all elements after <i>pos</i> are included; otherwise <i>length</i> elements (or all remaining elements if there are less than <i>length</i> elements) are included.</p>
<!-- @@@mid -->
<!-- $$$move[overload1]$$$moveintint -->
<h3 class="fn" id="move"><a name="move"></a><span class="type">void</span> QVector::<span class="name">move</span>(<span class="type">int</span> <i>from</i>, <span class="type">int</span> <i>to</i>)</h3>
<p>Moves the item at index position <i>from</i> to index position <i>to</i>.</p>
<p>Provided for compatibility with <a href="qlist.html">QList</a>.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qlist.html#move">QList::move</a>().</p>
<!-- @@@move -->
<!-- $$$pop_back[overload1]$$$pop_back -->
<h3 class="fn" id="pop_back"><a name="pop_back"></a><span class="type">void</span> QVector::<span class="name">pop_back</span>()</h3>
<p>此函数用于STL风格的兼容性，它相当于 <a href="qvector.html#removeLast">removeLast</a>().</p>
<!-- @@@pop_back -->
<!-- $$$pop_front[overload1]$$$pop_front -->
<h3 class="fn" id="pop_front"><a name="pop_front"></a><span class="type">void</span> QVector::<span class="name">pop_front</span>()</h3>
<p>此函数用于STL风格的兼容性，它相当于 <a href="qvector.html#removeFirst">removeFirst</a>().</p>
<!-- @@@pop_front -->
<!-- $$$push_back[overload1]$$$push_backconstT& -->
<h3 class="fn" id="push_back"><a name="push_back"></a><span class="type">void</span> QVector::<span class="name">push_back</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>此函数支持STL风格的兼容性，它等同于 append(<i>value</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backT&& -->
<h3 class="fn" id="push_back-1"><a name="push_back-1"></a><span class="type">void</span> QVector::<span class="name">push_back</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@push_back -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" id="rbegin"><a name="rbegin"></a><span class="type"><a href="qvector.html#reverse_iterator-typedef">QVector::reverse_iterator</a></span> QVector::<span class="name">rbegin</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first item in the vector, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#begin">begin</a>(), <a href="qvector.html#crbegin">crbegin</a>(), 和 <a href="qvector.html#rend">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" id="rbegin-1"><a name="rbegin-1"></a><span class="type"><a href="qvector.html#const_reverse_iterator-typedef">QVector::const_reverse_iterator</a></span> QVector::<span class="name">rbegin</span>() const</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@rbegin -->
<!-- $$$remove[overload1]$$$removeint -->
<h3 class="fn" id="remove"><a name="remove"></a><span class="type">void</span> QVector::<span class="name">remove</span>(<span class="type">int</span> <i>i</i>)</h3>
<p>这是一个重载函数。</p>
<p>Removes the element at index position <i>i</i>.</p>
<p><b> 参见 </b><a href="qvector.html#insert">insert</a>(), <a href="qvector.html#replace">replace</a>(), 和 <a href="qvector.html#fill">fill</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeintint -->
<h3 class="fn" id="remove-1"><a name="remove-1"></a><span class="type">void</span> QVector::<span class="name">remove</span>(<span class="type">int</span> <i>i</i>, <span class="type">int</span> <i>count</i>)</h3>
<p>这是一个重载函数。</p>
<p>Removes <i>count</i> elements from the middle of the vector, starting at index position <i>i</i>.</p>
<p><b> 参见 </b><a href="qvector.html#insert">insert</a>(), <a href="qvector.html#replace">replace</a>(), 和 <a href="qvector.html#fill">fill</a>().</p>
<!-- @@@remove -->
<!-- $$$removeAll[overload1]$$$removeAllconstT& -->
<h3 class="fn" id="removeAll"><a name="removeAll"></a><span class="type">int</span> QVector::<span class="name">removeAll</span>(const <span class="type">T</span> &amp;<i>t</i>)</h3>
<p>Removes all elements that compare equal to <i>t</i> from the vector. Returns the number of elements removed, if any.</p>
<p>Provided for compatibility with <a href="qlist.html">QList</a>.</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#removeOne">removeOne</a>() 和 <a href="qlist.html#removeAll">QList::removeAll</a>().</p>
<!-- @@@removeAll -->
<!-- $$$removeAt[overload1]$$$removeAtint -->
<h3 class="fn" id="removeAt"><a name="removeAt"></a><span class="type">void</span> QVector::<span class="name">removeAt</span>(<span class="type">int</span> <i>i</i>)</h3>
<p>Removes the element at index position <i>i</i>. Equivalent to</p>
<pre class="cpp">

  remove(i);

</pre>
<p>Provided for compatibility with <a href="qlist.html">QList</a>.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#remove">remove</a>() 和 <a href="qlist.html#removeAt">QList::removeAt</a>().</p>
<!-- @@@removeAt -->
<!-- $$$removeFirst[overload1]$$$removeFirst -->
<h3 class="fn" id="removeFirst"><a name="removeFirst"></a><span class="type">void</span> QVector::<span class="name">removeFirst</span>()</h3>
<p>Removes the first item in the vector. Calling this function is equivalent to calling remove(0)。向量表不允许为空值。若向量表有可能为空值，则务必在调用此函数之前调用 <a href="qvector.html#isEmpty">isEmpty</a>()来加以判断，做好提前规避。</p>
<p>这个函数是在Qt 5.1版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#remove">remove</a>(), <a href="qvector.html#takeFirst">takeFirst</a>(), 和 <a href="qvector.html#isEmpty">isEmpty</a>().</p>
<!-- @@@removeFirst -->
<!-- $$$removeLast[overload1]$$$removeLast -->
<h3 class="fn" id="removeLast"><a name="removeLast"></a><span class="type">void</span> QVector::<span class="name">removeLast</span>()</h3>
<p>Removes the last item in the vector. Calling this function is equivalent to calling remove(<a href="qvector.html#size">size</a>() - 1)。向量表不允许为空值。若向量表有可能为空值，则务必在调用此函数之前调用 <a href="qvector.html#isEmpty">isEmpty</a>()来加以判断，做好提前规避。</p>
<p>这个函数是在Qt 5.1版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#remove">remove</a>(), <a href="qvector.html#takeLast">takeLast</a>(), <a href="qvector.html#removeFirst">removeFirst</a>(), 和 <a href="qvector.html#isEmpty">isEmpty</a>().</p>
<!-- @@@removeLast -->
<!-- $$$removeOne[overload1]$$$removeOneconstT& -->
<h3 class="fn" id="removeOne"><a name="removeOne"></a><span class="type">bool</span> QVector::<span class="name">removeOne</span>(const <span class="type">T</span> &amp;<i>t</i>)</h3>
<p>Removes the first element that compares equal to <i>t</i> from the vector. Returns whether an element was, in fact, removed.</p>
<p>Provided for compatibility with <a href="qlist.html">QList</a>.</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#removeAll">removeAll</a>() 和 <a href="qlist.html#removeOne">QList::removeOne</a>().</p>
<!-- @@@removeOne -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" id="rend"><a name="rend"></a><span class="type"><a href="qvector.html#reverse_iterator-typedef">QVector::reverse_iterator</a></span> QVector::<span class="name">rend</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to one past the last item in the vector, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#end">end</a>(), <a href="qvector.html#crend">crend</a>(), 和 <a href="qvector.html#rbegin">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" id="rend-1"><a name="rend-1"></a><span class="type"><a href="qvector.html#const_reverse_iterator-typedef">QVector::const_reverse_iterator</a></span> QVector::<span class="name">rend</span>() const</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@rend -->
<!-- $$$replace[overload1]$$$replaceintconstT& -->
<h3 class="fn" id="replace"><a name="replace"></a><span class="type">void</span> QVector::<span class="name">replace</span>(<span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Replaces the item at index position <i>i</i> with <i>value</i>.</p>
<p><i>i</i> must be a valid index position in the vector (i.e&#x2e;, 0 &lt;= <i>i</i> &lt; <a href="qvector.html#size">size</a>()).</p>
<p><b> 参见 </b><a href="qvector.html#operator-5b-5d">operator[]</a>() 和 <a href="qvector.html#remove">remove</a>().</p>
<!-- @@@replace -->
<!-- $$$reserve[overload1]$$$reserveint -->
<h3 class="fn" id="reserve"><a name="reserve"></a><span class="type">void</span> QVector::<span class="name">reserve</span>(<span class="type">int</span> <i>size</i>)</h3>
<p>Attempts to allocate memory for at least <i>size</i> elements. If you know in advance how large the vector will be, you should call this function to prevent reallocations and memory fragmentation.</p>
<p>If <i>size</i> is an underestimate, the worst that will happen is that the <a href="qvector.html">QVector</a> will be a bit slower. If <i>size</i> is an overestimate, you may have used more memory than the normal <a href="qvector.html">QVector</a> growth strategy would have allocated—or you may have used less.</p>
<p>An alternative to reserve() is calling <a href="qvector.html#resize">resize</a>(). Whether or not that is faster than reserve() depends on the element type, because <a href="qvector.html#resize">resize</a>() default-constructs all elements, and requires assignment to existing entries rather than calling <a href="qvector.html#append">append</a>(), which copy- or move-constructs. For simple types, like <code>int</code> or <code>double</code>, <a href="qvector.html#resize">resize</a>() is typically faster, but for anything more complex, you should prefer reserve().</p>
<p><b>警告：</b> If the size passed to <a href="qvector.html#resize">resize</a>() was underestimated, you run out of allocated space and into undefined behavior. This problem does not exist with reserve(), because it treats the size as just a hint.</p>
<p><b> 参见 </b><a href="qvector.html#squeeze">squeeze</a>() 和 <a href="qvector.html#capacity">capacity</a>().</p>
<!-- @@@reserve -->
<!-- $$$resize[overload1]$$$resizeint -->
<h3 class="fn" id="resize"><a name="resize"></a><span class="type">void</span> QVector::<span class="name">resize</span>(<span class="type">int</span> <i>size</i>)</h3>
<p>Sets the size of the vector to <i>size</i>. If <i>size</i> is greater than the current size, elements are added to the end; the new elements are initialized with a <a href="containers.html#default-constructed-value">default-constructed value</a>. If <i>size</i> is less than the current size, elements are removed from the end.</p>
<p>Since Qt 5.6, resize() doesn't shrink the capacity anymore. To shed excess capacity, use <a href="qvector.html#squeeze">squeeze</a>().</p>
<p><b> 参见 </b><a href="qvector.html#size">size</a>().</p>
<!-- @@@resize -->
<!-- $$$shrink_to_fit[overload1]$$$shrink_to_fit -->
<h3 class="fn" id="shrink_to_fit"><a name="shrink_to_fit"></a><span class="type">void</span> QVector::<span class="name">shrink_to_fit</span>()</h3>
<p>此函数用于STL风格的兼容性，它相当于 <a href="qvector.html#squeeze">squeeze</a>().</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<!-- @@@shrink_to_fit -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><a name="size"></a><span class="type">int</span> QVector::<span class="name">size</span>() const</h3>
<p>Returns the number of items in the vector.</p>
<p><b> 参见 </b><a href="qvector.html#isEmpty">isEmpty</a>() 和 <a href="qvector.html#resize">resize</a>().</p>
<!-- @@@size -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" id="squeeze"><a name="squeeze"></a><span class="type">void</span> QVector::<span class="name">squeeze</span>()</h3>
<p>Releases any memory not required to store the items.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qvector.html">QVector</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b> 参见 </b><a href="qvector.html#reserve">reserve</a>() 和 <a href="qvector.html#capacity">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$startsWith[overload1]$$$startsWithconstT& -->
<h3 class="fn" id="startsWith"><a name="startsWith"></a><span class="type">bool</span> QVector::<span class="name">startsWith</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns <code>true</code> if this vector is not empty and its first item is equal to <i>value</i>; otherwise returns <code>false</code>.</p>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#isEmpty">isEmpty</a>() 和 <a href="qvector.html#first">first</a>().</p>
<!-- @@@startsWith -->
<!-- $$$swap[overload1]$$$swapQVector<T>& -->
<h3 class="fn" id="swap"><a name="swap"></a><span class="type">void</span> QVector::<span class="name">swap</span>(<span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Swaps vector <i>other</i> with this vector. This operation is very fast and never fails.</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<!-- @@@swap -->
<!-- $$$takeAt[overload1]$$$takeAtint -->
<h3 class="fn" id="takeAt"><a name="takeAt"></a><span class="type">T</span> QVector::<span class="name">takeAt</span>(<span class="type">int</span> <i>i</i>)</h3>
<p>Removes the element at index position <i>i</i> and returns it.</p>
<p>Equivalent to</p>
<pre class="cpp">

  T t <span class="operator">=</span> at(i);
  remove(i);
  <span class="keyword">return</span> t;

</pre>
<p>Provided for compatibility with <a href="qlist.html">QList</a>.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#takeFirst">takeFirst</a>(), <a href="qvector.html#takeLast">takeLast</a>(), 和 <a href="qlist.html#takeAt">QList::takeAt</a>().</p>
<!-- @@@takeAt -->
<!-- $$$takeFirst[overload1]$$$takeFirst -->
<h3 class="fn" id="takeFirst"><a name="takeFirst"></a><span class="type">T</span> QVector::<span class="name">takeFirst</span>()</h3>
<p>Removes the first item in the vector and returns it. This function assumes the vector is not empty. To avoid failure, call <a href="qvector.html#isEmpty">isEmpty</a>() before calling this function.</p>
<p>这个函数是在Qt 5.1版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#takeLast">takeLast</a>() 和 <a href="qvector.html#removeFirst">removeFirst</a>().</p>
<!-- @@@takeFirst -->
<!-- $$$takeLast[overload1]$$$takeLast -->
<h3 class="fn" id="takeLast"><a name="takeLast"></a><span class="type">T</span> QVector::<span class="name">takeLast</span>()</h3>
<p>删除当前列表中的最后一项并并返回最后一项。 This function assumes the vector is not empty. To avoid failure, call <a href="qvector.html#isEmpty">isEmpty</a>() before calling this function.</p>
<p>If you don't use the return value, <a href="qvector.html#removeLast">removeLast</a>() is more efficient.</p>
<p>这个函数是在Qt 5.1版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#takeFirst">takeFirst</a>() 和 <a href="qvector.html#removeLast">removeLast</a>().</p>
<!-- @@@takeLast -->
<!-- $$$toList[overload1]$$$toList -->
<h3 class="fn" id="toList"><a name="toList"></a><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">toList</span>() const</h3>
<p>Returns a <a href="qlist.html">QList</a> object with the data contained in this <a href="qvector.html">QVector</a>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> vect;
  vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;red&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;green&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;blue&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;black&quot;</span>;

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> list <span class="operator">=</span> vect<span class="operator">.</span>toList();
  <span class="comment">// list: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;]</span>

</pre>
<p><b> 参见 </b><a href="qvector.html#fromList">fromList</a>() 和 <a href="qlist.html#fromVector">QList::fromVector</a>().</p>
<!-- @@@toList -->
<!-- $$$toStdVector[overload1]$$$toStdVector -->
<h3 class="fn" id="toStdVector"><a name="toStdVector"></a><span class="type">std::vector</span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">toStdVector</span>() const</h3>
<p>Returns a std::vector object with the data contained in this <a href="qvector.html">QVector</a>. Example:</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html#QVector">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> vector;
  vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1.2</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">0.5</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3.14</span>;

  std<span class="operator">::</span>vector<span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> stdvector <span class="operator">=</span> vector<span class="operator">.</span>toStdVector();

</pre>
<p><b> 参见 </b><a href="qvector.html#fromStdVector">fromStdVector</a>() 和 <a href="qlist.html#toStdList">QList::toStdList</a>().</p>
<!-- @@@toStdVector -->
<!-- $$$value[overload1]$$$valueint -->
<h3 class="fn" id="value"><a name="value"></a><span class="type">T</span> QVector::<span class="name">value</span>(<span class="type">int</span> <i>i</i>) const</h3>
<p>Returns the value at index position <i>i</i> in the vector.</p>
<p>若索引值 <i>i</i> 越界，则该函数将返回 <a href="containers.html#default-constructed-value">default-constructed value</a>. If you are certain that <i>i</i> is within bounds, you can use <a href="qvector.html#at">at</a>() instead, which is slightly faster.</p>
<p><b> 参见 </b><a href="qvector.html#at">at</a>() 和 <a href="qvector.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@value -->
<!-- $$$value$$$valueintconstT& -->
<h3 class="fn" id="value-1"><a name="value-1"></a><span class="type">T</span> QVector::<span class="name">value</span>(<span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp;<i>defaultValue</i>) const</h3>
<p>这是一个重载函数。</p>
<p>若索引值 <i>i</i> 越界，则该函数将返回默认值 <i>defaultValue</i>。</p>
<!-- @@@value -->
<!-- $$$operator!=[overload1]$$$operator!=constQVector<T>& -->
<h3 class="fn" id="operator-not-eq"><a name="operator-not-eq"></a><span class="type">bool</span> QVector::<span class="name">operator!=</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code>true</code> if <i>other</i> is not equal to this vector; otherwise returns <code>false</code>.</p>
<p>Two vectors are considered equal if they contain the same values in the same order.</p>
<p>该函数邀请值类型的列表元素实现了 <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qvector.html#operator-eq-eq">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator+[overload1]$$$operator+constQVector<T>& -->
<h3 class="fn" id="operator-2b"><a name="operator-2b"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">operator+</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns a vector that contains all the items in this vector followed by all the items in the <i>other</i> vector.</p>
<p><b> 参见 </b><a href="qvector.html#operator-2b-eq">operator+=</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+=[overload1]$$$operator+=constQVector<T>& -->
<h3 class="fn" id="operator-2b-eq"><a name="operator-2b-eq"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator+=</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Appends the items of the <i>other</i> vector to this vector and returns a reference to this vector.</p>
<p><b> 参见 </b><a href="qvector.html#operator-2b">operator+</a>() 和 <a href="qvector.html#append">append</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constT& -->
<h3 class="fn" id="operator-2b-eq-1"><a name="operator-2b-eq-1"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator+=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>这是一个重载函数。</p>
<p>Appends <i>value</i> to the vector.</p>
<p><b> 参见 </b><a href="qvector.html#append">append</a>() 和 <a href="qvector.html#operator-lt-lt">operator&lt;&lt;</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=T&& -->
<h3 class="fn" id="operator-2b-eq-2"><a name="operator-2b-eq-2"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator+=</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.11版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#append">append</a>() 和 <a href="qvector.html#operator-lt-lt">operator&lt;&lt;</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator<<[overload1]$$$operator<<constT& -->
<h3 class="fn" id="operator-lt-lt"><a name="operator-lt-lt"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator&lt;&lt;</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Appends <i>value</i> to the vector and returns a reference to this vector.</p>
<p><b> 参见 </b><a href="qvector.html#append">append</a>() 和 <a href="qvector.html#operator-2b-eq">operator+=</a>().</p>
<!-- @@@operator<< -->
<!-- $$$operator<<$$$operator<<constQVector<T>& -->
<h3 class="fn" id="operator-lt-lt-1"><a name="operator-lt-lt-1"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator&lt;&lt;</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Appends <i>other</i> to the vector and returns a reference to the vector.</p>
<!-- @@@operator<< -->
<!-- $$$operator<<$$$operator<<T&& -->
<h3 class="fn" id="operator-lt-lt-2"><a name="operator-lt-lt-2"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator&lt;&lt;</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.11版本中新增引入的。</p>
<p><b> 参见 </b><a href="qvector.html#append">append</a>() 和 <a href="qvector.html#operator-2b-eq">operator+=</a>().</p>
<!-- @@@operator<< -->
<!-- $$$operator=[overload1]$$$operator=constQVector<T>& -->
<h3 class="fn" id="operator-eq"><a name="operator-eq"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator=</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Assigns <i>other</i> to this vector and returns a reference to this vector.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QVector<T>&& -->
<h3 class="fn" id="operator-eq-1"><a name="operator-eq-1"></a><span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator=</span>(<span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i>other</i> to this <a href="qvector.html">QVector</a> instance.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQVector<T>& -->
<h3 class="fn" id="operator-eq-eq"><a name="operator-eq-eq"></a><span class="type">bool</span> QVector::<span class="name">operator==</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code>true</code> if <i>other</i> is equal to this vector; otherwise returns <code>false</code>.</p>
<p>Two vectors are considered equal if they contain the same values in the same order.</p>
<p>该函数邀请值类型的列表元素实现了 <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qvector.html#operator-not-eq">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator[][overload1]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d"><a name="operator-5b-5d"></a><span class="type">T</span> &amp;QVector::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>)</h3>
<p>Returns the item at index position <i>i</i> as a modifiable reference.</p>
<p><i>i</i> must be a valid index position in the vector (i.e&#x2e;, 0 &lt;= <i>i</i> &lt; <a href="qvector.html#size">size</a>()).</p>
<p>Note that using non-const operators can cause <a href="qvector.html">QVector</a> to do a deep copy.</p>
<p><b> 参见 </b><a href="qvector.html#at">at</a>() 和 <a href="qvector.html#value">value</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d-1"><a name="operator-5b-5d-1"></a>const <span class="type">T</span> &amp;QVector::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>) const</h3>
<p>这是一个重载函数。</p>
<p>Same as at(<i>i</i>).</p>
<!-- @@@operator[] -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
<!-- $$$qHash[overload1]$$$qHashconstQVector<T>&uint -->
<h3 class="fn" id="qHash"><a name="qHash"></a><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qHash</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>key</i>, <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>seed</i> = ...)</h3>
<p>Returns the hash value for <i>key</i>, using <i>seed</i> to seed the calculation.</p>
<p>This function requires <a href="qstringview.html#qHash">qHash</a>() to be overloaded for the value type <code>T</code>.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@qHash -->
<!-- $$$operator<[overload1]$$$operator<constQVector<T>&constQVector<T>& -->
<h3 class="fn" id="operator-lt"><a name="operator-lt"></a><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code>true</code> if vector <i>lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically less than</a> <i>rhs</i>; otherwise returns <code>false</code>.</p>
<p>该函数邀请值类型的列表元素实现了 <code>operator&lt;()</code>.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@operator< -->
<!-- $$$operator<<$$$operator<<QDataStream&constQVector<T>& -->
<h3 class="fn" id="operator-lt-lt-3"><a name="operator-lt-lt-3"></a><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>vector</i>)</h3>
<p>Writes the vector <i>vector</i> to stream <i>out</i>.</p>
<p>该函数要求值类型的列表元素实现了 <code>operator&lt;&lt;()</code>.</p>
<p><b> 参见 </b><a href="datastreamformat.html">数据流运算符的格式</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator<=[overload1]$$$operator<=constQVector<T>&constQVector<T>& -->
<h3 class="fn" id="operator-lt-eq"><a name="operator-lt-eq"></a><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code>true</code> if vector <i>lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically less than or equal to</a> <i>rhs</i>; otherwise returns <code>false</code>.</p>
<p>该函数邀请值类型的列表元素实现了 <code>operator&lt;()</code>.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@operator<= -->
<!-- $$$operator>[overload1]$$$operator>constQVector<T>&constQVector<T>& -->
<h3 class="fn" id="operator-gt"><a name="operator-gt"></a><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code>true</code> if vector <i>lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically greater than</a> <i>rhs</i>; otherwise returns <code>false</code>.</p>
<p>该函数邀请值类型的列表元素实现了 <code>operator&lt;()</code>.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@operator> -->
<!-- $$$operator>=[overload1]$$$operator>=constQVector<T>&constQVector<T>& -->
<h3 class="fn" id="operator-gt-eq"><a name="operator-gt-eq"></a><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code>true</code> if vector <i>lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically greater than or equal to</a> <i>rhs</i>; otherwise returns <code>false</code>.</p>
<p>该函数邀请值类型的列表元素实现了 <code>operator&lt;()</code>.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@operator>= -->
<!-- $$$operator>>[overload1]$$$operator>>QDataStream&QVector<T>& -->
<h3 class="fn" id="operator-gt-gt"><a name="operator-gt-gt"></a><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qvector.html#QVector">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>vector</i>)</h3>
<p>Reads a vector from stream <i>in</i> into <i>vector</i>.</p>
<p>该函数要求值类型的列表元素实现了 <code>operator&gt;&gt;()</code>.</p>
<p><b> 参见 </b><a href="datastreamformat.html">数据流运算符的格式</a>.</p>
<!-- @@@operator>> -->
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
