<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qsharedpointer.cpp -->
  <title>QSharedPointer Class | Qt Core 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QSharedPointer</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#related-non-members">相关非成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#thread-safety">Thread-Safety</a></li>
<li class="level2"><a href="#other-pointer-classes">Other Pointer Classes</a></li>
<li class="level2"><a href="#optional-pointer-tracking">Optional Pointer Tracking</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QSharedPointer Class</h1>
<!-- $$$QSharedPointer-brief -->
<p>The <a href="qsharedpointer.html">QSharedPointer</a> class holds a strong reference to a shared pointer. <a href="#details">More...</a></p>
<!-- @@@QSharedPointer -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QSharedPointer&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 4.5</td></tr></table></div><ul>
<li><a href="qsharedpointer-members.html">所有成员清单，包括继承而来的成员</a></li>
</ul>
<p><b>注意：</b> 此类中的所有函数都是 <a href="../qtdoc/threads-reentrancy.html">可重入的。</a></p>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-1">QSharedPointer</a></b>(X *<i>ptr</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-2">QSharedPointer</a></b>(X *<i>ptr</i>, Deleter <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-3">QSharedPointer</a></b>(<i>std::nullptr_t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-4">QSharedPointer</a></b>(<i>std::nullptr_t</i>, Deleter <i>d</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-5">QSharedPointer</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#QSharedPointer-6">QSharedPointer</a></b>(const QWeakPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#dtor.QSharedPointer">~QSharedPointer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#clear">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#constCast">constCast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#data">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#dynamicCast">dynamicCast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#get">get</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#isNull">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#objectCast">objectCast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#reset">reset</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#reset-1">reset</a></b>(T *<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#reset-2">reset</a></b>(T *<i>t</i>, Deleter <i>deleter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#staticCast">staticCast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#swap">swap</a></b>(QSharedPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWeakPointer&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#toWeakRef">toWeakRef</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-bool">operator bool</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not">operator!</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-2a">operator*</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator--gt">operator-&gt;</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq">operator=</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-1">operator=</a></b>(const QWeakPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#create">create</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#create-1">create</a></b>(<i>...</i>)</td></tr>
</table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">相关非成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerCast">qSharedPointerCast</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerConstCast">qSharedPointerConstCast</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerDynamicCast">qSharedPointerDynamicCast</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;X&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#qSharedPointerObjectCast">qSharedPointerObjectCast</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq">operator!=</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>ptr1</i>, const QSharedPointer&lt;X&gt; &amp;<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq-1">operator!=</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>ptr1</i>, const X *<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq-2">operator!=</a></b>(const T *<i>ptr1</i>, const QSharedPointer&lt;X&gt; &amp;<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq-3">operator!=</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>lhs</i>, <i>std::nullptr_t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-not-eq-4">operator!=</a></b>(<i>std::nullptr_t</i>, const QSharedPointer&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDebug </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-lt-lt">operator&lt;&lt;</a></b>(QDebug <i>debug</i>, const QSharedPointer&lt;T&gt; &amp;<i>ptr</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq">operator==</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>ptr1</i>, const QSharedPointer&lt;X&gt; &amp;<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq-1">operator==</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>ptr1</i>, const X *<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq-2">operator==</a></b>(const T *<i>ptr1</i>, const QSharedPointer&lt;X&gt; &amp;<i>ptr2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq-3">operator==</a></b>(const QSharedPointer&lt;T&gt; &amp;<i>lhs</i>, <i>std::nullptr_t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsharedpointer.html#operator-eq-eq-4">operator==</a></b>(<i>std::nullptr_t</i>, const QSharedPointer&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QSharedPointer-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qsharedpointer.html">QSharedPointer</a> class holds a strong reference to a shared pointer.</p>
<p>The <a href="qsharedpointer.html">QSharedPointer</a> is an automatic, shared pointer in C++. It behaves exactly like a normal pointer for normal purposes, including respect for constness.</p>
<p><a href="qsharedpointer.html">QSharedPointer</a> will delete the pointer it is holding when it goes out of scope, provided no other <a href="qsharedpointer.html">QSharedPointer</a> objects are referencing it.</p>
<p>A <a href="qsharedpointer.html">QSharedPointer</a> object can be created from a normal pointer, another <a href="qsharedpointer.html">QSharedPointer</a> object or by promoting a <a href="qweakpointer.html">QWeakPointer</a> object to a strong reference.</p>
<a name="thread-safety"></a>
<h3 >Thread-Safety</h3>
<p><a href="qsharedpointer.html">QSharedPointer</a> 和 <a href="qweakpointer.html">QWeakPointer</a> are thread-safe and operate atomically on the pointer value. Different threads can also access the <a href="qsharedpointer.html">QSharedPointer</a> or <a href="qweakpointer.html">QWeakPointer</a> pointing to the same object at the same time without need for locking mechanisms.</p>
<p>It should be noted that, while the pointer value can be accessed in this manner, <a href="qsharedpointer.html">QSharedPointer</a> 和 <a href="qweakpointer.html">QWeakPointer</a> provide no guarantee about the object being pointed to. Thread-safety and reentrancy rules for that object still apply.</p>
<a name="other-pointer-classes"></a>
<h3 >Other Pointer Classes</h3>
<p>Qt also provides two other pointer wrapper classes: <a href="qpointer.html">QPointer</a> 和 <a href="qshareddatapointer.html">QSharedDataPointer</a>. They are incompatible with one another, since each has its very different use case.</p>
<p><a href="qsharedpointer.html">QSharedPointer</a> holds a shared pointer by means of an external reference count (i.e&#x2e;, a reference counter placed outside the object). Like its name indicates, the pointer value is shared among all instances of <a href="qsharedpointer.html">QSharedPointer</a> 和 <a href="qweakpointer.html">QWeakPointer</a>. The contents of the object pointed to by the pointer should not be considered shared, however: there is only one object. For that reason, <a href="qsharedpointer.html">QSharedPointer</a> does not provide a way to detach or make copies of the pointed object.</p>
<p><a href="qshareddatapointer.html">QSharedDataPointer</a>, on the other hand, holds a pointer to shared data (i.e&#x2e;, a class derived from <a href="qshareddata.html">QSharedData</a>). It does so by means of an internal reference count, placed in the <a href="qshareddata.html">QSharedData</a> base class. This class can, therefore, detach based on the type of access made to the data being guarded: if it's a non-const access, it creates a copy atomically for the operation to complete.</p>
<p><a href="qexplicitlyshareddatapointer.html">QExplicitlySharedDataPointer</a> is a variant of <a href="qshareddatapointer.html">QSharedDataPointer</a>, except that it only detaches if <a href="qexplicitlyshareddatapointer.html#detach">QExplicitlySharedDataPointer::detach</a>() is explicitly called (hence the name).</p>
<p><a href="qscopedpointer.html">QScopedPointer</a> simply holds a pointer to a heap allocated object and deletes it in its destructor. This class is useful when an object needs to be heap allocated and deleted, but no more. <a href="qscopedpointer.html">QScopedPointer</a> is lightweight, it makes no use of additional structure or reference counting.</p>
<p>Finally, <a href="qpointer.html">QPointer</a> holds a pointer to a <a href="qobject.html">QObject</a>-derived object, but it does so weakly. <a href="qweakpointer.html">QWeakPointer</a> has the same functionality, but its use for that function is deprecated.</p>
<a name="optional-pointer-tracking"></a>
<h3 >Optional Pointer Tracking</h3>
<p>A feature of <a href="qsharedpointer.html">QSharedPointer</a> that can be enabled at compile-time for debugging purposes is a pointer tracking mechanism. When enabled, <a href="qsharedpointer.html">QSharedPointer</a> registers in a global set all the pointers that it tracks. This allows one to catch mistakes like assigning the same pointer to two <a href="qsharedpointer.html">QSharedPointer</a> objects.</p>
<p>This function is enabled by defining the <code>QT_SHAREDPOINTER_TRACK_POINTERS</code> macro before including the <a href="qsharedpointer.html">QSharedPointer</a> header.</p>
<p>It is safe to use this feature even with code compiled without the feature. <a href="qsharedpointer.html">QSharedPointer</a> will ensure that the pointer is removed from the tracker even from code compiled without pointer tracking.</p>
<p>Note, however, that the pointer tracking feature has limitations on multiple- or virtual-inheritance (that is, in cases where two different pointer addresses can refer to the same object). In that case, if a pointer is cast to a different type and its value changes, <a href="qsharedpointer.html">QSharedPointer</a>'s pointer tracking mechanism may fail to detect that the object being tracked is the same.</p>
</div>
<p><b> 参见 </b><a href="qshareddatapointer.html">QSharedDataPointer</a>, <a href="qweakpointer.html">QWeakPointer</a>, <a href="qscopedpointer.html">QScopedPointer</a>, and <a href="qenablesharedfromthis.html">QEnableSharedFromThis</a>.</p>
<!-- @@@QSharedPointer -->
<div class="types">
<h2>成员类型文档</h2>
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QSharedPointer[overload1]$$$QSharedPointer -->
<h3 class="fn" id="QSharedPointer"><a name="QSharedPointer"></a>QSharedPointer::<span class="name">QSharedPointer</span>()</h3>
<p>Creates a <a href="qsharedpointer.html">QSharedPointer</a> that points to null (0).</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerX* -->
<h3 class="fn" id="QSharedPointer-1"><a name="QSharedPointer-1"></a>QSharedPointer::<span class="name">QSharedPointer</span>(<span class="type">X</span> *<i>ptr</i>)</h3>
<p>Creates a <a href="qsharedpointer.html">QSharedPointer</a> that points to <i>ptr</i>. The pointer <i>ptr</i> becomes managed by this <a href="qsharedpointer.html">QSharedPointer</a> and must not be passed to another <a href="qsharedpointer.html">QSharedPointer</a> object or deleted outside this object.</p>
<p>Since Qt 5.8, when the last reference to this <a href="qsharedpointer.html">QSharedPointer</a> gets destroyed, <i>ptr</i> will be deleted by calling <code>X</code>'s destructor (even if <code>X</code> is not the same as <a href="qsharedpointer.html">QSharedPointer</a>'s template parameter <code>T</code>). Previously, the destructor for <code>T</code> was called.</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerX*Deleter -->
<h3 class="fn" id="QSharedPointer-2"><a name="QSharedPointer-2"></a>QSharedPointer::<span class="name">QSharedPointer</span>(<span class="type">X</span> *<i>ptr</i>, <span class="type">Deleter</span> <i>d</i>)</h3>
<p>Creates a <a href="qsharedpointer.html">QSharedPointer</a> that points to <i>ptr</i>. The pointer <i>ptr</i> becomes managed by this <a href="qsharedpointer.html">QSharedPointer</a> and must not be passed to another <a href="qsharedpointer.html">QSharedPointer</a> object or deleted outside this object.</p>
<p>The deleter parameter <i>d</i> specifies the custom deleter for this object. The custom deleter is called, instead of the operator delete(), when the strong reference count drops to 0. This is useful, for instance, for calling <a href="qobject.html#deleteLater">deleteLater()</a> on a <a href="qobject.html">QObject</a> instead:</p>
<pre class="cpp">

      <span class="keyword">static</span> <span class="type">void</span> doDeleteLater(MyObject <span class="operator">*</span>obj)
      {
          obj<span class="operator">-</span><span class="operator">&gt;</span>deleteLater();
      }

      <span class="type">void</span> otherFunction()
      {
          <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span><span class="operator">&lt;</span>MyObject<span class="operator">&gt;</span> obj <span class="operator">=</span>
              <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span><span class="operator">&lt;</span>MyObject<span class="operator">&gt;</span>(<span class="keyword">new</span> MyObject<span class="operator">,</span> doDeleteLater);

          <span class="comment">// continue using obj</span>
          obj<span class="operator">.</span>clear();    <span class="comment">// calls obj-&gt;deleteLater();</span>
      }

</pre>
<p>Note that the custom deleter function will be called with a pointer to type <code>X</code>, even if the <a href="qsharedpointer.html">QSharedPointer</a> template parameter <code>T</code> is not the same.</p>
<p>It is also possible to specify a member function directly, as in:</p>
<pre class="cpp">

      <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span><span class="operator">&lt;</span>MyObject<span class="operator">&gt;</span> obj <span class="operator">=</span>
          <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span><span class="operator">&lt;</span>MyObject<span class="operator">&gt;</span>(<span class="keyword">new</span> MyObject<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qobject.html">QObject</a></span><span class="operator">::</span>deleteLater);

</pre>
<p><b> 参见 </b><a href="qsharedpointer.html#clear">clear</a>().</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerstd::nullptr_t -->
<h3 class="fn" id="QSharedPointer-3"><a name="QSharedPointer-3"></a>QSharedPointer::<span class="name">QSharedPointer</span>(<i>std::nullptr_t</i>)</h3>
<p>Creates a <a href="qsharedpointer.html">QSharedPointer</a> that is null. This is equivalent to the <a href="qsharedpointer.html">QSharedPointer</a> default constructor.</p>
<p>这个函数是在Qt 5.8版本中新增引入的。</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerstd::nullptr_tDeleter -->
<h3 class="fn" id="QSharedPointer-4"><a name="QSharedPointer-4"></a>QSharedPointer::<span class="name">QSharedPointer</span>(<i>std::nullptr_t</i>, <span class="type">Deleter</span> <i>d</i>)</h3>
<p>Creates a <a href="qsharedpointer.html">QSharedPointer</a> that is null. This is equivalent to the <a href="qsharedpointer.html">QSharedPointer</a> default constructor.</p>
<p>The deleter parameter <i>d</i> specifies the custom deleter for this object. The custom deleter is called, instead of the operator delete(), when the strong reference count drops to 0.</p>
<p>这个函数是在Qt 5.8版本中新增引入的。</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerconstQSharedPointer<T>& -->
<h3 class="fn" id="QSharedPointer-5"><a name="QSharedPointer-5"></a>QSharedPointer::<span class="name">QSharedPointer</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Creates a <a href="qsharedpointer.html">QSharedPointer</a> object that shares <i>other</i>'s pointer.</p>
<p>If <code>T</code> is a derived type of the template parameter of this class, <a href="qsharedpointer.html">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error.</p>
<!-- @@@QSharedPointer -->
<!-- $$$QSharedPointer$$$QSharedPointerconstQWeakPointer<T>& -->
<h3 class="fn" id="QSharedPointer-6"><a name="QSharedPointer-6"></a>QSharedPointer::<span class="name">QSharedPointer</span>(const <span class="type"><a href="qweakpointer.html">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Creates a <a href="qsharedpointer.html">QSharedPointer</a> by promoting the weak reference <i>other</i> to strong reference and sharing its pointer.</p>
<p>If <code>T</code> is a derived type of the template parameter of this class, <a href="qsharedpointer.html">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error.</p>
<p><b> 参见 </b><a href="qweakpointer.html#toStrongRef">QWeakPointer::toStrongRef</a>().</p>
<!-- @@@QSharedPointer -->
<!-- $$$~QSharedPointer[overload1]$$$~QSharedPointer -->
<h3 class="fn" id="dtor.QSharedPointer"><a name="dtor.QSharedPointer"></a>QSharedPointer::<span class="name">~QSharedPointer</span>()</h3>
<p>Destroys this <a href="qsharedpointer.html">QSharedPointer</a> object. If it is the last reference to the pointer stored, this will delete the pointer as well.</p>
<!-- @@@~QSharedPointer -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear"><a name="clear"></a><span class="type">void</span> QSharedPointer::<span class="name">clear</span>()</h3>
<p>Clears this <a href="qsharedpointer.html">QSharedPointer</a> object, dropping the reference that it may have had to the pointer. If this was the last reference, then the pointer itself will be deleted.</p>
<!-- @@@clear -->
<!-- $$$constCast[overload1]$$$constCast -->
<h3 class="fn" id="constCast"><a name="constCast"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; QSharedPointer::<span class="name">constCast</span>() const</h3>
<p>Performs a <code>const_cast</code> from this pointer's type to <code>X</code> and returns a <a href="qsharedpointer.html">QSharedPointer</a> that shares the reference. This function can be used for up- and for down-casting, but is more useful for up-casting.</p>
<p><b> 参见 </b><a href="qsharedpointer.html#isNull">isNull</a>() 和 <a href="qsharedpointer.html#qSharedPointerConstCast">qSharedPointerConstCast</a>().</p>
<!-- @@@constCast -->
<!-- $$$create[overload1]$$$create -->
<h3 class="fn" id="create"><a name="create"></a><code>[static] </code><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; QSharedPointer::<span class="name">create</span>()</h3>
<p>Creates a <a href="qsharedpointer.html">QSharedPointer</a> object and allocates a new item of type <code>T</code>. The <a href="qsharedpointer.html">QSharedPointer</a> internals and the object are allocated in one single memory allocation, which could help reduce memory fragmentation in a long-running application.</p>
<p>This function calls the default constructor for type <code>T</code>.</p>
<p>这个函数是在Qt 5.1版本中新增引入的。</p>
<!-- @@@create -->
<!-- $$$create$$$create... -->
<h3 class="fn" id="create-1"><a name="create-1"></a><code>[static] </code><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; QSharedPointer::<span class="name">create</span>(<i>...</i>)</h3>
<p>这是一个重载函数。</p>
<p>Creates a <a href="qsharedpointer.html">QSharedPointer</a> object and allocates a new item of type <code>T</code>. The <a href="qsharedpointer.html">QSharedPointer</a> internals and the object are allocated in one single memory allocation, which could help reduce memory fragmentation in a long-running application.</p>
<p>This function will attempt to call a constructor for type <code>T</code> that can accept all the arguments passed. Arguments will be perfectly-forwarded.</p>
<p><b>Note: </b>This function is only fully available with a C++11 compiler that supports perfect forwarding of an arbitrary number of arguments.</p><p>If the compiler does not support the necessary C++11 features, then a restricted version is available since Qt 5.4: you may pass one (but just one) argument, and it will always be passed by const reference.</p>
<p>If you target Qt before version 5.4, you must use the overload that calls the default constructor.</p>
<p>这个函数是在Qt 5.1版本中新增引入的。</p>
<!-- @@@create -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" id="data"><a name="data"></a><span class="type">T</span> *QSharedPointer::<span class="name">data</span>() const</h3>
<p>Returns the value of the pointer referenced by this object.</p>
<p>Note: do not delete the pointer returned by this function or pass it to another function that could delete it, including creating <a href="qsharedpointer.html">QSharedPointer</a> or <a href="qweakpointer.html">QWeakPointer</a> objects.</p>
<!-- @@@data -->
<!-- $$$dynamicCast[overload1]$$$dynamicCast -->
<h3 class="fn" id="dynamicCast"><a name="dynamicCast"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; QSharedPointer::<span class="name">dynamicCast</span>() const</h3>
<p>Performs a dynamic cast from this pointer's type to <code>X</code> and returns a <a href="qsharedpointer.html">QSharedPointer</a> that shares the reference. If this function is used to up-cast, then <a href="qsharedpointer.html">QSharedPointer</a> will perform a <code>dynamic_cast</code>, which means that if the object being pointed by this <a href="qsharedpointer.html">QSharedPointer</a> is not of type <code>X</code>, the returned object will be null.</p>
<p>Note: the template type <code>X</code> must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use <a href="qsharedpointer.html#constCast">constCast</a>() if you need to drop those qualifiers.</p>
<p><b> 参见 </b><a href="qsharedpointer.html#qSharedPointerDynamicCast">qSharedPointerDynamicCast</a>().</p>
<!-- @@@dynamicCast -->
<!-- $$$get[overload1]$$$get -->
<h3 class="fn" id="get"><a name="get"></a><span class="type">T</span> *QSharedPointer::<span class="name">get</span>() const</h3>
<p>等同于 <a href="qsharedpointer.html#data">data</a>().</p>
<p>This function is provided for API compatibility with <code>std::shared_ptr</code>.</p>
<p>这个函数是在Qt 5.11版本中新增引入的。</p>
<!-- @@@get -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" id="isNull"><a name="isNull"></a><span class="type">bool</span> QSharedPointer::<span class="name">isNull</span>() const</h3>
<p>Returns <code>true</code> if this object is holding a reference to a null pointer.</p>
<!-- @@@isNull -->
<!-- $$$objectCast[overload1]$$$objectCast -->
<h3 class="fn" id="objectCast"><a name="objectCast"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; QSharedPointer::<span class="name">objectCast</span>() const</h3>
<p>Performs a <a href="qobject.html#qobject_cast">qobject_cast</a>() from this pointer's type to <code>X</code> and returns a <a href="qsharedpointer.html">QSharedPointer</a> that shares the reference. If this function is used to up-cast, then <a href="qsharedpointer.html">QSharedPointer</a> will perform a <code>qobject_cast</code>, which means that if the object being pointed by this <a href="qsharedpointer.html">QSharedPointer</a> is not of type <code>X</code>, the returned object will be null.</p>
<p>Note: the template type <code>X</code> must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use <a href="qsharedpointer.html#constCast">constCast</a>() if you need to drop those qualifiers.</p>
<p>这个函数是在Qt 4.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qsharedpointer.html#qSharedPointerObjectCast">qSharedPointerObjectCast</a>().</p>
<!-- @@@objectCast -->
<!-- $$$reset[overload1]$$$reset -->
<h3 class="fn" id="reset"><a name="reset"></a><span class="type">void</span> QSharedPointer::<span class="name">reset</span>()</h3>
<p>等同于 <a href="qsharedpointer.html#clear">clear</a>(). For std::shared_ptr compatibility.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@reset -->
<!-- $$$reset$$$resetT* -->
<h3 class="fn" id="reset-1"><a name="reset-1"></a><span class="type">void</span> QSharedPointer::<span class="name">reset</span>(<span class="type">T</span> *<i>t</i>)</h3>
<p>Resets this <a href="qsharedpointer.html">QSharedPointer</a> object to point to <i>t</i> instead. Equivalent to:</p>
<pre class="cpp">

      <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span><span class="operator">&lt;</span>T<span class="operator">&gt;</span> other(t); <span class="keyword">this</span><span class="operator">-</span><span class="operator">&gt;</span>swap(other);

</pre>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@reset -->
<!-- $$$reset$$$resetT*Deleter -->
<h3 class="fn" id="reset-2"><a name="reset-2"></a><span class="type">void</span> QSharedPointer::<span class="name">reset</span>(<span class="type">T</span> *<i>t</i>, <span class="type">Deleter</span> <i>deleter</i>)</h3>
<p>Resets this <a href="qsharedpointer.html">QSharedPointer</a> object to point to <i>t</i> instead, with the Deleter <i>deleter</i>. Equivalent to:</p>
<pre class="cpp">

      <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span><span class="operator">&lt;</span>T<span class="operator">&gt;</span> other(t<span class="operator">,</span> deleter); <span class="keyword">this</span><span class="operator">-</span><span class="operator">&gt;</span>swap(other);

</pre>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<!-- @@@reset -->
<!-- $$$staticCast[overload1]$$$staticCast -->
<h3 class="fn" id="staticCast"><a name="staticCast"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; QSharedPointer::<span class="name">staticCast</span>() const</h3>
<p>Performs a static cast from this pointer's type to <code>X</code> and returns a <a href="qsharedpointer.html">QSharedPointer</a> that shares the reference. This function can be used for up- and for down-casting, but is more useful for up-casting.</p>
<p>Note: the template type <code>X</code> must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use <a href="qsharedpointer.html#constCast">constCast</a>() if you need to drop those qualifiers.</p>
<p><b> 参见 </b><a href="qsharedpointer.html#dynamicCast">dynamicCast</a>(), <a href="qsharedpointer.html#constCast">constCast</a>(), 和 <a href="qsharedpointer.html#qSharedPointerCast">qSharedPointerCast</a>().</p>
<!-- @@@staticCast -->
<!-- $$$swap[overload1]$$$swapQSharedPointer<T>& -->
<h3 class="fn" id="swap"><a name="swap"></a><span class="type">void</span> QSharedPointer::<span class="name">swap</span>(<span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Swaps this shared pointer instance with <i>other</i>. This function is very fast and never fails.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<!-- @@@swap -->
<!-- $$$toWeakRef[overload1]$$$toWeakRef -->
<h3 class="fn" id="toWeakRef"><a name="toWeakRef"></a><span class="type"><a href="qweakpointer.html">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; QSharedPointer::<span class="name">toWeakRef</span>() const</h3>
<p>Returns a weak reference object that shares the pointer referenced by this object.</p>
<p><b> 参见 </b><a href="qweakpointer.html#QWeakPointer">QWeakPointer::QWeakPointer</a>().</p>
<!-- @@@toWeakRef -->
<!-- $$$operator bool[overload1]$$$operator bool -->
<h3 class="fn" id="operator-bool"><a name="operator-bool"></a><span class="type">bool</span> QSharedPointer::<span class="name">operator bool</span>() const</h3>
<p>Returns <code>true</code> if this object is not null. This function is suitable for use in <code>if-constructs</code>, like:</p>
<pre class="cpp">

      <span class="keyword">if</span> (sharedptr) { <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> }

</pre>
<p><b> 参见 </b><a href="qsharedpointer.html#isNull">isNull</a>().</p>
<!-- @@@operator bool -->
<!-- $$$operator![overload1]$$$operator! -->
<h3 class="fn" id="operator-not"><a name="operator-not"></a><span class="type">bool</span> QSharedPointer::<span class="name">operator!</span>() const</h3>
<p>Returns <code>true</code> if this object is null. This function is suitable for use in <code>if-constructs</code>, like:</p>
<pre class="cpp">

      <span class="keyword">if</span> (<span class="operator">!</span>sharedptr) { <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> }

</pre>
<p><b> 参见 </b><a href="qsharedpointer.html#isNull">isNull</a>().</p>
<!-- @@@operator! -->
<!-- $$$operator*[overload1]$$$operator* -->
<h3 class="fn" id="operator-2a"><a name="operator-2a"></a><span class="type">T</span> &amp;QSharedPointer::<span class="name">operator*</span>() const</h3>
<p>Provides access to the shared pointer's members.</p>
<p><b> 参见 </b><a href="qsharedpointer.html#isNull">isNull</a>().</p>
<!-- @@@operator* -->
<!-- $$$operator->[overload1]$$$operator-> -->
<h3 class="fn" id="operator--gt"><a name="operator--gt"></a><span class="type">T</span> *QSharedPointer::<span class="name">operator-&gt;</span>() const</h3>
<p>Provides access to the shared pointer's members.</p>
<p><b> 参见 </b><a href="qsharedpointer.html#isNull">isNull</a>().</p>
<!-- @@@operator-> -->
<!-- $$$operator=[overload1]$$$operator=constQSharedPointer<T>& -->
<h3 class="fn" id="operator-eq"><a name="operator-eq"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QSharedPointer::<span class="name">operator=</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Makes this object share <i>other</i>'s pointer. The current pointer reference is discarded and, if it was the last, the pointer will be deleted.</p>
<p>If <code>T</code> is a derived type of the template parameter of this class, <a href="qsharedpointer.html">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=constQWeakPointer<T>& -->
<h3 class="fn" id="operator-eq-1"><a name="operator-eq-1"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QSharedPointer::<span class="name">operator=</span>(const <span class="type"><a href="qweakpointer.html">QWeakPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Promotes <i>other</i> to a strong reference and makes this object share a reference to the pointer referenced by it. The current pointer reference is discarded and, if it was the last, the pointer will be deleted.</p>
<p>If <code>T</code> is a derived type of the template parameter of this class, <a href="qsharedpointer.html">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error.</p>
<!-- @@@operator= -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
<!-- $$$qSharedPointerCast[overload1]$$$qSharedPointerCastconstQSharedPointer<T>& -->
<h3 class="fn" id="qSharedPointerCast"><a name="qSharedPointerCast"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerCast</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i>other</i>, cast to type <code>X</code>. The types <code>T</code> and <code>X</code> must belong to one hierarchy for the <code>static_cast</code> to succeed.</p>
<p>Note that <code>X</code> must have the same cv-qualifiers (<code>const</code> and <code>volatile</code>) that <code>T</code> has, or the code will fail to compile. Use <a href="qsharedpointer.html#qSharedPointerConstCast">qSharedPointerConstCast</a> to cast away the constness.</p>
<p><b> 参见 </b><a href="qsharedpointer.html#staticCast">QSharedPointer::staticCast</a>(), <a href="qsharedpointer.html#qSharedPointerDynamicCast">qSharedPointerDynamicCast</a>(), 和 <a href="qsharedpointer.html#qSharedPointerConstCast">qSharedPointerConstCast</a>().</p>
<!-- @@@qSharedPointerCast -->
<!-- $$$qSharedPointerConstCast[overload1]$$$qSharedPointerConstCastconstQSharedPointer<T>& -->
<h3 class="fn" id="qSharedPointerConstCast"><a name="qSharedPointerConstCast"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerConstCast</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i>src</i>, cast to type <code>X</code>. The types <code>T</code> and <code>X</code> must belong to one hierarchy for the <code>const_cast</code> to succeed. The <code>const</code> and <code>volatile</code> differences between <code>T</code> and <code>X</code> are ignored.</p>
<p><b> 参见 </b><a href="qsharedpointer.html#constCast">QSharedPointer::constCast</a>(), <a href="qsharedpointer.html#qSharedPointerCast">qSharedPointerCast</a>(), 和 <a href="qsharedpointer.html#qSharedPointerDynamicCast">qSharedPointerDynamicCast</a>().</p>
<!-- @@@qSharedPointerConstCast -->
<!-- $$$qSharedPointerDynamicCast[overload1]$$$qSharedPointerDynamicCastconstQSharedPointer<T>& -->
<h3 class="fn" id="qSharedPointerDynamicCast"><a name="qSharedPointerDynamicCast"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerDynamicCast</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>Returns a shared pointer to the pointer held by <i>src</i>, using a dynamic cast to type <code>X</code> to obtain an internal pointer of the appropriate type. If the <code>dynamic_cast</code> fails, the object returned will be null.</p>
<p>Note that <code>X</code> must have the same cv-qualifiers (<code>const</code> and <code>volatile</code>) that <code>T</code> has, or the code will fail to compile. Use <a href="qsharedpointer.html#qSharedPointerConstCast">qSharedPointerConstCast</a> to cast away the constness.</p>
<p><b> 参见 </b><a href="qsharedpointer.html#dynamicCast">QSharedPointer::dynamicCast</a>(), <a href="qsharedpointer.html#qSharedPointerCast">qSharedPointerCast</a>(), 和 <a href="qsharedpointer.html#qSharedPointerConstCast">qSharedPointerConstCast</a>().</p>
<!-- @@@qSharedPointerDynamicCast -->
<!-- $$$qSharedPointerObjectCast[overload1]$$$qSharedPointerObjectCastconstQSharedPointer<T>& -->
<h3 class="fn" id="qSharedPointerObjectCast"><a name="qSharedPointerObjectCast"></a><span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; <span class="name">qSharedPointerObjectCast</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>src</i>)</h3>
<p>The qSharedPointerObjectCast function is for casting a shared pointer.</p>
<p>Returns a shared pointer to the pointer held by <i>src</i>, using a <a href="qobject.html#qobject_cast">qobject_cast</a>() to type <code>X</code> to obtain an internal pointer of the appropriate type. If the <code>qobject_cast</code> fails, the object returned will be null.</p>
<p>Note that <code>X</code> must have the same cv-qualifiers (<code>const</code> and <code>volatile</code>) that <code>T</code> has, or the code will fail to compile. Use <a href="qsharedpointer.html#qSharedPointerConstCast">qSharedPointerConstCast</a> to cast away the constness.</p>
<p>这个函数是在Qt 4.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qsharedpointer.html#objectCast">QSharedPointer::objectCast</a>(), <a href="qsharedpointer.html#qSharedPointerCast">qSharedPointerCast</a>(), 和 <a href="qsharedpointer.html#qSharedPointerConstCast">qSharedPointerConstCast</a>().</p>
<!-- @@@qSharedPointerObjectCast -->
<!-- $$$operator!=[overload1]$$$operator!=constQSharedPointer<T>&constQSharedPointer<X>& -->
<h3 class="fn" id="operator-not-eq"><a name="operator-not-eq"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr1</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>ptr2</i>)</h3>
<p>Returns <code>true</code> if the pointer referenced by <i>ptr1</i> is not the same pointer as that referenced by <i>ptr2</i>.</p>
<p>If <i>ptr2</i>'s template parameter is different from <i>ptr1</i>'s, <a href="qsharedpointer.html">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <i>ptr2</i>'s template parameter is not a base or a derived type from <i>ptr1</i>'s, you will get a compiler error.</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQSharedPointer<T>&constX* -->
<h3 class="fn" id="operator-not-eq-1"><a name="operator-not-eq-1"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr1</i>, const <span class="type">X</span> *<i>ptr2</i>)</h3>
<p>Returns <code>true</code> if the pointer referenced by <i>ptr1</i> is not the same pointer as <i>ptr2</i>.</p>
<p>If <i>ptr2</i>'s type is different from <i>ptr1</i>'s, <a href="qsharedpointer.html">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <i>ptr2</i>'s type is not a base or a derived type from this <i>ptr1</i>'s, you will get a compiler error.</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constT*constQSharedPointer<X>& -->
<h3 class="fn" id="operator-not-eq-2"><a name="operator-not-eq-2"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type">T</span> *<i>ptr1</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>ptr2</i>)</h3>
<p>Returns <code>true</code> if the pointer <i>ptr1</i> is not the same pointer as that referenced by <i>ptr2</i>.</p>
<p>If <i>ptr2</i>'s template parameter is different from <i>ptr1</i>'s type, <a href="qsharedpointer.html">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <i>ptr2</i>'s template parameter is not a base or a derived type from <i>ptr1</i>'s type, you will get a compiler error.</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQSharedPointer<T>&std::nullptr_t -->
<h3 class="fn" id="operator-not-eq-3"><a name="operator-not-eq-3"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, <i>std::nullptr_t</i>)</h3>
<p>Returns <code>true</code> if the pointer referenced by <i>lhs</i> is a valid (i.e&#x2e; non-null) pointer.</p>
<p>这个函数是在Qt 5.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qsharedpointer.html#isNull">QSharedPointer::isNull</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=std::nullptr_tconstQSharedPointer<T>& -->
<h3 class="fn" id="operator-not-eq-4"><a name="operator-not-eq-4"></a><span class="type">bool</span> <span class="name">operator!=</span>(<i>std::nullptr_t</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code>true</code> if the pointer referenced by <i>rhs</i> is a valid (i.e&#x2e; non-null) pointer.</p>
<p>这个函数是在Qt 5.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qsharedpointer.html#isNull">QSharedPointer::isNull</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator<<[overload1]$$$operator<<QDebugconstQSharedPointer<T>& -->
<h3 class="fn" id="operator-lt-lt"><a name="operator-lt-lt"></a><span class="type"><a href="qdebug.html">QDebug</a></span> <span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdebug.html">QDebug</a></span> <i>debug</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr</i>)</h3>
<p>Writes the pointer tracked by <i>ptr</i> into the debug object <i>debug</i> for debugging purposes.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="../qtdoc/testing-and-debugging.html#debugging-techniques">Debugging Techniques</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator==[overload1]$$$operator==constQSharedPointer<T>&constQSharedPointer<X>& -->
<h3 class="fn" id="operator-eq-eq"><a name="operator-eq-eq"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr1</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>ptr2</i>)</h3>
<p>Returns <code>true</code> if the pointer referenced by <i>ptr1</i> is the same pointer as that referenced by <i>ptr2</i>.</p>
<p>If <i>ptr2</i>'s template parameter is different from <i>ptr1</i>'s, <a href="qsharedpointer.html">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <i>ptr2</i>'s template parameter is not a base or a derived type from <i>ptr1</i>'s, you will get a compiler error.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQSharedPointer<T>&constX* -->
<h3 class="fn" id="operator-eq-eq-1"><a name="operator-eq-eq-1"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>ptr1</i>, const <span class="type">X</span> *<i>ptr2</i>)</h3>
<p>Returns <code>true</code> if the pointer referenced by <i>ptr1</i> is the same pointer as <i>ptr2</i>.</p>
<p>If <i>ptr2</i>'s type is different from <i>ptr1</i>'s, <a href="qsharedpointer.html">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <i>ptr2</i>'s type is not a base or a derived type from this <i>ptr1</i>'s, you will get a compiler error.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constT*constQSharedPointer<X>& -->
<h3 class="fn" id="operator-eq-eq-2"><a name="operator-eq-eq-2"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type">T</span> *<i>ptr1</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">X</span>&gt; &amp;<i>ptr2</i>)</h3>
<p>Returns <code>true</code> if the pointer <i>ptr1</i> is the same pointer as that referenced by <i>ptr2</i>.</p>
<p>If <i>ptr2</i>'s template parameter is different from <i>ptr1</i>'s type, <a href="qsharedpointer.html">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <i>ptr2</i>'s template parameter is not a base or a derived type from <i>ptr1</i>'s type, you will get a compiler error.</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQSharedPointer<T>&std::nullptr_t -->
<h3 class="fn" id="operator-eq-eq-3"><a name="operator-eq-eq-3"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, <i>std::nullptr_t</i>)</h3>
<p>Returns <code>true</code> if the pointer referenced by <i>lhs</i> is a null pointer.</p>
<p>这个函数是在Qt 5.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qsharedpointer.html#isNull">QSharedPointer::isNull</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==std::nullptr_tconstQSharedPointer<T>& -->
<h3 class="fn" id="operator-eq-eq-4"><a name="operator-eq-eq-4"></a><span class="type">bool</span> <span class="name">operator==</span>(<i>std::nullptr_t</i>, const <span class="type"><a href="qsharedpointer.html#QSharedPointer">QSharedPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)</h3>
<p>Returns <code>true</code> if the pointer referenced by <i>rhs</i> is a null pointer.</p>
<p>这个函数是在Qt 5.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qsharedpointer.html#isNull">QSharedPointer::isNull</a>().</p>
<!-- @@@operator== -->
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
