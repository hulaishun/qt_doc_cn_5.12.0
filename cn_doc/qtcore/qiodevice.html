<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qiodevice.cpp -->
  <title>QIODevice Class | Qt Core 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QIODevice</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#protected-functions">保护函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QIODevice Class</h1>
<!-- $$$QIODevice-brief -->
<p>The <a href="qiodevice.html">QIODevice</a> class is the base interface class of all I/O devices in Qt. <a href="#details">More...</a></p>
<!-- @@@QIODevice -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QIODevice&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="qobject.html">QObject</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的子类有：</td><td class="memItemRight bottomAlign"> <p><a href="qbuffer.html">QBuffer</a>, <a href="qfiledevice.html">QFileDevice</a>, 和 <a href="qprocess.html">QProcess</a></p>
</td></tr></table></div><ul>
<li><a href="qiodevice-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qiodevice-obsolete.html">过时的成员</a></li>
</ul>
<p><b>注意：</b> 此类中的所有函数都是 <a href="../qtdoc/threads-reentrancy.html">可重入的。</a></p>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#OpenModeFlag-enum">OpenModeFlag</a></b> { NotOpen, ReadOnly, WriteOnly, ReadWrite, ..., ExistingOnly }</td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#QIODevice">QIODevice</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#QIODevice-1">QIODevice</a></b>(QObject *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#dtor.QIODevice">~QIODevice</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#atEnd">atEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#bytesAvailable">bytesAvailable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#bytesToWrite">bytesToWrite</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#canReadLine">canReadLine</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#close">close</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#commitTransaction">commitTransaction</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#currentReadChannel">currentReadChannel</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#currentWriteChannel">currentWriteChannel</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#errorString">errorString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#getChar">getChar</a></b>(char *<i>c</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#isOpen">isOpen</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#isReadable">isReadable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#isSequential">isSequential</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#isTextModeEnabled">isTextModeEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#isTransactionStarted">isTransactionStarted</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#isWritable">isWritable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#open">open</a></b>(QIODevice::OpenMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QIODevice::OpenMode </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#openMode">openMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#peek">peek</a></b>(char *<i>data</i>, qint64 <i>maxSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#peek-1">peek</a></b>(qint64 <i>maxSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#pos">pos</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#putChar">putChar</a></b>(char <i>c</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#read">read</a></b>(char *<i>data</i>, qint64 <i>maxSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#read-1">read</a></b>(qint64 <i>maxSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#readAll">readAll</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#readChannelCount">readChannelCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#readLine">readLine</a></b>(char *<i>data</i>, qint64 <i>maxSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#readLine-1">readLine</a></b>(qint64 <i>maxSize</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#reset">reset</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#rollbackTransaction">rollbackTransaction</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#seek">seek</a></b>(qint64 <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#setCurrentReadChannel">setCurrentReadChannel</a></b>(int <i>channel</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#setCurrentWriteChannel">setCurrentWriteChannel</a></b>(int <i>channel</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#setTextModeEnabled">setTextModeEnabled</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#size">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#skip">skip</a></b>(qint64 <i>maxSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#startTransaction">startTransaction</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#ungetChar">ungetChar</a></b>(char <i>c</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#waitForBytesWritten">waitForBytesWritten</a></b>(int <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#waitForReadyRead">waitForReadyRead</a></b>(int <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#write">write</a></b>(const char *<i>data</i>, qint64 <i>maxSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#write-1">write</a></b>(const char *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#write-2">write</a></b>(const QByteArray &amp;<i>byteArray</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#writeChannelCount">writeChannelCount</a></b>() const</td></tr>
</table></div>
<ul>
<li class="fn">32 个公共函数继承于 <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#aboutToClose">aboutToClose</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#bytesWritten">bytesWritten</a></b>(qint64 <i>bytes</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#channelBytesWritten">channelBytesWritten</a></b>(int <i>channel</i>, qint64 <i>bytes</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#channelReadyRead">channelReadyRead</a></b>(int <i>channel</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#readChannelFinished">readChannelFinished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#readyRead">readyRead</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">2 个信号继承于 <a href="qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">11 个静态公共成员继承于 <a href="qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="protected-functions"></a>
<h2 id="protected-functions">保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#readData">readData</a></b>(char *<i>data</i>, qint64 <i>maxSize</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#readLineData">readLineData</a></b>(char *<i>data</i>, qint64 <i>maxSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#setErrorString">setErrorString</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#setOpenMode">setOpenMode</a></b>(QIODevice::OpenMode <i>openMode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qiodevice.html#writeData">writeData</a></b>(const char *<i>data</i>, qint64 <i>maxSize</i>) = 0</td></tr>
</table></div>
<ul>
<li class="fn">9 个保护函数继承于 <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<h3>其他继承成员有</h3>
<ul>
<li class="fn">1 个属性继承于 <a href="qobject.html#properties">QObject</a></li>
<li class="fn">1 个公共槽函数继承于 <a href="qobject.html#public-slots">QObject</a></li>
<li class="fn">1 个保护类型继承于 <a href="qobject.html#protected-variables">QObject</a></li>
<li class="fn">1 个静态保护成员继承于 <a href="qobject.html#static-protected-members">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QIODevice-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qiodevice.html">QIODevice</a> class is the base interface class of all I/O devices in Qt.</p>
<p><a href="qiodevice.html">QIODevice</a> provides both a common implementation and an abstract interface for devices that support reading and writing of blocks of data, such as <a href="qfile.html">QFile</a>, <a href="qbuffer.html">QBuffer</a> 和 <a href="../qtnetwork/qtcpsocket.html">QTcpSocket</a>. <a href="qiodevice.html">QIODevice</a> is abstract and can not be instantiated, but it is common to use the interface it defines to provide device-independent I/O features. For example, Qt's XML classes operate on a <a href="qiodevice.html">QIODevice</a> pointer, allowing them to be used with various devices (such as files and buffers).</p>
<p>Before accessing the device, <a href="qiodevice.html#open">open</a>() must be called to set the correct <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a> (such as <a href="qiodevice.html#OpenModeFlag-enum">ReadOnly</a> or <a href="qiodevice.html#OpenModeFlag-enum">ReadWrite</a>). You can then write to the device with <a href="qiodevice.html#write">write</a>() or <a href="qiodevice.html#putChar">putChar</a>(), and read by calling either <a href="qiodevice.html#read">read</a>(), <a href="qiodevice.html#readLine">readLine</a>(), or <a href="qiodevice.html#readAll">readAll</a>(). Call <a href="qiodevice.html#close">close</a>() when you are done with the device.</p>
<p><a href="qiodevice.html">QIODevice</a> distinguishes between two types of devices: random-access devices and sequential devices.</p>
<ul>
<li>Random-access devices support seeking to arbitrary positions using <a href="qiodevice.html#seek">seek</a>(). The current position in the file is available by calling <a href="qiodevice.html#pos">pos</a>(). <a href="qfile.html">QFile</a> 和 <a href="qbuffer.html">QBuffer</a> are examples of random-access devices.</li>
<li>Sequential devices don't support seeking to arbitrary positions. The data must be read in one pass. The functions <a href="qiodevice.html#pos">pos</a>() 和 <a href="qiodevice.html#size">size</a>() don't work for sequential devices. <a href="../qtnetwork/qtcpsocket.html">QTcpSocket</a> 和 <a href="qprocess.html">QProcess</a> are examples of sequential devices.</li>
</ul>
<p>You can use <a href="qiodevice.html#isSequential">isSequential</a>() to determine the type of device.</p>
<p><a href="qiodevice.html">QIODevice</a> emits <a href="qiodevice.html#readyRead">readyRead</a>() when new data is available for reading; for example, if new data has arrived on the network or if additional data is appended to a file that you are reading from. You can call <a href="qiodevice.html#bytesAvailable">bytesAvailable</a>() to determine the number of bytes that are currently available for reading. It's common to use <a href="qiodevice.html#bytesAvailable">bytesAvailable</a>() together with the <a href="qiodevice.html#readyRead">readyRead</a>() signal when programming with asynchronous devices such as <a href="../qtnetwork/qtcpsocket.html">QTcpSocket</a>, where fragments of data can arrive at arbitrary points in time. <a href="qiodevice.html">QIODevice</a> emits the <a href="qiodevice.html#bytesWritten">bytesWritten</a>() signal every time a payload of data has been written to the device. Use <a href="qiodevice.html#bytesToWrite">bytesToWrite</a>() to determine the current amount of data waiting to be written.</p>
<p>Certain subclasses of <a href="qiodevice.html">QIODevice</a>, such as <a href="../qtnetwork/qtcpsocket.html">QTcpSocket</a> 和 <a href="qprocess.html">QProcess</a>, are asynchronous. This means that I/O functions such as <a href="qiodevice.html#write">write</a>() or <a href="qiodevice.html#read">read</a>() always return immediately, while communication with the device itself may happen when control goes back to the event loop. <a href="qiodevice.html">QIODevice</a> provides functions that allow you to force these operations to be performed immediately, while blocking the calling thread and without entering the event loop. This allows <a href="qiodevice.html">QIODevice</a> subclasses to be used without an event loop, or in a separate thread:</p>
<ul>
<li><a href="qiodevice.html#waitForReadyRead">waitForReadyRead</a>() - This function suspends operation in the calling thread until new data is available for reading.</li>
<li><a href="qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>() - This function suspends operation in the calling thread until one payload of data has been written to the device.</li>
<li>waitFor...&#x2e;() - Subclasses of <a href="qiodevice.html">QIODevice</a> implement blocking functions for device-specific operations. For example, <a href="qprocess.html">QProcess</a> has a function called <a href="qprocess.html#waitForStarted">waitForStarted()</a> which suspends operation in the calling thread until the process has started.</li>
</ul>
<p>Calling these functions from the main, GUI thread, may cause your user interface to freeze. Example:</p>
<pre class="cpp">

  <span class="type"><a href="qprocess.html">QProcess</a></span> gzip;
  gzip<span class="operator">.</span>start(<span class="string">&quot;gzip&quot;</span><span class="operator">,</span> <span class="type"><a href="qstringlist.html">QStringList</a></span>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;-c&quot;</span>);
  <span class="keyword">if</span> (<span class="operator">!</span>gzip<span class="operator">.</span>waitForStarted())
      <span class="keyword">return</span> <span class="keyword">false</span>;

  gzip<span class="operator">.</span>write(<span class="string">&quot;uncompressed data&quot;</span>);

  <span class="type"><a href="qbytearray.html">QByteArray</a></span> compressed;
  <span class="keyword">while</span> (gzip<span class="operator">.</span>waitForReadyRead())
      compressed <span class="operator">+</span><span class="operator">=</span> gzip<span class="operator">.</span>readAll();

</pre>
<p>By subclassing <a href="qiodevice.html">QIODevice</a>, you can provide the same interface to your own I/O devices. Subclasses of <a href="qiodevice.html">QIODevice</a> are only required to implement the protected <a href="qiodevice.html#readData">readData</a>() 和 <a href="qiodevice.html#writeData">writeData</a>() functions. <a href="qiodevice.html">QIODevice</a> uses these functions to implement all its convenience functions, such as <a href="qiodevice.html#getChar">getChar</a>(), <a href="qiodevice.html#readLine">readLine</a>() 和 <a href="qiodevice.html#write">write</a>(). <a href="qiodevice.html">QIODevice</a> also handles access control for you, so you can safely assume that the device is opened in write mode if <a href="qiodevice.html#writeData">writeData</a>() is called.</p>
<p>Some subclasses, such as <a href="qfile.html">QFile</a> 和 <a href="../qtnetwork/qtcpsocket.html">QTcpSocket</a>, are implemented using a memory buffer for intermediate storing of data. This reduces the number of required device accessing calls, which are often very slow. Buffering makes functions like <a href="qiodevice.html#getChar">getChar</a>() 和 <a href="qiodevice.html#putChar">putChar</a>() fast, as they can operate on the memory buffer instead of directly on the device itself. Certain I/O operations, however, don't work well with a buffer. For example, if several users open the same device and read it character by character, they may end up reading the same data when they meant to read a separate chunk each. For this reason, <a href="qiodevice.html">QIODevice</a> allows you to bypass any buffering by passing the Unbuffered flag to <a href="qiodevice.html#open">open</a>(). When subclassing <a href="qiodevice.html">QIODevice</a>, remember to bypass any buffer you may use when the device is open in Unbuffered mode.</p>
<p>Usually, the incoming data stream from an asynchronous device is fragmented, and chunks of data can arrive at arbitrary points in time. To handle incomplete reads of data structures, use the transaction mechanism implemented by <a href="qiodevice.html">QIODevice</a>. See <a href="qiodevice.html#startTransaction">startTransaction</a>() and related functions for more details.</p>
<p>Some sequential devices support communicating via multiple channels. These channels represent separate streams of data that have the property of independently sequenced delivery. Once the device is opened, you can determine the number of channels by calling the <a href="qiodevice.html#readChannelCount">readChannelCount</a>() 和 <a href="qiodevice.html#writeChannelCount">writeChannelCount</a>() functions. To switch between channels, call <a href="qiodevice.html#setCurrentReadChannel">setCurrentReadChannel</a>() 和 <a href="qiodevice.html#setCurrentWriteChannel">setCurrentWriteChannel</a>(), respectively. <a href="qiodevice.html">QIODevice</a> also provides additional signals to handle asynchronous communication on a per-channel basis.</p>
</div>
<p><b> 参见 </b><a href="qbuffer.html">QBuffer</a>, <a href="qfile.html">QFile</a>, 和 <a href="../qtnetwork/qtcpsocket.html">QTcpSocket</a>.</p>
<!-- @@@QIODevice -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$OpenModeFlag$$$NotOpen$$$ReadOnly$$$WriteOnly$$$ReadWrite$$$Append$$$Truncate$$$Text$$$Unbuffered$$$NewOnly$$$ExistingOnly -->
<h3 class="flags" id="OpenModeFlag-enum"><a name="OpenModeFlag-enum"></a>enum QIODevice::<span class="name">OpenModeFlag</span><br/>flags QIODevice::<span class="name">OpenMode</span></h3>
<p>This enum is used with <a href="qiodevice.html#open">open</a>() to describe the mode in which a device is opened. It is also returned by <a href="qiodevice.html#openMode">openMode</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QIODevice::NotOpen</code></td><td class="topAlign tblval"><code>0x0000</code></td><td class="topAlign">The device is not open.</td></tr>
<tr><td class="topAlign"><code>QIODevice::ReadOnly</code></td><td class="topAlign tblval"><code>0x0001</code></td><td class="topAlign">The device is open for reading.</td></tr>
<tr><td class="topAlign"><code>QIODevice::WriteOnly</code></td><td class="topAlign tblval"><code>0x0002</code></td><td class="topAlign">The device is open for writing. Note that, for file-system subclasses (e.g&#x2e; <a href="qfile.html">QFile</a>), this mode implies Truncate unless combined with ReadOnly, Append or NewOnly.</td></tr>
<tr><td class="topAlign"><code>QIODevice::ReadWrite</code></td><td class="topAlign tblval"><code>ReadOnly | WriteOnly</code></td><td class="topAlign">The device is open for reading and writing.</td></tr>
<tr><td class="topAlign"><code>QIODevice::Append</code></td><td class="topAlign tblval"><code>0x0004</code></td><td class="topAlign">The device is opened in append mode so that all data is written to the end of the file.</td></tr>
<tr><td class="topAlign"><code>QIODevice::Truncate</code></td><td class="topAlign tblval"><code>0x0008</code></td><td class="topAlign">If possible, the device is truncated before it is opened. All earlier contents of the device are lost.</td></tr>
<tr><td class="topAlign"><code>QIODevice::Text</code></td><td class="topAlign tblval"><code>0x0010</code></td><td class="topAlign">When reading, the end-of-line terminators are translated to '\n'. When writing, the end-of-line terminators are translated to the local encoding, for example '\r\n' for Win32.</td></tr>
<tr><td class="topAlign"><code>QIODevice::Unbuffered</code></td><td class="topAlign tblval"><code>0x0020</code></td><td class="topAlign">Any buffer in the device is bypassed.</td></tr>
<tr><td class="topAlign"><code>QIODevice::NewOnly</code></td><td class="topAlign tblval"><code>0x0040</code></td><td class="topAlign">Fail if the file to be opened already exists. Create and open the file only if it does not exist. There is a guarantee from the operating system that you are the only one creating and opening the file. Note that this mode implies WriteOnly, and combining it with ReadWrite is allowed. This flag currently only affects <a href="qfile.html">QFile</a>. Other classes might use this flag in the future, but until then using this flag with any classes other than <a href="qfile.html">QFile</a> may result in undefined behavior. (since Qt 5.11)</td></tr>
<tr><td class="topAlign"><code>QIODevice::ExistingOnly</code></td><td class="topAlign tblval"><code>0x0080</code></td><td class="topAlign">Fail if the file to be opened does not exist. This flag must be specified alongside ReadOnly, WriteOnly, or ReadWrite. Note that using this flag with ReadOnly alone is redundant, as ReadOnly already fails when the file does not exist. This flag currently only affects <a href="qfile.html">QFile</a>. Other classes might use this flag in the future, but until then using this flag with any classes other than <a href="qfile.html">QFile</a> may result in undefined behavior. (since Qt 5.11)</td></tr>
</table></div>
<p>Certain flags, such as <code>Unbuffered</code> and <code>Truncate</code>, are meaningless when used with some subclasses. Some of these restrictions are implied by the type of device that is represented by a subclass. In other cases, the restriction may be due to the implementation, or may be imposed by the underlying platform; for example, <a href="../qtnetwork/qtcpsocket.html">QTcpSocket</a> does not support <code>Unbuffered</code> mode, and limitations in the native API prevent <a href="qfile.html">QFile</a> from supporting <code>Unbuffered</code> on Windows.</p>
<p>The OpenMode type is a typedef for <a href="qflags.html">QFlags</a>&lt;OpenModeFlag&gt;. It stores an OR combination of OpenModeFlag values.</p>
<!-- @@@OpenModeFlag -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QIODevice[overload1]$$$QIODevice -->
<h3 class="fn" id="QIODevice"><a name="QIODevice"></a>QIODevice::<span class="name">QIODevice</span>()</h3>
<p>Constructs a <a href="qiodevice.html">QIODevice</a> object.</p>
<!-- @@@QIODevice -->
<!-- $$$QIODevice$$$QIODeviceQObject* -->
<h3 class="fn" id="QIODevice-1"><a name="QIODevice-1"></a>QIODevice::<span class="name">QIODevice</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>parent</i>)</h3>
<p>Constructs a <a href="qiodevice.html">QIODevice</a> object with the given <i>parent</i>.</p>
<!-- @@@QIODevice -->
<!-- $$$~QIODevice[overload1]$$$~QIODevice -->
<h3 class="fn" id="dtor.QIODevice"><a name="dtor.QIODevice"></a><code>[virtual] </code>QIODevice::<span class="name">~QIODevice</span>()</h3>
<p>The destructor is virtual, and <a href="qiodevice.html">QIODevice</a> is an abstract base class. This destructor does not call <a href="qiodevice.html#close">close</a>(), but the subclass destructor might. If you are in doubt, call <a href="qiodevice.html#close">close</a>() before destroying the <a href="qiodevice.html">QIODevice</a>.</p>
<!-- @@@~QIODevice -->
<!-- $$$aboutToClose[overload1]$$$aboutToClose -->
<h3 class="fn" id="aboutToClose"><a name="aboutToClose"></a><code>[signal] </code><span class="type">void</span> QIODevice::<span class="name">aboutToClose</span>()</h3>
<p>This signal is emitted when the device is about to close. Connect this signal if you have operations that need to be performed before the device closes (e.g&#x2e;, if you have data in a separate buffer that needs to be written to the device).</p>
<!-- @@@aboutToClose -->
<!-- $$$atEnd[overload1]$$$atEnd -->
<h3 class="fn" id="atEnd"><a name="atEnd"></a><code>[virtual] </code><span class="type">bool</span> QIODevice::<span class="name">atEnd</span>() const</h3>
<p>Returns <code>true</code> if the current read and write position is at the end of the device (i.e&#x2e; there is no more data available for reading on the device); otherwise returns <code>false</code>.</p>
<p>For some devices, atEnd() can return true even though there is more data to read. This special case only applies to devices that generate data in direct response to you calling <a href="qiodevice.html#read">read</a>() (e.g&#x2e;, <code>/dev</code> or <code>/proc</code> files on Unix and <a href="../qtdoc/internationalization.html#macos">macOS</a>, or console input / <code>stdin</code> on all platforms).</p>
<p><b> 参见 </b><a href="qiodevice.html#bytesAvailable">bytesAvailable</a>(), <a href="qiodevice.html#read">read</a>(), 和 <a href="qiodevice.html#isSequential">isSequential</a>().</p>
<!-- @@@atEnd -->
<!-- $$$bytesAvailable[overload1]$$$bytesAvailable -->
<h3 class="fn" id="bytesAvailable"><a name="bytesAvailable"></a><code>[virtual] </code><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">bytesAvailable</span>() const</h3>
<p>Returns the number of bytes that are available for reading. This function is commonly used with sequential devices to determine the number of bytes to allocate in a buffer before reading.</p>
<p>Subclasses that reimplement this function must call the base implementation in order to include the size of the buffer of <a href="qiodevice.html">QIODevice</a>. Example:</p>
<pre class="cpp">

  <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> CustomDevice<span class="operator">::</span>bytesAvailable() <span class="keyword">const</span>
  {
      <span class="keyword">return</span> buffer<span class="operator">.</span>size() <span class="operator">+</span> <span class="type"><a href="qiodevice.html#QIODevice">QIODevice</a></span><span class="operator">::</span>bytesAvailable();
  }

</pre>
<p><b> 参见 </b><a href="qiodevice.html#bytesToWrite">bytesToWrite</a>(), <a href="qiodevice.html#readyRead">readyRead</a>(), 和 <a href="qiodevice.html#isSequential">isSequential</a>().</p>
<!-- @@@bytesAvailable -->
<!-- $$$bytesToWrite[overload1]$$$bytesToWrite -->
<h3 class="fn" id="bytesToWrite"><a name="bytesToWrite"></a><code>[virtual] </code><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">bytesToWrite</span>() const</h3>
<p>For buffered devices, this function returns the number of bytes waiting to be written. For devices with no buffer, this function returns 0.</p>
<p>Subclasses that reimplement this function must call the base implementation in order to include the size of the buffer of <a href="qiodevice.html">QIODevice</a>.</p>
<p><b> 参见 </b><a href="qiodevice.html#bytesAvailable">bytesAvailable</a>(), <a href="qiodevice.html#bytesWritten">bytesWritten</a>(), 和 <a href="qiodevice.html#isSequential">isSequential</a>().</p>
<!-- @@@bytesToWrite -->
<!-- $$$bytesWritten[overload1]$$$bytesWrittenqint64 -->
<h3 class="fn" id="bytesWritten"><a name="bytesWritten"></a><code>[signal] </code><span class="type">void</span> QIODevice::<span class="name">bytesWritten</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>bytes</i>)</h3>
<p>This signal is emitted every time a payload of data has been written to the device's current write channel. The <i>bytes</i> argument is set to the number of bytes that were written in this payload.</p>
<p>bytesWritten() is not emitted recursively; if you reenter the event loop or call <a href="qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>() inside a slot connected to the bytesWritten() signal, the signal will not be reemitted (although <a href="qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>() may still return true).</p>
<p><b> 参见 </b><a href="qiodevice.html#readyRead">readyRead</a>().</p>
<!-- @@@bytesWritten -->
<!-- $$$canReadLine[overload1]$$$canReadLine -->
<h3 class="fn" id="canReadLine"><a name="canReadLine"></a><code>[virtual] </code><span class="type">bool</span> QIODevice::<span class="name">canReadLine</span>() const</h3>
<p>Returns <code>true</code> if a complete line of data can be read from the device; otherwise returns <code>false</code>.</p>
<p>Note that unbuffered devices, which have no way of determining what can be read, always return false.</p>
<p>This function is often called in conjunction with the <a href="qiodevice.html#readyRead">readyRead</a>() signal.</p>
<p>Subclasses that reimplement this function must call the base implementation in order to include the contents of the <a href="qiodevice.html">QIODevice</a>'s buffer. Example:</p>
<pre class="cpp">

  bool CustomDevice<span class="operator">::</span>canReadLine() <span class="keyword">const</span>
  {
      <span class="keyword">return</span> buffer<span class="operator">.</span>contains(<span class="char">'\n'</span>) <span class="operator">|</span><span class="operator">|</span> <span class="type"><a href="qiodevice.html#QIODevice">QIODevice</a></span><span class="operator">::</span>canReadLine();
  }

</pre>
<p><b> 参见 </b><a href="qiodevice.html#readyRead">readyRead</a>() 和 <a href="qiodevice.html#readLine">readLine</a>().</p>
<!-- @@@canReadLine -->
<!-- $$$channelBytesWritten[overload1]$$$channelBytesWrittenintqint64 -->
<h3 class="fn" id="channelBytesWritten"><a name="channelBytesWritten"></a><code>[signal] </code><span class="type">void</span> QIODevice::<span class="name">channelBytesWritten</span>(<span class="type">int</span> <i>channel</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>bytes</i>)</h3>
<p>This signal is emitted every time a payload of data has been written to the device. The <i>bytes</i> argument is set to the number of bytes that were written in this payload, while <i>channel</i> is the channel they were written to. Unlike <a href="qiodevice.html#bytesWritten">bytesWritten</a>(), it is emitted regardless of the <a href="qiodevice.html#currentWriteChannel">current write channel</a>.</p>
<p>channelBytesWritten() can be emitted recursively - even for the same channel.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#bytesWritten">bytesWritten</a>() 和 <a href="qiodevice.html#channelReadyRead">channelReadyRead</a>().</p>
<!-- @@@channelBytesWritten -->
<!-- $$$channelReadyRead[overload1]$$$channelReadyReadint -->
<h3 class="fn" id="channelReadyRead"><a name="channelReadyRead"></a><code>[signal] </code><span class="type">void</span> QIODevice::<span class="name">channelReadyRead</span>(<span class="type">int</span> <i>channel</i>)</h3>
<p>This signal is emitted when new data is available for reading from the device. The <i>channel</i> argument is set to the index of the read channel on which the data has arrived. Unlike <a href="qiodevice.html#readyRead">readyRead</a>(), it is emitted regardless of the <a href="qiodevice.html#currentReadChannel">current read channel</a>.</p>
<p>channelReadyRead() can be emitted recursively - even for the same channel.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#readyRead">readyRead</a>() 和 <a href="qiodevice.html#channelBytesWritten">channelBytesWritten</a>().</p>
<!-- @@@channelReadyRead -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" id="close"><a name="close"></a><code>[virtual] </code><span class="type">void</span> QIODevice::<span class="name">close</span>()</h3>
<p>First emits <a href="qiodevice.html#aboutToClose">aboutToClose</a>(), then closes the device and sets its <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a> to <a href="qiodevice.html#OpenModeFlag-enum">NotOpen</a>. The error string is also reset.</p>
<p><b> 参见 </b><a href="qiodevice.html#setOpenMode">setOpenMode</a>() 和 <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a>.</p>
<!-- @@@close -->
<!-- $$$commitTransaction[overload1]$$$commitTransaction -->
<h3 class="fn" id="commitTransaction"><a name="commitTransaction"></a><span class="type">void</span> QIODevice::<span class="name">commitTransaction</span>()</h3>
<p>Completes a read transaction.</p>
<p>For sequential devices, all data recorded in the internal buffer during the transaction will be discarded.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#startTransaction">startTransaction</a>() 和 <a href="qiodevice.html#rollbackTransaction">rollbackTransaction</a>().</p>
<!-- @@@commitTransaction -->
<!-- $$$currentReadChannel[overload1]$$$currentReadChannel -->
<h3 class="fn" id="currentReadChannel"><a name="currentReadChannel"></a><span class="type">int</span> QIODevice::<span class="name">currentReadChannel</span>() const</h3>
<p>Returns the index of the current read channel.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#setCurrentReadChannel">setCurrentReadChannel</a>(), <a href="qiodevice.html#readChannelCount">readChannelCount</a>(), 和 <a href="qprocess.html">QProcess</a>.</p>
<!-- @@@currentReadChannel -->
<!-- $$$currentWriteChannel[overload1]$$$currentWriteChannel -->
<h3 class="fn" id="currentWriteChannel"><a name="currentWriteChannel"></a><span class="type">int</span> QIODevice::<span class="name">currentWriteChannel</span>() const</h3>
<p>Returns the the index of the current write channel.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#setCurrentWriteChannel">setCurrentWriteChannel</a>() 和 <a href="qiodevice.html#writeChannelCount">writeChannelCount</a>().</p>
<!-- @@@currentWriteChannel -->
<!-- $$$errorString[overload1]$$$errorString -->
<h3 class="fn" id="errorString"><a name="errorString"></a><span class="type"><a href="qstring.html">QString</a></span> QIODevice::<span class="name">errorString</span>() const</h3>
<p>Returns a human-readable description of the last device error that occurred.</p>
<p><b> 参见 </b><a href="qiodevice.html#setErrorString">setErrorString</a>().</p>
<!-- @@@errorString -->
<!-- $$$getChar[overload1]$$$getCharchar* -->
<h3 class="fn" id="getChar"><a name="getChar"></a><span class="type">bool</span> QIODevice::<span class="name">getChar</span>(<span class="type">char</span> *<i>c</i>)</h3>
<p>Reads one character from the device and stores it in <i>c</i>. If <i>c</i> is 0, the character is discarded. Returns <code>true</code> on success; otherwise returns <code>false</code>.</p>
<p><b> 参见 </b><a href="qiodevice.html#read">read</a>(), <a href="qiodevice.html#putChar">putChar</a>(), 和 <a href="qiodevice.html#ungetChar">ungetChar</a>().</p>
<!-- @@@getChar -->
<!-- $$$isOpen[overload1]$$$isOpen -->
<h3 class="fn" id="isOpen"><a name="isOpen"></a><span class="type">bool</span> QIODevice::<span class="name">isOpen</span>() const</h3>
<p>Returns <code>true</code> if the device is open; otherwise returns <code>false</code>. A device is open if it can be read from and/or written to. By default, this function returns <code>false</code> if <a href="qiodevice.html#openMode">openMode</a>() returns <code>NotOpen</code>.</p>
<p><b> 参见 </b><a href="qiodevice.html#openMode">openMode</a>() 和 <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a>.</p>
<!-- @@@isOpen -->
<!-- $$$isReadable[overload1]$$$isReadable -->
<h3 class="fn" id="isReadable"><a name="isReadable"></a><span class="type">bool</span> QIODevice::<span class="name">isReadable</span>() const</h3>
<p>Returns <code>true</code> if data can be read from the device; otherwise returns false. Use <a href="qiodevice.html#bytesAvailable">bytesAvailable</a>() to determine how many bytes can be read.</p>
<p>This is a convenience function which checks if the <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a> of the device contains the <a href="qiodevice.html#OpenModeFlag-enum">ReadOnly</a> flag.</p>
<p><b> 参见 </b><a href="qiodevice.html#openMode">openMode</a>() 和 <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a>.</p>
<!-- @@@isReadable -->
<!-- $$$isSequential[overload1]$$$isSequential -->
<h3 class="fn" id="isSequential"><a name="isSequential"></a><code>[virtual] </code><span class="type">bool</span> QIODevice::<span class="name">isSequential</span>() const</h3>
<p>Returns <code>true</code> if this device is sequential; otherwise returns false.</p>
<p>Sequential devices, as opposed to a random-access devices, have no concept of a start, an end, a size, or a current position, and they do not support seeking. You can only read from the device when it reports that data is available. The most common example of a sequential device is a network socket. On Unix, special files such as /dev/zero and fifo pipes are sequential.</p>
<p>Regular files, on the other hand, do support random access. They have both a size and a current position, and they also support seeking backwards and forwards in the data stream. Regular files are non-sequential.</p>
<p><b> 参见 </b><a href="qiodevice.html#bytesAvailable">bytesAvailable</a>().</p>
<!-- @@@isSequential -->
<!-- $$$isTextModeEnabled[overload1]$$$isTextModeEnabled -->
<h3 class="fn" id="isTextModeEnabled"><a name="isTextModeEnabled"></a><span class="type">bool</span> QIODevice::<span class="name">isTextModeEnabled</span>() const</h3>
<p>Returns <code>true</code> if the <a href="qiodevice.html#OpenModeFlag-enum">Text</a> flag is enabled; otherwise returns <code>false</code>.</p>
<p><b> 参见 </b><a href="qiodevice.html#setTextModeEnabled">setTextModeEnabled</a>().</p>
<!-- @@@isTextModeEnabled -->
<!-- $$$isTransactionStarted[overload1]$$$isTransactionStarted -->
<h3 class="fn" id="isTransactionStarted"><a name="isTransactionStarted"></a><span class="type">bool</span> QIODevice::<span class="name">isTransactionStarted</span>() const</h3>
<p>Returns <code>true</code> if a transaction is in progress on the device, otherwise <code>false</code>.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#startTransaction">startTransaction</a>().</p>
<!-- @@@isTransactionStarted -->
<!-- $$$isWritable[overload1]$$$isWritable -->
<h3 class="fn" id="isWritable"><a name="isWritable"></a><span class="type">bool</span> QIODevice::<span class="name">isWritable</span>() const</h3>
<p>Returns <code>true</code> if data can be written to the device; otherwise returns false.</p>
<p>This is a convenience function which checks if the <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a> of the device contains the <a href="qiodevice.html#OpenModeFlag-enum">WriteOnly</a> flag.</p>
<p><b> 参见 </b><a href="qiodevice.html#openMode">openMode</a>() 和 <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a>.</p>
<!-- @@@isWritable -->
<!-- $$$open[overload1]$$$openQIODevice::OpenMode -->
<h3 class="fn" id="open"><a name="open"></a><code>[virtual] </code><span class="type">bool</span> QIODevice::<span class="name">open</span>(<span class="type"><a href="qiodevice.html#OpenModeFlag-enum">QIODevice::OpenMode</a></span> <i>mode</i>)</h3>
<p>Opens the device and sets its <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a> to <i>mode</i>. Returns <code>true</code> if successful; otherwise returns <code>false</code>. This function should be called from any reimplementations of open() or other functions that open the device.</p>
<p><b> 参见 </b><a href="qiodevice.html#openMode">openMode</a>() 和 <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a>.</p>
<!-- @@@open -->
<!-- $$$openMode[overload1]$$$openMode -->
<h3 class="fn" id="openMode"><a name="openMode"></a><span class="type"><a href="qiodevice.html#OpenModeFlag-enum">QIODevice::OpenMode</a></span> QIODevice::<span class="name">openMode</span>() const</h3>
<p>Returns the mode in which the device has been opened; i.e&#x2e; <a href="qiodevice.html#OpenModeFlag-enum">ReadOnly</a> or <a href="qiodevice.html#OpenModeFlag-enum">WriteOnly</a>.</p>
<p><b> 参见 </b><a href="qiodevice.html#setOpenMode">setOpenMode</a>() 和 <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a>.</p>
<!-- @@@openMode -->
<!-- $$$peek[overload1]$$$peekchar*qint64 -->
<h3 class="fn" id="peek"><a name="peek"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">peek</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>Reads at most <i>maxSize</i> bytes from the device into <i>data</i>, without side effects (i.e&#x2e;, if you call <a href="qiodevice.html#read">read</a>() after peek(), you will get the same data). Returns the number of bytes read. If an error occurs, such as when attempting to peek a device opened in <a href="qiodevice.html#OpenModeFlag-enum">WriteOnly</a> mode, this function returns -1.</p>
<p>0 is returned when no more data is available for reading.</p>
<p>样例：</p>
<pre class="cpp">

  bool isExeFile(<span class="type"><a href="qfile.html">QFile</a></span> <span class="operator">*</span>file)
  {
      <span class="type">char</span> buf<span class="operator">[</span><span class="number">2</span><span class="operator">]</span>;
      <span class="keyword">if</span> (file<span class="operator">-</span><span class="operator">&gt;</span>peek(buf<span class="operator">,</span> <span class="keyword">sizeof</span>(buf)) <span class="operator">=</span><span class="operator">=</span> <span class="keyword">sizeof</span>(buf))
          <span class="keyword">return</span> (buf<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> <span class="char">'M'</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> buf<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> <span class="char">'Z'</span>);
      <span class="keyword">return</span> <span class="keyword">false</span>;
  }

</pre>
<p>这个函数是在Qt 4.1版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#read">read</a>().</p>
<!-- @@@peek -->
<!-- $$$peek$$$peekqint64 -->
<h3 class="fn" id="peek-1"><a name="peek-1"></a><span class="type"><a href="qbytearray.html">QByteArray</a></span> QIODevice::<span class="name">peek</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>这是一个重载函数。</p>
<p>Peeks at most <i>maxSize</i> bytes from the device, returning the data peeked as a <a href="qbytearray.html">QByteArray</a>.</p>
<p>样例：</p>
<pre class="cpp">

  bool isExeFile(<span class="type"><a href="qfile.html">QFile</a></span> <span class="operator">*</span>file)
  {
      <span class="keyword">return</span> file<span class="operator">-</span><span class="operator">&gt;</span>peek(<span class="number">2</span>) <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;MZ&quot;</span>;
  }

</pre>
<p>This function has no way of reporting errors; returning an empty <a href="qbytearray.html">QByteArray</a> can mean either that no data was currently available for peeking, or that an error occurred.</p>
<p>这个函数是在Qt 4.1版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#read">read</a>().</p>
<!-- @@@peek -->
<!-- $$$pos[overload1]$$$pos -->
<h3 class="fn" id="pos"><a name="pos"></a><code>[virtual] </code><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">pos</span>() const</h3>
<p>For random-access devices, this function returns the position that data is written to or read from. For sequential devices or closed devices, where there is no concept of a &quot;current position&quot;, 0 is returned.</p>
<p>The current read/write position of the device is maintained internally by <a href="qiodevice.html">QIODevice</a>, so reimplementing this function is not necessary. When subclassing <a href="qiodevice.html">QIODevice</a>, use <a href="qiodevice.html#seek">QIODevice::seek</a>() to notify <a href="qiodevice.html">QIODevice</a> about changes in the device position.</p>
<p><b> 参见 </b><a href="qiodevice.html#isSequential">isSequential</a>() 和 <a href="qiodevice.html#seek">seek</a>().</p>
<!-- @@@pos -->
<!-- $$$putChar[overload1]$$$putCharchar -->
<h3 class="fn" id="putChar"><a name="putChar"></a><span class="type">bool</span> QIODevice::<span class="name">putChar</span>(<span class="type">char</span> <i>c</i>)</h3>
<p>Writes the character <i>c</i> to the device. Returns <code>true</code> on success; otherwise returns <code>false</code>.</p>
<p><b> 参见 </b><a href="qiodevice.html#write">write</a>(), <a href="qiodevice.html#getChar">getChar</a>(), 和 <a href="qiodevice.html#ungetChar">ungetChar</a>().</p>
<!-- @@@putChar -->
<!-- $$$read[overload1]$$$readchar*qint64 -->
<h3 class="fn" id="read"><a name="read"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">read</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>Reads at most <i>maxSize</i> bytes from the device into <i>data</i>, and returns the number of bytes read. If an error occurs, such as when attempting to read from a device opened in <a href="qiodevice.html#OpenModeFlag-enum">WriteOnly</a> mode, this function returns -1.</p>
<p>0 is returned when no more data is available for reading. However, reading past the end of the stream is considered an error, so this function returns -1 in those cases (that is, reading on a closed socket or after a process has died).</p>
<p><b> 参见 </b><a href="qiodevice.html#readData">readData</a>(), <a href="qiodevice.html#readLine">readLine</a>(), 和 <a href="qiodevice.html#write">write</a>().</p>
<!-- @@@read -->
<!-- $$$read$$$readqint64 -->
<h3 class="fn" id="read-1"><a name="read-1"></a><span class="type"><a href="qbytearray.html">QByteArray</a></span> QIODevice::<span class="name">read</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>这是一个重载函数。</p>
<p>Reads at most <i>maxSize</i> bytes from the device, and returns the data read as a <a href="qbytearray.html">QByteArray</a>.</p>
<p>This function has no way of reporting errors; returning an empty <a href="qbytearray.html">QByteArray</a> can mean either that no data was currently available for reading, or that an error occurred.</p>
<!-- @@@read -->
<!-- $$$readAll[overload1]$$$readAll -->
<h3 class="fn" id="readAll"><a name="readAll"></a><span class="type"><a href="qbytearray.html">QByteArray</a></span> QIODevice::<span class="name">readAll</span>()</h3>
<p>Reads all remaining data from the device, and returns it as a byte array.</p>
<p>This function has no way of reporting errors; returning an empty <a href="qbytearray.html">QByteArray</a> can mean either that no data was currently available for reading, or that an error occurred.</p>
<!-- @@@readAll -->
<!-- $$$readChannelCount[overload1]$$$readChannelCount -->
<h3 class="fn" id="readChannelCount"><a name="readChannelCount"></a><span class="type">int</span> QIODevice::<span class="name">readChannelCount</span>() const</h3>
<p>Returns the number of available read channels if the device is open; otherwise returns 0.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#writeChannelCount">writeChannelCount</a>() 和 <a href="qprocess.html">QProcess</a>.</p>
<!-- @@@readChannelCount -->
<!-- $$$readChannelFinished[overload1]$$$readChannelFinished -->
<h3 class="fn" id="readChannelFinished"><a name="readChannelFinished"></a><code>[signal] </code><span class="type">void</span> QIODevice::<span class="name">readChannelFinished</span>()</h3>
<p>This signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected, which means that there might still be data available for reading with <a href="qiodevice.html#read">read</a>().</p>
<p>这个函数是在Qt 4.4版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#atEnd">atEnd</a>() 和 <a href="qiodevice.html#read">read</a>().</p>
<!-- @@@readChannelFinished -->
<!-- $$$readData[overload1]$$$readDatachar*qint64 -->
<h3 class="fn" id="readData"><a name="readData"></a><code>[pure virtual protected] </code><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">readData</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>Reads up to <i>maxSize</i> bytes from the device into <i>data</i>, and returns the number of bytes read or -1 if an error occurred.</p>
<p>If there are no bytes to be read and there can never be more bytes available (examples include socket closed, pipe closed, sub-process finished), this function returns -1.</p>
<p>This function is called by <a href="qiodevice.html">QIODevice</a>. Reimplement this function when creating a subclass of <a href="qiodevice.html">QIODevice</a>.</p>
<p>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for <a href="qdatastream.html">QDataStream</a> to be able to operate on the class. <a href="qdatastream.html">QDataStream</a> assumes all the requested information was read and therefore does not retry reading if there was a problem.</p>
<p>This function might be called with a maxSize of 0, which can be used to perform post-reading operations.</p>
<p><b> 参见 </b><a href="qiodevice.html#read">read</a>(), <a href="qiodevice.html#readLine">readLine</a>(), 和 <a href="qiodevice.html#writeData">writeData</a>().</p>
<!-- @@@readData -->
<!-- $$$readLine[overload1]$$$readLinechar*qint64 -->
<h3 class="fn" id="readLine"><a name="readLine"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">readLine</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>This function reads a line of ASCII characters from the device, up to a maximum of <i>maxSize</i> - 1 bytes, stores the characters in <i>data</i>, and returns the number of bytes read. If a line could not be read but no error ocurred, this function returns 0. If an error occurs, this function returns the length of what could be read, or -1 if nothing was read.</p>
<p>A terminating '\0' byte is always appended to <i>data</i>, so <i>maxSize</i> must be larger than 1.</p>
<p>Data is read until either of the following conditions are met:</p>
<ul>
<li>The first '\n' character is read.</li>
<li><i>maxSize</i> - 1 bytes are read.</li>
<li>The end of the device data is detected.</li>
</ul>
<p>For example, the following code reads a line of characters from a file:</p>
<pre class="cpp">

  <span class="type"><a href="qfile.html">QFile</a></span> file(<span class="string">&quot;box.txt&quot;</span>);
  <span class="keyword">if</span> (file<span class="operator">.</span>open(<span class="type"><a href="qfile.html">QFile</a></span><span class="operator">::</span>ReadOnly)) {
      <span class="type">char</span> buf<span class="operator">[</span><span class="number">1024</span><span class="operator">]</span>;
      <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> lineLength <span class="operator">=</span> file<span class="operator">.</span>readLine(buf<span class="operator">,</span> <span class="keyword">sizeof</span>(buf));
      <span class="keyword">if</span> (lineLength <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
          <span class="comment">// the line is available in buf</span>
      }
  }

</pre>
<p>The newline character ('\n') is included in the buffer. If a newline is not encountered before maxSize - 1 bytes are read, a newline will not be inserted into the buffer. On windows newline characters are replaced with '\n'.</p>
<p>This function calls <a href="qiodevice.html#readLineData">readLineData</a>(), which is implemented using repeated calls to <a href="qiodevice.html#getChar">getChar</a>(). You can provide a more efficient implementation by reimplementing <a href="qiodevice.html#readLineData">readLineData</a>() in your own subclass.</p>
<p><b> 参见 </b><a href="qiodevice.html#getChar">getChar</a>(), <a href="qiodevice.html#read">read</a>(), 和 <a href="qiodevice.html#write">write</a>().</p>
<!-- @@@readLine -->
<!-- $$$readLine$$$readLineqint64 -->
<h3 class="fn" id="readLine-1"><a name="readLine-1"></a><span class="type"><a href="qbytearray.html">QByteArray</a></span> QIODevice::<span class="name">readLine</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i> = 0)</h3>
<p>这是一个重载函数。</p>
<p>Reads a line from the device, but no more than <i>maxSize</i> characters, and returns the result as a byte array.</p>
<p>This function has no way of reporting errors; returning an empty <a href="qbytearray.html">QByteArray</a> can mean either that no data was currently available for reading, or that an error occurred.</p>
<!-- @@@readLine -->
<!-- $$$readLineData[overload1]$$$readLineDatachar*qint64 -->
<h3 class="fn" id="readLineData"><a name="readLineData"></a><code>[virtual protected] </code><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">readLineData</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>Reads up to <i>maxSize</i> characters into <i>data</i> and returns the number of characters read.</p>
<p>This function is called by <a href="qiodevice.html#readLine">readLine</a>(), and provides its base implementation, using <a href="qiodevice.html#getChar">getChar</a>(). Buffered devices can improve the performance of <a href="qiodevice.html#readLine">readLine</a>() by reimplementing this function.</p>
<p><a href="qiodevice.html#readLine">readLine</a>() appends a '\0' byte to <i>data</i>; readLineData() does not need to do this.</p>
<p>If you reimplement this function, be careful to return the correct value: it should return the number of bytes read in this line, including the terminating newline, or 0 if there is no line to be read at this point. If an error occurs, it should return -1 if and only if no bytes were read. Reading past EOF is considered an error.</p>
<!-- @@@readLineData -->
<!-- $$$readyRead[overload1]$$$readyRead -->
<h3 class="fn" id="readyRead"><a name="readyRead"></a><code>[signal] </code><span class="type">void</span> QIODevice::<span class="name">readyRead</span>()</h3>
<p>This signal is emitted once every time new data is available for reading from the device's current read channel. It will only be emitted again once new data is available, such as when a new payload of network data has arrived on your network socket, or when a new block of data has been appended to your device.</p>
<p>readyRead() is not emitted recursively; if you reenter the event loop or call <a href="qiodevice.html#waitForReadyRead">waitForReadyRead</a>() inside a slot connected to the readyRead() signal, the signal will not be reemitted (although <a href="qiodevice.html#waitForReadyRead">waitForReadyRead</a>() may still return true).</p>
<p>Note for developers implementing classes derived from <a href="qiodevice.html">QIODevice</a>: you should always emit readyRead() when new data has arrived (do not emit it only because there's data still to be read in your buffers). Do not emit readyRead() in other conditions.</p>
<p><b> 参见 </b><a href="qiodevice.html#bytesWritten">bytesWritten</a>().</p>
<!-- @@@readyRead -->
<!-- $$$reset[overload1]$$$reset -->
<h3 class="fn" id="reset"><a name="reset"></a><code>[virtual] </code><span class="type">bool</span> QIODevice::<span class="name">reset</span>()</h3>
<p>Seeks to the start of input for random-access devices. Returns true on success; otherwise returns <code>false</code> (for example, if the device is not open).</p>
<p>Note that when using a <a href="qtextstream.html">QTextStream</a> on a <a href="qfile.html">QFile</a>, calling reset() on the <a href="qfile.html">QFile</a> will not have the expected result because <a href="qtextstream.html">QTextStream</a> buffers the file. Use the <a href="qtextstream.html#seek">QTextStream::seek</a>() function instead.</p>
<p><b> 参见 </b><a href="qiodevice.html#seek">seek</a>().</p>
<!-- @@@reset -->
<!-- $$$rollbackTransaction[overload1]$$$rollbackTransaction -->
<h3 class="fn" id="rollbackTransaction"><a name="rollbackTransaction"></a><span class="type">void</span> QIODevice::<span class="name">rollbackTransaction</span>()</h3>
<p>Rolls back a read transaction.</p>
<p>Restores the input stream to the point of the <a href="qiodevice.html#startTransaction">startTransaction</a>() call. This function is commonly used to rollback the transaction when an incomplete read was detected prior to committing the transaction.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#startTransaction">startTransaction</a>() 和 <a href="qiodevice.html#commitTransaction">commitTransaction</a>().</p>
<!-- @@@rollbackTransaction -->
<!-- $$$seek[overload1]$$$seekqint64 -->
<h3 class="fn" id="seek"><a name="seek"></a><code>[virtual] </code><span class="type">bool</span> QIODevice::<span class="name">seek</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>pos</i>)</h3>
<p>For random-access devices, this function sets the current position to <i>pos</i>, returning true on success, or false if an error occurred. For sequential devices, the default behavior is to produce a warning and return false.</p>
<p>When subclassing <a href="qiodevice.html">QIODevice</a>, you must call QIODevice::seek() at the start of your function to ensure integrity with <a href="qiodevice.html">QIODevice</a>'s built-in buffer.</p>
<p><b> 参见 </b><a href="qiodevice.html#pos">pos</a>() 和 <a href="qiodevice.html#isSequential">isSequential</a>().</p>
<!-- @@@seek -->
<!-- $$$setCurrentReadChannel[overload1]$$$setCurrentReadChannelint -->
<h3 class="fn" id="setCurrentReadChannel"><a name="setCurrentReadChannel"></a><span class="type">void</span> QIODevice::<span class="name">setCurrentReadChannel</span>(<span class="type">int</span> <i>channel</i>)</h3>
<p>Sets the current read channel of the <a href="qiodevice.html">QIODevice</a> to the given <i>channel</i>. The current input channel is used by the functions <a href="qiodevice.html#read">read</a>(), <a href="qiodevice.html#readAll">readAll</a>(), <a href="qiodevice.html#readLine">readLine</a>(), 和 <a href="qiodevice.html#getChar">getChar</a>(). It also determines which channel triggers <a href="qiodevice.html">QIODevice</a> to emit <a href="qiodevice.html#readyRead">readyRead</a>().</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#currentReadChannel">currentReadChannel</a>(), <a href="qiodevice.html#readChannelCount">readChannelCount</a>(), 和 <a href="qprocess.html">QProcess</a>.</p>
<!-- @@@setCurrentReadChannel -->
<!-- $$$setCurrentWriteChannel[overload1]$$$setCurrentWriteChannelint -->
<h3 class="fn" id="setCurrentWriteChannel"><a name="setCurrentWriteChannel"></a><span class="type">void</span> QIODevice::<span class="name">setCurrentWriteChannel</span>(<span class="type">int</span> <i>channel</i>)</h3>
<p>Sets the current write channel of the <a href="qiodevice.html">QIODevice</a> to the given <i>channel</i>. The current output channel is used by the functions <a href="qiodevice.html#write">write</a>(), <a href="qiodevice.html#putChar">putChar</a>(). It also determines which channel triggers <a href="qiodevice.html">QIODevice</a> to emit <a href="qiodevice.html#bytesWritten">bytesWritten</a>().</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#currentWriteChannel">currentWriteChannel</a>() 和 <a href="qiodevice.html#writeChannelCount">writeChannelCount</a>().</p>
<!-- @@@setCurrentWriteChannel -->
<!-- $$$setErrorString[overload1]$$$setErrorStringconstQString& -->
<h3 class="fn" id="setErrorString"><a name="setErrorString"></a><code>[protected] </code><span class="type">void</span> QIODevice::<span class="name">setErrorString</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>)</h3>
<p>Sets the human readable description of the last device error that occurred to <i>str</i>.</p>
<p><b> 参见 </b><a href="qiodevice.html#errorString">errorString</a>().</p>
<!-- @@@setErrorString -->
<!-- $$$setOpenMode[overload1]$$$setOpenModeQIODevice::OpenMode -->
<h3 class="fn" id="setOpenMode"><a name="setOpenMode"></a><code>[protected] </code><span class="type">void</span> QIODevice::<span class="name">setOpenMode</span>(<span class="type"><a href="qiodevice.html#OpenModeFlag-enum">QIODevice::OpenMode</a></span> <i>openMode</i>)</h3>
<p>Sets the <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a> of the device to <i>openMode</i>. Call this function to set the open mode if the flags change after the device has been opened.</p>
<p><b> 参见 </b><a href="qiodevice.html#openMode">openMode</a>() 和 <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a>.</p>
<!-- @@@setOpenMode -->
<!-- $$$setTextModeEnabled[overload1]$$$setTextModeEnabledbool -->
<h3 class="fn" id="setTextModeEnabled"><a name="setTextModeEnabled"></a><span class="type">void</span> QIODevice::<span class="name">setTextModeEnabled</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>If <i>enabled</i> is true, this function sets the <a href="qiodevice.html#OpenModeFlag-enum">Text</a> flag on the device; otherwise the <a href="qiodevice.html#OpenModeFlag-enum">Text</a> flag is removed. This feature is useful for classes that provide custom end-of-line handling on a <a href="qiodevice.html">QIODevice</a>.</p>
<p>The IO device should be opened before calling this function.</p>
<p><b> 参见 </b><a href="qiodevice.html#isTextModeEnabled">isTextModeEnabled</a>(), <a href="qiodevice.html#open">open</a>(), 和 <a href="qiodevice.html#setOpenMode">setOpenMode</a>().</p>
<!-- @@@setTextModeEnabled -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><a name="size"></a><code>[virtual] </code><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">size</span>() const</h3>
<p>For open random-access devices, this function returns the size of the device. For open sequential devices, <a href="qiodevice.html#bytesAvailable">bytesAvailable</a>() is returned.</p>
<p>If the device is closed, the size returned will not reflect the actual size of the device.</p>
<p><b> 参见 </b><a href="qiodevice.html#isSequential">isSequential</a>() 和 <a href="qiodevice.html#pos">pos</a>().</p>
<!-- @@@size -->
<!-- $$$skip[overload1]$$$skipqint64 -->
<h3 class="fn" id="skip"><a name="skip"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">skip</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>Skips up to <i>maxSize</i> bytes from the device. Returns the number of bytes actually skipped, or -1 on error.</p>
<p>This function does not wait and only discards the data that is already available for reading.</p>
<p>If the device is opened in text mode, end-of-line terminators are translated to '\n' symbols and count as a single byte identically to the <a href="qiodevice.html#read">read</a>() 和 <a href="qiodevice.html#peek">peek</a>() behavior.</p>
<p>This function works for all devices, including sequential ones that cannot <a href="qiodevice.html#seek">seek</a>(). It is optimized to skip unwanted data after a <a href="qiodevice.html#peek">peek</a>() call.</p>
<p>For random-access devices, skip() can be used to seek forward from the current position. Negative <i>maxSize</i> values are not allowed.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#peek">peek</a>(), <a href="qiodevice.html#seek">seek</a>(), 和 <a href="qiodevice.html#read">read</a>().</p>
<!-- @@@skip -->
<!-- $$$startTransaction[overload1]$$$startTransaction -->
<h3 class="fn" id="startTransaction"><a name="startTransaction"></a><span class="type">void</span> QIODevice::<span class="name">startTransaction</span>()</h3>
<p>Starts a new read transaction on the device.</p>
<p>Defines a restorable point within the sequence of read operations. For sequential devices, read data will be duplicated internally to allow recovery in case of incomplete reads. For random-access devices, this function saves the current position. Call <a href="qiodevice.html#commitTransaction">commitTransaction</a>() or <a href="qiodevice.html#rollbackTransaction">rollbackTransaction</a>() to finish the transaction.</p>
<p><b>Note: </b>Nesting transactions is not supported.</p><p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#commitTransaction">commitTransaction</a>() 和 <a href="qiodevice.html#rollbackTransaction">rollbackTransaction</a>().</p>
<!-- @@@startTransaction -->
<!-- $$$ungetChar[overload1]$$$ungetCharchar -->
<h3 class="fn" id="ungetChar"><a name="ungetChar"></a><span class="type">void</span> QIODevice::<span class="name">ungetChar</span>(<span class="type">char</span> <i>c</i>)</h3>
<p>Puts the character <i>c</i> back into the device, and decrements the current position unless the position is 0. This function is usually called to &quot;undo&quot; a <a href="qiodevice.html#getChar">getChar</a>() operation, such as when writing a backtracking parser.</p>
<p>If <i>c</i> was not previously read from the device, the behavior is undefined.</p>
<p><b>Note: </b>This function is not available while a transaction is in progress.</p><!-- @@@ungetChar -->
<!-- $$$waitForBytesWritten[overload1]$$$waitForBytesWrittenint -->
<h3 class="fn" id="waitForBytesWritten"><a name="waitForBytesWritten"></a><code>[virtual] </code><span class="type">bool</span> QIODevice::<span class="name">waitForBytesWritten</span>(<span class="type">int</span> <i>msecs</i>)</h3>
<p>For buffered devices, this function waits until a payload of buffered written data has been written to the device and the <a href="qiodevice.html#bytesWritten">bytesWritten</a>() signal has been emitted, or until <i>msecs</i> milliseconds have passed. If msecs is -1, this function will not time out. For unbuffered devices, it returns immediately.</p>
<p>Returns <code>true</code> if a payload of data was written to the device; otherwise returns <code>false</code> (i.e&#x2e; if the operation timed out, or if an error occurred).</p>
<p>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread.</p>
<p>If called from within a slot connected to the <a href="qiodevice.html#bytesWritten">bytesWritten</a>() signal, <a href="qiodevice.html#bytesWritten">bytesWritten</a>() will not be reemitted.</p>
<p>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns <code>false</code>.</p>
<p><b>Warning:</b> Calling this function from the main (GUI) thread might cause your user interface to freeze.</p>
<p><b> 参见 </b><a href="qiodevice.html#waitForReadyRead">waitForReadyRead</a>().</p>
<!-- @@@waitForBytesWritten -->
<!-- $$$waitForReadyRead[overload1]$$$waitForReadyReadint -->
<h3 class="fn" id="waitForReadyRead"><a name="waitForReadyRead"></a><code>[virtual] </code><span class="type">bool</span> QIODevice::<span class="name">waitForReadyRead</span>(<span class="type">int</span> <i>msecs</i>)</h3>
<p>Blocks until new data is available for reading and the <a href="qiodevice.html#readyRead">readyRead</a>() signal has been emitted, or until <i>msecs</i> milliseconds have passed. If msecs is -1, this function will not time out.</p>
<p>Returns <code>true</code> if new data is available for reading; otherwise returns false (if the operation timed out or if an error occurred).</p>
<p>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread.</p>
<p>If called from within a slot connected to the <a href="qiodevice.html#readyRead">readyRead</a>() signal, <a href="qiodevice.html#readyRead">readyRead</a>() will not be reemitted.</p>
<p>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns <code>false</code>.</p>
<p><b>Warning:</b> Calling this function from the main (GUI) thread might cause your user interface to freeze.</p>
<p><b> 参见 </b><a href="qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>().</p>
<!-- @@@waitForReadyRead -->
<!-- $$$write[overload1]$$$writeconstchar*qint64 -->
<h3 class="fn" id="write"><a name="write"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">write</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>Writes at most <i>maxSize</i> bytes of data from <i>data</i> to the device. Returns the number of bytes that were actually written, or -1 if an error occurred.</p>
<p><b> 参见 </b><a href="qiodevice.html#read">read</a>() 和 <a href="qiodevice.html#writeData">writeData</a>().</p>
<!-- @@@write -->
<!-- $$$write$$$writeconstchar* -->
<h3 class="fn" id="write-1"><a name="write-1"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">write</span>(const <span class="type">char</span> *<i>data</i>)</h3>
<p>这是一个重载函数。</p>
<p>Writes data from a zero-terminated string of 8-bit characters to the device. Returns the number of bytes that were actually written, or -1 if an error occurred. This is equivalent to</p>
<pre class="cpp">

  <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
  <span class="type"><a href="qiodevice.html#QIODevice">QIODevice</a></span><span class="operator">::</span>write(data<span class="operator">,</span> qstrlen(data));
  <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

</pre>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#read">read</a>() 和 <a href="qiodevice.html#writeData">writeData</a>().</p>
<!-- @@@write -->
<!-- $$$write$$$writeconstQByteArray& -->
<h3 class="fn" id="write-2"><a name="write-2"></a><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">write</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>byteArray</i>)</h3>
<p>这是一个重载函数。</p>
<p>Writes the content of <i>byteArray</i> to the device. Returns the number of bytes that were actually written, or -1 if an error occurred.</p>
<p><b> 参见 </b><a href="qiodevice.html#read">read</a>() 和 <a href="qiodevice.html#writeData">writeData</a>().</p>
<!-- @@@write -->
<!-- $$$writeChannelCount[overload1]$$$writeChannelCount -->
<h3 class="fn" id="writeChannelCount"><a name="writeChannelCount"></a><span class="type">int</span> QIODevice::<span class="name">writeChannelCount</span>() const</h3>
<p>Returns the number of available write channels if the device is open; otherwise returns 0.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qiodevice.html#readChannelCount">readChannelCount</a>().</p>
<!-- @@@writeChannelCount -->
<!-- $$$writeData[overload1]$$$writeDataconstchar*qint64 -->
<h3 class="fn" id="writeData"><a name="writeData"></a><code>[pure virtual protected] </code><span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QIODevice::<span class="name">writeData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>maxSize</i>)</h3>
<p>Writes up to <i>maxSize</i> bytes from <i>data</i> to the device. Returns the number of bytes written, or -1 if an error occurred.</p>
<p>This function is called by <a href="qiodevice.html">QIODevice</a>. Reimplement this function when creating a subclass of <a href="qiodevice.html">QIODevice</a>.</p>
<p>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for <a href="qdatastream.html">QDataStream</a> to be able to operate on the class. <a href="qdatastream.html">QDataStream</a> assumes all the information was written and therefore does not retry writing if there was a problem.</p>
<p><b> 参见 </b><a href="qiodevice.html#read">read</a>() 和 <a href="qiodevice.html#write">write</a>().</p>
<!-- @@@writeData -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
