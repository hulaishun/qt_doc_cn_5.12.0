<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qbytearray.cpp -->
  <title>QByteArray Class | Qt Core 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QByteArray</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#related-non-members">相关非成员</a></li>
<li class="level1"><a href="#macros">宏定义</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#notes-on-locale">Notes on Locale</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QByteArray Class</h1>
<!-- $$$QByteArray-brief -->
<p>The <a href="qbytearray.html">QByteArray</a> class provides an array of bytes. <a href="#details">More...</a></p>
<!-- @@@QByteArray -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QByteArray&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr></table></div><ul>
<li><a href="qbytearray-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qbytearray-obsolete.html">过时的成员</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html">reentrant</a>.</p>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#Base64Option-enum">Base64Option</a></b> { Base64Encoding, Base64UrlEncoding, KeepTrailingEquals, OmitTrailingEquals }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#Base64Option-enum">Base64Options</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#const_iterator-typedef">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#const_reverse_iterator-typedef">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#iterator-typedef">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#reverse_iterator-typedef">reverse_iterator</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray">QByteArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray-1">QByteArray</a></b>(const char *<i>data</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray-2">QByteArray</a></b>(int <i>size</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray-4">QByteArray</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray-5">QByteArray</a></b>(QByteArray &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#dtor.QByteArray">~QByteArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append">append</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-1">append</a></b>(int <i>count</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-2">append</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-3">append</a></b>(const char *<i>str</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-4">append</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-5">append</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#at">at</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#back">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteRef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#back-1">back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#begin">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#begin-1">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#capacity">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#cbegin">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#cend">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#chop">chop</a></b>(int <i>n</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#chopped">chopped</a></b>(int <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#clear">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#compare">compare</a></b>(const char *<i>c</i>, Qt::CaseSensitivity <i>cs</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#compare-1">compare</a></b>(const QByteArray &amp;<i>a</i>, Qt::CaseSensitivity <i>cs</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#constBegin">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#constData">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#constEnd">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#contains">contains</a></b>(const QByteArray &amp;<i>ba</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#contains-1">contains</a></b>(const char *<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#contains-2">contains</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#count">count</a></b>(const QByteArray &amp;<i>ba</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#count-1">count</a></b>(const char *<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#count-2">count</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#count-3">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#crbegin">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#crend">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#data">data</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#data-1">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#end">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#end-1">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#endsWith">endsWith</a></b>(const QByteArray &amp;<i>ba</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#endsWith-1">endsWith</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#endsWith-2">endsWith</a></b>(const char *<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fill">fill</a></b>(char <i>ch</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#front">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteRef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#front-1">front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#indexOf">indexOf</a></b>(const QByteArray &amp;<i>ba</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#indexOf-1">indexOf</a></b>(const char *<i>str</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#indexOf-2">indexOf</a></b>(char <i>ch</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#indexOf-3">indexOf</a></b>(const QString &amp;<i>str</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert">insert</a></b>(int <i>i</i>, const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-1">insert</a></b>(int <i>i</i>, int <i>count</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-2">insert</a></b>(int <i>i</i>, const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-3">insert</a></b>(int <i>i</i>, const char *<i>str</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-4">insert</a></b>(int <i>i</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-5">insert</a></b>(int <i>i</i>, const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#isEmpty">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#isLower">isLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#isNull">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#isUpper">isUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#lastIndexOf">lastIndexOf</a></b>(const QByteArray &amp;<i>ba</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#lastIndexOf-1">lastIndexOf</a></b>(const char *<i>str</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#lastIndexOf-2">lastIndexOf</a></b>(char <i>ch</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#lastIndexOf-3">lastIndexOf</a></b>(const QString &amp;<i>str</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#left">left</a></b>(int <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#leftJustified">leftJustified</a></b>(int <i>width</i>, char <i>fill</i> = ' ', bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#length">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#mid">mid</a></b>(int <i>pos</i>, int <i>len</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend">prepend</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend-1">prepend</a></b>(int <i>count</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend-2">prepend</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend-3">prepend</a></b>(const char *<i>str</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend-4">prepend</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_back">push_back</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_back-1">push_back</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_back-2">push_back</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_front">push_front</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_front-1">push_front</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_front-2">push_front</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rbegin">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rbegin-1">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#remove">remove</a></b>(int <i>pos</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rend">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rend-1">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#repeated">repeated</a></b>(int <i>times</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace">replace</a></b>(int <i>pos</i>, int <i>len</i>, const QByteArray &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-1">replace</a></b>(int <i>pos</i>, int <i>len</i>, const char *<i>after</i>, int <i>alen</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-2">replace</a></b>(int <i>pos</i>, int <i>len</i>, const char *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-3">replace</a></b>(char <i>before</i>, const char *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-4">replace</a></b>(char <i>before</i>, const QByteArray &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-5">replace</a></b>(const char *<i>before</i>, const char *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-6">replace</a></b>(const char *<i>before</i>, int <i>bsize</i>, const char *<i>after</i>, int <i>asize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-7">replace</a></b>(const QByteArray &amp;<i>before</i>, const QByteArray &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-8">replace</a></b>(const QByteArray &amp;<i>before</i>, const char *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-9">replace</a></b>(const char *<i>before</i>, const QByteArray &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-10">replace</a></b>(char <i>before</i>, char <i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-11">replace</a></b>(const QString &amp;<i>before</i>, const char *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-12">replace</a></b>(char <i>before</i>, const QString &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-13">replace</a></b>(const QString &amp;<i>before</i>, const QByteArray &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#reserve">reserve</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#resize">resize</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#right">right</a></b>(int <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rightJustified">rightJustified</a></b>(int <i>width</i>, char <i>fill</i> = ' ', bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum">setNum</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-1">setNum</a></b>(ushort <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-2">setNum</a></b>(short <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-3">setNum</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-4">setNum</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-5">setNum</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-6">setNum</a></b>(float <i>n</i>, char <i>f</i> = 'g', int <i>prec</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-7">setNum</a></b>(double <i>n</i>, char <i>f</i> = 'g', int <i>prec</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setRawData">setRawData</a></b>(const char *<i>data</i>, uint <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#shrink_to_fit">shrink_to_fit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#simplified">simplified</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#size">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#split">split</a></b>(char <i>sep</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#squeeze">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#startsWith">startsWith</a></b>(const QByteArray &amp;<i>ba</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#startsWith-1">startsWith</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#startsWith-2">startsWith</a></b>(const char *<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#swap">swap</a></b>(QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toBase64">toBase64</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toBase64-1">toBase64</a></b>(QByteArray::Base64Options <i>options</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CFDataRef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toCFData">toCFData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toDouble">toDouble</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toFloat">toFloat</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toHex">toHex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toHex-1">toHex</a></b>(char <i>separator</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toInt">toInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> long </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toLong">toLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qlonglong </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toLongLong">toLongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toLower">toLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> NSData *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toNSData">toNSData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toPercentEncoding">toPercentEncoding</a></b>(const QByteArray &amp;<i>exclude</i> = QByteArray(), const QByteArray &amp;<i>include</i> = QByteArray(), char <i>percent</i> = '%') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CFDataRef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toRawCFData">toRawCFData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> NSData *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toRawNSData">toRawNSData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> short </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toShort">toShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::string </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toStdString">toStdString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toUInt">toUInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ulong </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toULong">toULong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qulonglong </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toULongLong">toULongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ushort </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toUShort">toUShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toUpper">toUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#trimmed">trimmed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#truncate">truncate</a></b>(int <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-const-char--2a">operator const char *</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const void *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-const-void--2a">operator const void *</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-not-eq">operator!=</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-eq">operator+=</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-eq-1">operator+=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-eq-2">operator+=</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-eq-3">operator+=</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt">operator&lt;</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-eq">operator&lt;=</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq">operator=</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-1">operator=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-2">operator=</a></b>(QByteArray &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-eq">operator==</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt">operator&gt;</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-eq">operator&gt;=</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteRef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-5b-5d">operator[]</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-5b-5d-1">operator[]</a></b>(uint <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-5b-5d-2">operator[]</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteRef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-5b-5d-3">operator[]</a></b>(uint <i>i</i>)</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromBase64">fromBase64</a></b>(const QByteArray &amp;<i>base64</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromBase64-1">fromBase64</a></b>(const QByteArray &amp;<i>base64</i>, QByteArray::Base64Options <i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromCFData">fromCFData</a></b>(CFDataRef <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromHex">fromHex</a></b>(const QByteArray &amp;<i>hexEncoded</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromNSData">fromNSData</a></b>(const NSData *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromPercentEncoding">fromPercentEncoding</a></b>(const QByteArray &amp;<i>input</i>, char <i>percent</i> = '%')</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromRawCFData">fromRawCFData</a></b>(CFDataRef <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromRawData">fromRawData</a></b>(const char *<i>data</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromRawNSData">fromRawNSData</a></b>(const NSData *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromStdString">fromStdString</a></b>(const std::string &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number">number</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-1">number</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-2">number</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-3">number</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-4">number</a></b>(double <i>n</i>, char <i>f</i> = 'g', int <i>prec</i> = 6)</td></tr>
</table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">相关非成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qChecksum">qChecksum</a></b>(const char *<i>data</i>, uint <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qChecksum-1">qChecksum</a></b>(const char *<i>data</i>, uint <i>len</i>, Qt::ChecksumType <i>standard</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qCompress">qCompress</a></b>(const uchar *<i>data</i>, int <i>nbytes</i>, int <i>compressionLevel</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qCompress">qCompress</a></b>(const QByteArray &amp;<i>data</i>, int <i>compressionLevel</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qUncompress">qUncompress</a></b>(const uchar *<i>data</i>, int <i>nbytes</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qUncompress">qUncompress</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qsnprintf">qsnprintf</a></b>(char *<i>str</i>, size_t <i>n</i>, const char *<i>fmt</i>, <i>...</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrcmp">qstrcmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrcpy">qstrcpy</a></b>(char *<i>dst</i>, const char *<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrdup">qstrdup</a></b>(const char *<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstricmp">qstricmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrlen">qstrlen</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrncmp">qstrncmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>, uint <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrncpy">qstrncpy</a></b>(char *<i>dst</i>, const char *<i>src</i>, uint <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrnicmp">qstrnicmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>, uint <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrnlen">qstrnlen</a></b>(const char *<i>str</i>, uint <i>maxlen</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qvsnprintf">qvsnprintf</a></b>(char *<i>str</i>, size_t <i>n</i>, const char *<i>fmt</i>, va_list <i>ap</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-not-eq-1">operator!=</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-not-eq-2">operator!=</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-not-eq-3">operator!=</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b">operator+</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-1">operator+</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-2">operator+</a></b>(const QByteArray &amp;<i>a1</i>, char <i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-3">operator+</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-4">operator+</a></b>(char <i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-1">operator&lt;</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-2">operator&lt;</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-3">operator&lt;</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-lt">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-eq-1">operator&lt;=</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-eq-2">operator&lt;=</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-eq-3">operator&lt;=</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-eq-1">operator==</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-eq-2">operator==</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-eq-3">operator==</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-1">operator&gt;</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-2">operator&gt;</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-3">operator&gt;</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-eq-1">operator&gt;=</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-eq-2">operator&gt;=</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-eq-3">operator&gt;=</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-gt">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QByteArray &amp;<i>ba</i>)</td></tr>
</table></div>
<a name="macros"></a>
<h2 id="macros">宏定义</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArrayLiteral">QByteArrayLiteral</a></b>(<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY">QT_NO_CAST_FROM_BYTEARRAY</a></b></td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QByteArray-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qbytearray.html">QByteArray</a> class provides an array of bytes.</p>
<p><a href="qbytearray.html">QByteArray</a> can be used to store both raw bytes (including '\0's) and traditional 8-bit '\0'-terminated strings. Using <a href="qbytearray.html">QByteArray</a> is much more convenient than using <code>const char *</code>. Behind the scenes, it always ensures that the data is followed by a '\0' terminator, and uses <a href="implicit-sharing.html">implicit sharing</a> (copy-on-write) to reduce memory usage and avoid needless copying of data.</p>
<p>In addition to <a href="qbytearray.html">QByteArray</a>, Qt also provides the <a href="qstring.html">QString</a> class to store string data. For most purposes, <a href="qstring.html">QString</a> is the class you want to use. It stores 16-bit Unicode characters, making it easy to store non-ASCII/non-Latin-1 characters in your application. Furthermore, <a href="qstring.html">QString</a> is used throughout in the Qt API. The two main cases where <a href="qbytearray.html">QByteArray</a> is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g&#x2e;, with Qt for Embedded Linux).</p>
<p>One way to initialize a <a href="qbytearray.html">QByteArray</a> is simply to pass a <code>const char *</code> to its constructor. For example, the following code creates a byte array of size 5 containing the data &quot;Hello&quot;:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Hello&quot;</span>);

</pre>
<p>Although the <a href="qbytearray.html#size">size</a>() is 5, the byte array also maintains an extra '\0' character at the end so that if a function is used that asks for a pointer to the underlying data (e.g&#x2e; a call to <a href="qbytearray.html#data">data</a>()), the data pointed to is guaranteed to be '\0'-terminated.</p>
<p><a href="qbytearray.html">QByteArray</a> makes a deep copy of the <code>const char *</code> data, so you can modify it later without experiencing side effects. (If for performance reasons you don't want to take a deep copy of the character data, use <a href="qbytearray.html#fromRawData">QByteArray::fromRawData</a>() instead.)</p>
<p>Another approach is to set the size of the array using <a href="qbytearray.html#resize">resize</a>() and to initialize the data byte per byte. <a href="qbytearray.html">QByteArray</a> uses 0-based indexes, just like C++ arrays. To access the byte at a particular index position, you can use operator[](). On non-const byte arrays, operator[]() returns a reference to a byte that can be used on the left side of an assignment. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba;
  ba<span class="operator">.</span>resize(<span class="number">5</span>);
  ba<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x3c</span>;
  ba<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xb8</span>;
  ba<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x64</span>;
  ba<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x18</span>;
  ba<span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xca</span>;

</pre>
<p>For read-only access, an alternative syntax is to use <a href="qbytearray.html#at">at</a>():</p>
<pre class="cpp">

  <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> ba<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i) {
      <span class="keyword">if</span> (ba<span class="operator">.</span>at(i) <span class="operator">&gt;</span><span class="operator">=</span> <span class="char">'a'</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> ba<span class="operator">.</span>at(i) <span class="operator">&lt;</span><span class="operator">=</span> <span class="char">'f'</span>)
          cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Found character in range [a-f]&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
  }

</pre>
<p><a href="qbytearray.html#at">at</a>() can be faster than operator[](), because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur.</p>
<p>To extract many bytes at a time, use <a href="qbytearray.html#left">left</a>(), <a href="qbytearray.html#right">right</a>(), or <a href="qbytearray.html#mid">mid</a>().</p>
<p>A <a href="qbytearray.html">QByteArray</a> can embed '\0' bytes. The <a href="qbytearray.html#size">size</a>() function always returns the size of the whole array, including embedded '\0' bytes, but excluding the terminating '\0' added by <a href="qbytearray.html">QByteArray</a>. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba1(<span class="string">&quot;ca\0r\0t&quot;</span>);
  ba1<span class="operator">.</span>size();                     <span class="comment">// Returns 2.</span>
  ba1<span class="operator">.</span>constData();                <span class="comment">// Returns &quot;ca&quot; with terminating \0.</span>

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba2(<span class="string">&quot;ca\0r\0t&quot;</span><span class="operator">,</span> <span class="number">3</span>);
  ba2<span class="operator">.</span>size();                     <span class="comment">// Returns 3.</span>
  ba2<span class="operator">.</span>constData();                <span class="comment">// Returns &quot;ca\0&quot; with terminating \0.</span>

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba3(<span class="string">&quot;ca\0r\0t&quot;</span><span class="operator">,</span> <span class="number">4</span>);
  ba3<span class="operator">.</span>size();                     <span class="comment">// Returns 4.</span>
  ba3<span class="operator">.</span>constData();                <span class="comment">// Returns &quot;ca\0r&quot; with terminating \0.</span>

  <span class="keyword">const</span> <span class="type">char</span> cart<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {<span class="char">'c'</span><span class="operator">,</span> <span class="char">'a'</span><span class="operator">,</span> <span class="char">'\0'</span><span class="operator">,</span> <span class="char">'r'</span><span class="operator">,</span> <span class="char">'\0'</span><span class="operator">,</span> <span class="char">'t'</span>};
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba4(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromRawData(cart<span class="operator">,</span> <span class="number">6</span>));
  ba4<span class="operator">.</span>size();                     <span class="comment">// Returns 6.</span>
  ba4<span class="operator">.</span>constData();                <span class="comment">// Returns &quot;ca\0r\0t&quot; without terminating \0.</span>

</pre>
<p>If you want to obtain the length of the data up to and excluding the first '\0' character, call <a href="qbytearray.html#qstrlen">qstrlen</a>() on the byte array.</p>
<p>After a call to <a href="qbytearray.html#resize">resize</a>(), newly allocated bytes have undefined values. To set all the bytes to a particular value, call <a href="qbytearray.html#fill">fill</a>().</p>
<p>To obtain a pointer to the actual character data, call <a href="qbytearray.html#data">data</a>() or <a href="qbytearray.html#constData">constData</a>(). These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the <a href="qbytearray.html">QByteArray</a>. It is also guaranteed that the data ends with a '\0' byte unless the <a href="qbytearray.html">QByteArray</a> was created from a <a href="qbytearray.html#fromRawData">raw data</a>. This '\0' byte is automatically provided by <a href="qbytearray.html">QByteArray</a> and is not counted in <a href="qbytearray.html#size">size</a>().</p>
<p><a href="qbytearray.html">QByteArray</a> provides the following basic functions for modifying the byte data: <a href="qbytearray.html#append">append</a>(), <a href="qbytearray.html#prepend">prepend</a>(), <a href="qbytearray.html#insert">insert</a>(), <a href="qbytearray.html#replace">replace</a>(), and <a href="qbytearray.html#remove">remove</a>(). For example:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;and&quot;</span>);
  x<span class="operator">.</span>prepend(<span class="string">&quot;rock &quot;</span>);         <span class="comment">// x == &quot;rock and&quot;</span>
  x<span class="operator">.</span>append(<span class="string">&quot; roll&quot;</span>);          <span class="comment">// x == &quot;rock and roll&quot;</span>
  x<span class="operator">.</span>replace(<span class="number">5</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="string">&quot;&amp;&quot;</span>);       <span class="comment">// x == &quot;rock &amp; roll&quot;</span>

</pre>
<p>The <a href="qbytearray.html#replace">replace</a>() and <a href="qbytearray.html#remove">remove</a>() functions' first two arguments are the position from which to start erasing and the number of bytes that should be erased.</p>
<p>When you <a href="qbytearray.html#append">append</a>() data to a non-empty array, the array will be reallocated and the new data copied to it. You can avoid this behavior by calling <a href="qbytearray.html#reserve">reserve</a>(), which preallocates a certain amount of memory. You can also call <a href="qbytearray.html#capacity">capacity</a>() to find out how much memory <a href="qbytearray.html">QByteArray</a> actually allocated. Data appended to an empty array is not copied.</p>
<p>A frequent requirement is to remove whitespace characters from a byte array ('\n', '\t', ' ', etc.)&#x2e; If you want to remove whitespace from both ends of a <a href="qbytearray.html">QByteArray</a>, use <a href="qbytearray.html#trimmed">trimmed</a>(). If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the byte array, use <a href="qbytearray.html#simplified">simplified</a>().</p>
<p>If you want to find all occurrences of a particular character or substring in a <a href="qbytearray.html">QByteArray</a>, use <a href="qbytearray.html#indexOf">indexOf</a>() or <a href="qbytearray.html#lastIndexOf">lastIndexOf</a>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;&quot;</span>);
  <span class="type">int</span> j <span class="operator">=</span> <span class="number">0</span>;
  <span class="keyword">while</span> ((j <span class="operator">=</span> ba<span class="operator">.</span>indexOf(<span class="string">&quot;&lt;b&gt;&quot;</span><span class="operator">,</span> j)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
      cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Found &lt;b&gt; tag at index position &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> j <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
      <span class="operator">+</span><span class="operator">+</span>j;
  }

</pre>
<p>If you simply want to check whether a <a href="qbytearray.html">QByteArray</a> contains a particular character or substring, use <a href="qbytearray.html#contains">contains</a>(). If you want to find out how many times a particular character or substring occurs in the byte array, use <a href="qbytearray.html#count-3">count</a>(). If you want to replace all occurrences of a particular value with another, use one of the two-parameter <a href="qbytearray.html#replace">replace</a>() overloads.</p>
<p><a href="qbytearray.html">QByteArray</a>s can be compared using overloaded operators such as operator&lt;(), operator&lt;=(), operator==(), operator&gt;=(), and so on. The comparison is based exclusively on the numeric values of the characters and is very fast, but is not what a human would expect. <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() is a better choice for sorting user-interface strings.</p>
<p>For historical reasons, <a href="qbytearray.html">QByteArray</a> distinguishes between a null byte array and an empty byte array. A <i>null</i> byte array is a byte array that is initialized using <a href="qbytearray.html">QByteArray</a>'s default constructor or by passing (const char *)0 to the constructor. An <i>empty</i> byte array is any byte array with size 0. A null byte array is always empty, but an empty byte array isn't necessarily null:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>()<span class="operator">.</span>isNull();          <span class="comment">// returns true</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>()<span class="operator">.</span>isEmpty();         <span class="comment">// returns true</span>

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns true</span>

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isNull();     <span class="comment">// returns false</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isEmpty();    <span class="comment">// returns false</span>

</pre>
<p>All functions except <a href="qbytearray.html#isNull">isNull</a>() treat null byte arrays the same as empty byte arrays. For example, <a href="qbytearray.html#data">data</a>() returns a pointer to a '\0' character for a null byte array (<i>not</i> a null pointer), and <a href="qbytearray.html#QByteArray">QByteArray</a>() compares equal to <a href="qbytearray.html">QByteArray</a>(&quot;&quot;). We recommend that you always use <a href="qbytearray.html#isEmpty">isEmpty</a>() and avoid <a href="qbytearray.html#isNull">isNull</a>().</p>
<a name="notes-on-locale"></a>
<h3 >Notes on Locale</h3>
<a name="number-string-conversions"></a>
<h4 >Number-String Conversions</h4>
<p>Functions that perform conversions between numeric data types and strings are performed in the C locale, irrespective of the user's locale settings. Use <a href="qstring.html">QString</a> to perform locale-aware conversions between numbers and strings.</p>
<a name="8-bit-character-comparisons"></a>
<h4 >8-bit Character Comparisons</h4>
<p>In <a href="qbytearray.html">QByteArray</a>, the notion of uppercase and lowercase and of which character is greater than or less than another character is locale dependent. This affects functions that support a case insensitive option or that compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only ASCII characters. (If <code>$LC_CTYPE</code> is set, most Unix systems do &quot;the right thing&quot;.) Functions that this affects include <a href="qbytearray.html#contains">contains</a>(), <a href="qbytearray.html#indexOf">indexOf</a>(), <a href="qbytearray.html#lastIndexOf">lastIndexOf</a>(), operator&lt;(), operator&lt;=(), operator&gt;(), operator&gt;=(), <a href="qbytearray.html#isLower">isLower</a>(), <a href="qbytearray.html#isUpper">isUpper</a>(), <a href="qbytearray.html#toLower">toLower</a>() and <a href="qbytearray.html#toUpper">toUpper</a>().</p>
<p>This issue does not apply to <a href="qstring.html">QString</a>s since they represent characters using Unicode.</p>
</div>
<p><b>参见</b><a href="qstring.html">QString</a> and <a href="qbitarray.html">QBitArray</a>.</p>
<!-- @@@QByteArray -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$Base64Option$$$Base64Encoding$$$Base64UrlEncoding$$$KeepTrailingEquals$$$OmitTrailingEquals -->
<h3 class="flags" id="Base64Option-enum"><a name="Base64Option-enum"></a>enum QByteArray::<span class="name">Base64Option</span><br/>flags QByteArray::<span class="name">Base64Options</span></h3>
<p>This enum contains the options available for encoding and decoding Base64. Base64 is defined by <a href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</a>, with the following options:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QByteArray::Base64Encoding</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">(default) The regular Base64 alphabet, called simply &quot;base64&quot;</td></tr>
<tr><td class="topAlign"><code>QByteArray::Base64UrlEncoding</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">An alternate alphabet, called &quot;base64url&quot;, which replaces two characters in the alphabet to be more friendly to URLs.</td></tr>
<tr><td class="topAlign"><code>QByteArray::KeepTrailingEquals</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">(default) Keeps the trailing padding equal signs at the end of the encoded data, so the data is always a size multiple of four.</td></tr>
<tr><td class="topAlign"><code>QByteArray::OmitTrailingEquals</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">Omits adding the padding equal signs at the end of the encoded data.</td></tr>
</table></div>
<p><a href="qbytearray.html#fromBase64">QByteArray::fromBase64</a>() ignores the KeepTrailingEquals and OmitTrailingEquals options and will not flag errors in case they are missing or if there are too many of them.</p>
<p>This enum was introduced or modified in  Qt 5.2.</p>
<p>The Base64Options type is a typedef for <a href="qflags.html">QFlags</a>&lt;Base64Option&gt;. It stores an OR combination of Base64Option values.</p>
<!-- @@@Base64Option -->
<!-- $$$const_iterator -->
<h3 class="fn" id="const_iterator-typedef"><a name="const_iterator-typedef"></a>typedef QByteArray::<span class="name">const_iterator</span></h3>
<p>This typedef provides an STL-style const iterator for <a href="qbytearray.html">QByteArray</a>.</p>
<p><b>参见</b><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> and <a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" id="const_reverse_iterator-typedef"><a name="const_reverse_iterator-typedef"></a>typedef QByteArray::<span class="name">const_reverse_iterator</span></h3>
<p>This typedef provides an STL-style const reverse iterator for <a href="qbytearray.html">QByteArray</a>.</p>
<p>这个类型定义是在Qt 5.6版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#reverse_iterator-typedef">QByteArray::reverse_iterator</a> and <a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$iterator -->
<h3 class="fn" id="iterator-typedef"><a name="iterator-typedef"></a>typedef QByteArray::<span class="name">iterator</span></h3>
<p>This typedef provides an STL-style non-const iterator for <a href="qbytearray.html">QByteArray</a>.</p>
<p><b>参见</b><a href="qbytearray.html#reverse_iterator-typedef">QByteArray::reverse_iterator</a> and <a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$reverse_iterator -->
<h3 class="fn" id="reverse_iterator-typedef"><a name="reverse_iterator-typedef"></a>typedef QByteArray::<span class="name">reverse_iterator</span></h3>
<p>This typedef provides an STL-style non-const reverse iterator for <a href="qbytearray.html">QByteArray</a>.</p>
<p>这个类型定义是在Qt 5.6版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> and <a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a>.</p>
<!-- @@@reverse_iterator -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QByteArray[overload1]$$$QByteArray -->
<h3 class="fn" id="QByteArray"><a name="QByteArray"></a>QByteArray::<span class="name">QByteArray</span>()</h3>
<p>Constructs an empty byte array.</p>
<p><b>参见</b><a href="qbytearray.html#isEmpty">isEmpty</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray$$$QByteArrayconstchar*int -->
<h3 class="fn" id="QByteArray-1"><a name="QByteArray-1"></a>QByteArray::<span class="name">QByteArray</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Constructs a byte array containing the first <i>size</i> bytes of array <i>data</i>.</p>
<p>If <i>data</i> is 0, a null byte array is constructed.</p>
<p>If <i>size</i> is negative, <i>data</i> is assumed to point to a nul-terminated string and its length is determined dynamically. The terminating nul-character is not considered part of the byte array.</p>
<p><a href="qbytearray.html">QByteArray</a> makes a deep copy of the string data.</p>
<p><b>参见</b><a href="qbytearray.html#fromRawData">fromRawData</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray$$$QByteArrayintchar -->
<h3 class="fn" id="QByteArray-2"><a name="QByteArray-2"></a>QByteArray::<span class="name">QByteArray</span>(<span class="type">int</span> <i>size</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>Constructs a byte array of size <i>size</i> with every byte set to character <i>ch</i>.</p>
<p><b>参见</b><a href="qbytearray.html#fill">fill</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray$$$QByteArrayconstQByteArray& -->
<h3 class="fn" id="QByteArray-4"><a name="QByteArray-4"></a>QByteArray::<span class="name">QByteArray</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i>other</i>.</p>
<p>This operation takes <a href="containers.html#constant-time">constant time</a>, because <a href="qbytearray.html">QByteArray</a> is <a href="implicit-sharing.html">implicitly shared</a>. This makes returning a <a href="qbytearray.html">QByteArray</a> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="containers.html#linear-time">linear time</a>.</p>
<p><b>参见</b><a href="qbytearray.html#operator-eq">operator=</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray$$$QByteArrayQByteArray&& -->
<h3 class="fn" id="QByteArray-5"><a name="QByteArray-5"></a>QByteArray::<span class="name">QByteArray</span>(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a <a href="qbytearray.html">QByteArray</a> instance, making it point at the same object that <i>other</i> was pointing to.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@QByteArray -->
<!-- $$$~QByteArray[overload1]$$$~QByteArray -->
<h3 class="fn" id="dtor.QByteArray"><a name="dtor.QByteArray"></a>QByteArray::<span class="name">~QByteArray</span>()</h3>
<p>Destroys the byte array.</p>
<!-- @@@~QByteArray -->
<!-- $$$append[overload1]$$$appendconstQByteArray& -->
<h3 class="fn" id="append"><a name="append"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Appends the byte array <i>ba</i> onto the end of this byte array.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;free&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;dom&quot;</span>);
  x<span class="operator">.</span>append(y);
  <span class="comment">// x == &quot;freedom&quot;</span>

</pre>
<p>This is the same as insert(<a href="qbytearray.html#size">size</a>(), <i>ba</i>).</p>
<p>Note: <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html">implicitly shared</a> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <i>ba</i>. In this case, no copying of data is done, taking <a href="containers.html#constant-time">constant time</a>. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>This operation typically does not suffer from allocation overhead, because <a href="qbytearray.html">QByteArray</a> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</p>
<p><b>参见</b><a href="qbytearray.html#operator-2b-eq">operator+=</a>(), <a href="qbytearray.html#prepend">prepend</a>(), and <a href="qbytearray.html#insert">insert</a>().</p>
<!-- @@@append -->
<!-- $$$append$$$appendintchar -->
<h3 class="fn" id="append-1"><a name="append-1"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(<span class="type">int</span> <i>count</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends <i>count</i> copies of character <i>ch</i> to this byte array and returns a reference to this byte array.</p>
<p>If <i>count</i> is negative or zero nothing is appended to the byte array.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstchar* -->
<h3 class="fn" id="append-2"><a name="append-2"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the string <i>str</i> to this byte array.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstchar*int -->
<h3 class="fn" id="append-3"><a name="append-3"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>len</i>)</h3>
<p>This function overloads <a href="qbytearray.html#append">append</a>().</p>
<p>Appends the first <i>len</i> characters of the string <i>str</i> to this byte array and returns a reference to this byte array.</p>
<p>If <i>len</i> is negative, the length of the string will be determined automatically using <a href="qbytearray.html#qstrlen">qstrlen</a>(). If <i>len</i> is zero or <i>str</i> is null, nothing is appended to the byte array. Ensure that <i>len</i> is <i>not</i> longer than <i>str</i>.</p>
<!-- @@@append -->
<!-- $$$append$$$appendchar -->
<h3 class="fn" id="append-4"><a name="append-4"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the character <i>ch</i> to this byte array.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstQString& -->
<h3 class="fn" id="append-5"><a name="append-5"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the string <i>str</i> to this byte array. The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>You can disable this function by defining <code>QT_NO_CAST_TO_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#toUtf8">QString::toUtf8</a>() (or <a href="qstring.html#toLatin1">QString::toLatin1</a>() or <a href="qstring.html#toLocal8Bit">QString::toLocal8Bit</a>()) explicitly if you want to convert the data to <code>const char *</code>.</p>
<!-- @@@append -->
<!-- $$$at[overload1]$$$atint -->
<h3 class="fn" id="at"><a name="at"></a><span class="type">char</span> QByteArray::<span class="name">at</span>(<span class="type">int</span> <i>i</i>) const</h3>
<p>Returns the character at index position <i>i</i> in the byte array.</p>
<p><i>i</i> must be a valid index position in the byte array (i.e&#x2e;, 0 &lt;= <i>i</i> &lt; <a href="qbytearray.html#size">size</a>()).</p>
<p><b>参见</b><a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" id="back"><a name="back"></a><span class="type">char</span> QByteArray::<span class="name">back</span>() const</h3>
<p>Returns the last character in the byte array. Same as <code>at(size() - 1)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<p><b>Warning:</b> Calling this function on an empty byte array constitutes undefined behavior.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#front">front</a>(), <a href="qbytearray.html#at">at</a>(), and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$back$$$back -->
<h3 class="fn" id="back-1"><a name="back-1"></a><span class="type">QByteRef</span> QByteArray::<span class="name">back</span>()</h3>
<p>Returns a reference to the last character in the byte array. Same as <code>operator[](size() - 1)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<p><b>Warning:</b> Calling this function on an empty byte array constitutes undefined behavior.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#front">front</a>(), <a href="qbytearray.html#at">at</a>(), and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin"><a name="begin"></a><span class="type"><a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a></span> QByteArray::<span class="name">begin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first character in the byte-array.</p>
<p><b>参见</b><a href="qbytearray.html#constBegin">constBegin</a>() and <a href="qbytearray.html#end">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1"><a name="begin-1"></a><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">begin</span>() const</h3>
<p>This function overloads <a href="qbytearray.html#begin">begin</a>().</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" id="capacity"><a name="capacity"></a><span class="type">int</span> QByteArray::<span class="name">capacity</span>() const</h3>
<p>Returns the maximum number of bytes that can be stored in the byte array without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qbytearray.html">QByteArray</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many bytes are in the byte array, call <a href="qbytearray.html#size">size</a>().</p>
<p><b>参见</b><a href="qbytearray.html#reserve">reserve</a>() and <a href="qbytearray.html#squeeze">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin"><a name="cbegin"></a><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first character in the byte-array.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#begin">begin</a>() and <a href="qbytearray.html#cend">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend"><a name="cend"></a><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary character after the last character in the list.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#cbegin">cbegin</a>() and <a href="qbytearray.html#end">end</a>().</p>
<!-- @@@cend -->
<!-- $$$chop[overload1]$$$chopint -->
<h3 class="fn" id="chop"><a name="chop"></a><span class="type">void</span> QByteArray::<span class="name">chop</span>(<span class="type">int</span> <i>n</i>)</h3>
<p>Removes <i>n</i> bytes from the end of the byte array.</p>
<p>If <i>n</i> is greater than <a href="qbytearray.html#size">size</a>(), the result is an empty byte array.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;STARTTLS\r\n&quot;</span>);
  ba<span class="operator">.</span>chop(<span class="number">2</span>);                 <span class="comment">// ba == &quot;STARTTLS&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#truncate">truncate</a>(), <a href="qbytearray.html#resize">resize</a>(), and <a href="qbytearray.html#left">left</a>().</p>
<!-- @@@chop -->
<!-- $$$chopped[overload1]$$$choppedint -->
<h3 class="fn" id="chopped"><a name="chopped"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">chopped</span>(<span class="type">int</span> <i>len</i>) const</h3>
<p>Returns a byte array that contains the leftmost <a href="qbytearray.html#size">size</a>() - <i>len</i> bytes of this byte array.</p>
<p><b>Note: </b>The behavior is undefined if <i>len</i> is negative or greater than <a href="qbytearray.html#size">size</a>().</p><p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#endsWith">endsWith</a>(), <a href="qbytearray.html#left">left</a>(), <a href="qbytearray.html#right">right</a>(), <a href="qbytearray.html#mid">mid</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@chopped -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear"><a name="clear"></a><span class="type">void</span> QByteArray::<span class="name">clear</span>()</h3>
<p>Clears the contents of the byte array and makes it null.</p>
<p><b>参见</b><a href="qbytearray.html#resize">resize</a>() and <a href="qbytearray.html#isNull">isNull</a>().</p>
<!-- @@@clear -->
<!-- $$$compare[overload1]$$$compareconstchar*Qt::CaseSensitivity -->
<h3 class="fn" id="compare"><a name="compare"></a><span class="type">int</span> QByteArray::<span class="name">compare</span>(const <span class="type">char</span> *<i>c</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...) const</h3>
<p>Returns an integer less than, equal to, or greater than zero depending on whether this <a href="qbytearray.html">QByteArray</a> sorts before, at the same position, or after the string pointed to by <i>c</i>. The comparison is performed according to case sensitivity <i>cs</i>.</p>
<p>这个函数是在Qt 5.12版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#operator-eq-eq">operator==</a>.</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareconstQByteArray&Qt::CaseSensitivity -->
<h3 class="fn" id="compare-1"><a name="compare-1"></a><span class="type">int</span> QByteArray::<span class="name">compare</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a</i>, <span class="type">Qt::CaseSensitivity</span> <i>cs</i> = ...) const</h3>
<p>This is an overloaded function.</p>
<p>Returns an integer less than, equal to, or greater than zero depending on whether this <a href="qbytearray.html">QByteArray</a> sorts before, at the same position, or after the <a href="qbytearray.html">QByteArray</a> <i>a</i>. The comparison is performed according to case sensitivity <i>cs</i>.</p>
<p>这个函数是在Qt 5.12版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#operator-eq-eq">operator==</a>.</p>
<!-- @@@compare -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin"><a name="constBegin"></a><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first character in the byte-array.</p>
<p><b>参见</b><a href="qbytearray.html#begin">begin</a>() and <a href="qbytearray.html#constEnd">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constData[overload1]$$$constData -->
<h3 class="fn" id="constData"><a name="constData"></a>const <span class="type">char</span> *QByteArray::<span class="name">constData</span>() const</h3>
<p>Returns a pointer to the data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated unless the <a href="qbytearray.html">QByteArray</a> object was created from raw data. The pointer remains valid as long as the byte array isn't reallocated or destroyed.</p>
<p>This function is mostly useful to pass a byte array to a function that accepts a <code>const char *</code>.</p>
<p>Note: A <a href="qbytearray.html">QByteArray</a> can store any byte values including '\0's, but most functions that take <code>char *</code> arguments assume that the data ends at the first '\0' they encounter.</p>
<p><b>参见</b><a href="qbytearray.html#data">data</a>(), <a href="qbytearray.html#operator-5b-5d">operator[]</a>(), and <a href="qbytearray.html#fromRawData">fromRawData</a>().</p>
<!-- @@@constData -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd"><a name="constEnd"></a><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary character after the last character in the list.</p>
<p><b>参见</b><a href="qbytearray.html#constBegin">constBegin</a>() and <a href="qbytearray.html#end">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$contains[overload1]$$$containsconstQByteArray& -->
<h3 class="fn" id="contains"><a name="contains"></a><span class="type">bool</span> QByteArray::<span class="name">contains</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>) const</h3>
<p>Returns <code>true</code> if the byte array contains an occurrence of the byte array <i>ba</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#indexOf">indexOf</a>() and <a href="qbytearray.html#count-3">count</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstchar* -->
<h3 class="fn" id="contains-1"><a name="contains-1"></a><span class="type">bool</span> QByteArray::<span class="name">contains</span>(const <span class="type">char</span> *<i>str</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if the byte array contains the string <i>str</i>; otherwise returns <code>false</code>.</p>
<!-- @@@contains -->
<!-- $$$contains$$$containschar -->
<h3 class="fn" id="contains-2"><a name="contains-2"></a><span class="type">bool</span> QByteArray::<span class="name">contains</span>(<span class="type">char</span> <i>ch</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if the byte array contains the character <i>ch</i>; otherwise returns <code>false</code>.</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstQByteArray& -->
<h3 class="fn" id="count"><a name="count"></a><span class="type">int</span> QByteArray::<span class="name">count</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>) const</h3>
<p>Returns the number of (potentially overlapping) occurrences of byte array <i>ba</i> in this byte array.</p>
<p><b>参见</b><a href="qbytearray.html#contains">contains</a>() and <a href="qbytearray.html#indexOf">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countconstchar* -->
<h3 class="fn" id="count-1"><a name="count-1"></a><span class="type">int</span> QByteArray::<span class="name">count</span>(const <span class="type">char</span> *<i>str</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the number of (potentially overlapping) occurrences of string <i>str</i> in the byte array.</p>
<!-- @@@count -->
<!-- $$$count$$$countchar -->
<h3 class="fn" id="count-2"><a name="count-2"></a><span class="type">int</span> QByteArray::<span class="name">count</span>(<span class="type">char</span> <i>ch</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the number of occurrences of character <i>ch</i> in the byte array.</p>
<p><b>参见</b><a href="qbytearray.html#contains">contains</a>() and <a href="qbytearray.html#indexOf">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn" id="count-3"><a name="count-3"></a><span class="type">int</span> QByteArray::<span class="name">count</span>() const</h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="qbytearray.html#size">size</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" id="crbegin"><a name="crbegin"></a><span class="type"><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">crbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first character in the byte-array, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#begin">begin</a>(), <a href="qbytearray.html#rbegin">rbegin</a>(), and <a href="qbytearray.html#rend">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" id="crend"><a name="crend"></a><span class="type"><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">crend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to one past the last character in the byte-array, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#end">end</a>(), <a href="qbytearray.html#rend">rend</a>(), and <a href="qbytearray.html#rbegin">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" id="data"><a name="data"></a><span class="type">char</span> *QByteArray::<span class="name">data</span>()</h3>
<p>Returns a pointer to the data stored in the byte array. The pointer can be used to access and modify the bytes that compose the array. The data is '\0'-terminated, i.e&#x2e; the number of bytes in the returned character string is <a href="qbytearray.html#size">size</a>() + 1 for the '\0' terminator.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Hello world&quot;</span>);
  <span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> ba<span class="operator">.</span>data();
  <span class="keyword">while</span> (<span class="operator">*</span>data) {
      cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;[&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="operator">*</span>data <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;]&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> endl;
      <span class="operator">+</span><span class="operator">+</span>data;
  }

</pre>
<p>The pointer remains valid as long as the byte array isn't reallocated or destroyed. For read-only access, <a href="qbytearray.html#constData">constData</a>() is faster because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur.</p>
<p>This function is mostly useful to pass a byte array to a function that accepts a <code>const char *</code>.</p>
<p>The following example makes a copy of the char* returned by data(), but it will corrupt the heap and cause a crash because it does not allocate a byte for the '\0' at the end:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html">QString</a></span> tmp <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> tmp<span class="operator">.</span>toLocal8Bit();
  <span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> <span class="keyword">new</span> <span class="type">char</span><span class="operator">[</span>text<span class="operator">.</span>size()<span class="operator">]</span>;
  strcpy(data<span class="operator">,</span> text<span class="operator">.</span>data());
  <span class="keyword">delete</span> <span class="operator">[</span><span class="operator">]</span> data;

</pre>
<p>This one allocates the correct amount of space:</p>
<pre class="cpp">

  <span class="type"><a href="qstring.html">QString</a></span> tmp <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> tmp<span class="operator">.</span>toLocal8Bit();
  <span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> <span class="keyword">new</span> <span class="type">char</span><span class="operator">[</span>text<span class="operator">.</span>size() <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span>;
  strcpy(data<span class="operator">,</span> text<span class="operator">.</span>data());
  <span class="keyword">delete</span> <span class="operator">[</span><span class="operator">]</span> data;

</pre>
<p>Note: A <a href="qbytearray.html">QByteArray</a> can store any byte values including '\0's, but most functions that take <code>char *</code> arguments assume that the data ends at the first '\0' they encounter.</p>
<p><b>参见</b><a href="qbytearray.html#constData">constData</a>() and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$data -->
<h3 class="fn" id="data-1"><a name="data-1"></a>const <span class="type">char</span> *QByteArray::<span class="name">data</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@data -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end"><a name="end"></a><span class="type"><a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a></span> QByteArray::<span class="name">end</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary character after the last character in the byte-array.</p>
<p><b>参见</b><a href="qbytearray.html#begin">begin</a>() and <a href="qbytearray.html#constEnd">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1"><a name="end-1"></a><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">end</span>() const</h3>
<p>This function overloads <a href="qbytearray.html#end">end</a>().</p>
<!-- @@@end -->
<!-- $$$endsWith[overload1]$$$endsWithconstQByteArray& -->
<h3 class="fn" id="endsWith"><a name="endsWith"></a><span class="type">bool</span> QByteArray::<span class="name">endsWith</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>) const</h3>
<p>Returns <code>true</code> if this byte array ends with byte array <i>ba</i>; otherwise returns <code>false</code>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> url(<span class="string">&quot;http://qt-project.org/doc/qt-5.0/qtdoc/index.html&quot;</span>);
  <span class="keyword">if</span> (url<span class="operator">.</span>endsWith(<span class="string">&quot;.html&quot;</span>))
      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#startsWith">startsWith</a>() and <a href="qbytearray.html#right">right</a>().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithchar -->
<h3 class="fn" id="endsWith-1"><a name="endsWith-1"></a><span class="type">bool</span> QByteArray::<span class="name">endsWith</span>(<span class="type">char</span> <i>ch</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if this byte array ends with character <i>ch</i>; otherwise returns <code>false</code>.</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithconstchar* -->
<h3 class="fn" id="endsWith-2"><a name="endsWith-2"></a><span class="type">bool</span> QByteArray::<span class="name">endsWith</span>(const <span class="type">char</span> *<i>str</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if this byte array ends with string <i>str</i>; otherwise returns <code>false</code>.</p>
<!-- @@@endsWith -->
<!-- $$$fill[overload1]$$$fillcharint -->
<h3 class="fn" id="fill"><a name="fill"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">fill</span>(<span class="type">char</span> <i>ch</i>, <span class="type">int</span> <i>size</i> = -1)</h3>
<p>Sets every byte in the byte array to character <i>ch</i>. If <i>size</i> is different from -1 (the default), the byte array is resized to size <i>size</i> beforehand.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Istambul&quot;</span>);
  ba<span class="operator">.</span>fill(<span class="char">'o'</span>);
  <span class="comment">// ba == &quot;oooooooo&quot;</span>

  ba<span class="operator">.</span>fill(<span class="char">'X'</span><span class="operator">,</span> <span class="number">2</span>);
  <span class="comment">// ba == &quot;XX&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#resize">resize</a>().</p>
<!-- @@@fill -->
<!-- $$$fromBase64[overload1]$$$fromBase64constQByteArray& -->
<h3 class="fn" id="fromBase64"><a name="fromBase64"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromBase64</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>base64</i>)</h3>
<p>Returns a decoded copy of the Base64 array <i>base64</i>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</p>
<p>For example:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromBase64(<span class="string">&quot;UXQgaXMgZ3JlYXQh&quot;</span>);
  text<span class="operator">.</span>data();            <span class="comment">// returns &quot;Qt is great!&quot;</span>

</pre>
<p>The algorithm used to decode Base64-encoded data is defined in <a href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</a>.</p>
<p><b>参见</b><a href="qbytearray.html#toBase64">toBase64</a>().</p>
<!-- @@@fromBase64 -->
<!-- $$$fromBase64$$$fromBase64constQByteArray&QByteArray::Base64Options -->
<h3 class="fn" id="fromBase64-1"><a name="fromBase64-1"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromBase64</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>base64</i>, <span class="type"><a href="qbytearray.html#Base64Option-enum">QByteArray::Base64Options</a></span> <i>options</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a decoded copy of the Base64 array <i>base64</i>, using the alphabet defined by <i>options</i>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</p>
<p>For example:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromBase64(<span class="string">&quot;PHA+SGVsbG8/PC9wPg==&quot;</span><span class="operator">,</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64Encoding); <span class="comment">// returns &quot;&lt;p&gt;Hello?&lt;/p&gt;&quot;</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromBase64(<span class="string">&quot;PHA-SGVsbG8_PC9wPg==&quot;</span><span class="operator">,</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding); <span class="comment">// returns &quot;&lt;p&gt;Hello?&lt;/p&gt;&quot;</span>

</pre>
<p>The algorithm used to decode Base64-encoded data is defined in <a href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</a>.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#toBase64">toBase64</a>().</p>
<!-- @@@fromBase64 -->
<!-- $$$fromCFData[overload1]$$$fromCFDataCFDataRef -->
<h3 class="fn" id="fromCFData"><a name="fromCFData"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromCFData</span>(<span class="type">CFDataRef</span> <i>data</i>)</h3>
<p>Constructs a new <a href="qbytearray.html">QByteArray</a> containing a copy of the CFData <i>data</i>.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromRawCFData">fromRawCFData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#toRawCFData">toRawCFData</a>(), and <a href="qbytearray.html#toCFData">toCFData</a>().</p>
<!-- @@@fromCFData -->
<!-- $$$fromHex[overload1]$$$fromHexconstQByteArray& -->
<h3 class="fn" id="fromHex"><a name="fromHex"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromHex</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>hexEncoded</i>)</h3>
<p>Returns a decoded copy of the hex encoded array <i>hexEncoded</i>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</p>
<p>For example:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromHex(<span class="string">&quot;517420697320677265617421&quot;</span>);
  text<span class="operator">.</span>data();            <span class="comment">// returns &quot;Qt is great!&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#toHex">toHex</a>().</p>
<!-- @@@fromHex -->
<!-- $$$fromNSData[overload1]$$$fromNSDataconstNSData* -->
<h3 class="fn" id="fromNSData"><a name="fromNSData"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromNSData</span>(const <span class="type">NSData</span> *<i>data</i>)</h3>
<p>Constructs a new <a href="qbytearray.html">QByteArray</a> containing a copy of the NSData <i>data</i>.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromRawNSData">fromRawNSData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#toNSData">toNSData</a>(), and <a href="qbytearray.html#toRawNSData">toRawNSData</a>().</p>
<!-- @@@fromNSData -->
<!-- $$$fromPercentEncoding[overload1]$$$fromPercentEncodingconstQByteArray&char -->
<h3 class="fn" id="fromPercentEncoding"><a name="fromPercentEncoding"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromPercentEncoding</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>input</i>, <span class="type">char</span> <i>percent</i> = '%')</h3>
<p>Returns a decoded copy of the URI/URL-style percent-encoded <i>input</i>. The <i>percent</i> parameter allows you to replace the '%' character for another (for instance, '_' or '=').</p>
<p>For example:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromPercentEncoding(<span class="string">&quot;Qt%20is%20great%33&quot;</span>);
  text<span class="operator">.</span>data();            <span class="comment">// returns &quot;Qt is great!&quot;</span>

</pre>
<p><b>Note: </b>Given invalid input (such as a string containing the sequence &quot;%G5&quot;, which is not a valid hexadecimal number) the output will be invalid as well. As an example: the sequence &quot;%G5&quot; could be decoded to 'W'.</p><p>这个函数是在Qt 4.4版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#toPercentEncoding">toPercentEncoding</a>() and <a href="qurl.html#fromPercentEncoding">QUrl::fromPercentEncoding</a>().</p>
<!-- @@@fromPercentEncoding -->
<!-- $$$fromRawCFData[overload1]$$$fromRawCFDataCFDataRef -->
<h3 class="fn" id="fromRawCFData"><a name="fromRawCFData"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromRawCFData</span>(<span class="type">CFDataRef</span> <i>data</i>)</h3>
<p>Constructs a <a href="qbytearray.html">QByteArray</a> that uses the bytes of the CFData <i>data</i>.</p>
<p>The <i>data</i>'s bytes are not copied.</p>
<p>The caller guarantees that the CFData will not be deleted or modified as long as this <a href="qbytearray.html">QByteArray</a> object exists.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromCFData">fromCFData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#toRawCFData">toRawCFData</a>(), and <a href="qbytearray.html#toCFData">toCFData</a>().</p>
<!-- @@@fromRawCFData -->
<!-- $$$fromRawData[overload1]$$$fromRawDataconstchar*int -->
<h3 class="fn" id="fromRawData"><a name="fromRawData"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromRawData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>Constructs a <a href="qbytearray.html">QByteArray</a> that uses the first <i>size</i> bytes of the <i>data</i> array. The bytes are <i>not</i> copied. The <a href="qbytearray.html">QByteArray</a> will contain the <i>data</i> pointer. The caller guarantees that <i>data</i> will not be deleted or modified as long as this <a href="qbytearray.html">QByteArray</a> and any copies of it exist that have not been modified. In other words, because <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html">implicitly shared</a> class and the instance returned by this function contains the <i>data</i> pointer, the caller must not delete <i>data</i> or modify it directly as long as the returned <a href="qbytearray.html">QByteArray</a> and any copies exist. However, <a href="qbytearray.html">QByteArray</a> does not take ownership of <i>data</i>, so the <a href="qbytearray.html">QByteArray</a> destructor will never delete the raw <i>data</i>, even when the last <a href="qbytearray.html">QByteArray</a> referring to <i>data</i> is destroyed.</p>
<p>A subsequent attempt to modify the contents of the returned <a href="qbytearray.html">QByteArray</a> or any copy made from it will cause it to create a deep copy of the <i>data</i> array before doing the modification. This ensures that the raw <i>data</i> array itself will never be modified by <a href="qbytearray.html">QByteArray</a>.</p>
<p>Here is an example of how to read data using a <a href="qdatastream.html">QDataStream</a> on raw data in memory without copying the raw data into a <a href="qbytearray.html">QByteArray</a>:</p>
<pre class="cpp">

   <span class="keyword">static</span> <span class="keyword">const</span> <span class="type">char</span> mydata<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
      <span class="char">'\x00'</span><span class="operator">,</span> <span class="char">'\x00'</span><span class="operator">,</span> <span class="char">'\x03'</span><span class="operator">,</span> <span class="char">'\x84'</span><span class="operator">,</span> <span class="char">'\x78'</span><span class="operator">,</span> <span class="char">'\x9c'</span><span class="operator">,</span> <span class="char">'\x3b'</span><span class="operator">,</span> <span class="char">'\x76'</span><span class="operator">,</span>
      <span class="char">'\xec'</span><span class="operator">,</span> <span class="char">'\x18'</span><span class="operator">,</span> <span class="char">'\xc3'</span><span class="operator">,</span> <span class="char">'\x31'</span><span class="operator">,</span> <span class="char">'\x0a'</span><span class="operator">,</span> <span class="char">'\xf1'</span><span class="operator">,</span> <span class="char">'\xcc'</span><span class="operator">,</span> <span class="char">'\x99'</span><span class="operator">,</span>
      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
      <span class="char">'\x6d'</span><span class="operator">,</span> <span class="char">'\x5b'</span>
  };

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> data <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromRawData(mydata<span class="operator">,</span> <span class="keyword">sizeof</span>(mydata));
  <span class="type"><a href="qdatastream.html">QDataStream</a></span> in(<span class="operator">&amp;</span>data<span class="operator">,</span> <span class="type"><a href="qiodevice.html">QIODevice</a></span><span class="operator">::</span>ReadOnly);
  <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

</pre>
<p><b>Warning:</b> A byte array created with fromRawData() is <i>not</i> null-terminated, unless the raw data contains a 0 character at position <i>size</i>. While that does not matter for <a href="qdatastream.html">QDataStream</a> or functions like <a href="qbytearray.html#indexOf">indexOf</a>(), passing the byte array to a function accepting a <code>const char *</code> expected to be '\0'-terminated will fail.</p>
<p><b>参见</b><a href="qbytearray.html#setRawData">setRawData</a>(), <a href="qbytearray.html#data">data</a>(), and <a href="qbytearray.html#constData">constData</a>().</p>
<!-- @@@fromRawData -->
<!-- $$$fromRawNSData[overload1]$$$fromRawNSDataconstNSData* -->
<h3 class="fn" id="fromRawNSData"><a name="fromRawNSData"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromRawNSData</span>(const <span class="type">NSData</span> *<i>data</i>)</h3>
<p>Constructs a <a href="qbytearray.html">QByteArray</a> that uses the bytes of the NSData <i>data</i>.</p>
<p>The <i>data</i>'s bytes are not copied.</p>
<p>The caller guarantees that the NSData will not be deleted or modified as long as this <a href="qbytearray.html">QByteArray</a> object exists.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromNSData">fromNSData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#toRawNSData">toRawNSData</a>(), and <a href="qbytearray.html#toNSData">toNSData</a>().</p>
<!-- @@@fromRawNSData -->
<!-- $$$fromStdString[overload1]$$$fromStdStringconststd::string& -->
<h3 class="fn" id="fromStdString"><a name="fromStdString"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromStdString</span>(const <span class="type">std::string</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i>str</i> string as a <a href="qbytearray.html">QByteArray</a>.</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#toStdString">toStdString</a>() and <a href="qstring.html#fromStdString">QString::fromStdString</a>().</p>
<!-- @@@fromStdString -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" id="front"><a name="front"></a><span class="type">char</span> QByteArray::<span class="name">front</span>() const</h3>
<p>Returns the first character in the byte array. Same as <code>at(0)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<p><b>Warning:</b> Calling this function on an empty byte array constitutes undefined behavior.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#back">back</a>(), <a href="qbytearray.html#at">at</a>(), and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$front$$$front -->
<h3 class="fn" id="front-1"><a name="front-1"></a><span class="type">QByteRef</span> QByteArray::<span class="name">front</span>()</h3>
<p>Returns a reference to the first character in the byte array. Same as <code>operator[](0)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<p><b>Warning:</b> Calling this function on an empty byte array constitutes undefined behavior.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#back">back</a>(), <a href="qbytearray.html#at">at</a>(), and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$indexOf[overload1]$$$indexOfconstQByteArray&int -->
<h3 class="fn" id="indexOf"><a name="indexOf"></a><span class="type">int</span> QByteArray::<span class="name">indexOf</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>, <span class="type">int</span> <i>from</i> = 0) const</h3>
<p>Returns the index position of the first occurrence of the byte array <i>ba</i> in this byte array, searching forward from index position <i>from</i>. Returns -1 if <i>ba</i> could not be found.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;sticky question&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;sti&quot;</span>);
  x<span class="operator">.</span>indexOf(y);               <span class="comment">// returns 0</span>
  x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">1</span>);            <span class="comment">// returns 10</span>
  x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">10</span>);           <span class="comment">// returns 10</span>
  x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">11</span>);           <span class="comment">// returns -1</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#lastIndexOf">lastIndexOf</a>(), <a href="qbytearray.html#contains">contains</a>(), and <a href="qbytearray.html#count-3">count</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfconstchar*int -->
<h3 class="fn" id="indexOf-1"><a name="indexOf-1"></a><span class="type">int</span> QByteArray::<span class="name">indexOf</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>from</i> = 0) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the first occurrence of the string <i>str</i> in the byte array, searching forward from index position <i>from</i>. Returns -1 if <i>str</i> could not be found.</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfcharint -->
<h3 class="fn" id="indexOf-2"><a name="indexOf-2"></a><span class="type">int</span> QByteArray::<span class="name">indexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">int</span> <i>from</i> = 0) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the first occurrence of the character <i>ch</i> in the byte array, searching forward from index position <i>from</i>. Returns -1 if <i>ch</i> could not be found.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;ABCBA&quot;</span>);
  ba<span class="operator">.</span>indexOf(<span class="string">&quot;B&quot;</span>);            <span class="comment">// returns 1</span>
  ba<span class="operator">.</span>indexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">1</span>);         <span class="comment">// returns 1</span>
  ba<span class="operator">.</span>indexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">2</span>);         <span class="comment">// returns 3</span>
  ba<span class="operator">.</span>indexOf(<span class="string">&quot;X&quot;</span>);            <span class="comment">// returns -1</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#lastIndexOf">lastIndexOf</a>() and <a href="qbytearray.html#contains">contains</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfconstQString&int -->
<h3 class="fn" id="indexOf-3"><a name="indexOf-3"></a><span class="type">int</span> QByteArray::<span class="name">indexOf</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>, <span class="type">int</span> <i>from</i> = 0) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the first occurrence of the string <i>str</i> in the byte array, searching forward from index position <i>from</i>. Returns -1 if <i>str</i> could not be found.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>You can disable this function by defining <code>QT_NO_CAST_TO_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#toUtf8">QString::toUtf8</a>() (or <a href="qstring.html#toLatin1">QString::toLatin1</a>() or <a href="qstring.html#toLocal8Bit">QString::toLocal8Bit</a>()) explicitly if you want to convert the data to <code>const char *</code>.</p>
<!-- @@@indexOf -->
<!-- $$$insert[overload1]$$$insertintconstQByteArray& -->
<h3 class="fn" id="insert"><a name="insert"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Inserts the byte array <i>ba</i> at index position <i>i</i> and returns a reference to this byte array.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Meal&quot;</span>);
  ba<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;ontr&quot;</span>));
  <span class="comment">// ba == &quot;Montreal&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#append">append</a>(), <a href="qbytearray.html#prepend">prepend</a>(), <a href="qbytearray.html#replace">replace</a>(), and <a href="qbytearray.html#remove">remove</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintintchar -->
<h3 class="fn" id="insert-1"><a name="insert-1"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, <span class="type">int</span> <i>count</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts <i>count</i> copies of character <i>ch</i> at index position <i>i</i> in the byte array.</p>
<p>If <i>i</i> is greater than <a href="qbytearray.html#size">size</a>(), the array is first extended using <a href="qbytearray.html#resize">resize</a>().</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintconstchar* -->
<h3 class="fn" id="insert-2"><a name="insert-2"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts the string <i>str</i> at position <i>i</i> in the byte array.</p>
<p>If <i>i</i> is greater than <a href="qbytearray.html#size">size</a>(), the array is first extended using <a href="qbytearray.html#resize">resize</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintconstchar*int -->
<h3 class="fn" id="insert-3"><a name="insert-3"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>len</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts <i>len</i> bytes of the string <i>str</i> at position <i>i</i> in the byte array.</p>
<p>If <i>i</i> is greater than <a href="qbytearray.html#size">size</a>(), the array is first extended using <a href="qbytearray.html#resize">resize</a>().</p>
<p>这个函数是在Qt 4.6版本中新增引入的。</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintchar -->
<h3 class="fn" id="insert-4"><a name="insert-4"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts character <i>ch</i> at index position <i>i</i> in the byte array. If <i>i</i> is greater than <a href="qbytearray.html#size">size</a>(), the array is first extended using <a href="qbytearray.html#resize">resize</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintconstQString& -->
<h3 class="fn" id="insert-5"><a name="insert-5"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts the string <i>str</i> at index position <i>i</i> in the byte array. The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>If <i>i</i> is greater than <a href="qbytearray.html#size">size</a>(), the array is first extended using <a href="qbytearray.html#resize">resize</a>().</p>
<p>You can disable this function by defining <code>QT_NO_CAST_TO_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#toUtf8">QString::toUtf8</a>() (or <a href="qstring.html#toLatin1">QString::toLatin1</a>() or <a href="qstring.html#toLocal8Bit">QString::toLocal8Bit</a>()) explicitly if you want to convert the data to <code>const char *</code>.</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty"><a name="isEmpty"></a><span class="type">bool</span> QByteArray::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code>true</code> if the byte array has size 0; otherwise returns <code>false</code>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>()<span class="operator">.</span>isEmpty();         <span class="comment">// returns true</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns true</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isEmpty();    <span class="comment">// returns false</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#size">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$isLower[overload1]$$$isLower -->
<h3 class="fn" id="isLower"><a name="isLower"></a><span class="type">bool</span> QByteArray::<span class="name">isLower</span>() const</h3>
<p>Returns <code>true</code> if this byte array contains only lowercase letters, otherwise returns <code>false</code>. The byte array is interpreted as a Latin-1 encoded string.</p>
<p>这个函数是在Qt 5.12版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#isUpper">isUpper</a>() and <a href="qbytearray.html#toLower">toLower</a>().</p>
<!-- @@@isLower -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" id="isNull"><a name="isNull"></a><span class="type">bool</span> QByteArray::<span class="name">isNull</span>() const</h3>
<p>Returns <code>true</code> if this byte array is null; otherwise returns <code>false</code>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>()<span class="operator">.</span>isNull();          <span class="comment">// returns true</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isNull();     <span class="comment">// returns false</span>

</pre>
<p>Qt makes a distinction between null byte arrays and empty byte arrays for historical reasons. For most applications, what matters is whether or not a byte array contains any data, and this can be determined using <a href="qbytearray.html#isEmpty">isEmpty</a>().</p>
<p><b>参见</b><a href="qbytearray.html#isEmpty">isEmpty</a>().</p>
<!-- @@@isNull -->
<!-- $$$isUpper[overload1]$$$isUpper -->
<h3 class="fn" id="isUpper"><a name="isUpper"></a><span class="type">bool</span> QByteArray::<span class="name">isUpper</span>() const</h3>
<p>Returns <code>true</code> if this byte array contains only uppercase letters, otherwise returns <code>false</code>. The byte array is interpreted as a Latin-1 encoded string.</p>
<p>这个函数是在Qt 5.12版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#isLower">isLower</a>() and <a href="qbytearray.html#toUpper">toUpper</a>().</p>
<!-- @@@isUpper -->
<!-- $$$lastIndexOf[overload1]$$$lastIndexOfconstQByteArray&int -->
<h3 class="fn" id="lastIndexOf"><a name="lastIndexOf"></a><span class="type">int</span> QByteArray::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>, <span class="type">int</span> <i>from</i> = -1) const</h3>
<p>Returns the index position of the last occurrence of the byte array <i>ba</i> in this byte array, searching backward from index position <i>from</i>. If <i>from</i> is -1 (the default), the search starts at the last byte. Returns -1 if <i>ba</i> could not be found.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;crazy azimuths&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;az&quot;</span>);
  x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
  x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
  x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
  x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#indexOf">indexOf</a>(), <a href="qbytearray.html#contains">contains</a>(), and <a href="qbytearray.html#count-3">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstchar*int -->
<h3 class="fn" id="lastIndexOf-1"><a name="lastIndexOf-1"></a><span class="type">int</span> QByteArray::<span class="name">lastIndexOf</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>from</i> = -1) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the last occurrence of the string <i>str</i> in the byte array, searching backward from index position <i>from</i>. If <i>from</i> is -1 (the default), the search starts at the last (<a href="qbytearray.html#size">size</a>() - 1) byte. Returns -1 if <i>str</i> could not be found.</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfcharint -->
<h3 class="fn" id="lastIndexOf-2"><a name="lastIndexOf-2"></a><span class="type">int</span> QByteArray::<span class="name">lastIndexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">int</span> <i>from</i> = -1) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the last occurrence of character <i>ch</i> in the byte array, searching backward from index position <i>from</i>. If <i>from</i> is -1 (the default), the search starts at the last (<a href="qbytearray.html#size">size</a>() - 1) byte. Returns -1 if <i>ch</i> could not be found.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;ABCBA&quot;</span>);
  ba<span class="operator">.</span>lastIndexOf(<span class="string">&quot;B&quot;</span>);        <span class="comment">// returns 3</span>
  ba<span class="operator">.</span>lastIndexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">3</span>);     <span class="comment">// returns 3</span>
  ba<span class="operator">.</span>lastIndexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">2</span>);     <span class="comment">// returns 1</span>
  ba<span class="operator">.</span>lastIndexOf(<span class="string">&quot;X&quot;</span>);        <span class="comment">// returns -1</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#indexOf">indexOf</a>() and <a href="qbytearray.html#contains">contains</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstQString&int -->
<h3 class="fn" id="lastIndexOf-3"><a name="lastIndexOf-3"></a><span class="type">int</span> QByteArray::<span class="name">lastIndexOf</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>, <span class="type">int</span> <i>from</i> = -1) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the last occurrence of the string <i>str</i> in the byte array, searching backward from index position <i>from</i>. If <i>from</i> is -1 (the default), the search starts at the last (<a href="qbytearray.html#size">size</a>() - 1) byte. Returns -1 if <i>str</i> could not be found.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>You can disable this function by defining <code>QT_NO_CAST_TO_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#toUtf8">QString::toUtf8</a>() (or <a href="qstring.html#toLatin1">QString::toLatin1</a>() or <a href="qstring.html#toLocal8Bit">QString::toLocal8Bit</a>()) explicitly if you want to convert the data to <code>const char *</code>.</p>
<!-- @@@lastIndexOf -->
<!-- $$$left[overload1]$$$leftint -->
<h3 class="fn" id="left"><a name="left"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">left</span>(<span class="type">int</span> <i>len</i>) const</h3>
<p>Returns a byte array that contains the leftmost <i>len</i> bytes of this byte array.</p>
<p>The entire byte array is returned if <i>len</i> is greater than <a href="qbytearray.html#size">size</a>().</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Pineapple&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>left(<span class="number">4</span>);
  <span class="comment">// y == &quot;Pine&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#startsWith">startsWith</a>(), <a href="qbytearray.html#right">right</a>(), <a href="qbytearray.html#mid">mid</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@left -->
<!-- $$$leftJustified[overload1]$$$leftJustifiedintcharbool -->
<h3 class="fn" id="leftJustified"><a name="leftJustified"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">leftJustified</span>(<span class="type">int</span> <i>width</i>, <span class="type">char</span> <i>fill</i> = ' ', <span class="type">bool</span> <i>truncate</i> = false) const</h3>
<p>Returns a byte array of size <i>width</i> that contains this byte array padded by the <i>fill</i> character.</p>
<p>If <i>truncate</i> is false and the <a href="qbytearray.html#size">size</a>() of the byte array is more than <i>width</i>, then the returned byte array is a copy of this byte array.</p>
<p>If <i>truncate</i> is true and the <a href="qbytearray.html#size">size</a>() of the byte array is more than <i>width</i>, then any bytes in a copy of the byte array after position <i>width</i> are removed, and the copy is returned.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;apple&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>leftJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);   <span class="comment">// y == &quot;apple...&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#rightJustified">rightJustified</a>().</p>
<!-- @@@leftJustified -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" id="length"><a name="length"></a><span class="type">int</span> QByteArray::<span class="name">length</span>() const</h3>
<p>Same as <a href="qbytearray.html#size">size</a>().</p>
<!-- @@@length -->
<!-- $$$mid[overload1]$$$midintint -->
<h3 class="fn" id="mid"><a name="mid"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">mid</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i> = -1) const</h3>
<p>Returns a byte array containing <i>len</i> bytes from this byte array, starting at position <i>pos</i>.</p>
<p>If <i>len</i> is -1 (the default), or <i>pos</i> + <i>len</i> &gt;= <a href="qbytearray.html#size">size</a>(), returns a byte array containing all bytes starting at position <i>pos</i> until the end of the byte array.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Five pineapples&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>mid(<span class="number">5</span><span class="operator">,</span> <span class="number">4</span>);     <span class="comment">// y == &quot;pine&quot;</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> z <span class="operator">=</span> x<span class="operator">.</span>mid(<span class="number">5</span>);        <span class="comment">// z == &quot;pineapples&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#left">left</a>(), <a href="qbytearray.html#right">right</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@mid -->
<!-- $$$number[overload1]$$$numberintint -->
<h3 class="fn" id="number"><a name="number"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>Returns a byte array containing the string equivalent of the number <i>n</i> to base <i>base</i> (10 by default). The <i>base</i> can be any value between 2 and 36.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type">int</span> n <span class="operator">=</span> <span class="number">63</span>;
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>number(n);              <span class="comment">// returns &quot;63&quot;</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>number(n<span class="operator">,</span> <span class="number">16</span>);          <span class="comment">// returns &quot;3f&quot;</span>
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>number(n<span class="operator">,</span> <span class="number">16</span>)<span class="operator">.</span>toUpper();  <span class="comment">// returns &quot;3F&quot;</span>

</pre>
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#setNum">setNum</a>() and <a href="qbytearray.html#toInt">toInt</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberuintint -->
<h3 class="fn" id="number-1"><a name="number-1"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>参见</b><a href="qbytearray.html#toUInt">toUInt</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberqlonglongint -->
<h3 class="fn" id="number-2"><a name="number-2"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>参见</b><a href="qbytearray.html#toLongLong">toLongLong</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberqulonglongint -->
<h3 class="fn" id="number-3"><a name="number-3"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>参见</b><a href="qbytearray.html#toULongLong">toULongLong</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberdoublecharint -->
<h3 class="fn" id="number-4"><a name="number-4"></a><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>f</i> = 'g', <span class="type">int</span> <i>prec</i> = 6)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that contains the printed value of <i>n</i>, formatted in format <i>f</i> with precision <i>prec</i>.</p>
<p>Argument <i>n</i> is formatted according to the <i>f</i> format specified, which is <code>g</code> by default, and can be any of the following:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >格式</th><th >Meaning</th></tr></thead>
<tr valign="top" class="odd"><td ><code>e</code></td><td >format as [-]9.9e[+|-]999</td></tr>
<tr valign="top" class="even"><td ><code>E</code></td><td >format as [-]9.9E[+|-]999</td></tr>
<tr valign="top" class="odd"><td ><code>f</code></td><td >format as [-]9.9</td></tr>
<tr valign="top" class="even"><td ><code>g</code></td><td >use <code>e</code> or <code>f</code> format, whichever is the most concise</td></tr>
<tr valign="top" class="odd"><td ><code>G</code></td><td >use <code>E</code> or <code>f</code> format, whichever is the most concise</td></tr>
</table></div>
<p>With 'e', 'E', and 'f', <i>prec</i> is the number of digits after the decimal point. With 'g' and 'G', <i>prec</i> is the maximum number of significant digits (trailing zeroes are omitted).</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>number(<span class="number">12.3456</span><span class="operator">,</span> <span class="char">'E'</span><span class="operator">,</span> <span class="number">3</span>);
  <span class="comment">// ba == 1.235E+01</span>

</pre>
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#toDouble">toDouble</a>().</p>
<!-- @@@number -->
<!-- $$$prepend[overload1]$$$prependconstQByteArray& -->
<h3 class="fn" id="prepend"><a name="prepend"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Prepends the byte array <i>ba</i> to this byte array and returns a reference to this byte array.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;ship&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;air&quot;</span>);
  x<span class="operator">.</span>prepend(y);
  <span class="comment">// x == &quot;airship&quot;</span>

</pre>
<p>This is the same as insert(0, <i>ba</i>).</p>
<p>Note: <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html">implicitly shared</a> class. Consequently, if you prepend to an empty byte array, then the byte array will just share the data held in <i>ba</i>. In this case, no copying of data is done, taking <a href="containers.html#constant-time">constant time</a>. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>If the byte array being prepended to is not empty, a deep copy of the data is performed, taking <a href="containers.html#linear-time">linear time</a>.</p>
<p><b>参见</b><a href="qbytearray.html#append">append</a>() and <a href="qbytearray.html#insert">insert</a>().</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependintchar -->
<h3 class="fn" id="prepend-1"><a name="prepend-1"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(<span class="type">int</span> <i>count</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends <i>count</i> copies of character <i>ch</i> to this byte array.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstchar* -->
<h3 class="fn" id="prepend-2"><a name="prepend-2"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends the string <i>str</i> to this byte array.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstchar*int -->
<h3 class="fn" id="prepend-3"><a name="prepend-3"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>len</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends <i>len</i> bytes of the string <i>str</i> to this byte array.</p>
<p>这个函数是在Qt 4.6版本中新增引入的。</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependchar -->
<h3 class="fn" id="prepend-4"><a name="prepend-4"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends the character <i>ch</i> to this byte array.</p>
<!-- @@@prepend -->
<!-- $$$push_back[overload1]$$$push_backconstQByteArray& -->
<h3 class="fn" id="push_back"><a name="push_back"></a><span class="type">void</span> QByteArray::<span class="name">push_back</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>This function is provided for STL compatibility. It is equivalent to append(<i>other</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backconstchar* -->
<h3 class="fn" id="push_back-1"><a name="push_back-1"></a><span class="type">void</span> QByteArray::<span class="name">push_back</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as append(<i>str</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backchar -->
<h3 class="fn" id="push_back-2"><a name="push_back-2"></a><span class="type">void</span> QByteArray::<span class="name">push_back</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as append(<i>ch</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_front[overload1]$$$push_frontconstQByteArray& -->
<h3 class="fn" id="push_front"><a name="push_front"></a><span class="type">void</span> QByteArray::<span class="name">push_front</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>This function is provided for STL compatibility. It is equivalent to prepend(<i>other</i>).</p>
<!-- @@@push_front -->
<!-- $$$push_front$$$push_frontconstchar* -->
<h3 class="fn" id="push_front-1"><a name="push_front-1"></a><span class="type">void</span> QByteArray::<span class="name">push_front</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as prepend(<i>str</i>).</p>
<!-- @@@push_front -->
<!-- $$$push_front$$$push_frontchar -->
<h3 class="fn" id="push_front-2"><a name="push_front-2"></a><span class="type">void</span> QByteArray::<span class="name">push_front</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as prepend(<i>ch</i>).</p>
<!-- @@@push_front -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" id="rbegin"><a name="rbegin"></a><span class="type"><a href="qbytearray.html#reverse_iterator-typedef">QByteArray::reverse_iterator</a></span> QByteArray::<span class="name">rbegin</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first character in the byte-array, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#begin">begin</a>(), <a href="qbytearray.html#crbegin">crbegin</a>(), and <a href="qbytearray.html#rend">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" id="rbegin-1"><a name="rbegin-1"></a><span class="type"><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">rbegin</span>() const</h3>
<p>This is an overloaded function.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@rbegin -->
<!-- $$$remove[overload1]$$$removeintint -->
<h3 class="fn" id="remove"><a name="remove"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">remove</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i>)</h3>
<p>Removes <i>len</i> bytes from the array, starting at index position <i>pos</i>, and returns a reference to the array.</p>
<p>If <i>pos</i> is out of range, nothing happens. If <i>pos</i> is valid, but <i>pos</i> + <i>len</i> is larger than the size of the array, the array is truncated at position <i>pos</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Montreal&quot;</span>);
  ba<span class="operator">.</span>remove(<span class="number">1</span><span class="operator">,</span> <span class="number">4</span>);
  <span class="comment">// ba == &quot;Meal&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#insert">insert</a>() and <a href="qbytearray.html#replace">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" id="rend"><a name="rend"></a><span class="type"><a href="qbytearray.html#reverse_iterator-typedef">QByteArray::reverse_iterator</a></span> QByteArray::<span class="name">rend</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to one past the last character in the byte-array, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#end">end</a>(), <a href="qbytearray.html#crend">crend</a>(), and <a href="qbytearray.html#rbegin">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" id="rend-1"><a name="rend-1"></a><span class="type"><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">rend</span>() const</h3>
<p>This is an overloaded function.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@rend -->
<!-- $$$repeated[overload1]$$$repeatedint -->
<h3 class="fn" id="repeated"><a name="repeated"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">repeated</span>(<span class="type">int</span> <i>times</i>) const</h3>
<p>Returns a copy of this byte array repeated the specified number of <i>times</i>.</p>
<p>If <i>times</i> is less than 1, an empty byte array is returned.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;ab&quot;</span>);
  ba<span class="operator">.</span>repeated(<span class="number">4</span>);             <span class="comment">// returns &quot;abababab&quot;</span>

</pre>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<!-- @@@repeated -->
<!-- $$$replace[overload1]$$$replaceintintconstQByteArray& -->
<h3 class="fn" id="replace"><a name="replace"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>after</i>)</h3>
<p>Replaces <i>len</i> bytes from index position <i>pos</i> with the byte array <i>after</i>, and returns a reference to this byte array.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Say yes!&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;no&quot;</span>);
  x<span class="operator">.</span>replace(<span class="number">4</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> y);
  <span class="comment">// x == &quot;Say no!&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#insert">insert</a>() and <a href="qbytearray.html#remove">remove</a>().</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceintintconstchar*int -->
<h3 class="fn" id="replace-1"><a name="replace-1"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i>, const <span class="type">char</span> *<i>after</i>, <span class="type">int</span> <i>alen</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces <i>len</i> bytes from index position <i>pos</i> with <i>alen</i> bytes from the string <i>after</i>. <i>after</i> is allowed to have '\0' characters.</p>
<p>这个函数是在Qt 4.7版本中新增引入的。</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceintintconstchar* -->
<h3 class="fn" id="replace-2"><a name="replace-2"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i>, const <span class="type">char</span> *<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces <i>len</i> bytes from index position <i>pos</i> with the zero terminated string <i>after</i>.</p>
<p>Notice: this can change the length of the byte array.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replacecharconstchar* -->
<h3 class="fn" id="replace-3"><a name="replace-3"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">char</span> <i>before</i>, const <span class="type">char</span> *<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the character <i>before</i> with the string <i>after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replacecharconstQByteArray& -->
<h3 class="fn" id="replace-4"><a name="replace-4"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">char</span> <i>before</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the character <i>before</i> with the byte array <i>after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstchar*constchar* -->
<h3 class="fn" id="replace-5"><a name="replace-5"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type">char</span> *<i>before</i>, const <span class="type">char</span> *<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstchar*intconstchar*int -->
<h3 class="fn" id="replace-6"><a name="replace-6"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type">char</span> *<i>before</i>, <span class="type">int</span> <i>bsize</i>, const <span class="type">char</span> *<i>after</i>, <span class="type">int</span> <i>asize</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i>. Since the sizes of the strings are given by <i>bsize</i> and <i>asize</i>, they may contain zero characters and do not need to be zero-terminated.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQByteArray&constQByteArray& -->
<h3 class="fn" id="replace-7"><a name="replace-7"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>before</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the byte array <i>before</i> with the byte array <i>after</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;colour behaviour flavour neighbour&quot;</span>);
  ba<span class="operator">.</span>replace(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;ou&quot;</span>)<span class="operator">,</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;o&quot;</span>));
  <span class="comment">// ba == &quot;color behavior flavor neighbor&quot;</span>

</pre>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQByteArray&constchar* -->
<h3 class="fn" id="replace-8"><a name="replace-8"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>before</i>, const <span class="type">char</span> *<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the byte array <i>before</i> with the string <i>after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstchar*constQByteArray& -->
<h3 class="fn" id="replace-9"><a name="replace-9"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type">char</span> *<i>before</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the string <i>before</i> with the byte array <i>after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replacecharchar -->
<h3 class="fn" id="replace-10"><a name="replace-10"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">char</span> <i>before</i>, <span class="type">char</span> <i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the character <i>before</i> with the character <i>after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQString&constchar* -->
<h3 class="fn" id="replace-11"><a name="replace-11"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>before</i>, const <span class="type">char</span> *<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the string <i>before</i> with the string <i>after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replacecharconstQString& -->
<h3 class="fn" id="replace-12"><a name="replace-12"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">char</span> <i>before</i>, const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the character <i>before</i> with the string <i>after</i>. The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>You can disable this function by defining <code>QT_NO_CAST_TO_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#toUtf8">QString::toUtf8</a>() (or <a href="qstring.html#toLatin1">QString::toLatin1</a>() or <a href="qstring.html#toLocal8Bit">QString::toLocal8Bit</a>()) explicitly if you want to convert the data to <code>const char *</code>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQString&constQByteArray& -->
<h3 class="fn" id="replace-13"><a name="replace-13"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>before</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the string <i>before</i> with the byte array <i>after</i>. The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>You can disable this function by defining <code>QT_NO_CAST_TO_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#toUtf8">QString::toUtf8</a>() (or <a href="qstring.html#toLatin1">QString::toLatin1</a>() or <a href="qstring.html#toLocal8Bit">QString::toLocal8Bit</a>()) explicitly if you want to convert the data to <code>const char *</code>.</p>
<!-- @@@replace -->
<!-- $$$reserve[overload1]$$$reserveint -->
<h3 class="fn" id="reserve"><a name="reserve"></a><span class="type">void</span> QByteArray::<span class="name">reserve</span>(<span class="type">int</span> <i>size</i>)</h3>
<p>Attempts to allocate memory for at least <i>size</i> bytes. If you know in advance how large the byte array will be, you can call this function, and if you call <a href="qbytearray.html#resize">resize</a>() often you are likely to get better performance. If <i>size</i> is an underestimate, the worst that will happen is that the <a href="qbytearray.html">QByteArray</a> will be a bit slower.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qbytearray.html">QByteArray</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the byte array, call <a href="qbytearray.html#resize">resize</a>().</p>
<p><b>参见</b><a href="qbytearray.html#squeeze">squeeze</a>() and <a href="qbytearray.html#capacity">capacity</a>().</p>
<!-- @@@reserve -->
<!-- $$$resize[overload1]$$$resizeint -->
<h3 class="fn" id="resize"><a name="resize"></a><span class="type">void</span> QByteArray::<span class="name">resize</span>(<span class="type">int</span> <i>size</i>)</h3>
<p>Sets the size of the byte array to <i>size</i> bytes.</p>
<p>If <i>size</i> is greater than the current size, the byte array is extended to make it <i>size</i> bytes with the extra bytes added to the end. The new bytes are uninitialized.</p>
<p>If <i>size</i> is less than the current size, bytes are removed from the end.</p>
<p><b>参见</b><a href="qbytearray.html#size">size</a>() and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@resize -->
<!-- $$$right[overload1]$$$rightint -->
<h3 class="fn" id="right"><a name="right"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">right</span>(<span class="type">int</span> <i>len</i>) const</h3>
<p>Returns a byte array that contains the rightmost <i>len</i> bytes of this byte array.</p>
<p>The entire byte array is returned if <i>len</i> is greater than <a href="qbytearray.html#size">size</a>().</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Pineapple&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>right(<span class="number">5</span>);
  <span class="comment">// y == &quot;apple&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#endsWith">endsWith</a>(), <a href="qbytearray.html#left">left</a>(), <a href="qbytearray.html#mid">mid</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@right -->
<!-- $$$rightJustified[overload1]$$$rightJustifiedintcharbool -->
<h3 class="fn" id="rightJustified"><a name="rightJustified"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">rightJustified</span>(<span class="type">int</span> <i>width</i>, <span class="type">char</span> <i>fill</i> = ' ', <span class="type">bool</span> <i>truncate</i> = false) const</h3>
<p>Returns a byte array of size <i>width</i> that contains the <i>fill</i> character followed by this byte array.</p>
<p>If <i>truncate</i> is false and the size of the byte array is more than <i>width</i>, then the returned byte array is a copy of this byte array.</p>
<p>If <i>truncate</i> is true and the size of the byte array is more than <i>width</i>, then the resulting byte array is truncated at position <i>width</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;apple&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>rightJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);    <span class="comment">// y == &quot;...apple&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#leftJustified">leftJustified</a>().</p>
<!-- @@@rightJustified -->
<!-- $$$setNum[overload1]$$$setNumintint -->
<h3 class="fn" id="setNum"><a name="setNum"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>Sets the byte array to the printed value of <i>n</i> in base <i>base</i> (10 by default) and returns a reference to the byte array. The <i>base</i> can be any value between 2 and 36. For bases other than 10, n is treated as an unsigned integer.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba;
  <span class="type">int</span> n <span class="operator">=</span> <span class="number">63</span>;
  ba<span class="operator">.</span>setNum(n);           <span class="comment">// ba == &quot;63&quot;</span>
  ba<span class="operator">.</span>setNum(n<span class="operator">,</span> <span class="number">16</span>);       <span class="comment">// ba == &quot;3f&quot;</span>

</pre>
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#number">number</a>() and <a href="qbytearray.html#toInt">toInt</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumushortint -->
<h3 class="fn" id="setNum-1"><a name="setNum-1"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>参见</b><a href="qbytearray.html#toUShort">toUShort</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumshortint -->
<h3 class="fn" id="setNum-2"><a name="setNum-2"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">short</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>参见</b><a href="qbytearray.html#toShort">toShort</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumuintint -->
<h3 class="fn" id="setNum-3"><a name="setNum-3"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>参见</b><a href="qbytearray.html#toUInt">toUInt</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqlonglongint -->
<h3 class="fn" id="setNum-4"><a name="setNum-4"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>参见</b><a href="qbytearray.html#toLongLong">toLongLong</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqulonglongint -->
<h3 class="fn" id="setNum-5"><a name="setNum-5"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>参见</b><a href="qbytearray.html#toULongLong">toULongLong</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumfloatcharint -->
<h3 class="fn" id="setNum-6"><a name="setNum-6"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">float</span> <i>n</i>, <span class="type">char</span> <i>f</i> = 'g', <span class="type">int</span> <i>prec</i> = 6)</h3>
<p>This is an overloaded function.</p>
<p>Sets the byte array to the printed value of <i>n</i>, formatted in format <i>f</i> with precision <i>prec</i>, and returns a reference to the byte array.</p>
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#toFloat">toFloat</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumdoublecharint -->
<h3 class="fn" id="setNum-7"><a name="setNum-7"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>f</i> = 'g', <span class="type">int</span> <i>prec</i> = 6)</h3>
<p>This is an overloaded function.</p>
<p>Sets the byte array to the printed value of <i>n</i>, formatted in format <i>f</i> with precision <i>prec</i>, and returns a reference to the byte array.</p>
<p>The format <i>f</i> can be any of the following:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >格式</th><th >Meaning</th></tr></thead>
<tr valign="top" class="odd"><td ><code>e</code></td><td >format as [-]9.9e[+|-]999</td></tr>
<tr valign="top" class="even"><td ><code>E</code></td><td >format as [-]9.9E[+|-]999</td></tr>
<tr valign="top" class="odd"><td ><code>f</code></td><td >format as [-]9.9</td></tr>
<tr valign="top" class="even"><td ><code>g</code></td><td >use <code>e</code> or <code>f</code> format, whichever is the most concise</td></tr>
<tr valign="top" class="odd"><td ><code>G</code></td><td >use <code>E</code> or <code>f</code> format, whichever is the most concise</td></tr>
</table></div>
<p>With 'e', 'E', and 'f', <i>prec</i> is the number of digits after the decimal point. With 'g' and 'G', <i>prec</i> is the maximum number of significant digits (trailing zeroes are omitted).</p>
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#toDouble">toDouble</a>().</p>
<!-- @@@setNum -->
<!-- $$$setRawData[overload1]$$$setRawDataconstchar*uint -->
<h3 class="fn" id="setRawData"><a name="setRawData"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setRawData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>size</i>)</h3>
<p>Resets the <a href="qbytearray.html">QByteArray</a> to use the first <i>size</i> bytes of the <i>data</i> array. The bytes are <i>not</i> copied. The <a href="qbytearray.html">QByteArray</a> will contain the <i>data</i> pointer. The caller guarantees that <i>data</i> will not be deleted or modified as long as this <a href="qbytearray.html">QByteArray</a> and any copies of it exist that have not been modified.</p>
<p>This function can be used instead of <a href="qbytearray.html#fromRawData">fromRawData</a>() to re-use existing <a href="qbytearray.html">QByteArray</a> objects to save memory re-allocations.</p>
<p>这个函数是在Qt 4.7版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#data">data</a>(), and <a href="qbytearray.html#constData">constData</a>().</p>
<!-- @@@setRawData -->
<!-- $$$shrink_to_fit[overload1]$$$shrink_to_fit -->
<h3 class="fn" id="shrink_to_fit"><a name="shrink_to_fit"></a><span class="type">void</span> QByteArray::<span class="name">shrink_to_fit</span>()</h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="qbytearray.html#squeeze">squeeze</a>().</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<!-- @@@shrink_to_fit -->
<!-- $$$simplified[overload1]$$$simplified -->
<h3 class="fn" id="simplified"><a name="simplified"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">simplified</span>() const</h3>
<p>Returns a byte array that has whitespace removed from the start and the end, and which has each sequence of internal whitespace replaced with a single space.</p>
<p>Whitespace means any character for which the standard C++ <code>isspace()</code> function returns <code>true</code> in the C locale. This includes the ASCII isspace() function returns <code>true</code> in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;  lots\t of\nwhitespace\r\n &quot;</span>);
  ba <span class="operator">=</span> ba<span class="operator">.</span>simplified();
  <span class="comment">// ba == &quot;lots of whitespace&quot;;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#trimmed">trimmed</a>().</p>
<!-- @@@simplified -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><a name="size"></a><span class="type">int</span> QByteArray::<span class="name">size</span>() const</h3>
<p>Returns the number of bytes in this byte array.</p>
<p>The last byte in the byte array is at position size() - 1. In addition, <a href="qbytearray.html">QByteArray</a> ensures that the byte at position size() is always '\0', so that you can use the return value of <a href="qbytearray.html#data">data</a>() and <a href="qbytearray.html#constData">constData</a>() as arguments to functions that expect '\0'-terminated strings. If the <a href="qbytearray.html">QByteArray</a> object was created from a <a href="qbytearray.html#fromRawData">raw data</a> that didn't include the trailing null-termination character then <a href="qbytearray.html">QByteArray</a> doesn't add it automaticall unless the <a href="implicit-sharing.html#deep-copy">deep copy</a> is created.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Hello&quot;</span>);
  <span class="type">int</span> n <span class="operator">=</span> ba<span class="operator">.</span>size();          <span class="comment">// n == 5</span>
  ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;               <span class="comment">// returns 'H'</span>
  ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;               <span class="comment">// returns 'o'</span>
  ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">5</span><span class="operator">]</span>;               <span class="comment">// returns '\0'</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#isEmpty">isEmpty</a>() and <a href="qbytearray.html#resize">resize</a>().</p>
<!-- @@@size -->
<!-- $$$split[overload1]$$$splitchar -->
<h3 class="fn" id="split"><a name="split"></a><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>&gt; QByteArray::<span class="name">split</span>(<span class="type">char</span> <i>sep</i>) const</h3>
<p>Splits the byte array into subarrays wherever <i>sep</i> occurs, and returns the list of those arrays. If <i>sep</i> does not match anywhere in the byte array, split() returns a single-element list containing this byte array.</p>
<!-- @@@split -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" id="squeeze"><a name="squeeze"></a><span class="type">void</span> QByteArray::<span class="name">squeeze</span>()</h3>
<p>Releases any memory not required to store the array's data.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qbytearray.html">QByteArray</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b>参见</b><a href="qbytearray.html#reserve">reserve</a>() and <a href="qbytearray.html#capacity">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$startsWith[overload1]$$$startsWithconstQByteArray& -->
<h3 class="fn" id="startsWith"><a name="startsWith"></a><span class="type">bool</span> QByteArray::<span class="name">startsWith</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>) const</h3>
<p>Returns <code>true</code> if this byte array starts with byte array <i>ba</i>; otherwise returns <code>false</code>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> url(<span class="string">&quot;ftp://ftp.qt-project.org/&quot;</span>);
  <span class="keyword">if</span> (url<span class="operator">.</span>startsWith(<span class="string">&quot;ftp:&quot;</span>))
      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#endsWith">endsWith</a>() and <a href="qbytearray.html#left">left</a>().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithchar -->
<h3 class="fn" id="startsWith-1"><a name="startsWith-1"></a><span class="type">bool</span> QByteArray::<span class="name">startsWith</span>(<span class="type">char</span> <i>ch</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if this byte array starts with character <i>ch</i>; otherwise returns <code>false</code>.</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithconstchar* -->
<h3 class="fn" id="startsWith-2"><a name="startsWith-2"></a><span class="type">bool</span> QByteArray::<span class="name">startsWith</span>(const <span class="type">char</span> *<i>str</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if this byte array starts with string <i>str</i>; otherwise returns <code>false</code>.</p>
<!-- @@@startsWith -->
<!-- $$$swap[overload1]$$$swapQByteArray& -->
<h3 class="fn" id="swap"><a name="swap"></a><span class="type">void</span> QByteArray::<span class="name">swap</span>(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>Swaps byte array <i>other</i> with this byte array. This operation is very fast and never fails.</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<!-- @@@swap -->
<!-- $$$toBase64[overload1]$$$toBase64 -->
<h3 class="fn" id="toBase64"><a name="toBase64"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toBase64</span>() const</h3>
<p>Returns a copy of the byte array, encoded as Base64.</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text(<span class="string">&quot;Qt is great!&quot;</span>);
  text<span class="operator">.</span>toBase64();        <span class="comment">// returns &quot;UXQgaXMgZ3JlYXQh&quot;</span>

</pre>
<p>The algorithm used to encode Base64-encoded data is defined in <a href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</a>.</p>
<p><b>参见</b><a href="qbytearray.html#fromBase64">fromBase64</a>().</p>
<!-- @@@toBase64 -->
<!-- $$$toBase64$$$toBase64QByteArray::Base64Options -->
<h3 class="fn" id="toBase64-1"><a name="toBase64-1"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toBase64</span>(<span class="type"><a href="qbytearray.html#Base64Option-enum">QByteArray::Base64Options</a></span> <i>options</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a copy of the byte array, encoded using the options <i>options</i>.</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text(<span class="string">&quot;&lt;p&gt;Hello?&lt;/p&gt;&quot;</span>);
  text<span class="operator">.</span>toBase64(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64Encoding <span class="operator">|</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>OmitTrailingEquals);      <span class="comment">// returns &quot;PHA+SGVsbG8/PC9wPg&quot;</span>
  text<span class="operator">.</span>toBase64(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64Encoding);                                       <span class="comment">// returns &quot;PHA+SGVsbG8/PC9wPg==&quot;</span>
  text<span class="operator">.</span>toBase64(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding);                                    <span class="comment">// returns &quot;PHA-SGVsbG8_PC9wPg==&quot;</span>
  text<span class="operator">.</span>toBase64(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding <span class="operator">|</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>OmitTrailingEquals);   <span class="comment">// returns &quot;PHA-SGVsbG8_PC9wPg&quot;</span>

</pre>
<p>The algorithm used to encode Base64-encoded data is defined in <a href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</a>.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromBase64">fromBase64</a>().</p>
<!-- @@@toBase64 -->
<!-- $$$toCFData[overload1]$$$toCFData -->
<h3 class="fn" id="toCFData"><a name="toCFData"></a><span class="type">CFDataRef</span> QByteArray::<span class="name">toCFData</span>() const</h3>
<p>Creates a CFData from a <a href="qbytearray.html">QByteArray</a>. The caller owns the CFData object and is responsible for releasing it.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#toRawCFData">toRawCFData</a>(), <a href="qbytearray.html#fromCFData">fromCFData</a>(), <a href="qbytearray.html#fromRawCFData">fromRawCFData</a>(), and <a href="qbytearray.html#fromRawData">fromRawData</a>().</p>
<!-- @@@toCFData -->
<!-- $$$toDouble[overload1]$$$toDoublebool* -->
<h3 class="fn" id="toDouble"><a name="toDouble"></a><span class="type">double</span> QByteArray::<span class="name">toDouble</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the byte array converted to a <code>double</code> value.</p>
<p>Returns 0.0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> string(<span class="string">&quot;1234.56&quot;</span>);
  bool ok;
  <span class="type">double</span> a <span class="operator">=</span> string<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok);   <span class="comment">// a == 1234.56, ok == true</span>

  string <span class="operator">=</span> <span class="string">&quot;1234.56 Volt&quot;</span>;
  a <span class="operator">=</span> str<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok);             <span class="comment">// a == 0, ok == false</span>

</pre>
<p><b>Warning:</b> The <a href="qbytearray.html">QByteArray</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p>This function ignores leading and trailing whitespace.</p>
<p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toDouble -->
<!-- $$$toFloat[overload1]$$$toFloatbool* -->
<h3 class="fn" id="toFloat"><a name="toFloat"></a><span class="type">float</span> QByteArray::<span class="name">toFloat</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the byte array converted to a <code>float</code> value.</p>
<p>Returns 0.0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> string(<span class="string">&quot;1234.56&quot;</span>);
  bool ok;
  <span class="type">float</span> a <span class="operator">=</span> string<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);    <span class="comment">// a == 1234.56, ok == true</span>

  string <span class="operator">=</span> <span class="string">&quot;1234.56 Volt&quot;</span>;
  a <span class="operator">=</span> str<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);              <span class="comment">// a == 0, ok == false</span>

</pre>
<p><b>Warning:</b> The <a href="qbytearray.html">QByteArray</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p>This function ignores leading and trailing whitespace.</p>
<p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toFloat -->
<!-- $$$toHex[overload1]$$$toHex -->
<h3 class="fn" id="toHex"><a name="toHex"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toHex</span>() const</h3>
<p>Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.</p>
<p><b>参见</b><a href="qbytearray.html#fromHex">fromHex</a>().</p>
<!-- @@@toHex -->
<!-- $$$toHex$$$toHexchar -->
<h3 class="fn" id="toHex-1"><a name="toHex-1"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toHex</span>(<span class="type">char</span> <i>separator</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.</p>
<p>If <i>separator</i> is not '\0', the separator character is inserted between the hex bytes.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> macAddress <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromHex(<span class="string">&quot;123456abcdef&quot;</span>);
  macAddress<span class="operator">.</span>toHex(<span class="char">':'</span>); <span class="comment">// returns &quot;12:34:56:ab:cd:ef&quot;</span>
  macAddress<span class="operator">.</span>toHex(<span class="number">0</span>);   <span class="comment">// returns &quot;123456abcdef&quot;</span>

</pre>
<p>这个函数是在Qt 5.9版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromHex">fromHex</a>().</p>
<!-- @@@toHex -->
<!-- $$$toInt[overload1]$$$toIntbool*int -->
<h3 class="fn" id="toInt"><a name="toInt"></a><span class="type">int</span> QByteArray::<span class="name">toInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>int</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> str(<span class="string">&quot;FF&quot;</span>);
  bool ok;
  <span class="type">int</span> hex <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
  <span class="type">int</span> dec <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>

</pre>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toInt -->
<!-- $$$toLong[overload1]$$$toLongbool*int -->
<h3 class="fn" id="toLong"><a name="toLong"></a><span class="type">long</span> QByteArray::<span class="name">toLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to a <code>long</code> int using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> str(<span class="string">&quot;FF&quot;</span>);
  bool ok;
  <span class="type">long</span> hex <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);   <span class="comment">// hex == 255, ok == true</span>
  <span class="type">long</span> dec <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);   <span class="comment">// dec == 0, ok == false</span>

</pre>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p>这个函数是在Qt 4.1版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toLong -->
<!-- $$$toLongLong[overload1]$$$toLongLongbool*int -->
<h3 class="fn" id="toLongLong"><a name="toLongLong"></a><span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> QByteArray::<span class="name">toLongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to a <code>long long</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toLongLong -->
<!-- $$$toLower[overload1]$$$toLower -->
<h3 class="fn" id="toLower"><a name="toLower"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toLower</span>() const</h3>
<p>Returns a lowercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Qt by THE QT COMPANY&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>toLower();
  <span class="comment">// y == &quot;qt by the qt company&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#isLower">isLower</a>(), <a href="qbytearray.html#toUpper">toUpper</a>(), and <a href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</a>.</p>
<!-- @@@toLower -->
<!-- $$$toNSData[overload1]$$$toNSData -->
<h3 class="fn" id="toNSData"><a name="toNSData"></a><span class="type">NSData</span> *QByteArray::<span class="name">toNSData</span>() const</h3>
<p>Creates a NSData from a <a href="qbytearray.html">QByteArray</a>. The NSData object is autoreleased.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromNSData">fromNSData</a>(), <a href="qbytearray.html#fromRawNSData">fromRawNSData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), and <a href="qbytearray.html#toRawNSData">toRawNSData</a>().</p>
<!-- @@@toNSData -->
<!-- $$$toPercentEncoding[overload1]$$$toPercentEncodingconstQByteArray&constQByteArray&char -->
<h3 class="fn" id="toPercentEncoding"><a name="toPercentEncoding"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toPercentEncoding</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>exclude</i> = QByteArray(), const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>include</i> = QByteArray(), <span class="type">char</span> <i>percent</i> = '%') const</h3>
<p>Returns a URI/URL-style percent-encoded copy of this byte array. The <i>percent</i> parameter allows you to override the default '%' character for another.</p>
<p>By default, this function will encode all characters that are not one of the following:</p>
<p>ALPHA (&quot;a&quot; to &quot;z&quot; and &quot;A&quot; to &quot;Z&quot;) / DIGIT (0 to 9) / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</p>
<p>To prevent characters from being encoded pass them to <i>exclude</i>. To force characters to be encoded pass them to <i>include</i>. The <i>percent</i> character is always encoded.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> <span class="string">&quot;{a fishy string?}&quot;</span>;
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba <span class="operator">=</span> text<span class="operator">.</span>toPercentEncoding(<span class="string">&quot;{}&quot;</span><span class="operator">,</span> <span class="string">&quot;s&quot;</span>);
  <a href="qtglobal.html#qDebug">qDebug</a>(ba<span class="operator">.</span>constData());
  <span class="comment">// prints &quot;{a fi%73hy %73tring%3F}&quot;</span>

</pre>
<p>The hex encoding uses the numbers 0-9 and the uppercase letters A-F.</p>
<p>这个函数是在Qt 4.4版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromPercentEncoding">fromPercentEncoding</a>() and <a href="qurl.html#toPercentEncoding">QUrl::toPercentEncoding</a>().</p>
<!-- @@@toPercentEncoding -->
<!-- $$$toRawCFData[overload1]$$$toRawCFData -->
<h3 class="fn" id="toRawCFData"><a name="toRawCFData"></a><span class="type">CFDataRef</span> QByteArray::<span class="name">toRawCFData</span>() const</h3>
<p>Constructs a CFData that uses the bytes of the <a href="qbytearray.html">QByteArray</a>.</p>
<p>The <a href="qbytearray.html">QByteArray</a>'s bytes are not copied.</p>
<p>The caller guarantees that the <a href="qbytearray.html">QByteArray</a> will not be deleted or modified as long as this CFData object exists.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#toCFData">toCFData</a>(), <a href="qbytearray.html#fromRawCFData">fromRawCFData</a>(), <a href="qbytearray.html#fromCFData">fromCFData</a>(), and <a href="qbytearray.html#fromRawData">fromRawData</a>().</p>
<!-- @@@toRawCFData -->
<!-- $$$toRawNSData[overload1]$$$toRawNSData -->
<h3 class="fn" id="toRawNSData"><a name="toRawNSData"></a><span class="type">NSData</span> *QByteArray::<span class="name">toRawNSData</span>() const</h3>
<p>Constructs a NSData that uses the bytes of the <a href="qbytearray.html">QByteArray</a>.</p>
<p>The <a href="qbytearray.html">QByteArray</a>'s bytes are not copied.</p>
<p>The caller guarantees that the <a href="qbytearray.html">QByteArray</a> will not be deleted or modified as long as this NSData object exists.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromRawNSData">fromRawNSData</a>(), <a href="qbytearray.html#fromNSData">fromNSData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), and <a href="qbytearray.html#toNSData">toNSData</a>().</p>
<!-- @@@toRawNSData -->
<!-- $$$toShort[overload1]$$$toShortbool*int -->
<h3 class="fn" id="toShort"><a name="toShort"></a><span class="type">short</span> QByteArray::<span class="name">toShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to a <code>short</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toShort -->
<!-- $$$toStdString[overload1]$$$toStdString -->
<h3 class="fn" id="toStdString"><a name="toStdString"></a><span class="type">std::string</span> QByteArray::<span class="name">toStdString</span>() const</h3>
<p>Returns a std::string object with the data contained in this <a href="qbytearray.html">QByteArray</a>.</p>
<p>This operator is mostly useful to pass a <a href="qbytearray.html">QByteArray</a> to a function that accepts a std::string object.</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#fromStdString">fromStdString</a>() and <a href="qstring.html#toStdString">QString::toStdString</a>().</p>
<!-- @@@toStdString -->
<!-- $$$toUInt[overload1]$$$toUIntbool*int -->
<h3 class="fn" id="toUInt"><a name="toUInt"></a><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> QByteArray::<span class="name">toUInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>unsigned int</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toUInt -->
<!-- $$$toULong[overload1]$$$toULongbool*int -->
<h3 class="fn" id="toULong"><a name="toULong"></a><span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> QByteArray::<span class="name">toULong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>unsigned long int</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p>这个函数是在Qt 4.1版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toULong -->
<!-- $$$toULongLong[overload1]$$$toULongLongbool*int -->
<h3 class="fn" id="toULongLong"><a name="toULongLong"></a><span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> QByteArray::<span class="name">toULongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>unsigned long long</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toULongLong -->
<!-- $$$toUShort[overload1]$$$toUShortbool*int -->
<h3 class="fn" id="toUShort"><a name="toUShort"></a><span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> QByteArray::<span class="name">toUShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>unsigned short</code> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p><p><b>参见</b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toUShort -->
<!-- $$$toUpper[overload1]$$$toUpper -->
<h3 class="fn" id="toUpper"><a name="toUpper"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toUpper</span>() const</h3>
<p>Returns an uppercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Qt by THE QT COMPANY&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>toUpper();
  <span class="comment">// y == &quot;QT BY THE QT COMPANY&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#isUpper">isUpper</a>(), <a href="qbytearray.html#toLower">toLower</a>(), and <a href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</a>.</p>
<!-- @@@toUpper -->
<!-- $$$trimmed[overload1]$$$trimmed -->
<h3 class="fn" id="trimmed"><a name="trimmed"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">trimmed</span>() const</h3>
<p>Returns a byte array that has whitespace removed from the start and the end.</p>
<p>Whitespace means any character for which the standard C++ <code>isspace()</code> function returns <code>true</code> in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;  lots\t of\nwhitespace\r\n &quot;</span>);
  ba <span class="operator">=</span> ba<span class="operator">.</span>trimmed();
  <span class="comment">// ba == &quot;lots\t of\nwhitespace&quot;;</span>

</pre>
<p>Unlike <a href="qbytearray.html#simplified">simplified</a>(), trimmed() leaves internal whitespace alone.</p>
<p><b>参见</b><a href="qbytearray.html#simplified">simplified</a>().</p>
<!-- @@@trimmed -->
<!-- $$$truncate[overload1]$$$truncateint -->
<h3 class="fn" id="truncate"><a name="truncate"></a><span class="type">void</span> QByteArray::<span class="name">truncate</span>(<span class="type">int</span> <i>pos</i>)</h3>
<p>Truncates the byte array at index position <i>pos</i>.</p>
<p>If <i>pos</i> is beyond the end of the array, nothing happens.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Stockholm&quot;</span>);
  ba<span class="operator">.</span>truncate(<span class="number">5</span>);             <span class="comment">// ba == &quot;Stock&quot;</span>

</pre>
<p><b>参见</b><a href="qbytearray.html#chop">chop</a>(), <a href="qbytearray.html#resize">resize</a>(), and <a href="qbytearray.html#left">left</a>().</p>
<!-- @@@truncate -->
<!-- $$$operator!=[overload1]$$$operator!=constQString& -->
<h3 class="fn" id="operator-not-eq"><a name="operator-not-eq"></a><span class="type">bool</span> QByteArray::<span class="name">operator!=</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is not equal to string <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator!= -->
<!-- $$$operator+=[overload1]$$$operator+=constQByteArray& -->
<h3 class="fn" id="operator-2b-eq"><a name="operator-2b-eq"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Appends the byte array <i>ba</i> onto the end of this byte array and returns a reference to this byte array.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;free&quot;</span>);
  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;dom&quot;</span>);
  x <span class="operator">+</span><span class="operator">=</span> y;
  <span class="comment">// x == &quot;freedom&quot;</span>

</pre>
<p>Note: <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html">implicitly shared</a> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <i>ba</i>. In this case, no copying of data is done, taking <a href="containers.html#constant-time">constant time</a>. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>This operation typically does not suffer from allocation overhead, because <a href="qbytearray.html">QByteArray</a> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</p>
<p><b>参见</b><a href="qbytearray.html#append">append</a>() and <a href="qbytearray.html#prepend">prepend</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constchar* -->
<h3 class="fn" id="operator-2b-eq-1"><a name="operator-2b-eq-1"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the string <i>str</i> onto the end of this byte array and returns a reference to this byte array.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=char -->
<h3 class="fn" id="operator-2b-eq-2"><a name="operator-2b-eq-2"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the character <i>ch</i> onto the end of this byte array and returns a reference to this byte array.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constQString& -->
<h3 class="fn" id="operator-2b-eq-3"><a name="operator-2b-eq-3"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the string <i>str</i> onto the end of this byte array and returns a reference to this byte array. The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>You can disable this function by defining <code>QT_NO_CAST_TO_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#toUtf8">QString::toUtf8</a>() (or <a href="qstring.html#toLatin1">QString::toLatin1</a>() or <a href="qstring.html#toLocal8Bit">QString::toLocal8Bit</a>()) explicitly if you want to convert the data to <code>const char *</code>.</p>
<!-- @@@operator+= -->
<!-- $$$operator<[overload1]$$$operator<constQString& -->
<h3 class="fn" id="operator-lt"><a name="operator-lt"></a><span class="type">bool</span> QByteArray::<span class="name">operator&lt;</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is lexically less than string <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator< -->
<!-- $$$operator<=[overload1]$$$operator<=constQString& -->
<h3 class="fn" id="operator-lt-eq"><a name="operator-lt-eq"></a><span class="type">bool</span> QByteArray::<span class="name">operator&lt;=</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is lexically less than or equal to string <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator<= -->
<!-- $$$operator=[overload1]$$$operator=constQByteArray& -->
<h3 class="fn" id="operator-eq"><a name="operator-eq"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>Assigns <i>other</i> to this byte array and returns a reference to this byte array.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=constchar* -->
<h3 class="fn" id="operator-eq-1"><a name="operator-eq-1"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator=</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Assigns <i>str</i> to this byte array.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QByteArray&& -->
<h3 class="fn" id="operator-eq-2"><a name="operator-eq-2"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator=</span>(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i>other</i> to this <a href="qbytearray.html">QByteArray</a> instance.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQString& -->
<h3 class="fn" id="operator-eq-eq"><a name="operator-eq-eq"></a><span class="type">bool</span> QByteArray::<span class="name">operator==</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is equal to string <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator== -->
<!-- $$$operator>[overload1]$$$operator>constQString& -->
<h3 class="fn" id="operator-gt"><a name="operator-gt"></a><span class="type">bool</span> QByteArray::<span class="name">operator&gt;</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is lexically greater than string <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator> -->
<!-- $$$operator>=[overload1]$$$operator>=constQString& -->
<h3 class="fn" id="operator-gt-eq"><a name="operator-gt-eq"></a><span class="type">bool</span> QByteArray::<span class="name">operator&gt;=</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is greater than or equal to string <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="qstring.html#toUtf8">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator>= -->
<!-- $$$operator[][overload1]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d"><a name="operator-5b-5d"></a><span class="type">QByteRef</span> QByteArray::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>)</h3>
<p>Returns the byte at index position <i>i</i> as a modifiable reference.</p>
<p>If an assignment is made beyond the end of the byte array, the array is extended with <a href="qbytearray.html#resize">resize</a>() before the assignment takes place.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba;
  <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">10</span>; <span class="operator">+</span><span class="operator">+</span>i)
      ba<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> <span class="char">'A'</span> <span class="operator">+</span> i;
  <span class="comment">// ba == &quot;ABCDEFGHIJ&quot;</span>

</pre>
<p>The return value is of type QByteRef, a helper class for <a href="qbytearray.html">QByteArray</a>. When you get an object of type QByteRef, you can use it as if it were a char &amp;. If you assign to it, the assignment will apply to the character in the <a href="qbytearray.html">QByteArray</a> from which you got the reference.</p>
<p><b>参见</b><a href="qbytearray.html#at">at</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]uint -->
<h3 class="fn" id="operator-5b-5d-1"><a name="operator-5b-5d-1"></a><span class="type">char</span> QByteArray::<span class="name">operator[]</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>i</i>) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d-2"><a name="operator-5b-5d-2"></a><span class="type">char</span> QByteArray::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Same as at(<i>i</i>).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]uint -->
<h3 class="fn" id="operator-5b-5d-3"><a name="operator-5b-5d-3"></a><span class="type">QByteRef</span> QByteArray::<span class="name">operator[]</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>i</i>)</h3>
<p>This is an overloaded function.</p>
<!-- @@@operator[] -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
<!-- $$$qChecksum[overload1]$$$qChecksumconstchar*uint -->
<h3 class="fn" id="qChecksum"><a name="qChecksum"></a><span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <span class="name">qChecksum</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>len</i>)</h3>
<p>Returns the CRC-16 checksum of the first <i>len</i> bytes of <i>data</i>.</p>
<p>The checksum is independent of the byte order (endianness) and will be calculated accorded to the algorithm published in ISO 3309 (<a href="qt.html#ChecksumType-enum">Qt::ChecksumIso3309</a>).</p>
<p><b>Note: </b>This function is a 16-bit cache conserving (16 entry table) implementation of the CRC-16-CCITT algorithm.</p><!-- @@@qChecksum -->
<!-- $$$qChecksum$$$qChecksumconstchar*uintQt::ChecksumType -->
<h3 class="fn" id="qChecksum-1"><a name="qChecksum-1"></a><span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <span class="name">qChecksum</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>len</i>, <span class="type">Qt::ChecksumType</span> <i>standard</i>)</h3>
<p>Returns the CRC-16 checksum of the first <i>len</i> bytes of <i>data</i>.</p>
<p>The checksum is independent of the byte order (endianness) and will be calculated accorded to the algorithm published in <i>standard</i>.</p>
<p><b>Note: </b>This function is a 16-bit cache conserving (16 entry table) implementation of the CRC-16-CCITT algorithm.</p><p>这个函数是在Qt 5.9版本中新增引入的。</p>
<!-- @@@qChecksum -->
<!-- $$$qCompress[overload1]$$$qCompressconstuchar*intint -->
<h3 class="fn" id="qCompress"><a name="qCompress"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">qCompress</span>(const <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>nbytes</i>, <span class="type">int</span> <i>compressionLevel</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Compresses the first <i>nbytes</i> of <i>data</i> at compression level <i>compressionLevel</i> and returns the compressed data in a new byte array.</p>
<!-- @@@qCompress -->
<!-- $$$qCompress[overload1]$$$qCompressconstQByteArray&int -->
<h3 class="fn" id="qCompress"><a name="qCompress"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">qCompress</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>data</i>, <span class="type">int</span> <i>compressionLevel</i> = -1)</h3>
<p>Compresses the <i>data</i> byte array and returns the compressed data in a new byte array.</p>
<p>The <i>compressionLevel</i> parameter specifies how much compression should be used. Valid values are between 0 and 9, with 9 corresponding to the greatest compression (i.e&#x2e; smaller compressed data) at the cost of using a slower algorithm. Smaller values (8, 7, ..&#x2e;, 1) provide successively less compression at slightly faster speeds. The value 0 corresponds to no compression at all. The default value is -1, which specifies zlib's default compression.</p>
<p><b>参见</b><a href="qbytearray.html#qUncompress">qUncompress</a>().</p>
<!-- @@@qCompress -->
<!-- $$$qUncompress[overload1]$$$qUncompressconstuchar*int -->
<h3 class="fn" id="qUncompress"><a name="qUncompress"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">qUncompress</span>(const <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>nbytes</i>)</h3>
<p>This is an overloaded function.</p>
<p>Uncompresses the first <i>nbytes</i> of <i>data</i> and returns a new byte array with the uncompressed data.</p>
<!-- @@@qUncompress -->
<!-- $$$qUncompress[overload1]$$$qUncompressconstQByteArray& -->
<h3 class="fn" id="qUncompress"><a name="qUncompress"></a><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">qUncompress</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Uncompresses the <i>data</i> byte array and returns a new byte array with the uncompressed data.</p>
<p>Returns an empty <a href="qbytearray.html">QByteArray</a> if the input data was corrupt.</p>
<p>This function will uncompress data compressed with <a href="qbytearray.html#qCompress">qCompress</a>() from this and any earlier Qt version, back to Qt 3.1 when this feature was added.</p>
<p><b>Note:</b> If you want to use this function to uncompress external data that was compressed using zlib, you first need to prepend a four byte header to the byte array containing the data. The header must contain the expected length (in bytes) of the uncompressed data, expressed as an unsigned, big-endian, 32-bit integer.</p>
<p><b>参见</b><a href="qbytearray.html#qCompress">qCompress</a>().</p>
<!-- @@@qUncompress -->
<!-- $$$qsnprintf[overload1]$$$qsnprintfchar*size_tconstchar*... -->
<h3 class="fn" id="qsnprintf"><a name="qsnprintf"></a><span class="type">int</span> <span class="name">qsnprintf</span>(<span class="type">char</span> *<i>str</i>, <span class="type">size_t</span> <i>n</i>, const <span class="type">char</span> *<i>fmt</i>, <i>...</i>)</h3>
<a name="bytearray-qsnprintf"></a><p>A portable snprintf() function, calls qvsnprintf.</p>
<p><i>fmt</i> is the <code>printf()</code> format string. The result is put into <i>str</i>, which is a buffer of at least <i>n</i> bytes.</p>
<p><b>Warning:</b> Call this function only when you know what you are doing since it shows different behavior on certain platforms. Use <a href="qstring.html#asprintf">QString::asprintf</a>() to format a string instead.</p>
<p><b>参见</b><a href="qbytearray.html#qvsnprintf">qvsnprintf</a>() and <a href="qstring.html#asprintf">QString::asprintf</a>().</p>
<!-- @@@qsnprintf -->
<!-- $$$qstrcmp[overload1]$$$qstrcmpconstchar*constchar* -->
<h3 class="fn" id="qstrcmp"><a name="qstrcmp"></a><span class="type">int</span> <span class="name">qstrcmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>)</h3>
<p>A safe <code>strcmp()</code> function.</p>
<p>Compares <i>str1</i> and <i>str2</i>. Returns a negative value if <i>str1</i> is less than <i>str2</i>, 0 if <i>str1</i> is equal to <i>str2</i> or a positive value if <i>str1</i> is greater than <i>str2</i>.</p>
<p>Special case 1: Returns 0 if <i>str1</i> and <i>str2</i> are both nullptr.</p>
<p>Special case 2: Returns an arbitrary non-zero value if <i>str1</i> is nullptr or <i>str2</i> is nullptr (but not both).</p>
<p><b>参见</b><a href="qbytearray.html#qstrncmp">qstrncmp</a>(), <a href="qbytearray.html#qstricmp">qstricmp</a>(), <a href="qbytearray.html#qstrnicmp">qstrnicmp</a>(), <a href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</a>, and <a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@qstrcmp -->
<!-- $$$qstrcpy[overload1]$$$qstrcpychar*constchar* -->
<h3 class="fn" id="qstrcpy"><a name="qstrcpy"></a><span class="type">char</span> *<span class="name">qstrcpy</span>(<span class="type">char</span> *<i>dst</i>, const <span class="type">char</span> *<i>src</i>)</h3>
<p>Copies all the characters up to and including the '\0' from <i>src</i> into <i>dst</i> and returns a pointer to <i>dst</i>. If <i>src</i> is nullptr, it immediately returns nullptr.</p>
<p>This function assumes that <i>dst</i> is large enough to hold the contents of <i>src</i>.</p>
<p><b>Note: </b>If <i>dst</i> and <i>src</i> overlap, the behavior is undefined.</p><p><b>参见</b><a href="qbytearray.html#qstrncpy">qstrncpy</a>().</p>
<!-- @@@qstrcpy -->
<!-- $$$qstrdup[overload1]$$$qstrdupconstchar* -->
<h3 class="fn" id="qstrdup"><a name="qstrdup"></a><span class="type">char</span> *<span class="name">qstrdup</span>(const <span class="type">char</span> *<i>src</i>)</h3>
<p>Returns a duplicate string.</p>
<p>Allocates space for a copy of <i>src</i>, copies it, and returns a pointer to the copy. If <i>src</i> is nullptr, it immediately returns nullptr.</p>
<p>Ownership is passed to the caller, so the returned string must be deleted using <code>delete[]</code>.</p>
<!-- @@@qstrdup -->
<!-- $$$qstricmp[overload1]$$$qstricmpconstchar*constchar* -->
<h3 class="fn" id="qstricmp"><a name="qstricmp"></a><span class="type">int</span> <span class="name">qstricmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>)</h3>
<p>A safe <code>stricmp()</code> function.</p>
<p>Compares <i>str1</i> and <i>str2</i> ignoring the case of the characters. The encoding of the strings is assumed to be Latin-1.</p>
<p>Returns a negative value if <i>str1</i> is less than <i>str2</i>, 0 if <i>str1</i> is equal to <i>str2</i> or a positive value if <i>str1</i> is greater than <i>str2</i>.</p>
<p>Special case 1: Returns 0 if <i>str1</i> and <i>str2</i> are both nullptr.</p>
<p>Special case 2: Returns a random non-zero value if <i>str1</i> is nullptr or <i>str2</i> is nullptr (but not both).</p>
<p><b>参见</b><a href="qbytearray.html#qstrcmp">qstrcmp</a>(), <a href="qbytearray.html#qstrncmp">qstrncmp</a>(), <a href="qbytearray.html#qstrnicmp">qstrnicmp</a>(), <a href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</a>, and <a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@qstricmp -->
<!-- $$$qstrlen[overload1]$$$qstrlenconstchar* -->
<h3 class="fn" id="qstrlen"><a name="qstrlen"></a><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qstrlen</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>A safe <code>strlen()</code> function.</p>
<p>Returns the number of characters that precede the terminating '\0', or 0 if <i>str</i> is nullptr.</p>
<p><b>参见</b><a href="qbytearray.html#qstrnlen">qstrnlen</a>().</p>
<!-- @@@qstrlen -->
<!-- $$$qstrncmp[overload1]$$$qstrncmpconstchar*constchar*uint -->
<h3 class="fn" id="qstrncmp"><a name="qstrncmp"></a><span class="type">int</span> <span class="name">qstrncmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>, <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>len</i>)</h3>
<p>A safe <code>strncmp()</code> function.</p>
<p>Compares at most <i>len</i> bytes of <i>str1</i> and <i>str2</i>.</p>
<p>Returns a negative value if <i>str1</i> is less than <i>str2</i>, 0 if <i>str1</i> is equal to <i>str2</i> or a positive value if <i>str1</i> is greater than <i>str2</i>.</p>
<p>Special case 1: Returns 0 if <i>str1</i> and <i>str2</i> are both nullptr.</p>
<p>Special case 2: Returns a random non-zero value if <i>str1</i> is nullptr or <i>str2</i> is nullptr (but not both).</p>
<p><b>参见</b><a href="qbytearray.html#qstrcmp">qstrcmp</a>(), <a href="qbytearray.html#qstricmp">qstricmp</a>(), <a href="qbytearray.html#qstrnicmp">qstrnicmp</a>(), <a href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</a>, and <a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@qstrncmp -->
<!-- $$$qstrncpy[overload1]$$$qstrncpychar*constchar*uint -->
<h3 class="fn" id="qstrncpy"><a name="qstrncpy"></a><span class="type">char</span> *<span class="name">qstrncpy</span>(<span class="type">char</span> *<i>dst</i>, const <span class="type">char</span> *<i>src</i>, <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>len</i>)</h3>
<p>A safe <code>strncpy()</code> function.</p>
<p>Copies at most <i>len</i> bytes from <i>src</i> (stopping at <i>len</i> or the terminating '\0' whichever comes first) into <i>dst</i> and returns a pointer to <i>dst</i>. Guarantees that <i>dst</i> is '\0'-terminated. If <i>src</i> or <i>dst</i> is nullptr, returns nullptr immediately.</p>
<p>This function assumes that <i>dst</i> is at least <i>len</i> characters long.</p>
<p><b>Note: </b>If <i>dst</i> and <i>src</i> overlap, the behavior is undefined.</p><p><b>Note: </b>When compiling with Visual C++ compiler version 14.00 (Visual C++ 2005) or later, internally the function strncpy_s will be used.</p><p><b>参见</b><a href="qbytearray.html#qstrcpy">qstrcpy</a>().</p>
<!-- @@@qstrncpy -->
<!-- $$$qstrnicmp[overload1]$$$qstrnicmpconstchar*constchar*uint -->
<h3 class="fn" id="qstrnicmp"><a name="qstrnicmp"></a><span class="type">int</span> <span class="name">qstrnicmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>, <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>len</i>)</h3>
<p>A safe <code>strnicmp()</code> function.</p>
<p>Compares at most <i>len</i> bytes of <i>str1</i> and <i>str2</i> ignoring the case of the characters. The encoding of the strings is assumed to be Latin-1.</p>
<p>Returns a negative value if <i>str1</i> is less than <i>str2</i>, 0 if <i>str1</i> is equal to <i>str2</i> or a positive value if <i>str1</i> is greater than <i>str2</i>.</p>
<p>Special case 1: Returns 0 if <i>str1</i> and <i>str2</i> are both nullptr.</p>
<p>Special case 2: Returns a random non-zero value if <i>str1</i> is nullptr or <i>str2</i> is nullptr (but not both).</p>
<p><b>参见</b><a href="qbytearray.html#qstrcmp">qstrcmp</a>(), <a href="qbytearray.html#qstrncmp">qstrncmp</a>(), <a href="qbytearray.html#qstricmp">qstricmp</a>(), <a href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</a>, and <a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@qstrnicmp -->
<!-- $$$qstrnlen[overload1]$$$qstrnlenconstchar*uint -->
<h3 class="fn" id="qstrnlen"><a name="qstrnlen"></a><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qstrnlen</span>(const <span class="type">char</span> *<i>str</i>, <span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>maxlen</i>)</h3>
<p>A safe <code>strnlen()</code> function.</p>
<p>Returns the number of characters that precede the terminating '\0', but at most <i>maxlen</i>. If <i>str</i> is nullptr, returns 0.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b>参见</b><a href="qbytearray.html#qstrlen">qstrlen</a>().</p>
<!-- @@@qstrnlen -->
<!-- $$$qvsnprintf[overload1]$$$qvsnprintfchar*size_tconstchar*va_list -->
<h3 class="fn" id="qvsnprintf"><a name="qvsnprintf"></a><span class="type">int</span> <span class="name">qvsnprintf</span>(<span class="type">char</span> *<i>str</i>, <span class="type">size_t</span> <i>n</i>, const <span class="type">char</span> *<i>fmt</i>, <span class="type">va_list</span> <i>ap</i>)</h3>
<p>A portable <code>vsnprintf()</code> function. Will call <code>::vsnprintf()</code>, <code>::_vsnprintf()</code>, or <code>::vsnprintf_s</code> depending on the system, or fall back to an internal version.</p>
<p><i>fmt</i> is the <code>printf()</code> format string. The result is put into <i>str</i>, which is a buffer of at least <i>n</i> bytes.</p>
<p>The caller is responsible to call <code>va_end()</code> on <i>ap</i>.</p>
<p><b>Warning:</b> Since vsnprintf() shows different behavior on certain platforms, you should not rely on the return value or on the fact that you will always get a 0 terminated string back.</p>
<p>Ideally, you should never call this function but use <a href="qstring.html#asprintf">QString::asprintf</a>() instead.</p>
<p><b>参见</b><a href="qbytearray.html#qsnprintf">qsnprintf</a>() and <a href="qstring.html#asprintf">QString::asprintf</a>().</p>
<!-- @@@qvsnprintf -->
<!-- $$$operator!=$$$operator!=constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-not-eq-1"><a name="operator-not-eq-1"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is not equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQByteArray&constchar* -->
<h3 class="fn" id="operator-not-eq-2"><a name="operator-not-eq-2"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is not equal to string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constchar*constQByteArray& -->
<h3 class="fn" id="operator-not-eq-3"><a name="operator-not-eq-3"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if string <i>a1</i> is not equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator+[overload1]$$$operator+constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-2b"><a name="operator-2b"></a>const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>Returns a byte array that is the result of concatenating byte array <i>a1</i> and byte array <i>a2</i>.</p>
<p><b>参见</b><a href="qbytearray.html#operator-2b-eq">QByteArray::operator+=</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constQByteArray&constchar* -->
<h3 class="fn" id="operator-2b-1"><a name="operator-2b-1"></a>const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating byte array <i>a1</i> and string <i>a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constQByteArray&char -->
<h3 class="fn" id="operator-2b-2"><a name="operator-2b-2"></a>const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, <span class="type">char</span> <i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating byte array <i>a1</i> and character <i>a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constchar*constQByteArray& -->
<h3 class="fn" id="operator-2b-3"><a name="operator-2b-3"></a>const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating string <i>a1</i> and byte array <i>a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+charconstQByteArray& -->
<h3 class="fn" id="operator-2b-4"><a name="operator-2b-4"></a>const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(<span class="type">char</span> <i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating character <i>a1</i> and byte array <i>a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator<$$$operator<constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-lt-1"><a name="operator-lt-1"></a><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically less than byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constQByteArray&constchar* -->
<h3 class="fn" id="operator-lt-2"><a name="operator-lt-2"></a><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically less than string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constchar*constQByteArray& -->
<h3 class="fn" id="operator-lt-3"><a name="operator-lt-3"></a><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if string <i>a1</i> is lexically less than byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator<<[overload1]$$$operator<<QDataStream&constQByteArray& -->
<h3 class="fn" id="operator-lt-lt"><a name="operator-lt-lt"></a><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Writes byte array <i>ba</i> to the stream <i>out</i> and returns a reference to the stream.</p>
<p><b>参见</b><a href="datastreamformat.html">序列化Qt数据类型</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator<=$$$operator<=constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-lt-eq-1"><a name="operator-lt-eq-1"></a><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically less than or equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constQByteArray&constchar* -->
<h3 class="fn" id="operator-lt-eq-2"><a name="operator-lt-eq-2"></a><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically less than or equal to string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constchar*constQByteArray& -->
<h3 class="fn" id="operator-lt-eq-3"><a name="operator-lt-eq-3"></a><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if string <i>a1</i> is lexically less than or equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator==$$$operator==constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-eq-eq-1"><a name="operator-eq-eq-1"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQByteArray&constchar* -->
<h3 class="fn" id="operator-eq-eq-2"><a name="operator-eq-eq-2"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is equal to string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constchar*constQByteArray& -->
<h3 class="fn" id="operator-eq-eq-3"><a name="operator-eq-eq-3"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if string <i>a1</i> is equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator>$$$operator>constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-gt-1"><a name="operator-gt-1"></a><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically greater than byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constQByteArray&constchar* -->
<h3 class="fn" id="operator-gt-2"><a name="operator-gt-2"></a><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically greater than string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constchar*constQByteArray& -->
<h3 class="fn" id="operator-gt-3"><a name="operator-gt-3"></a><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if string <i>a1</i> is lexically greater than byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator> -->
<!-- $$$operator>=$$$operator>=constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-gt-eq-1"><a name="operator-gt-eq-1"></a><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically greater than or equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constQByteArray&constchar* -->
<h3 class="fn" id="operator-gt-eq-2"><a name="operator-gt-eq-2"></a><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically greater than or equal to string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constchar*constQByteArray& -->
<h3 class="fn" id="operator-gt-eq-3"><a name="operator-gt-eq-3"></a><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if string <i>a1</i> is lexically greater than or equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>参见</b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator>= -->
<!-- $$$operator>>[overload1]$$$operator>>QDataStream&QByteArray& -->
<h3 class="fn" id="operator-gt-gt"><a name="operator-gt-gt"></a><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Reads a byte array into <i>ba</i> from the stream <i>in</i> and returns a reference to the stream.</p>
<p><b>参见</b><a href="datastreamformat.html">序列化Qt数据类型</a>.</p>
<!-- @@@operator>> -->
</div>
<div class="macros">
<h2>宏定义文档</h2>
<!-- $$$QByteArrayLiteral[overload1]$$$QByteArrayLiteral -->
<h3 class="fn" id="QByteArrayLiteral"><a name="QByteArrayLiteral"></a><span class="name">QByteArrayLiteral</span>(<i>ba</i>)</h3>
<p>The macro generates the data for a <a href="qbytearray.html">QByteArray</a> out of the string literal <i>ba</i> at compile time. Creating a <a href="qbytearray.html">QByteArray</a> from it is free in this case, and the generated byte array data is stored in the read-only segment of the compiled object file.</p>
<p>For instance:</p>
<pre class="cpp">

  <span class="type"><a href="qbytearray.html">QByteArray</a></span> ba <span class="operator">=</span> <span class="type">QByteArrayLiteral</span>(<span class="string">&quot;byte array contents&quot;</span>);

</pre>
<p>Using QByteArrayLiteral instead of a double quoted plain C++ string literal can significantly speed up creation of <a href="qbytearray.html">QByteArray</a> instances from data known at compile time.</p>
<p><b>参见</b><a href="qstring.html#QStringLiteral">QStringLiteral</a>.</p>
<!-- @@@QByteArrayLiteral -->
<!-- $$$QT_NO_CAST_FROM_BYTEARRAY[overload1]$$$QT_NO_CAST_FROM_BYTEARRAY -->
<h3 class="fn" id="QT_NO_CAST_FROM_BYTEARRAY"><a name="QT_NO_CAST_FROM_BYTEARRAY"></a><span class="name">QT_NO_CAST_FROM_BYTEARRAY</span></h3>
<p>Disables automatic conversions from <a href="qbytearray.html">QByteArray</a> to const char * or const void *.</p>
<p><b>参见</b><a href="qstring.html#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a> and <a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a>.</p>
<!-- @@@QT_NO_CAST_FROM_BYTEARRAY -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
