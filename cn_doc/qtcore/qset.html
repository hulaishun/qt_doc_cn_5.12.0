<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qset.qdoc -->
  <title>QSet Class | Qt核心模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QSet</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#related-non-members">相关非成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QSet Class</h1>
<!-- $$$QSet-brief -->
<p>The <a href="qset.html">QSet</a> class is a template class that provides a hash-table-based set. <a href="#details">更多详情...</a></p>
<!-- @@@QSet -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QSet&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr></table></div><ul>
<li><a href="qset-members.html">所有成员清单，包括继承而来的成员</a></li>
</ul>
<p><b>注意：</b> 此类中的所有函数都是 <a href="../qtdoc/threads-reentrancy.html">可重入的。</a></p>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qset-const-iterator.html">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qset-iterator.html">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#ConstIterator-typedef">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#Iterator-typedef">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#const_pointer-typedef">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#const_reference-typedef">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#const_reverse_iterator-typedef">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#difference_type-typedef">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#key_type-typedef">key_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#pointer-typedef">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#reference-typedef">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#reverse_iterator-typedef">reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#size_type-typedef">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#value_type-typedef">value_type</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#QSet">QSet</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#QSet-1">QSet</a></b>(std::initializer_list&lt;T&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#begin">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#begin-1">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qset.html#capacity">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#cbegin">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#cend">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#clear">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#constBegin">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#constEnd">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#constFind">constFind</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#contains">contains</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#contains-1">contains</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qset.html#count">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#crbegin">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#crend">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#empty">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#end">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#end-1">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#erase">erase</a></b>(QSet::const_iterator <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#erase-1">erase</a></b>(QSet::iterator <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#find">find</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#find-1">find</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#insert">insert</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#intersect">intersect</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#intersects">intersects</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#isEmpty">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#rbegin">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#rbegin-1">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#remove">remove</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#rend">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#rend-1">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#reserve">reserve</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qset.html#size">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#squeeze">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#subtract">subtract</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#swap">swap</a></b>(QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#toList">toList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#unite">unite</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#values">values</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-not-eq">operator!=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and">operator&amp;</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and-eq">operator&amp;=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and-eq-1">operator&amp;=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b">operator+</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b-eq">operator+=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b-eq-1">operator+=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-">operator-</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator--eq">operator-=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator--eq-1">operator-=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-lt-lt">operator&lt;&lt;</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-eq-eq">operator==</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c">operator|</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c-eq">operator|=</a></b>(const QSet&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c-eq-1">operator|=</a></b>(const T &amp;<i>value</i>)</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#fromList">fromList</a></b>(const QList&lt;T&gt; &amp;<i>list</i>)</td></tr>
</table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">相关非成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-lt-lt-1">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QSet&lt;T&gt; &amp;<i>set</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-gt-gt">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QSet&lt;T&gt; &amp;<i>set</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QSet-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qset.html">QSet</a> class is a template class that provides a hash-table-based set.</p>
<p><a href="qset.html">QSet</a>&lt;T&gt; is one of Qt's generic <a href="containers.html">容器类</a>. It stores values in an unspecified order and provides very fast lookup of the values. Internally, <a href="qset.html">QSet</a>&lt;T&gt; is implemented as a <a href="qhash.html#qhash">QHash</a>.</p>
<p>Here's an example <a href="qset.html">QSet</a> with <a href="qstring.html">QString</a> values:</p>
<pre class="cpp">

  <span class="type"><a href="qset.html#QSet">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> set;

</pre>
<p>To insert a value into the set, use <a href="qset.html#insert">insert</a>():</p>
<pre class="cpp">

  set<span class="operator">.</span>insert(<span class="string">&quot;one&quot;</span>);
  set<span class="operator">.</span>insert(<span class="string">&quot;three&quot;</span>);
  set<span class="operator">.</span>insert(<span class="string">&quot;seven&quot;</span>);

</pre>
<p>Another way to insert items into the set is to use operator&lt;&lt;():</p>
<pre class="cpp">

  set <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;twelve&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;fifteen&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;nineteen&quot;</span>;

</pre>
<p>To test whether an item belongs to the set or not, use <a href="qset.html#contains">contains</a>():</p>
<pre class="cpp">

  <span class="keyword">if</span> (<span class="operator">!</span>set<span class="operator">.</span>contains(<span class="string">&quot;ninety-nine&quot;</span>))
      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

</pre>
<p>If you want to navigate through all the values stored in a <a href="qset.html">QSet</a>, you can use an iterator. <a href="qset.html">QSet</a> supports both <a href="containers.html#java-style-iterators">Java-style iterators</a> (<a href="qsetiterator.html">QSetIterator</a> 和 <a href="qmutablesetiterator.html">QMutableSetIterator</a>) and <a href="containers.html#stl-style-iterators">STL-style iterators</a> (<a href="qset-iterator.html">QSet::iterator</a> 和 <a href="qset-const-iterator.html">QSet::const_iterator</a>). Here's how to iterate over a <a href="qset.html">QSet</a>&lt;<a href="../qtwidgets/qwidget.html">QWidget</a> *&gt; using a Java-style iterator:</p>
<pre class="cpp">

  <span class="type"><a href="qsetiterator.html">QSetIterator</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qwidget.html">QWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span> i(set);
  <span class="keyword">while</span> (i<span class="operator">.</span>hasNext())
      <a href="qtglobal.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>next();

</pre>
<p>Here's the same code, but using an STL-style iterator:</p>
<pre class="cpp">

  <span class="type"><a href="qset.html#QSet">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qwidget.html">QWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span><span class="operator">::</span>const_iterator i <span class="operator">=</span> set<span class="operator">.</span>constBegin();
  <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> set<span class="operator">.</span>constEnd()) {
      <a href="qtglobal.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="operator">*</span>i;
      <span class="operator">+</span><span class="operator">+</span>i;
  }

</pre>
<p><a href="qset.html">QSet</a> is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <a href="qmap.html">QMap</a>.</p>
<p>To navigate through a <a href="qset.html">QSet</a>, you can also use <a href="containers.html#foreach">foreach</a>:</p>
<pre class="cpp">

  <span class="type"><a href="qset.html#QSet">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> set;
  <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
  foreach (<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>value<span class="operator">,</span> set)
      <a href="qtglobal.html#qDebug">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> value;

</pre>
<p>Items can be removed from the set using <a href="qset.html#remove">remove</a>(). There is also a <a href="qset.html#clear">clear</a>() function that removes all items.</p>
<p><a href="qset.html">QSet</a>'s value data type must be an <a href="containers.html#assignable-data-type">assignable data type</a>. You cannot, for example, store a <a href="../qtwidgets/qwidget.html">QWidget</a> as a value; instead, store a <a href="../qtwidgets/qwidget.html">QWidget</a> *. In addition, the type must provide <code>operator==()</code>, and there must also be a global <a href="qstringview.html#qHash">qHash</a>() function that returns a hash value for an argument of the key's type. See the <a href="qhash.html#qhash">QHash</a> documentation for a list of types supported by <a href="qstringview.html#qHash">qHash</a>().</p>
<p>Internally, <a href="qset.html">QSet</a> uses a hash table to perform lookups. The hash table automatically grows and shrinks to provide fast lookups without wasting memory. You can still control the size of the hash table by calling <a href="qset.html#reserve">reserve</a>(), if you already know approximately how many elements the <a href="qset.html">QSet</a> will contain, but this isn't necessary to obtain good performance. You can also call <a href="qset.html#capacity">capacity</a>() to retrieve the hash table's size.</p>
</div>
<p><b> 参见 </b><a href="qsetiterator.html">QSetIterator</a>, <a href="qmutablesetiterator.html">QMutableSetIterator</a>, <a href="qhash.html#qhash">QHash</a>, 和 <a href="qmap.html">QMap</a>.</p>
<!-- @@@QSet -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" id="ConstIterator-typedef"><a name="ConstIterator-typedef"></a>typedef QSet::<span class="name">ConstIterator</span></h3>
<p>Qt风格的同义词<a href="qset-const-iterator.html">QSet::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn" id="Iterator-typedef"><a name="Iterator-typedef"></a>typedef QSet::<span class="name">Iterator</span></h3>
<p>Qt风格的同义词<a href="qset-iterator.html">QSet::iterator</a>.</p>
<p>这个类型重定义是在Qt 4.2版本中新增引入的。</p>
<!-- @@@Iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" id="const_pointer-typedef"><a name="const_pointer-typedef"></a>typedef QSet::<span class="name">const_pointer</span></h3>
<p>const T *的常量指针类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" id="const_reference-typedef"><a name="const_reference-typedef"></a>typedef QSet::<span class="name">const_reference</span></h3>
<p>const T &amp;的常量引用类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@const_reference -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" id="const_reverse_iterator-typedef"><a name="const_reverse_iterator-typedef"></a>typedef QSet::<span class="name">const_reverse_iterator</span></h3>
<p>The QSet::const_reverse_iterator typedef provides an STL-style const reverse iterator for <a href="qset.html">QSet</a>.</p>
<p>它只是简单类型重定义，方便使用于 <code>std::reverse_iterator&lt;QSet::const_iterator&gt;</code>.</p>
<p><b>警告：</b> Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="containers.html#implicit-sharing-iterator-problem">Implicit sharing iterator problem</a>.</p>
<p>这个类型定义是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#rbegin">QSet::rbegin</a>(), <a href="qset.html#rend">QSet::rend</a>(), <a href="qset.html#reverse_iterator-typedef">QSet::reverse_iterator</a>, 和 <a href="qset-const-iterator.html">QSet::const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" id="difference_type-typedef"><a name="difference_type-typedef"></a>typedef QSet::<span class="name">difference_type</span></h3>
<p>ptrdiff_t的常量类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@difference_type -->
<!-- $$$key_type -->
<h3 class="fn" id="key_type-typedef"><a name="key_type-typedef"></a>typedef QSet::<span class="name">key_type</span></h3>
<p>T的值类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@key_type -->
<!-- $$$pointer -->
<h3 class="fn" id="pointer-typedef"><a name="pointer-typedef"></a>typedef QSet::<span class="name">pointer</span></h3>
<p>T *的指针类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" id="reference-typedef"><a name="reference-typedef"></a>typedef QSet::<span class="name">reference</span></h3>
<p>T &amp;的引用类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@reference -->
<!-- $$$reverse_iterator -->
<h3 class="fn" id="reverse_iterator-typedef"><a name="reverse_iterator-typedef"></a>typedef QSet::<span class="name">reverse_iterator</span></h3>
<p>The QSet::reverse_iterator typedef provides an STL-style non-const reverse iterator for <a href="qset.html">QSet</a>.</p>
<p>它只是简单类型重定义，方便使用于 <code>std::reverse_iterator&lt;QSet::iterator&gt;</code>.</p>
<p><b>警告：</b> Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="containers.html#implicit-sharing-iterator-problem">Implicit sharing iterator problem</a>.</p>
<p>这个类型定义是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#rbegin">QSet::rbegin</a>(), <a href="qset.html#rend">QSet::rend</a>(), <a href="qset.html#const_reverse_iterator-typedef">QSet::const_reverse_iterator</a>, 和 <a href="qset-iterator.html">QSet::iterator</a>.</p>
<!-- @@@reverse_iterator -->
<!-- $$$size_type -->
<h3 class="fn" id="size_type-typedef"><a name="size_type-typedef"></a>typedef QSet::<span class="name">size_type</span></h3>
<p>int的类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" id="value_type-typedef"><a name="value_type-typedef"></a>typedef QSet::<span class="name">value_type</span></h3>
<p>T的值类型重定义，提供了对STL风格的兼容支持。</p>
<!-- @@@value_type -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="operator-7c"><a name="operator-7c"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; QSet::<span class="name">operator|</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3><h3 class="fn fngroupitem" id="operator-2b"><a name="operator-2b"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; QSet::<span class="name">operator+</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3></div>
<p>Returns a new <a href="qset.html">QSet</a> that is the union of this set and the <i>other</i> set.</p>
<p><b> 参见 </b><a href="qset.html#unite">unite</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), <a href="qset.html#operator-and">operator&amp;</a>(), 和 <a href="qset.html#operator-">operator-</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="operator-7c-eq"><a name="operator-7c-eq"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator|=</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3><h3 class="fn fngroupitem" id="operator-2b-eq"><a name="operator-2b-eq"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator+=</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3></div>
<p>Same as unite(<i>other</i>).</p>
<p><b> 参见 </b><a href="qset.html#operator-7c">operator|</a>(), <a href="qset.html#operator-and-eq">operator&amp;=</a>(), 和 <a href="qset.html#operator--eq">operator-=</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="operator-lt-lt"><a name="operator-lt-lt"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator&lt;&lt;</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3><h3 class="fn fngroupitem" id="operator-2b-eq-1"><a name="operator-2b-eq-1"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator+=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3><h3 class="fn fngroupitem" id="operator-7c-eq-1"><a name="operator-7c-eq-1"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator|=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3></div>
<p>Inserts a new item <i>value</i> and returns a reference to the set. If <i>value</i> already exists in the set, the set is left unchanged.</p>
<p><b> 参见 </b><a href="qset.html#insert">insert</a>().</p>
<!-- @@@ -->
<!-- $$$QSet[overload1]$$$QSet -->
<h3 class="fn" id="QSet"><a name="QSet"></a>QSet::<span class="name">QSet</span>()</h3>
<p>构造函数，创建一个空集合。</p>
<p><b> 参见 </b><a href="qset.html#clear">clear</a>().</p>
<!-- @@@QSet -->
<!-- $$$QSet$$$QSetstd::initializer_list<T> -->
<h3 class="fn" id="QSet-1"><a name="QSet-1"></a>QSet::<span class="name">QSet</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">T</span>&gt; <i>list</i>)</h3>
<p>Constructs a set with a copy of each of the elements in the initializer list <i>list</i>.</p>
<p>仅当程序以C++11模式编译下，此函数方可适用。<
<p>这个函数是在Qt 5.1版本中新增引入的。</p>
<!-- @@@QSet -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin"><a name="begin"></a><span class="type"><a href="qset-const-iterator.html">QSet::const_iterator</a></span> QSet::<span class="name">begin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> positioned at the first item in the set.</p>
<p><b> 参见 </b><a href="qset.html#constBegin">constBegin</a>() 和 <a href="qset.html#end">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1"><a name="begin-1"></a><span class="type"><a href="qset-iterator.html">QSet::iterator</a></span> QSet::<span class="name">begin</span>()</h3>
<p>这是一个重载函数。</p>
<p>Returns a non-const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> positioned at the first item in the set.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" id="capacity"><a name="capacity"></a><span class="type">int</span> QSet::<span class="name">capacity</span>() const</h3>
<p>Returns the number of buckets in the set's internal hash table.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qset.html">QSet</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the set, call <a href="qset.html#size">size</a>().</p>
<p><b> 参见 </b><a href="qset.html#reserve">reserve</a>() 和 <a href="qset.html#squeeze">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin"><a name="cbegin"></a><span class="type"><a href="qset-const-iterator.html">QSet::const_iterator</a></span> QSet::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> positioned at the first item in the set.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#begin">begin</a>() 和 <a href="qset.html#cend">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend"><a name="cend"></a><span class="type"><a href="qset-const-iterator.html">QSet::const_iterator</a></span> QSet::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> pointing to the imaginary item after the last item in the set.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#cbegin">cbegin</a>() 和 <a href="qset.html#end">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear"><a name="clear"></a><span class="type">void</span> QSet::<span class="name">clear</span>()</h3>
<p>删除集合中的所有元素。</p>
<p><b> 参见 </b><a href="qset.html#remove">remove</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin"><a name="constBegin"></a><span class="type"><a href="qset-const-iterator.html">QSet::const_iterator</a></span> QSet::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> positioned at the first item in the set.</p>
<p><b> 参见 </b><a href="qset.html#begin">begin</a>() 和 <a href="qset.html#constEnd">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd"><a name="constEnd"></a><span class="type"><a href="qset-const-iterator.html">QSet::const_iterator</a></span> QSet::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> pointing to the imaginary item after the last item in the set.</p>
<p><b> 参见 </b><a href="qset.html#constBegin">constBegin</a>() 和 <a href="qset.html#end">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind[overload1]$$$constFindconstT& -->
<h3 class="fn" id="constFind"><a name="constFind"></a><span class="type"><a href="qset-const-iterator.html">QSet::const_iterator</a></span> QSet::<span class="name">constFind</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns a const iterator positioned at the item <i>value</i> in the set. If the set contains no item <i>value</i>, the function returns <a href="qset.html#constEnd">constEnd</a>().</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#find">find</a>() 和 <a href="qset.html#contains">contains</a>().</p>
<!-- @@@constFind -->
<!-- $$$contains[overload1]$$$containsconstT& -->
<h3 class="fn" id="contains"><a name="contains"></a><span class="type">bool</span> QSet::<span class="name">contains</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns <code>true</code> if the set contains item <i>value</i>; otherwise returns false.</p>
<p><b> 参见 </b><a href="qset.html#insert">insert</a>(), <a href="qset.html#remove">remove</a>(), 和 <a href="qset.html#find">find</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQSet<T>& -->
<h3 class="fn" id="contains-1"><a name="contains-1"></a><span class="type">bool</span> QSet::<span class="name">contains</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code>true</code> if the set contains all items from the <i>other</i> set; 否则则返回 <code>false</code>。</p>
<p>这个函数是在Qt 4.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#insert">insert</a>(), <a href="qset.html#remove">remove</a>(), 和 <a href="qset.html#find">find</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$count -->
<h3 class="fn" id="count"><a name="count"></a><span class="type">int</span> QSet::<span class="name">count</span>() const</h3>
<p>等同于 <a href="qset.html#size">size</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" id="crbegin"><a name="crbegin"></a><span class="type"><a href="qset.html#const_reverse_iterator-typedef">QSet::const_reverse_iterator</a></span> QSet::<span class="name">crbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first item in the set, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#begin">begin</a>(), <a href="qset.html#rbegin">rbegin</a>(), 和 <a href="qset.html#rend">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" id="crend"><a name="crend"></a><span class="type"><a href="qset.html#const_reverse_iterator-typedef">QSet::const_reverse_iterator</a></span> QSet::<span class="name">crend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to one past the last item in the set, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#end">end</a>(), <a href="qset.html#rend">rend</a>(), 和 <a href="qset.html#rbegin">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" id="empty"><a name="empty"></a><span class="type">bool</span> QSet::<span class="name">empty</span>() const</h3>
<p>Returns <code>true</code> if the set is empty. This function is provided for STL compatibility. It 等同于 <a href="qset.html#isEmpty">isEmpty</a>().</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end"><a name="end"></a><span class="type"><a href="qset-const-iterator.html">QSet::const_iterator</a></span> QSet::<span class="name">end</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> positioned at the imaginary item after the last item in the set.</p>
<p><b> 参见 </b><a href="qset.html#constEnd">constEnd</a>() 和 <a href="qset.html#begin">begin</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1"><a name="end-1"></a><span class="type"><a href="qset-iterator.html">QSet::iterator</a></span> QSet::<span class="name">end</span>()</h3>
<p>这是一个重载函数。</p>
<p>Returns a non-const <a href="containers.html#stl-style-iterators">STL样式迭代器</a> pointing to the imaginary item after the last item in the set.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<!-- @@@end -->
<!-- $$$erase[overload1]$$$eraseQSet::const_iterator -->
<h3 class="fn" id="erase"><a name="erase"></a><span class="type"><a href="qset-iterator.html">QSet::iterator</a></span> QSet::<span class="name">erase</span>(<span class="type"><a href="qset-const-iterator.html">QSet::const_iterator</a></span> <i>pos</i>)</h3>
<p>Removes the item at the iterator position <i>pos</i> from the set, and returns an iterator positioned at the next item in the set.</p>
<p>Unlike <a href="qset.html#remove">remove</a>(), this function never causes <a href="qset.html">QSet</a> to rehash its internal data structure. This means that it can safely be called while iterating, and won't affect the order of items in the set.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#remove">remove</a>() 和 <a href="qset.html#find">find</a>().</p>
<!-- @@@erase -->
<!-- $$$erase$$$eraseQSet::iterator -->
<h3 class="fn" id="erase-1"><a name="erase-1"></a><span class="type"><a href="qset-iterator.html">QSet::iterator</a></span> QSet::<span class="name">erase</span>(<span class="type"><a href="qset-iterator.html">QSet::iterator</a></span> <i>pos</i>)</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<!-- @@@erase -->
<!-- $$$find[overload1]$$$findconstT& -->
<h3 class="fn" id="find"><a name="find"></a><span class="type"><a href="qset-const-iterator.html">QSet::const_iterator</a></span> QSet::<span class="name">find</span>(const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns a const iterator positioned at the item <i>value</i> in the set. If the set contains no item <i>value</i>, the function returns <a href="qset.html#constEnd">constEnd</a>().</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#constFind">constFind</a>() 和 <a href="qset.html#contains">contains</a>().</p>
<!-- @@@find -->
<!-- $$$find$$$findconstT& -->
<h3 class="fn" id="find-1"><a name="find-1"></a><span class="type"><a href="qset-iterator.html">QSet::iterator</a></span> QSet::<span class="name">find</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>这是一个重载函数。</p>
<p>Returns a non-const iterator positioned at the item <i>value</i> in the set. If the set contains no item <i>value</i>, the function returns <a href="qset.html#end">end</a>().</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<!-- @@@find -->
<!-- $$$fromList[overload1]$$$fromListconstQList<T>& -->
<h3 class="fn" id="fromList"><a name="fromList"></a><code>[静态函数] </code><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; QSet::<span class="name">fromList</span>(const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>list</i>)</h3>
<p>Returns a new <a href="qset.html">QSet</a> object containing the data contained in <i>list</i>. Since <a href="qset.html">QSet</a> doesn't allow duplicates, the resulting <a href="qset.html">QSet</a> might be smaller than the <i>list</i>, because <a href="qlist.html">QList</a> can contain duplicates.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Julia&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Mike&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Mike&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Julia&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Julia&quot;</span>;

  <span class="type"><a href="qset.html#QSet">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> set <span class="operator">=</span> <span class="type"><a href="qset.html#QSet">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span><span class="operator">::</span>fromList(list);
  set<span class="operator">.</span>contains(<span class="string">&quot;Julia&quot;</span>);  <span class="comment">// returns true</span>
  set<span class="operator">.</span>contains(<span class="string">&quot;Mike&quot;</span>);   <span class="comment">// returns true</span>
  set<span class="operator">.</span>size();             <span class="comment">// returns 2</span>

</pre>
<p><b> 参见 </b><a href="qset.html#toList">toList</a>() 和 <a href="qlist.html#toSet">QList::toSet</a>().</p>
<!-- @@@fromList -->
<!-- $$$insert[overload1]$$$insertconstT& -->
<h3 class="fn" id="insert"><a name="insert"></a><span class="type"><a href="qset-iterator.html">QSet::iterator</a></span> QSet::<span class="name">insert</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts item <i>value</i> into the set, if <i>value</i> isn't already in the set, and returns an iterator pointing at the inserted item.</p>
<p><b> 参见 </b><a href="qset.html#operator-lt-lt">operator&lt;&lt;</a>(), <a href="qset.html#remove">remove</a>(), 和 <a href="qset.html#contains">contains</a>().</p>
<!-- @@@insert -->
<!-- $$$intersect[overload1]$$$intersectconstQSet<T>& -->
<h3 class="fn" id="intersect"><a name="intersect"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">intersect</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Removes all items from this set that are not contained in the <i>other</i> set. A reference to this set is returned.</p>
<p><b> 参见 </b><a href="qset.html#intersects">intersects</a>(), <a href="qset.html#operator-and-eq">operator&amp;=</a>(), <a href="qset.html#unite">unite</a>(), 和 <a href="qset.html#subtract">subtract</a>().</p>
<!-- @@@intersect -->
<!-- $$$intersects[overload1]$$$intersectsconstQSet<T>& -->
<h3 class="fn" id="intersects"><a name="intersects"></a><span class="type">bool</span> QSet::<span class="name">intersects</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code>true</code> if this set has at least one item in common with <i>other</i>.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#contains">contains</a>() 和 <a href="qset.html#intersect">intersect</a>().</p>
<!-- @@@intersects -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty"><a name="isEmpty"></a><span class="type">bool</span> QSet::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code>true</code> if the set contains no elements; otherwise returns false.</p>
<p><b> 参见 </b><a href="qset.html#size">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" id="rbegin"><a name="rbegin"></a><span class="type"><a href="qset.html#reverse_iterator-typedef">QSet::reverse_iterator</a></span> QSet::<span class="name">rbegin</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first item in the set, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#begin">begin</a>(), <a href="qset.html#crbegin">crbegin</a>(), 和 <a href="qset.html#rend">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" id="rbegin-1"><a name="rbegin-1"></a><span class="type"><a href="qset.html#const_reverse_iterator-typedef">QSet::const_reverse_iterator</a></span> QSet::<span class="name">rbegin</span>() const</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@rbegin -->
<!-- $$$remove[overload1]$$$removeconstT& -->
<h3 class="fn" id="remove"><a name="remove"></a><span class="type">bool</span> QSet::<span class="name">remove</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Removes any occurrence of item <i>value</i> from the set. Returns true if an item was actually removed; 否则则返回 <code>false</code>。</p>
<p><b> 参见 </b><a href="qset.html#contains">contains</a>() 和 <a href="qset.html#insert">insert</a>().</p>
<!-- @@@remove -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" id="rend"><a name="rend"></a><span class="type"><a href="qset.html#reverse_iterator-typedef">QSet::reverse_iterator</a></span> QSet::<span class="name">rend</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to one past the last item in the set, in reverse order.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qset.html#end">end</a>(), <a href="qset.html#crend">crend</a>(), 和 <a href="qset.html#rbegin">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" id="rend-1"><a name="rend-1"></a><span class="type"><a href="qset.html#const_reverse_iterator-typedef">QSet::const_reverse_iterator</a></span> QSet::<span class="name">rend</span>() const</h3>
<p>这是一个重载函数。</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@rend -->
<!-- $$$reserve[overload1]$$$reserveint -->
<h3 class="fn" id="reserve"><a name="reserve"></a><span class="type">void</span> QSet::<span class="name">reserve</span>(<span class="type">int</span> <i>size</i>)</h3>
<p>Ensures that the set's internal hash table consists of at least <i>size</i> buckets.</p>
<p>This function is useful for code that needs to build a huge set and wants to avoid repeated reallocation. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qset.html#QSet">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> set;
  set<span class="operator">.</span>reserve(<span class="number">20000</span>);
  <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">20000</span>; <span class="operator">+</span><span class="operator">+</span>i)
      set<span class="operator">.</span>insert(values<span class="operator">[</span>i<span class="operator">]</span>);

</pre>
<p>Ideally, <i>size</i> should be slightly more than the maximum number of elements expected in the set. <i>size</i> doesn't have to be prime, because <a href="qset.html">QSet</a> will use a prime number internally anyway. If <i>size</i> is an underestimate, the worst that will happen is that the <a href="qset.html">QSet</a> will be a bit slower.</p>
<p>In general, you will rarely ever need to call this function. <a href="qset.html">QSet</a>'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</p>
<p><b> 参见 </b><a href="qset.html#squeeze">squeeze</a>() 和 <a href="qset.html#capacity">capacity</a>().</p>
<!-- @@@reserve -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><a name="size"></a><span class="type">int</span> QSet::<span class="name">size</span>() const</h3>
<p>返回集合中的所有元素项的总数量。</p>
<p><b> 参见 </b><a href="qset.html#isEmpty">isEmpty</a>() 和 <a href="qset.html#count">count</a>().</p>
<!-- @@@size -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" id="squeeze"><a name="squeeze"></a><span class="type">void</span> QSet::<span class="name">squeeze</span>()</h3>
<p>Reduces the size of the set's internal hash table to save memory.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qset.html">QSet</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b> 参见 </b><a href="qset.html#reserve">reserve</a>() 和 <a href="qset.html#capacity">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$subtract[overload1]$$$subtractconstQSet<T>& -->
<h3 class="fn" id="subtract"><a name="subtract"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">subtract</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Removes all items from this set that are contained in the <i>other</i> set. Returns a reference to this set.</p>
<p><b> 参见 </b><a href="qset.html#operator--eq">operator-=</a>(), <a href="qset.html#unite">unite</a>(), 和 <a href="qset.html#intersect">intersect</a>().</p>
<!-- @@@subtract -->
<!-- $$$swap[overload1]$$$swapQSet<T>& -->
<h3 class="fn" id="swap"><a name="swap"></a><span class="type">void</span> QSet::<span class="name">swap</span>(<span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>交换当前集合和 <i>other</i>集合。此操作巨快，且从未失手失败过。</p>
<!-- @@@swap -->
<!-- $$$toList[overload1]$$$toList -->
<h3 class="fn" id="toList"><a name="toList"></a><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">T</span>&gt; QSet::<span class="name">toList</span>() const</h3>
<p>Returns a new <a href="qlist.html">QList</a> containing the elements in the set. The order of the elements in the <a href="qlist.html">QList</a> is undefined.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qset.html#QSet">QSet</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> set;
  set <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;red&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;green&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;blue&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;black&quot;</span>;

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> list <span class="operator">=</span> set<span class="operator">.</span>toList();
  <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(list);

</pre>
<p><b> 参见 </b><a href="qset.html#fromList">fromList</a>() 和 <a href="qlist.html#fromSet">QList::fromSet</a>().</p>
<!-- @@@toList -->
<!-- $$$unite[overload1]$$$uniteconstQSet<T>& -->
<h3 class="fn" id="unite"><a name="unite"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">unite</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Each item in the <i>other</i> set that isn't already in this set is inserted into this set. A reference to this set is returned.</p>
<p><b> 参见 </b><a href="qset.html#operator-7c-eq">operator|=</a>(), <a href="qset.html#intersect">intersect</a>(), 和 <a href="qset.html#subtract">subtract</a>().</p>
<!-- @@@unite -->
<!-- $$$values[overload1]$$$values -->
<h3 class="fn" id="values"><a name="values"></a><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">T</span>&gt; QSet::<span class="name">values</span>() const</h3>
<p>Returns a new <a href="qlist.html">QList</a> containing the elements in the set. The order of the elements in the <a href="qlist.html">QList</a> is undefined.</p>
<p>此函数等同于 <a href="qset.html#toList">toList</a>().</p>
<p><b> 参见 </b><a href="qset.html#fromList">fromList</a>() 和 <a href="qlist.html#fromSet">QList::fromSet</a>().</p>
<!-- @@@values -->
<!-- $$$operator!=[overload1]$$$operator!=constQSet<T>& -->
<h3 class="fn" id="operator-not-eq"><a name="operator-not-eq"></a><span class="type">bool</span> QSet::<span class="name">operator!=</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code>true</code> if the <i>other</i> set is not equal to this set; 否则则返回 <code>false</code>。</p>
<p>Two sets are considered equal if they contain the same elements.</p>
<p>该函数要求值类型的列表元素实现了 <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qset.html#operator-eq-eq">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator&[overload1]$$$operator&constQSet<T>& -->
<h3 class="fn" id="operator-and"><a name="operator-and"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; QSet::<span class="name">operator&amp;</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns a new <a href="qset.html">QSet</a> that is the intersection of this set and the <i>other</i> set.</p>
<p><b> 参见 </b><a href="qset.html#intersect">intersect</a>(), <a href="qset.html#operator-and-eq">operator&amp;=</a>(), <a href="qset.html#operator-7c">operator|</a>(), 和 <a href="qset.html#operator-">operator-</a>().</p>
<!-- @@@operator& -->
<!-- $$$operator&=[overload1]$$$operator&=constQSet<T>& -->
<h3 class="fn" id="operator-and-eq"><a name="operator-and-eq"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator&amp;=</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Same as intersect(<i>other</i>).</p>
<p><b> 参见 </b><a href="qset.html#operator-and">operator&amp;</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), 和 <a href="qset.html#operator--eq">operator-=</a>().</p>
<!-- @@@operator&= -->
<!-- $$$operator&=$$$operator&=constT& -->
<h3 class="fn" id="operator-and-eq-1"><a name="operator-and-eq-1"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator&amp;=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>这是一个重载函数。</p>
<p>Same as intersect(<i>other</i>), if we consider <i>other</i> to be a set that contains the singleton <i>value</i>.</p>
<!-- @@@operator&= -->
<!-- $$$operator-[overload1]$$$operator-constQSet<T>& -->
<h3 class="fn" id="operator-"><a name="operator-"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; QSet::<span class="name">operator-</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns a new <a href="qset.html">QSet</a> that is the set difference of this set and the <i>other</i> set, i.e&#x2e;, this set - <i>other</i> set.</p>
<p><b> 参见 </b><a href="qset.html#subtract">subtract</a>(), <a href="qset.html#operator--eq">operator-=</a>(), <a href="qset.html#operator-7c">operator|</a>(), 和 <a href="qset.html#operator-and">operator&amp;</a>().</p>
<!-- @@@operator- -->
<!-- $$$operator-=[overload1]$$$operator-=constQSet<T>& -->
<h3 class="fn" id="operator--eq"><a name="operator--eq"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator-=</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Same as subtract(<i>other</i>).</p>
<p><b> 参见 </b><a href="qset.html#operator-">operator-</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), 和 <a href="qset.html#operator-and-eq">operator&amp;=</a>().</p>
<!-- @@@operator-= -->
<!-- $$$operator-=$$$operator-=constT& -->
<h3 class="fn" id="operator--eq-1"><a name="operator--eq-1"></a><span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;QSet::<span class="name">operator-=</span>(const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Removes the occurrence of item <i>value</i> from the set, if it is found, and returns a reference to the set. If the <i>value</i> is not contained the set, nothing is removed.</p>
<p><b> 参见 </b><a href="qset.html#remove">remove</a>().</p>
<!-- @@@operator-= -->
<!-- $$$operator==[overload1]$$$operator==constQSet<T>& -->
<h3 class="fn" id="operator-eq-eq"><a name="operator-eq-eq"></a><span class="type">bool</span> QSet::<span class="name">operator==</span>(const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns <code>true</code> if the <i>other</i> set is equal to this set; 否则则返回 <code>false</code>。</p>
<p>Two sets are considered equal if they contain the same elements.</p>
<p>该函数要求值类型的列表元素实现了 <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qset.html#operator-not-eq">operator!=</a>().</p>
<!-- @@@operator== -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
<!-- $$$operator<<$$$operator<<QDataStream&constQSet<T>& -->
<h3 class="fn" id="operator-lt-lt-1"><a name="operator-lt-lt-1"></a><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>set</i>)</h3>
<p>Writes the <i>set</i> to stream <i>out</i>.</p>
<p>该函数要求值类型的列表元素实现了 <code>operator&lt;&lt;()</code>.</p>
<p><b> 参见 </b><a href="datastreamformat.html">数据流运算符的格式</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator>>[overload1]$$$operator>>QDataStream&QSet<T>& -->
<h3 class="fn" id="operator-gt-gt"><a name="operator-gt-gt"></a><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qset.html#QSet">QSet</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>set</i>)</h3>
<p>Reads a set from stream <i>in</i> into <i>set</i>.</p>
<p>该函数要求值类型的列表元素实现了 <code>operator&gt;&gt;()</code>.</p>
<p><b> 参见 </b><a href="datastreamformat.html">数据流运算符的格式</a>.</p>
<!-- @@@operator>> -->
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
