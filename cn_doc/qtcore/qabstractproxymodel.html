<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qabstractproxymodel.cpp -->
  <title>QAbstractProxyModel Class | Qt核心模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QAbstractProxyModel</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#reimplemented-public-functions">重新实现的公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#protected-slots">保护槽函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QAbstractProxyModel Class</h1>
<!-- $$$QAbstractProxyModel-brief -->
<p>The <a href="qabstractproxymodel.html">QAbstractProxyModel</a> class provides a base class for proxy item models that can do sorting, filtering or other data processing tasks. <a href="#details">更多详情...</a></p>
<!-- @@@QAbstractProxyModel -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QAbstractProxyModel&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 4.1</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="qabstractitemmodel.html">QAbstractItemModel</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的子类有：</td><td class="memItemRight bottomAlign"> <p><a href="qidentityproxymodel.html">QIdentityProxyModel</a> 和 <a href="qsortfilterproxymodel.html">QSortFilterProxyModel</a></p>
</td></tr></table></div><ul>
<li><a href="qabstractproxymodel-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qabstractproxymodel-obsolete.html">过时的成员</a></li>
</ul>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<ul>
<li class="fn"><b><a href="qabstractproxymodel.html#sourceModel-prop">sourceModel</a></b> : QAbstractItemModel*</li>
</ul>
<ul>
<li class="fn">1 个属性继承于 <a href="qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#QAbstractProxyModel">QAbstractProxyModel</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#dtor.QAbstractProxyModel">~QAbstractProxyModel</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QModelIndex </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#mapFromSource">mapFromSource</a></b>(const QModelIndex &amp;<i>sourceIndex</i>) const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QItemSelection </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#mapSelectionFromSource">mapSelectionFromSource</a></b>(const QItemSelection &amp;<i>sourceSelection</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QItemSelection </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#mapSelectionToSource">mapSelectionToSource</a></b>(const QItemSelection &amp;<i>proxySelection</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QModelIndex </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#mapToSource">mapToSource</a></b>(const QModelIndex &amp;<i>proxyIndex</i>) const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#setSourceModel">setSourceModel</a></b>(QAbstractItemModel *<i>sourceModel</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractItemModel *</td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#sourceModel">sourceModel</a></b>() const</td></tr>
</table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">重新实现的公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QModelIndex </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#buddy">buddy</a></b>(const QModelIndex &amp;<i>index</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#canDropMimeData">canDropMimeData</a></b>(const QMimeData *<i>data</i>, Qt::DropAction <i>action</i>, int <i>row</i>, int <i>column</i>, const QModelIndex &amp;<i>parent</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#canFetchMore">canFetchMore</a></b>(const QModelIndex &amp;<i>parent</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#data">data</a></b>(const QModelIndex &amp;<i>proxyIndex</i>, int <i>role</i> = Qt::DisplayRole) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#dropMimeData">dropMimeData</a></b>(const QMimeData *<i>data</i>, Qt::DropAction <i>action</i>, int <i>row</i>, int <i>column</i>, const QModelIndex &amp;<i>parent</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#fetchMore">fetchMore</a></b>(const QModelIndex &amp;<i>parent</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual Qt::ItemFlags </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#flags">flags</a></b>(const QModelIndex &amp;<i>index</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#hasChildren">hasChildren</a></b>(const QModelIndex &amp;<i>parent</i> = QModelIndex()) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#headerData">headerData</a></b>(int <i>section</i>, Qt::Orientation <i>orientation</i>, int <i>role</i> = Qt::DisplayRole) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QMap&lt;int, QVariant&gt; </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#itemData">itemData</a></b>(const QModelIndex &amp;<i>proxyIndex</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QMimeData *</td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#mimeData">mimeData</a></b>(const QModelIndexList &amp;<i>indexes</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QStringList </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#mimeTypes">mimeTypes</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#revert">revert</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#setData">setData</a></b>(const QModelIndex &amp;<i>index</i>, const QVariant &amp;<i>value</i>, int <i>role</i> = Qt::EditRole) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#setHeaderData">setHeaderData</a></b>(int <i>section</i>, Qt::Orientation <i>orientation</i>, const QVariant &amp;<i>value</i>, int <i>role</i> = Qt::EditRole) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#setItemData">setItemData</a></b>(const QModelIndex &amp;<i>index</i>, const QMap&lt;int, QVariant&gt; &amp;<i>roles</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QModelIndex </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#sibling">sibling</a></b>(int <i>row</i>, int <i>column</i>, const QModelIndex &amp;<i>idx</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#sort">sort</a></b>(int <i>column</i>, Qt::SortOrder <i>order</i> = Qt::AscendingOrder) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#span">span</a></b>(const QModelIndex &amp;<i>index</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#submit">submit</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual Qt::DropActions </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#supportedDragActions">supportedDragActions</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual Qt::DropActions </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#supportedDropActions">supportedDropActions</a></b>() const override</td></tr>
</table></div>
<ul>
<li class="fn">40 个公共函数继承于 <a href="qabstractitemmodel.html#public-functions">QAbstractItemModel</a></li>
<li class="fn">32 个公共函数继承于 <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#sourceModel-prop">sourceModelChanged</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">18 个信号继承于 <a href="qabstractitemmodel.html#signals">QAbstractItemModel</a></li>
<li class="fn">2 个信号继承于 <a href="qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">1 个静态公共成员继承于 <a href="qabstractitemmodel.html#static-public-members">QAbstractItemModel</a></li>
<li class="fn">11 个静态公共成员继承于 <a href="qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="protected-slots"></a>
<h2 id="protected-slots">保护槽函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qabstractproxymodel.html#resetInternalData">resetInternalData</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">1 个保护槽函数继承于 <a href="qabstractitemmodel.html#protected-slots">QAbstractItemModel</a></li>
</ul>
<h3>其他继承成员有</h3>
<ul>
<li class="fn">2 个公共槽函数继承于 <a href="qabstractitemmodel.html#public-slots">QAbstractItemModel</a></li>
<li class="fn">1 个公共槽函数继承于 <a href="qobject.html#public-slots">QObject</a></li>
<li class="fn">19 个保护函数继承于 <a href="qabstractitemmodel.html#protected-functions">QAbstractItemModel</a></li>
<li class="fn">9 个保护函数继承于 <a href="qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 个保护类型继承于 <a href="qobject.html#protected-variables">QObject</a></li>
<li class="fn">1 个静态保护成员继承于 <a href="qobject.html#static-protected-members">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QAbstractProxyModel-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qabstractproxymodel.html">QAbstractProxyModel</a> class provides a base class for proxy item models that can do sorting, filtering or other data processing tasks.</p>
<p>This class defines the standard interface that proxy models must use to be able to interoperate correctly with other model/view components. It is not supposed to be instantiated directly.</p>
<p>All standard proxy models are derived from the <a href="qabstractproxymodel.html">QAbstractProxyModel</a> class. If you need to create a new proxy model class, it is usually better to subclass an existing class that provides the closest behavior to the one you want to provide.</p>
<p>Proxy models that filter or sort items of data from a source model should be created by using or subclassing <a href="qsortfilterproxymodel.html">QSortFilterProxyModel</a>.</p>
<p>To subclass <a href="qabstractproxymodel.html">QAbstractProxyModel</a>, you need to implement <a href="qabstractproxymodel.html#mapFromSource">mapFromSource</a>() 和 <a href="qabstractproxymodel.html#mapToSource">mapToSource</a>(). The <a href="qabstractproxymodel.html#mapSelectionFromSource">mapSelectionFromSource</a>() 和 <a href="qabstractproxymodel.html#mapSelectionToSource">mapSelectionToSource</a>() functions only need to be reimplemented if you need a behavior different from the default behavior.</p>
<p><b>注意： </b>If the source model is deleted or no source model is specified, the proxy model operates on a empty placeholder model.</p></div>
<p><b> 参见 </b><a href="qsortfilterproxymodel.html">QSortFilterProxyModel</a>, <a href="qabstractitemmodel.html">QAbstractItemModel</a>, 和 <a href="../qtwidgets/model-view-programming.html">模型/视图的编程</a>.</p>
<!-- @@@QAbstractProxyModel -->
<div class="types">
<h2>成员类型文档</h2>
</div>
<div class="prop">
<h2>属性文档</h2>
<!-- $$$sourceModel-prop$$$sourceModel$$$setSourceModelQAbstractItemModel*$$$sourceModelChanged -->
<h3 class="fn" id="sourceModel-prop"><a name="sourceModel-prop"></a><span class="name">sourceModel</span> : <span class="type"><a href="qabstractitemmodel.html#QAbstractItemModel">QAbstractItemModel</a></span>*</h3>
<p>此属性包含了该代理模型的源模型。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QAbstractItemModel *</td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qabstractproxymodel.html#sourceModel">sourceModel</a></b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> virtual void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qabstractproxymodel.html#setSourceModel">setSourceModel</a></b></span>(QAbstractItemModel *<i>sourceModel</i>)</td></tr>
</table></div>
<p><b>通知信号：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sourceModelChanged</b></span>()</td><td class="memItemRight bottomAlign">[see note below]</td></tr>
</table></div>
<p><b>注意： </b>这是个私有信号，它可用于信号连接，但是不能由用户触发。</p>
<!-- @@@sourceModel -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QAbstractProxyModel[overload1]$$$QAbstractProxyModelQObject* -->
<h3 class="fn" id="QAbstractProxyModel"><a name="QAbstractProxyModel"></a>QAbstractProxyModel::<span class="name">QAbstractProxyModel</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>构造函数，用传入的参数<i>parent</i>来创建一个代理模型。</p>
<!-- @@@QAbstractProxyModel -->
<!-- $$$~QAbstractProxyModel[overload1]$$$~QAbstractProxyModel -->
<h3 class="fn" id="dtor.QAbstractProxyModel"><a name="dtor.QAbstractProxyModel"></a><code>[虚函数] </code>QAbstractProxyModel::<span class="name">~QAbstractProxyModel</span>()</h3>
<p>析构函数，释放该代理模型。</p>
<!-- @@@~QAbstractProxyModel -->
<!-- $$$buddy[overload1]$$$buddyconstQModelIndex& -->
<h3 class="fn" id="buddy"><a name="buddy"></a><code>[重载虚函数] </code><span class="type"><a href="qmodelindex.html">QModelIndex</a></span> QAbstractProxyModel::<span class="name">buddy</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>index</i>) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#buddy">QAbstractItemModel::buddy</a>().</p>
<!-- @@@buddy -->
<!-- $$$canDropMimeData[overload1]$$$canDropMimeDataconstQMimeData*Qt::DropActionintintconstQModelIndex& -->
<h3 class="fn" id="canDropMimeData"><a name="canDropMimeData"></a><code>[重载虚函数] </code><span class="type">bool</span> QAbstractProxyModel::<span class="name">canDropMimeData</span>(const <span class="type"><a href="qmimedata.html">QMimeData</a></span> *<i>data</i>, <span class="type">Qt::DropAction</span> <i>action</i>, <span class="type">int</span> <i>row</i>, <span class="type">int</span> <i>column</i>, const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>parent</i>) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#canDropMimeData">QAbstractItemModel::canDropMimeData</a>().</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<!-- @@@canDropMimeData -->
<!-- $$$canFetchMore[overload1]$$$canFetchMoreconstQModelIndex& -->
<h3 class="fn" id="canFetchMore"><a name="canFetchMore"></a><code>[重载虚函数] </code><span class="type">bool</span> QAbstractProxyModel::<span class="name">canFetchMore</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>parent</i>) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#canFetchMore">QAbstractItemModel::canFetchMore</a>().</p>
<!-- @@@canFetchMore -->
<!-- $$$data[overload1]$$$dataconstQModelIndex&int -->
<h3 class="fn" id="data"><a name="data"></a><code>[重载虚函数] </code><span class="type"><a href="qvariant.html">QVariant</a></span> QAbstractProxyModel::<span class="name">data</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>proxyIndex</i>, <span class="type">int</span> <i>role</i> = Qt::DisplayRole) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#data">QAbstractItemModel::data</a>().</p>
<p><b> 参见 </b><a href="qabstractproxymodel.html#setData">setData</a>().</p>
<!-- @@@data -->
<!-- $$$dropMimeData[overload1]$$$dropMimeDataconstQMimeData*Qt::DropActionintintconstQModelIndex& -->
<h3 class="fn" id="dropMimeData"><a name="dropMimeData"></a><code>[重载虚函数] </code><span class="type">bool</span> QAbstractProxyModel::<span class="name">dropMimeData</span>(const <span class="type"><a href="qmimedata.html">QMimeData</a></span> *<i>data</i>, <span class="type">Qt::DropAction</span> <i>action</i>, <span class="type">int</span> <i>row</i>, <span class="type">int</span> <i>column</i>, const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>parent</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#dropMimeData">QAbstractItemModel::dropMimeData</a>().</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<!-- @@@dropMimeData -->
<!-- $$$fetchMore[overload1]$$$fetchMoreconstQModelIndex& -->
<h3 class="fn" id="fetchMore"><a name="fetchMore"></a><code>[重载虚函数] </code><span class="type">void</span> QAbstractProxyModel::<span class="name">fetchMore</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>parent</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#fetchMore">QAbstractItemModel::fetchMore</a>().</p>
<!-- @@@fetchMore -->
<!-- $$$flags[overload1]$$$flagsconstQModelIndex& -->
<h3 class="fn" id="flags"><a name="flags"></a><code>[重载虚函数] </code><span class="type">Qt::ItemFlags</span> QAbstractProxyModel::<span class="name">flags</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>index</i>) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#flags">QAbstractItemModel::flags</a>().</p>
<!-- @@@flags -->
<!-- $$$hasChildren[overload1]$$$hasChildrenconstQModelIndex& -->
<h3 class="fn" id="hasChildren"><a name="hasChildren"></a><code>[重载虚函数] </code><span class="type">bool</span> QAbstractProxyModel::<span class="name">hasChildren</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>parent</i> = QModelIndex()) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#hasChildren">QAbstractItemModel::hasChildren</a>().</p>
<!-- @@@hasChildren -->
<!-- $$$headerData[overload1]$$$headerDataintQt::Orientationint -->
<h3 class="fn" id="headerData"><a name="headerData"></a><code>[重载虚函数] </code><span class="type"><a href="qvariant.html">QVariant</a></span> QAbstractProxyModel::<span class="name">headerData</span>(<span class="type">int</span> <i>section</i>, <span class="type">Qt::Orientation</span> <i>orientation</i>, <span class="type">int</span> <i>role</i> = Qt::DisplayRole) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#headerData">QAbstractItemModel::headerData</a>().</p>
<p><b> 参见 </b><a href="qabstractproxymodel.html#setHeaderData">setHeaderData</a>().</p>
<!-- @@@headerData -->
<!-- $$$itemData[overload1]$$$itemDataconstQModelIndex& -->
<h3 class="fn" id="itemData"><a name="itemData"></a><code>[重载虚函数] </code><span class="type"><a href="qmap.html">QMap</a></span>&lt;<span class="type">int</span>, <span class="type"><a href="qvariant.html">QVariant</a></span>&gt; QAbstractProxyModel::<span class="name">itemData</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>proxyIndex</i>) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#itemData">QAbstractItemModel::itemData</a>().</p>
<p><b> 参见 </b><a href="qabstractproxymodel.html#setItemData">setItemData</a>().</p>
<!-- @@@itemData -->
<!-- $$$mapFromSource[overload1]$$$mapFromSourceconstQModelIndex& -->
<h3 class="fn" id="mapFromSource"><a name="mapFromSource"></a><code>[纯虚函数] </code><span class="type"><a href="qmodelindex.html">QModelIndex</a></span> QAbstractProxyModel::<span class="name">mapFromSource</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>sourceIndex</i>) const</h3>
<p>Reimplement this function to return the model index in the proxy model that corresponds to the <i>sourceIndex</i> from the source model.</p>
<p><b>注意： </b>This function can be invoked via the meta-object system and from QML. See <a href="qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>.</p>
<p><b> 参见 </b><a href="qabstractproxymodel.html#mapToSource">mapToSource</a>().</p>
<!-- @@@mapFromSource -->
<!-- $$$mapSelectionFromSource[overload1]$$$mapSelectionFromSourceconstQItemSelection& -->
<h3 class="fn" id="mapSelectionFromSource"><a name="mapSelectionFromSource"></a><code>[虚函数] </code><span class="type"><a href="qitemselection.html">QItemSelection</a></span> QAbstractProxyModel::<span class="name">mapSelectionFromSource</span>(const <span class="type"><a href="qitemselection.html">QItemSelection</a></span> &amp;<i>sourceSelection</i>) const</h3>
<p>Returns a proxy selection mapped from the specified <i>sourceSelection</i>.</p>
<p>Reimplement this method to map source selections to proxy selections.</p>
<p><b>注意： </b>This function can be invoked via the meta-object system and from QML. See <a href="qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>.</p>
<!-- @@@mapSelectionFromSource -->
<!-- $$$mapSelectionToSource[overload1]$$$mapSelectionToSourceconstQItemSelection& -->
<h3 class="fn" id="mapSelectionToSource"><a name="mapSelectionToSource"></a><code>[虚函数] </code><span class="type"><a href="qitemselection.html">QItemSelection</a></span> QAbstractProxyModel::<span class="name">mapSelectionToSource</span>(const <span class="type"><a href="qitemselection.html">QItemSelection</a></span> &amp;<i>proxySelection</i>) const</h3>
<p>Returns a source selection mapped from the specified <i>proxySelection</i>.</p>
<p>Reimplement this method to map proxy selections to source selections.</p>
<p><b>注意： </b>This function can be invoked via the meta-object system and from QML. See <a href="qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>.</p>
<!-- @@@mapSelectionToSource -->
<!-- $$$mapToSource[overload1]$$$mapToSourceconstQModelIndex& -->
<h3 class="fn" id="mapToSource"><a name="mapToSource"></a><code>[纯虚函数] </code><span class="type"><a href="qmodelindex.html">QModelIndex</a></span> QAbstractProxyModel::<span class="name">mapToSource</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>proxyIndex</i>) const</h3>
<p>Reimplement this function to return the model index in the source model that corresponds to the <i>proxyIndex</i> in the proxy model.</p>
<p><b>注意： </b>This function can be invoked via the meta-object system and from QML. See <a href="qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>.</p>
<p><b> 参见 </b><a href="qabstractproxymodel.html#mapFromSource">mapFromSource</a>().</p>
<!-- @@@mapToSource -->
<!-- $$$mimeData[overload1]$$$mimeDataconstQModelIndexList& -->
<h3 class="fn" id="mimeData"><a name="mimeData"></a><code>[重载虚函数] </code><span class="type"><a href="qmimedata.html">QMimeData</a></span> *QAbstractProxyModel::<span class="name">mimeData</span>(const <span class="type"><a href="qmodelindex.html#QModelIndexList-typedef">QModelIndexList</a></span> &amp;<i>indexes</i>) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#mimeData">QAbstractItemModel::mimeData</a>().</p>
<!-- @@@mimeData -->
<!-- $$$mimeTypes[overload1]$$$mimeTypes -->
<h3 class="fn" id="mimeTypes"><a name="mimeTypes"></a><code>[重载虚函数] </code><span class="type"><a href="qstringlist.html">QStringList</a></span> QAbstractProxyModel::<span class="name">mimeTypes</span>() const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#mimeTypes">QAbstractItemModel::mimeTypes</a>().</p>
<!-- @@@mimeTypes -->
<!-- $$$resetInternalData[overload1]$$$resetInternalData -->
<h3 class="fn" id="resetInternalData"><a name="resetInternalData"></a><code>[保护槽函数] </code><span class="type">void</span> QAbstractProxyModel::<span class="name">resetInternalData</span>()</h3>
<p>清空该代理模型的角色名称 <a href="qabstractitemmodel.html#roleNames">roleNames</a>。</p>
<!-- @@@resetInternalData -->
<!-- $$$revert[overload1]$$$revert -->
<h3 class="fn" id="revert"><a name="revert"></a><code>[重载虚函数] </code><span class="type">void</span> QAbstractProxyModel::<span class="name">revert</span>()</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#revert">QAbstractItemModel::revert</a>().</p>
<!-- @@@revert -->
<!-- $$$setData[overload1]$$$setDataconstQModelIndex&constQVariant&int -->
<h3 class="fn" id="setData"><a name="setData"></a><code>[重载虚函数] </code><span class="type">bool</span> QAbstractProxyModel::<span class="name">setData</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>index</i>, const <span class="type"><a href="qvariant.html">QVariant</a></span> &amp;<i>value</i>, <span class="type">int</span> <i>role</i> = Qt::EditRole)</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#setData">QAbstractItemModel::setData</a>().</p>
<p><b> 参见 </b><a href="qabstractproxymodel.html#data">data</a>().</p>
<!-- @@@setData -->
<!-- $$$setHeaderData[overload1]$$$setHeaderDataintQt::OrientationconstQVariant&int -->
<h3 class="fn" id="setHeaderData"><a name="setHeaderData"></a><code>[重载虚函数] </code><span class="type">bool</span> QAbstractProxyModel::<span class="name">setHeaderData</span>(<span class="type">int</span> <i>section</i>, <span class="type">Qt::Orientation</span> <i>orientation</i>, const <span class="type"><a href="qvariant.html">QVariant</a></span> &amp;<i>value</i>, <span class="type">int</span> <i>role</i> = Qt::EditRole)</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#setHeaderData">QAbstractItemModel::setHeaderData</a>().</p>
<p><b> 参见 </b><a href="qabstractproxymodel.html#headerData">headerData</a>().</p>
<!-- @@@setHeaderData -->
<!-- $$$setItemData[overload1]$$$setItemDataconstQModelIndex&constQMap<int,QVariant>& -->
<h3 class="fn" id="setItemData"><a name="setItemData"></a><code>[重载虚函数] </code><span class="type">bool</span> QAbstractProxyModel::<span class="name">setItemData</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>index</i>, const <span class="type"><a href="qmap.html">QMap</a></span>&lt;<span class="type">int</span>, <span class="type"><a href="qvariant.html">QVariant</a></span>&gt; &amp;<i>roles</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#setItemData">QAbstractItemModel::setItemData</a>().</p>
<p><b> 参见 </b><a href="qabstractproxymodel.html#itemData">itemData</a>().</p>
<!-- @@@setItemData -->
<!-- $$$setSourceModel -->
<h3 class="fn" id="setSourceModel"><a name="setSourceModel"></a><code>[虚函数] </code><span class="type">void</span> QAbstractProxyModel::<span class="name">setSourceModel</span>(<span class="type"><a href="qabstractitemmodel.html#QAbstractItemModel">QAbstractItemModel</a></span> *<i>sourceModel</i>)</h3>
<p>设置该代理模型的源模型为传入的 <i>sourceModel</i>，用于代理模型处理。 </p>
<p>子类需要在此方法开始处调用 <a href="qabstractitemmodel.html#beginResetModel">beginResetModel</a>()函数，从旧模型中断开信号槽连接，调用此方法连接信号槽到新模型，然后调用 <a href="qabstractitemmodel.html#endResetModel">endResetModel</a>()函数。</p>
<p><b>注意：</b> 此设置函数来自于属性 <a href="qabstractproxymodel.html#sourceModel-prop">sourceModel</a>. </p><p><b> 参见 </b><a href="qabstractproxymodel.html#sourceModel">sourceModel</a>().</p>
<!-- @@@setSourceModel -->
<!-- $$$sibling[overload1]$$$siblingintintconstQModelIndex& -->
<h3 class="fn" id="sibling"><a name="sibling"></a><code>[重载虚函数] </code><span class="type"><a href="qmodelindex.html">QModelIndex</a></span> QAbstractProxyModel::<span class="name">sibling</span>(<span class="type">int</span> <i>row</i>, <span class="type">int</span> <i>column</i>, const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>idx</i>) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#sibling">QAbstractItemModel::sibling</a>().</p>
<!-- @@@sibling -->
<!-- $$$sort[overload1]$$$sortintQt::SortOrder -->
<h3 class="fn" id="sort"><a name="sort"></a><code>[重载虚函数] </code><span class="type">void</span> QAbstractProxyModel::<span class="name">sort</span>(<span class="type">int</span> <i>column</i>, <span class="type">Qt::SortOrder</span> <i>order</i> = Qt::AscendingOrder)</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#sort">QAbstractItemModel::sort</a>().</p>
<!-- @@@sort -->
<!-- $$$sourceModel -->
<h3 class="fn" id="sourceModel"><a name="sourceModel"></a><span class="type"><a href="qabstractitemmodel.html#QAbstractItemModel">QAbstractItemModel</a></span> *QAbstractProxyModel::<span class="name">sourceModel</span>() const</h3>
<p>返回包含数据的源模型，源模型可用于该代理模型。</p>
<p><b>注意：</b> 此获取函数来自于属性 <a href="qabstractproxymodel.html#sourceModel-prop">sourceModel</a>. </p><p><b> 参见 </b><a href="qabstractproxymodel.html#setSourceModel">setSourceModel</a>().</p>
<!-- @@@sourceModel -->
<!-- $$$span[overload1]$$$spanconstQModelIndex& -->
<h3 class="fn" id="span"><a name="span"></a><code>[重载虚函数] </code><span class="type"><a href="qsize.html">QSize</a></span> QAbstractProxyModel::<span class="name">span</span>(const <span class="type"><a href="qmodelindex.html">QModelIndex</a></span> &amp;<i>index</i>) const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#span">QAbstractItemModel::span</a>().</p>
<!-- @@@span -->
<!-- $$$submit[overload1]$$$submit -->
<h3 class="fn" id="submit"><a name="submit"></a><code>[重载虚函数] </code><span class="type">bool</span> QAbstractProxyModel::<span class="name">submit</span>()</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#submit">QAbstractItemModel::submit</a>().</p>
<!-- @@@submit -->
<!-- $$$supportedDragActions[overload1]$$$supportedDragActions -->
<h3 class="fn" id="supportedDragActions"><a name="supportedDragActions"></a><code>[重载虚函数] </code><span class="type">Qt::DropActions</span> QAbstractProxyModel::<span class="name">supportedDragActions</span>() const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#supportedDragActions">QAbstractItemModel::supportedDragActions</a>().</p>
<!-- @@@supportedDragActions -->
<!-- $$$supportedDropActions[overload1]$$$supportedDropActions -->
<h3 class="fn" id="supportedDropActions"><a name="supportedDropActions"></a><code>[重载虚函数] </code><span class="type">Qt::DropActions</span> QAbstractProxyModel::<span class="name">supportedDropActions</span>() const</h3>
<p>重新实现了父类函数接口 <a href="qabstractitemmodel.html#supportedDropActions">QAbstractItemModel::supportedDropActions</a>().</p>
<!-- @@@supportedDropActions -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
