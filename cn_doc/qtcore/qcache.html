<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qcache.qdoc -->
  <title>缓存类 | Qt核心模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td ><a href="qtcore-module.html">C++类</a></td><td >QCache</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">缓存类</h1>
<!-- $$$QCache-brief -->
<p><a href="qcache.html">QCache</a>类是个支持缓存的模板类。<a href="#details">更多详情...</a></p>
<!-- @@@QCache -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QCache&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr></table></div><ul>
<li><a href="qcache-members.html">所有成员清单，包括继承而来的成员</a></li>
</ul>
<p><b>注意：</b> 此类中的所有函数都是 <a href="../qtdoc/threads-reentrancy.html">可重入的。</a></p>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#QCache">QCache</a></b>(int <i>maxCost</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#dtor.QCache">~QCache</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#clear">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#contains">contains</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#count">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#insert">insert</a></b>(const Key &amp;<i>key</i>, T *<i>object</i>, int <i>cost</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#isEmpty">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#keys">keys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#maxCost">maxCost</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qcache.html#object">object</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#remove">remove</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#setMaxCost">setMaxCost</a></b>(int <i>cost</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#size">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qcache.html#take">take</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcache.html#totalCost">totalCost</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="qcache.html#operator-5b-5d">operator[]</a></b>(const Key &amp;<i>key</i>) const</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QCache-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p><a href="qcache.html">QCache</a>类是个支持缓存的模板类。</p>
<p><a href="qcache.html">QCache</a>&lt;Key, T&gt; defines a cache that stores objects of type T associated with keys of type Key. For example, here's the definition of a cache that stores objects of type Employee associated with an integer key:</p>
<pre class="cpp">

  <span class="type"><a href="qcache.html#QCache">QCache</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> Employee<span class="operator">&gt;</span> cache;

</pre>
<p>如下演示了如何插入对象到缓存中：</p>
<pre class="cpp">

  Employee <span class="operator">*</span>employee <span class="operator">=</span> <span class="keyword">new</span> Employee;
  employee<span class="operator">-</span><span class="operator">&gt;</span>setId(<span class="number">37</span>);
  employee<span class="operator">-</span><span class="operator">&gt;</span>setName(<span class="string">&quot;Richard Schmit&quot;</span>);
  <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
  cache<span class="operator">.</span>insert(employee<span class="operator">-</span><span class="operator">&gt;</span>id()<span class="operator">,</span> employee);

</pre>
<p>The advantage of using <a href="qcache.html">QCache</a> over some other key-based data structure (such as <a href="qmap.html">QMap</a> or <a href="qhash.html#qhash">QHash</a>) is that <a href="qcache.html">QCache</a> automatically takes ownership of the objects that are inserted into the cache and deletes them to make room for new objects, if necessary. When inserting an object into the cache, you can specify a <i>cost</i>, which should bear some approximate relationship to the amount of memory taken by the object. When the sum of all objects' costs (<a href="qcache.html#totalCost">totalCost</a>()) exceeds the cache's limit (<a href="qcache.html#maxCost">maxCost</a>()), <a href="qcache.html">QCache</a> starts deleting objects in the cache to keep under the limit, starting with less recently accessed objects.</p>
<p>By default, <a href="qcache.html">QCache</a>'s <a href="qcache.html#maxCost">maxCost</a>() is 100. You can specify a different value in the <a href="qcache.html">QCache</a> constructor:</p>
<pre class="cpp">

  <span class="type"><a href="qcache.html#QCache">QCache</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> MyDataStructure<span class="operator">&gt;</span> cache(<span class="number">5000</span>);

</pre>
<p>Each time you call <a href="qcache.html#insert">insert</a>(), you can specify a cost as third argument (after the key and a pointer to the object to insert). After the call, the inserted object is owned by the <a href="qcache.html">QCache</a>, which may delete it at any time to make room for other objects.</p>
<p>To look up objects in the cache, use <a href="qcache.html#object">object</a>() or operator[](). This function looks up an object by its key, and returns either a pointer to the cached object (which is owned by the cache) or 0.</p>
<p>If you want to remove an object from the cache for a particular key, call <a href="qcache.html#remove">remove</a>(). This will also delete the object. If you want to remove an object from the cache without the <a href="qcache.html">QCache</a> deleting it, use <a href="qcache.html#take">take</a>().</p>
</div>
<p><b> 参见 </b><a href="../qtgui/qpixmapcache.html">QPixmapCache</a>, <a href="qhash.html#qhash">QHash</a>, 和 <a href="qmap.html">QMap</a>.</p>
<!-- @@@QCache -->
<div class="types">
<h2>成员类型文档</h2>
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QCache[overload1]$$$QCacheint -->
<h3 class="fn" id="QCache"><a name="QCache"></a>QCache::<span class="name">QCache</span>(<span class="type">int</span> <i>maxCost</i> = ...)</h3>
<p>构造函数，创建一个内容总成本不超过<i>maxCost</i>数量的缓存。</p>
<!-- @@@QCache -->
<!-- $$$~QCache[overload1]$$$~QCache -->
<h3 class="fn" id="dtor.QCache"><a name="dtor.QCache"></a>QCache::<span class="name">~QCache</span>()</h3>
<p>析构函数，删除缓存中所有对象。</p>
<!-- @@@~QCache -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear"><a name="clear"></a><span class="type">void</span> QCache::<span class="name">clear</span>()</h3>
<p>删除缓存中所有对象。</p>
<p><b> 参见 </b><a href="qcache.html#remove">remove</a>() 和 <a href="qcache.html#take">take</a>().</p>
<!-- @@@clear -->
<!-- $$$contains[overload1]$$$containsconstKey& -->
<h3 class="fn" id="contains"><a name="contains"></a><span class="type">bool</span> QCache::<span class="name">contains</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>若缓存中包含关键字为<i>key</i>的对象则返回 <code>true</code> ； 否则则返回 <code>false</code>。</p>
<p><b> 参见 </b><a href="qcache.html#take">take</a>() 和 <a href="qcache.html#remove">remove</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$count -->
<h3 class="fn" id="count"><a name="count"></a><span class="type">int</span> QCache::<span class="name">count</span>() const</h3>
<p>等同于 <a href="qcache.html#size">size</a>().</p>
<!-- @@@count -->
<!-- $$$insert[overload1]$$$insertconstKey&T*int -->
<h3 class="fn" id="insert"><a name="insert"></a><span class="type">bool</span> QCache::<span class="name">insert</span>(const <span class="type">Key</span> &amp;<i>key</i>, <span class="type">T</span> *<i>object</i>, <span class="type">int</span> <i>cost</i> = ...)</h3>
<p>Inserts <i>object</i> into the cache with key <i>key</i> and associated cost <i>cost</i>. Any object with the same key already in the cache will be removed.</p>
<p>After this call, <i>object</i> is owned by the <a href="qcache.html">QCache</a> and may be deleted at any time. In particular, if <i>cost</i> is greater than <a href="qcache.html#maxCost">maxCost</a>(), the object will be deleted immediately.</p>
<p>若对象已增加到缓存中，则该函数返回 <code>true</code>；否则将返回 <code>false</code>。</p>
<p><b> 参见 </b><a href="qcache.html#take">take</a>() 和 <a href="qcache.html#remove">remove</a>().</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty"><a name="isEmpty"></a><span class="type">bool</span> QCache::<span class="name">isEmpty</span>() const</h3>
<p>若缓存中不包含任何对象则返回 <code>true</code> ； 否则则返回 <code>false</code>。</p>
<p><b> 参见 </b><a href="qcache.html#size">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$keys[overload1]$$$keys -->
<h3 class="fn" id="keys"><a name="keys"></a><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">Key</span>&gt; QCache::<span class="name">keys</span>() const</h3>
<p>返回缓存中所有关键字的列表。</p>
<!-- @@@keys -->
<!-- $$$maxCost[overload1]$$$maxCost -->
<h3 class="fn" id="maxCost"><a name="maxCost"></a><span class="type">int</span> QCache::<span class="name">maxCost</span>() const</h3>
<p>返回缓存中最大允许的总成本。</p>
<p><b> 参见 </b><a href="qcache.html#setMaxCost">setMaxCost</a>() 和 <a href="qcache.html#totalCost">totalCost</a>().</p>
<!-- @@@maxCost -->
<!-- $$$object[overload1]$$$objectconstKey& -->
<h3 class="fn" id="object"><a name="object"></a><span class="type">T</span> *QCache::<span class="name">object</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>返回关键字为<i>key</i>的关联对象，若缓存中不存在此关键字则返回0。</p>
<p><b>警告：</b> 返回对象属于 <a href="qcache.html">QCache</a>，因此有可能在任何时间被缓存删除了。 </p>
<p><b> 参见 </b><a href="qcache.html#take">take</a>() 和 <a href="qcache.html#remove">remove</a>().</p>
<!-- @@@object -->
<!-- $$$remove[overload1]$$$removeconstKey& -->
<h3 class="fn" id="remove"><a name="remove"></a><span class="type">bool</span> QCache::<span class="name">remove</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>删除关联的关键字为<i>key</i>的对象。 若在缓存中找到此对象则返回 <code>true</code>。 否则则返回 <code>false</code>。</p>
<p><b> 参见 </b><a href="qcache.html#take">take</a>() 和 <a href="qcache.html#clear">clear</a>().</p>
<!-- @@@remove -->
<!-- $$$setMaxCost[overload1]$$$setMaxCostint -->
<h3 class="fn" id="setMaxCost"><a name="setMaxCost"></a><span class="type">void</span> QCache::<span class="name">setMaxCost</span>(<span class="type">int</span> <i>cost</i>)</h3>
<p>设置缓存中最大允许的对象数量为 <i>cost</i>。 If the current total cost is greater than <i>cost</i>, some objects are deleted immediately.</p>
<p><b> 参见 </b><a href="qcache.html#maxCost">maxCost</a>() 和 <a href="qcache.html#totalCost">totalCost</a>().</p>
<!-- @@@setMaxCost -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><a name="size"></a><span class="type">int</span> QCache::<span class="name">size</span>() const</h3>
<p>返回缓存中所有对象的数量。</p>
<p><b> 参见 </b><a href="qcache.html#isEmpty">isEmpty</a>().</p>
<!-- @@@size -->
<!-- $$$take[overload1]$$$takeconstKey& -->
<h3 class="fn" id="take"><a name="take"></a><span class="type">T</span> *QCache::<span class="name">take</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>从缓存中取走关键字为<i>key</i>关联的对象，但不会delete此对象。 返回被取走对象的指针，若缓存中不存在此关键字则返回0。</p>
<p>返回对象的所有权将传递给调用值。</p>
<p><b> 参见 </b><a href="qcache.html#remove">remove</a>().</p>
<!-- @@@take -->
<!-- $$$totalCost[overload1]$$$totalCost -->
<h3 class="fn" id="totalCost"><a name="totalCost"></a><span class="type">int</span> QCache::<span class="name">totalCost</span>() const</h3>
<p>返回缓存中所有对象的总成本数量。</p>
<p>This value is normally below <a href="qcache.html#maxCost">maxCost</a>(), but <a href="qcache.html">QCache</a> makes an exception for Qt's <a href="implicit-sharing.html">implicitly shared</a> classes. If a cached object shares its internal data with another instance, <a href="qcache.html">QCache</a> may keep the object lying around, possibly contributing to making totalCost() larger than <a href="qcache.html#maxCost">maxCost</a>().</p>
<p><b> 参见 </b><a href="qcache.html#setMaxCost">setMaxCost</a>().</p>
<!-- @@@totalCost -->
<!-- $$$operator[][overload1]$$$operator[]constKey& -->
<h3 class="fn" id="operator-5b-5d"><a name="operator-5b-5d"></a><span class="type">T</span> *QCache::<span class="name">operator[]</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>返回关键字为<i>key</i>的关联对象，若缓存中不存在此关键字则返回0。</p>
<p>此函数等同于 <a href="qcache.html#object">object</a>().</p>
<p><b>警告：</b> 返回对象属于 <a href="qcache.html">QCache</a>，因此有可能在任何时间被缓存删除了。 </p>
<!-- @@@operator[] -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
