<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qalgorithms.qdoc -->
  <title>Obsolete Members for &lt;QtAlgorithms&gt; | Qt核心模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtcore-index.html">Qt核心</a></td><td >Obsolete Members for &lt;QtAlgorithms&gt;</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar"><div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Obsolete Members for &lt;QtAlgorithms&gt;</h1>
<p><b>The following members of class <a href="qtalgorithms.html">&lt;QtAlgorithms&gt;</a> are obsolete.</b> They are provided to keep old source code working. We strongly advise against using them in new code.</p>
<h2>函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qBinaryFind-1">qBinaryFind</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>typename Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qBinaryFind-2">qBinaryFind</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>OutputIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qCopy">qCopy</a></b>(InputIterator <i>begin1</i>, InputIterator <i>end1</i>, OutputIterator <i>begin2</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>BiIterator2 </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qCopyBackward">qCopyBackward</a></b>(BiIterator1 <i>begin1</i>, BiIterator1 <i>end1</i>, BiIterator2 <i>end2</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qCount">qCount</a></b>(InputIterator <i>begin</i>, InputIterator <i>end</i>, const T &amp;<i>value</i>, Size &amp;<i>n</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qCount-1">qCount</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>, Size &amp;<i>n</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>bool </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qEqual">qEqual</a></b>(InputIterator1 <i>begin1</i>, InputIterator1 <i>end1</i>, InputIterator2 <i>begin2</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qFill">qFill</a></b>(ForwardIterator <i>begin</i>, ForwardIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qFill-1">qFill</a></b>(Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>InputIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qFind">qFind</a></b>(InputIterator <i>begin</i>, InputIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>typename Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qFind-1">qFind</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>LessThan </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qGreater">qGreater</a></b>()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>LessThan </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qLess">qLess</a></b>()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qLowerBound-1">qLowerBound</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>typename Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qLowerBound-2">qLowerBound</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qSort">qSort</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qSort-1">qSort</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qSort-2">qSort</a></b>(Container &amp;<i>container</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qStableSort-1">qStableSort</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qStableSort-2">qStableSort</a></b>(Container &amp;<i>container</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qSwap-1">qSwap</a></b>(T &amp;<i>var1</i>, T &amp;<i>var2</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qUpperBound-1">qUpperBound</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>typename Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qUpperBound-2">qUpperBound</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
</table></div>
<h2>函数文档</h2>
<!-- $$$qBinaryFind[overload1]$$$qBinaryFindRandomAccessIteratorRandomAccessIteratorconstT& -->
<h3 class="fn" id="qBinaryFind"><a name="qBinaryFind"></a><span class="type">RandomAccessIterator</span> <span class="name">qBinaryFind</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::binary_search</code> or <code>std::lower_bound</code> instead.</p>
<p>Performs a binary search of the range [<i>begin</i>, <i>end</i>) and returns the position of an occurrence of <i>value</i>. If there are no occurrences of <i>value</i>, returns <i>end</i>.</p>
<p>The items in the range [<i>begin</i>, <i>end</i>) must be sorted in ascending order; see <a href="qtalgorithms-obsolete.html#qSort">qSort</a>().</p>
<p>If there are many occurrences of the same value, any one of them could be returned. Use <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>() or <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>() if you need finer control.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vect;
  vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span>
          qBinaryFind(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);
  <span class="comment">// i == vect.begin() + 2 (or 3 or 4)</span>

</pre>
<p>This function requires the item type (in the example above, <a href="qstring.html">QString</a>) to implement <code>operator&lt;()</code>.</p>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>(), <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>(), 和 <a href="qtalgorithms.html#random-access-iterators">random access iterators</a>.</p>
<!-- @@@qBinaryFind -->
<!-- $$$qBinaryFind$$$qBinaryFindRandomAccessIteratorRandomAccessIteratorconstT&LessThan -->
<h3 class="fn" id="qBinaryFind-1"><a name="qBinaryFind-1"></a><span class="type">RandomAccessIterator</span> <span class="name">qBinaryFind</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::binary_search</code> or <code>std::lower_bound</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>Note that the items in the range must be sorted according to the order specified by the <i>lessThan</i> object.</p>
<!-- @@@qBinaryFind -->
<!-- $$$qBinaryFind$$$qBinaryFindconstContainer&constT& -->
<h3 class="fn" id="qBinaryFind-2"><a name="qBinaryFind-2"></a><span class="type">typename</span> <span class="type">Container::const_iterator</span> <span class="name">qBinaryFind</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::binary_search</code> or <code>std::lower_bound</code> instead.</p>
<p>此函数等同于 <a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>(<i>container</i>.begin(), <i>container</i>.end(), <i>value</i>);</p>
<!-- @@@qBinaryFind -->
<!-- $$$qCopy[overload1]$$$qCopyInputIteratorInputIteratorOutputIterator -->
<h3 class="fn" id="qCopy"><a name="qCopy"></a><span class="type">OutputIterator</span> <span class="name">qCopy</span>(<span class="type">InputIterator</span> <i>begin1</i>, <span class="type">InputIterator</span> <i>end1</i>, <span class="type">OutputIterator</span> <i>begin2</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::copy</code> instead.</p>
<p>Copies the items from range [<i>begin1</i>, <i>end1</i>) to range [<i>begin2</i>, ..&#x2e;), in the order in which they appear.</p>
<p>The item at position <i>begin1</i> is assigned to that at position <i>begin2</i>; the item at position <i>begin1</i> + 1 is assigned to that at position <i>begin2</i> + 1; and so on.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect1(<span class="number">3</span>);
  qCopy(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect1<span class="operator">.</span>begin());
  <span class="comment">// vect: [ &quot;one&quot;, &quot;two&quot;, &quot;three&quot; ]</span>

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect2(<span class="number">8</span>);
  qCopy(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect2<span class="operator">.</span>begin() <span class="operator">+</span> <span class="number">2</span>);
  <span class="comment">// vect: [ &quot;&quot;, &quot;&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; ]</span>

</pre>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qCopyBackward">qCopyBackward</a>(), <a href="qtalgorithms.html#input-iterators">input iterators</a>, 和 <a href="qtalgorithms.html#output-iterators">output iterators</a>.</p>
<!-- @@@qCopy -->
<!-- $$$qCopyBackward[overload1]$$$qCopyBackwardBiIterator1BiIterator1BiIterator2 -->
<h3 class="fn" id="qCopyBackward"><a name="qCopyBackward"></a><span class="type">BiIterator2</span> <span class="name">qCopyBackward</span>(<span class="type">BiIterator1</span> <i>begin1</i>, <span class="type">BiIterator1</span> <i>end1</i>, <span class="type">BiIterator2</span> <i>end2</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::copy_backward</code> instead.</p>
<p>Copies the items from range [<i>begin1</i>, <i>end1</i>) to range [..&#x2e;, <i>end2</i>).</p>
<p>The item at position <i>end1</i> - 1 is assigned to that at position <i>end2</i> - 1; the item at position <i>end1</i> - 2 is assigned to that at position <i>end2</i> - 2; and so on.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect(<span class="number">5</span>);
  qCopyBackward(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect<span class="operator">.</span>end());
  <span class="comment">// vect: [ &quot;&quot;, &quot;&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot; ]</span>

</pre>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qCopy">qCopy</a>() 和 <a href="qtalgorithms.html#bidirectional-iterators">bidirectional iterators</a>.</p>
<!-- @@@qCopyBackward -->
<!-- $$$qCount[overload1]$$$qCountInputIteratorInputIteratorconstT&Size& -->
<h3 class="fn" id="qCount"><a name="qCount"></a><span class="type">void</span> <span class="name">qCount</span>(<span class="type">InputIterator</span> <i>begin</i>, <span class="type">InputIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">Size</span> &amp;<i>n</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::count</code> instead.</p>
<p>Returns the number of occurrences of <i>value</i> in the range [<i>begin</i>, <i>end</i>), which is returned in <i>n</i>. <i>n</i> is never initialized, the count is added to <i>n</i>. It is the caller's responsibility to initialize <i>n</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

  <span class="type">int</span> countOf6 <span class="operator">=</span> <span class="number">0</span>;
  qCount(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> countOf6);
  <span class="comment">// countOf6 == 3</span>

  <span class="type">int</span> countOf7 <span class="operator">=</span> <span class="number">0</span>;
  qCount(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> countOf7);
  <span class="comment">// countOf7 == 0</span>

</pre>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qtalgorithms.html#input-iterators">input iterators</a>.</p>
<!-- @@@qCount -->
<!-- $$$qCount$$$qCountconstContainer&constT&Size& -->
<h3 class="fn" id="qCount-1"><a name="qCount-1"></a><span class="type">void</span> <span class="name">qCount</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">Size</span> &amp;<i>n</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::count</code> instead.</p>
<p>Instead of operating on iterators, as in the other overload, this function operates on the specified <i>container</i> to obtain the number of instances of <i>value</i> in the variable passed as a reference in argument <i>n</i>.</p>
<!-- @@@qCount -->
<!-- $$$qEqual[overload1]$$$qEqualInputIterator1InputIterator1InputIterator2 -->
<h3 class="fn" id="qEqual"><a name="qEqual"></a><span class="type">bool</span> <span class="name">qEqual</span>(<span class="type">InputIterator1</span> <i>begin1</i>, <span class="type">InputIterator1</span> <i>end1</i>, <span class="type">InputIterator2</span> <i>begin2</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::equal</code> instead.</p>
<p>Compares the items in the range [<i>begin1</i>, <i>end1</i>) with the items in the range [<i>begin2</i>, ..&#x2e;)&#x2e; Returns <code>true</code> if all the items compare equal; otherwise returns <code>false</code>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect(<span class="number">3</span>);
  vect<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;one&quot;</span>;
  vect<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;two&quot;</span>;
  vect<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;three&quot;</span>;

  bool ret1 <span class="operator">=</span> qEqual(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect<span class="operator">.</span>begin());
  <span class="comment">// ret1 == true</span>

  vect<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;seven&quot;</span>;
  bool ret2 <span class="operator">=</span> qEqual(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect<span class="operator">.</span>begin());
  <span class="comment">// ret2 == false</span>

</pre>
<p>This function requires the item type (in the example above, <a href="qstring.html">QString</a>) to implement <code>operator==()</code>.</p>
<p><b> 参见 </b><a href="qtalgorithms.html#input-iterators">input iterators</a>.</p>
<!-- @@@qEqual -->
<!-- $$$qFill[overload1]$$$qFillForwardIteratorForwardIteratorconstT& -->
<h3 class="fn" id="qFill"><a name="qFill"></a><span class="type">void</span> <span class="name">qFill</span>(<span class="type">ForwardIterator</span> <i>begin</i>, <span class="type">ForwardIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::fill</code> instead.</p>
<p>Fills the range [<i>begin</i>, <i>end</i>) with <i>value</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  qFill(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;eleven&quot;</span>);
  <span class="comment">// list: [ &quot;eleven&quot;, &quot;eleven&quot;, &quot;eleven&quot; ]</span>

  qFill(list<span class="operator">.</span>begin() <span class="operator">+</span> <span class="number">1</span><span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;six&quot;</span>);
  <span class="comment">// list: [ &quot;eleven&quot;, &quot;six&quot;, &quot;six&quot; ]</span>

</pre>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qCopy">qCopy</a>() 和 <a href="qtalgorithms.html#forward-iterators">forward iterators</a>.</p>
<!-- @@@qFill -->
<!-- $$$qFill$$$qFillContainer&constT& -->
<h3 class="fn" id="qFill-1"><a name="qFill-1"></a><span class="type">void</span> <span class="name">qFill</span>(<span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::fill</code> instead.</p>
<p>此函数等同于 <a href="qtalgorithms-obsolete.html#qFill">qFill</a>(<i>container</i>.begin(), <i>container</i>.end(), <i>value</i>);</p>
<!-- @@@qFill -->
<!-- $$$qFind[overload1]$$$qFindInputIteratorInputIteratorconstT& -->
<h3 class="fn" id="qFind"><a name="qFind"></a><span class="type">InputIterator</span> <span class="name">qFind</span>(<span class="type">InputIterator</span> <i>begin</i>, <span class="type">InputIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::find</code> instead.</p>
<p>Returns an iterator to the first occurrence of <i>value</i> in a container in the range [<i>begin</i>, <i>end</i>). Returns <i>end</i> if <i>value</i> isn't found.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  <span class="type"><a href="qstringlist.html">QStringList</a></span><span class="operator">::</span>iterator i1 <span class="operator">=</span> qFind(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;two&quot;</span>);
  <span class="comment">// i1 == list.begin() + 1</span>

  <span class="type"><a href="qstringlist.html">QStringList</a></span><span class="operator">::</span>iterator i2 <span class="operator">=</span> qFind(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;seventy&quot;</span>);
  <span class="comment">// i2 == list.end()</span>

</pre>
<p>This function requires the item type (in the example above, <a href="qstring.html">QString</a>) to implement <code>operator==()</code>.</p>
<p>If the items in the range are in ascending order, you can get faster results by using <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>() or <a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>() instead of qFind().</p>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>() 和 <a href="qtalgorithms.html#input-iterators">input iterators</a>.</p>
<!-- @@@qFind -->
<!-- $$$qFind$$$qFindconstContainer&constT& -->
<h3 class="fn" id="qFind-1"><a name="qFind-1"></a><span class="type">typename</span> <span class="type">Container::const_iterator</span> <span class="name">qFind</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::find</code> instead.</p>
<p>此函数等同于 <a href="qtalgorithms-obsolete.html#qFind">qFind</a>(<i>container</i>.constBegin(), <i>container</i>.constEnd(), <i>value</i>);</p>
<!-- @@@qFind -->
<!-- $$$qGreater[overload1]$$$qGreater -->
<h3 class="fn" id="qGreater"><a name="qGreater"></a><span class="type">LessThan</span> <span class="name">qGreater</span>()</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::greater</code> instead.</p>
<p>Returns a functional object, or functor, that can be passed to <a href="qtalgorithms-obsolete.html#qSort">qSort</a>() or <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>().</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> qGreater<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
  <span class="comment">// list: [ 68, 33, 12, 12, 6 ]</span>

</pre>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qLess">qLess&lt;T&gt;</a>().</p>
<!-- @@@qGreater -->
<!-- $$$qLess[overload1]$$$qLess -->
<h3 class="fn" id="qLess"><a name="qLess"></a><span class="type">LessThan</span> <span class="name">qLess</span>()</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::less</code> instead.</p>
<p>Returns a functional object, or functor, that can be passed to <a href="qtalgorithms-obsolete.html#qSort">qSort</a>() or <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>().</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> qLess<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
  <span class="comment">// list: [ 6, 12, 12, 33, 68 ]</span>

</pre>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qGreater">qGreater&lt;T&gt;</a>().</p>
<!-- @@@qLess -->
<!-- $$$qLowerBound[overload1]$$$qLowerBoundRandomAccessIteratorRandomAccessIteratorconstT& -->
<h3 class="fn" id="qLowerBound"><a name="qLowerBound"></a><span class="type">RandomAccessIterator</span> <span class="name">qLowerBound</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::lower_bound</code> instead.</p>
<p>Performs a binary search of the range [<i>begin</i>, <i>end</i>) and returns the position of the first occurrence of <i>value</i>. If no such item is found, returns the position where it should be inserted.</p>
<p>The items in the range [<i>begin</i>, <i>end</i>) must be sorted in ascending order; see <a href="qtalgorithms-obsolete.html#qSort">qSort</a>().</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> qLowerBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">5</span>);
  list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">5</span>);
  <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8 ]</span>

  i <span class="operator">=</span> qLowerBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">12</span>);
  list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">12</span>);
  <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]</span>

</pre>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator&lt;()</code>.</p>
<p>qLowerBound() can be used in conjunction with <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>() to iterate over all occurrences of the same value:</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vect;
  vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;
  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator begin6 <span class="operator">=</span>
          qLowerBound(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);
  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator end6 <span class="operator">=</span>
          <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>(begin6<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> begin6;
  <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> end6) {
      <span class="operator">*</span>i <span class="operator">=</span> <span class="number">7</span>;
      <span class="operator">+</span><span class="operator">+</span>i;
  }
  <span class="comment">// vect: [ 3, 3, 7, 7, 7, 8 ]</span>

</pre>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>() 和 <a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>().</p>
<!-- @@@qLowerBound -->
<!-- $$$qLowerBound$$$qLowerBoundRandomAccessIteratorRandomAccessIteratorconstT&LessThan -->
<h3 class="fn" id="qLowerBound-1"><a name="qLowerBound-1"></a><span class="type">RandomAccessIterator</span> <span class="name">qLowerBound</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::lower_bound</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>Note that the items in the range must be sorted according to the order specified by the <i>lessThan</i> object.</p>
<!-- @@@qLowerBound -->
<!-- $$$qLowerBound$$$qLowerBoundconstContainer&constT& -->
<h3 class="fn" id="qLowerBound-2"><a name="qLowerBound-2"></a><span class="type">typename</span> <span class="type">Container::const_iterator</span> <span class="name">qLowerBound</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::lower_bound</code> instead.</p>
<p>For read-only iteration over containers, this function is broadly equivalent to <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>(<i>container</i>.begin(), <i>container</i>.end(), value). However, since it returns a const iterator, you cannot use it to modify the container; for example, to insert items.</p>
<!-- @@@qLowerBound -->
<!-- $$$qSort[overload1]$$$qSortRandomAccessIteratorRandomAccessIterator -->
<h3 class="fn" id="qSort"><a name="qSort"></a><span class="type">void</span> <span class="name">qSort</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::sort</code> instead.</p>
<p>Sorts the items in range [<i>begin</i>, <i>end</i>) in ascending order using the quicksort algorithm.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  qSort(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end());
  <span class="comment">// list: [ 6, 12, 12, 33, 68 ]</span>

</pre>
<p>The sort algorithm is efficient on large data sets. It operates in <a href="containers.html#linear-logarithmic-time">linear-logarithmic time</a>, O(<i>n</i> log <i>n</i>).</p>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator&lt;()</code>.</p>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. It is then undefined which one of the two items will appear before the other after the sort.</p>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>() 和 <a href="qtalgorithms.html#random-access-iterators">random access iterators</a>.</p>
<!-- @@@qSort -->
<!-- $$$qSort$$$qSortRandomAccessIteratorRandomAccessIteratorLessThan -->
<h3 class="fn" id="qSort-1"><a name="qSort-1"></a><span class="type">void</span> <span class="name">qSort</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::sort</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>For example, here's how to sort the strings in a <a href="qstringlist.html">QStringList</a> in case-insensitive alphabetical order:</p>
<pre class="cpp">

  bool caseInsensitiveLessThan(<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s1<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s2)
  {
      <span class="keyword">return</span> s1<span class="operator">.</span>toLower() <span class="operator">&lt;</span> s2<span class="operator">.</span>toLower();
  }

  <span class="type">int</span> doSomething()
  {
      <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
      list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;AlPha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beTA&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;gamma&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;DELTA&quot;</span>;
      <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> caseInsensitiveLessThan);
      <span class="comment">// list: [ &quot;AlPha&quot;, &quot;beTA&quot;, &quot;DELTA&quot;, &quot;gamma&quot; ]</span>
  }

</pre>
<p>To sort values in reverse order, pass <a href="qtalgorithms-obsolete.html#qGreater">qGreater&lt;T&gt;</a>() as the <i>lessThan</i> parameter. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <a href="qtalgorithms-obsolete.html#qGreater">qGreater</a><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
  <span class="comment">// list: [ 68, 33, 12, 12, 6 ]</span>

</pre>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. It is then undefined which one of the two items will appear before the other after the sort.</p>
<p>An alternative to using <a href="qtalgorithms-obsolete.html#qSort">qSort</a>() is to put the items to sort in a <a href="qmap.html">QMap</a>, using the sort key as the <a href="qmap.html">QMap</a> key. This is often more convenient than defining a <i>lessThan</i> function. For example, the following code shows how to sort a list of strings case insensitively using <a href="qmap.html">QMap</a>:</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;AlPha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beTA&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;gamma&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;DELTA&quot;</span>;

  <span class="type"><a href="qmap.html">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">,</span> <span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> map;
  foreach (<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>str<span class="operator">,</span> list)
      map<span class="operator">.</span>insert(str<span class="operator">.</span>toLower()<span class="operator">,</span> str);

  list <span class="operator">=</span> map<span class="operator">.</span>values();

</pre>
<p><b> 参见 </b><a href="qmap.html">QMap</a>.</p>
<!-- @@@qSort -->
<!-- $$$qSort$$$qSortContainer& -->
<h3 class="fn" id="qSort-2"><a name="qSort-2"></a><span class="type">void</span> <span class="name">qSort</span>(<span class="type">Container</span> &amp;<i>container</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::sort</code> instead.</p>
<p>此函数等同于 <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(<i>container</i>.begin(), <i>container</i>.end());</p>
<!-- @@@qSort -->
<!-- $$$qStableSort[overload1]$$$qStableSortRandomAccessIteratorRandomAccessIterator -->
<h3 class="fn" id="qStableSort"><a name="qStableSort"></a><span class="type">void</span> <span class="name">qStableSort</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::stable_sort</code> instead.</p>
<p>Sorts the items in range [<i>begin</i>, <i>end</i>) in ascending order using a stable sorting algorithm.</p>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. The item that appeared before the other in the original container will still appear first after the sort. This property is often useful when sorting user-visible data.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  qStableSort(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end());
  <span class="comment">// list: [ 6, 12, 12, 33, 68 ]</span>

</pre>
<p>The sort algorithm is efficient on large data sets. It operates in <a href="containers.html#linear-logarithmic-time">linear-logarithmic time</a>, O(<i>n</i> log <i>n</i>).</p>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator&lt;()</code>.</p>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qSort">qSort</a>() 和 <a href="qtalgorithms.html#random-access-iterators">random access iterators</a>.</p>
<!-- @@@qStableSort -->
<!-- $$$qStableSort$$$qStableSortRandomAccessIteratorRandomAccessIteratorLessThan -->
<h3 class="fn" id="qStableSort-1"><a name="qStableSort-1"></a><span class="type">void</span> <span class="name">qStableSort</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::stable_sort</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>For example, here's how to sort the strings in a <a href="qstringlist.html">QStringList</a> in case-insensitive alphabetical order:</p>
<pre class="cpp">

  bool caseInsensitiveLessThan(<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s1<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s2)
  {
      <span class="keyword">return</span> s1<span class="operator">.</span>toLower() <span class="operator">&lt;</span> s2<span class="operator">.</span>toLower();
  }

  <span class="type">int</span> doSomething()
  {
      <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
      list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;AlPha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beTA&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;gamma&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;DELTA&quot;</span>;
      <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> caseInsensitiveLessThan);
      <span class="comment">// list: [ &quot;AlPha&quot;, &quot;beTA&quot;, &quot;DELTA&quot;, &quot;gamma&quot; ]</span>
  }

</pre>
<p>Note that earlier versions of Qt allowed using a lessThan function that took its arguments by non-const reference. From 4.3 and on this is no longer possible, the arguments has to be passed by const reference or value.</p>
<p>To sort values in reverse order, pass <a href="qtalgorithms-obsolete.html#qGreater">qGreater&lt;T&gt;</a>() as the <i>lessThan</i> parameter. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <a href="qtalgorithms-obsolete.html#qGreater">qGreater</a><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
  <span class="comment">// list: [ 68, 33, 12, 12, 6 ]</span>

</pre>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. The item that appeared before the other in the original container will still appear first after the sort. This property is often useful when sorting user-visible data.</p>
<!-- @@@qStableSort -->
<!-- $$$qStableSort$$$qStableSortContainer& -->
<h3 class="fn" id="qStableSort-2"><a name="qStableSort-2"></a><span class="type">void</span> <span class="name">qStableSort</span>(<span class="type">Container</span> &amp;<i>container</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::stable_sort</code> instead.</p>
<p>此函数等同于 <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>(<i>container</i>.begin(), <i>container</i>.end());</p>
<!-- @@@qStableSort -->
<!-- $$$qSwap$$$qSwapT&T& -->
<h3 class="fn" id="qSwap-1"><a name="qSwap-1"></a><span class="type">void</span> <span class="name">qSwap</span>(<span class="type">T</span> &amp;<i>var1</i>, <span class="type">T</span> &amp;<i>var2</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::swap</code> instead.</p>
<p>Exchanges the values of variables <i>var1</i> and <i>var2</i>.</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type">double</span> pi <span class="operator">=</span> <span class="number">3.14</span>;
  <span class="type">double</span> e <span class="operator">=</span> <span class="number">2.71</span>;

  qSwap(pi<span class="operator">,</span> e);
  <span class="comment">// pi == 2.71, e == 3.14</span>

</pre>
<!-- @@@qSwap -->
<!-- $$$qUpperBound[overload1]$$$qUpperBoundRandomAccessIteratorRandomAccessIteratorconstT& -->
<h3 class="fn" id="qUpperBound"><a name="qUpperBound"></a><span class="type">RandomAccessIterator</span> <span class="name">qUpperBound</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>Use <code>std::upper_bound</code> instead.</p>
<p>Performs a binary search of the range [<i>begin</i>, <i>end</i>) and returns the position of the one-past-the-last occurrence of <i>value</i>. If no such item is found, returns the position where the item should be inserted.</p>
<p>The items in the range [<i>begin</i>, <i>end</i>) must be sorted in ascending order; see <a href="qtalgorithms-obsolete.html#qSort">qSort</a>().</p>
<p>样例：</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> qUpperBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">5</span>);
  list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">5</span>);
  <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8 ]</span>

  i <span class="operator">=</span> qUpperBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">12</span>);
  list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">12</span>);
  <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]</span>

</pre>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator&lt;()</code>.</p>
<p>qUpperBound() can be used in conjunction with <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>() to iterate over all occurrences of the same value:</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vect;
  vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;
  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator begin6 <span class="operator">=</span>
          <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);
  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator end6 <span class="operator">=</span>
          qUpperBound(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> begin6;
  <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> end6) {
      <span class="operator">*</span>i <span class="operator">=</span> <span class="number">7</span>;
      <span class="operator">+</span><span class="operator">+</span>i;
  }
  <span class="comment">// vect: [ 3, 3, 7, 7, 7, 8 ]</span>

</pre>
<p><b> 参见 </b><a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>() 和 <a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>().</p>
<!-- @@@qUpperBound -->
<!-- $$$qUpperBound$$$qUpperBoundRandomAccessIteratorRandomAccessIteratorconstT&LessThan -->
<h3 class="fn" id="qUpperBound-1"><a name="qUpperBound-1"></a><span class="type">RandomAccessIterator</span> <span class="name">qUpperBound</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::upper_bound</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>Note that the items in the range must be sorted according to the order specified by the <i>lessThan</i> object.</p>
<!-- @@@qUpperBound -->
<!-- $$$qUpperBound$$$qUpperBoundconstContainer&constT& -->
<h3 class="fn" id="qUpperBound-2"><a name="qUpperBound-2"></a><span class="type">typename</span> <span class="type">Container::const_iterator</span> <span class="name">qUpperBound</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>这是一个重载函数。</p>
<p>Use <code>std::upper_bound</code> instead.</p>
<p>此函数等同于 <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>(<i>container</i>.begin(), <i>container</i>.end(), <i>value</i>);</p>
<!-- @@@qUpperBound -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
