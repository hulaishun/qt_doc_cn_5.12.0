<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- collidingmice-example.qdoc -->
  <title>Colliding Mice Example | Qt部件模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtwidgets-index.html">Qt部件</a></td><td >Colliding Mice Example</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#mouse-class-definition">Mouse Class Definition</a></li>
<li class="level1"><a href="#mouse-class-definition">Mouse Class Definition</a></li>
<li class="level1"><a href="#the-main-function">The Main() Function</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Colliding Mice Example</h1>
<span class="subtitle"></span>
<!-- $$$graphicsview/collidingmice-brief -->
<p>Demonstrates how to animate items on a graphics view.</p>
<!-- @@@graphicsview/collidingmice -->
<!-- $$$graphicsview/collidingmice-description -->
<div class="descr"> <a name="details"></a>
<p>The Colliding Mice example shows how to use the Graphics View framework to implement animated items and detect collision between items.</p>
<p class="centerAlign"><img src="images/collidingmice-example.png" alt="" /></p><p>Graphics View provides the <a href="qgraphicsscene.html">QGraphicsScene</a> class for managing and interacting with a large number of custom-made 2D graphical items derived from the <a href="qgraphicsitem.html">QGraphicsItem</a> class, and a <a href="qgraphicsview.html">QGraphicsView</a> widget for visualizing the items, with support for zooming and rotation.</p>
<p>The example consists of an item class and a main function: the <code>Mouse</code> class represents the individual mice extending <a href="qgraphicsitem.html">QGraphicsItem</a>, and the <code>main()</code> function provides the main application window.</p>
<p>We will first review the <code>Mouse</code> class to see how to animate items and detect item collisions, and then we will review the <code>main()</code> function to see how to put the items into a scene and how to implement the corresponding view.</p>
<a name="mouse-class-definition"></a>
<h2 id="mouse-class-definition">Mouse Class Definition</h2>
<p>The <code>mouse</code> class inherits from <a href="qgraphicsitem.html">QGraphicsItem</a>. The <a href="qgraphicsitem.html">QGraphicsItem</a> class is the base class for all graphical items in the Graphics View framework, and provides a light-weight foundation for writing your own custom items.</p>
<pre class="cpp">

  <span class="keyword">class</span> Mouse : <span class="keyword">public</span> <span class="type"><a href="qgraphicsitem.html">QGraphicsItem</a></span>
  {
  <span class="keyword">public</span>:
      Mouse();

      <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> boundingRect() <span class="keyword">const</span> override;
      <span class="type"><a href="../qtgui/qpainterpath.html">QPainterPath</a></span> shape() <span class="keyword">const</span> override;
      <span class="type">void</span> paint(<span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstyleoptiongraphicsitem.html">QStyleOptionGraphicsItem</a></span> <span class="operator">*</span>option<span class="operator">,</span>
                 <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget) override;

  <span class="keyword">protected</span>:
      <span class="type">void</span> advance(<span class="type">int</span> step) override;

  <span class="keyword">private</span>:
      <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> angle;
      <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> speed;
      <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> mouseEyeDirection;
      <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> color;
  };

</pre>
<p>When writing a custom graphics item, you must implement <a href="qgraphicsitem.html">QGraphicsItem</a>'s two pure virtual public functions: <a href="qgraphicsitem.html#boundingRect">boundingRect()</a>, which returns an estimate of the area painted by the item, and <a href="qgraphicsitem.html#paint">paint()</a>, which implements the actual painting. In addition, we reimplement the <a href="qgraphicsitem.html#shape">shape()</a> 和 <a href="qgraphicsitem.html#advance">advance()</a>. We reimplement <a href="qgraphicsitem.html#shape">shape()</a> to return an accurate shape of our mouse item; the default implementation simply returns the item's bounding rectangle. We reimplement <a href="qgraphicsitem.html#advance">advance()</a> to handle the animation so it all happens on one update.</p>
<a name="mouse-class-definition"></a>
<h2 id="mouse-class-definition">Mouse Class Definition</h2>
<p>When constructing a mouse item, we first ensure that all the item's private variables are properly initialized:</p>
<pre class="cpp">

  Mouse<span class="operator">::</span>Mouse()
      : angle(<span class="number">0</span>)<span class="operator">,</span> speed(<span class="number">0</span>)<span class="operator">,</span> mouseEyeDirection(<span class="number">0</span>)<span class="operator">,</span>
        color(<span class="type"><a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">256</span>)<span class="operator">,</span> <span class="type"><a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">256</span>)<span class="operator">,</span> <span class="type"><a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">256</span>))
  {
      setRotation(<span class="type"><a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">360</span> <span class="operator">*</span> <span class="number">16</span>));
  }

</pre>
<p>To calculate the various components of the mouse's color, we use <a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a>.</p>
<p>Then we call the <a href="qgraphicsitem.html#setRotation">setRotation()</a> function inherited from <a href="qgraphicsitem.html">QGraphicsItem</a>. Items live in their own local coordinate system. Their coordinates are usually centered around (0, 0), and this is also the center for all transformations. By calling the item's <a href="qgraphicsitem.html#setRotation">setRotation()</a> function we alter the direction in which the mouse will start moving.</p>
<p>When the <a href="qgraphicsscene.html">QGraphicsScene</a> decides to advance the scene by a frame, it will call <a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>() on each of the items. This enables us to animate our mouse using our reimplementation of the advance() function.</p>
<pre class="cpp">

  <span class="type">void</span> Mouse<span class="operator">::</span>advance(<span class="type">int</span> step)
  {
      <span class="keyword">if</span> (<span class="operator">!</span>step)
          <span class="keyword">return</span>;
      <span class="type"><a href="../qtcore/qlinef.html">QLineF</a></span> lineToCenter(<span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span>(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span>)<span class="operator">,</span> mapFromScene(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span>));
      <span class="keyword">if</span> (lineToCenter<span class="operator">.</span>length() <span class="operator">&gt;</span> <span class="number">150</span>) {
          <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> angleToCenter <span class="operator">=</span> std<span class="operator">::</span>atan2(lineToCenter<span class="operator">.</span>dy()<span class="operator">,</span> lineToCenter<span class="operator">.</span>dx());
          angleToCenter <span class="operator">=</span> normalizeAngle((Pi <span class="operator">-</span> angleToCenter) <span class="operator">+</span> Pi <span class="operator">/</span> <span class="number">2</span>);

          <span class="keyword">if</span> (angleToCenter <span class="operator">&lt;</span> Pi <span class="operator">&amp;</span><span class="operator">&amp;</span> angleToCenter <span class="operator">&gt;</span> Pi <span class="operator">/</span> <span class="number">4</span>) {
              <span class="comment">// Rotate left</span>
              angle <span class="operator">+</span><span class="operator">=</span> (angle <span class="operator">&lt;</span> <span class="operator">-</span>Pi <span class="operator">/</span> <span class="number">2</span>) <span class="operator">?</span> <span class="number">0.25</span> : <span class="operator">-</span><span class="number">0.25</span>;
          } <span class="keyword">else</span> <span class="keyword">if</span> (angleToCenter <span class="operator">&gt;</span><span class="operator">=</span> Pi <span class="operator">&amp;</span><span class="operator">&amp;</span> angleToCenter <span class="operator">&lt;</span> (Pi <span class="operator">+</span> Pi <span class="operator">/</span> <span class="number">2</span> <span class="operator">+</span> Pi <span class="operator">/</span> <span class="number">4</span>)) {
              <span class="comment">// Rotate right</span>
              angle <span class="operator">+</span><span class="operator">=</span> (angle <span class="operator">&lt;</span> Pi <span class="operator">/</span> <span class="number">2</span>) <span class="operator">?</span> <span class="number">0.25</span> : <span class="operator">-</span><span class="number">0.25</span>;
          }
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="operator">::</span>sin(angle) <span class="operator">&lt;</span> <span class="number">0</span>) {
          angle <span class="operator">+</span><span class="operator">=</span> <span class="number">0.25</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="operator">::</span>sin(angle) <span class="operator">&gt;</span> <span class="number">0</span>) {
          angle <span class="operator">-</span><span class="operator">=</span> <span class="number">0.25</span>;
      }

</pre>
<p>First, we don't bother doing any advance if the step is <code>0</code>. This is because advance() is called twice: once with step == <code>0</code>, indicating that items are about to advance, and then with step == <code>1</code> for the actual advance. We also ensure that the mouse stays within a circle with a radius of 150 pixels.</p>
<p>Note the <a href="qgraphicsitem.html#mapFromScene">mapFromScene()</a> function provided by <a href="qgraphicsitem.html">QGraphicsItem</a>. This function maps a position given in <i>scene</i> coordinates, to the item's coordinate system.</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qgraphicsitem.html">QGraphicsItem</a></span> <span class="operator">*</span><span class="operator">&gt;</span> dangerMice <span class="operator">=</span> scene()<span class="operator">-</span><span class="operator">&gt;</span>items(<span class="type"><a href="../qtgui/qpolygonf.html">QPolygonF</a></span>()
                                                         <span class="operator">&lt;</span><span class="operator">&lt;</span> mapToScene(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span>)
                                                         <span class="operator">&lt;</span><span class="operator">&lt;</span> mapToScene(<span class="operator">-</span><span class="number">30</span><span class="operator">,</span> <span class="operator">-</span><span class="number">50</span>)
                                                         <span class="operator">&lt;</span><span class="operator">&lt;</span> mapToScene(<span class="number">30</span><span class="operator">,</span> <span class="operator">-</span><span class="number">50</span>));
      foreach (<span class="type"><a href="qgraphicsitem.html">QGraphicsItem</a></span> <span class="operator">*</span>item<span class="operator">,</span> dangerMice) {
          <span class="keyword">if</span> (item <span class="operator">=</span><span class="operator">=</span> <span class="keyword">this</span>)
              <span class="keyword">continue</span>;

          <span class="type"><a href="../qtcore/qlinef.html">QLineF</a></span> lineToMouse(<span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span>(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span>)<span class="operator">,</span> mapFromItem(item<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span>));
          <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> angleToMouse <span class="operator">=</span> std<span class="operator">::</span>atan2(lineToMouse<span class="operator">.</span>dy()<span class="operator">,</span> lineToMouse<span class="operator">.</span>dx());
          angleToMouse <span class="operator">=</span> normalizeAngle((Pi <span class="operator">-</span> angleToMouse) <span class="operator">+</span> Pi <span class="operator">/</span> <span class="number">2</span>);

          <span class="keyword">if</span> (angleToMouse <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> angleToMouse <span class="operator">&lt;</span> Pi <span class="operator">/</span> <span class="number">2</span>) {
              <span class="comment">// Rotate right</span>
              angle <span class="operator">+</span><span class="operator">=</span> <span class="number">0.5</span>;
          } <span class="keyword">else</span> <span class="keyword">if</span> (angleToMouse <span class="operator">&lt;</span><span class="operator">=</span> TwoPi <span class="operator">&amp;</span><span class="operator">&amp;</span> angleToMouse <span class="operator">&gt;</span> (TwoPi <span class="operator">-</span> Pi <span class="operator">/</span> <span class="number">2</span>)) {
              <span class="comment">// Rotate left</span>
              angle <span class="operator">-</span><span class="operator">=</span> <span class="number">0.5</span>;
          }
      }

      <span class="keyword">if</span> (dangerMice<span class="operator">.</span>size() <span class="operator">&gt;</span> <span class="number">1</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="type"><a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">10</span>) <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
          <span class="keyword">if</span> (<span class="type"><a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">1</span>))
              angle <span class="operator">+</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">1</span> <span class="operator">/</span> <span class="number">500.0</span>);
          <span class="keyword">else</span>
              angle <span class="operator">-</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">1</span> <span class="operator">/</span> <span class="number">500.0</span>);
      }

</pre>
<p>Then we try to avoid colliding with other mice.</p>
<pre class="cpp">

      speed <span class="operator">+</span><span class="operator">=</span> (<span class="operator">-</span><span class="number">50</span> <span class="operator">+</span> <span class="type"><a href="../qtcore/qrandomgenerator.html">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">100</span>)) <span class="operator">/</span> <span class="number">100.0</span>;

      <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> dx <span class="operator">=</span> <span class="operator">::</span>sin(angle) <span class="operator">*</span> <span class="number">10</span>;
      mouseEyeDirection <span class="operator">=</span> (<a href="../qtcore/qtglobal.html#qAbs">qAbs</a>(dx <span class="operator">/</span> <span class="number">5</span>) <span class="operator">&lt;</span> <span class="number">1</span>) <span class="operator">?</span> <span class="number">0</span> : dx <span class="operator">/</span> <span class="number">5</span>;

      setRotation(rotation() <span class="operator">+</span> dx);
      setPos(mapToParent(<span class="number">0</span><span class="operator">,</span> <span class="operator">-</span>(<span class="number">3</span> <span class="operator">+</span> sin(speed) <span class="operator">*</span> <span class="number">3</span>)));
  }

</pre>
<p>Finally, we calculate the mouse's speed and its eye direction (for use when painting the mouse), and set its new position.</p>
<p>The position of an item describes its origin (local coordinate (0, 0)) in the parent coordinates. The <a href="qgraphicsitem.html#setPos">QGraphicsItem::setPos</a>() function sets the position of the item to the given position in the parent's coordinate system. For items with no parent, the given position is interpreted as scene coordinates. <a href="qgraphicsitem.html">QGraphicsItem</a> also provides a <a href="qgraphicsitem.html#mapToParent">mapToParent()</a> function to map a position given in item coordinates to the parent's coordinate system. If the item has no parent, the position will be mapped to the scene's coordinate system instead.</p>
<p>Then it is time to provide an implementation for the pure virtual functions inherited from <a href="qgraphicsitem.html">QGraphicsItem</a>. Let's first take a look at the <a href="qgraphicsitem.html#boundingRect">boundingRect()</a> function:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> Mouse<span class="operator">::</span>boundingRect() <span class="keyword">const</span>
  {
      <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> adjust <span class="operator">=</span> <span class="number">0.5</span>;
      <span class="keyword">return</span> <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span>(<span class="operator">-</span><span class="number">18</span> <span class="operator">-</span> adjust<span class="operator">,</span> <span class="operator">-</span><span class="number">22</span> <span class="operator">-</span> adjust<span class="operator">,</span>
                    <span class="number">36</span> <span class="operator">+</span> adjust<span class="operator">,</span> <span class="number">60</span> <span class="operator">+</span> adjust);
  }

</pre>
<p>The <a href="qgraphicsitem.html#boundingRect">boundingRect()</a> function defines the outer bounds of the item as a rectangle. Note that the Graphics View framework uses the bounding rectangle to determine whether the item requires redrawing, so all painting must be done inside this rectangle.</p>
<pre class="cpp">

  <span class="type">void</span> Mouse<span class="operator">::</span>paint(<span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstyleoptiongraphicsitem.html">QStyleOptionGraphicsItem</a></span> <span class="operator">*</span><span class="operator">,</span> <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>)
  {
      <span class="comment">// Body</span>
      painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(color);
      painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="operator">-</span><span class="number">10</span><span class="operator">,</span> <span class="operator">-</span><span class="number">20</span><span class="operator">,</span> <span class="number">20</span><span class="operator">,</span> <span class="number">40</span>);

      <span class="comment">// Eyes</span>
      painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(<span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>white);
      painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="operator">-</span><span class="number">10</span><span class="operator">,</span> <span class="operator">-</span><span class="number">17</span><span class="operator">,</span> <span class="number">8</span><span class="operator">,</span> <span class="number">8</span>);
      painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="number">2</span><span class="operator">,</span> <span class="operator">-</span><span class="number">17</span><span class="operator">,</span> <span class="number">8</span><span class="operator">,</span> <span class="number">8</span>);

      <span class="comment">// Nose</span>
      painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(<span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>black);
      painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span>(<span class="operator">-</span><span class="number">2</span><span class="operator">,</span> <span class="operator">-</span><span class="number">22</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">4</span>));

      <span class="comment">// Pupils</span>
      painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span>(<span class="operator">-</span><span class="number">8.0</span> <span class="operator">+</span> mouseEyeDirection<span class="operator">,</span> <span class="operator">-</span><span class="number">17</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">4</span>));
      painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span>(<span class="number">4.0</span> <span class="operator">+</span> mouseEyeDirection<span class="operator">,</span> <span class="operator">-</span><span class="number">17</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">4</span>));

      <span class="comment">// Ears</span>
      painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(scene()<span class="operator">-</span><span class="operator">&gt;</span>collidingItems(<span class="keyword">this</span>)<span class="operator">.</span>isEmpty() <span class="operator">?</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>darkYellow : <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>red);
      painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="operator">-</span><span class="number">17</span><span class="operator">,</span> <span class="operator">-</span><span class="number">12</span><span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> <span class="number">16</span>);
      painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">12</span><span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> <span class="number">16</span>);

      <span class="comment">// Tail</span>
      <span class="type"><a href="../qtgui/qpainterpath.html">QPainterPath</a></span> path(<span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span>(<span class="number">0</span><span class="operator">,</span> <span class="number">20</span>));
      path<span class="operator">.</span>cubicTo(<span class="operator">-</span><span class="number">5</span><span class="operator">,</span> <span class="number">22</span><span class="operator">,</span> <span class="operator">-</span><span class="number">5</span><span class="operator">,</span> <span class="number">22</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">25</span>);
      path<span class="operator">.</span>cubicTo(<span class="number">5</span><span class="operator">,</span> <span class="number">27</span><span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="number">32</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">30</span>);
      path<span class="operator">.</span>cubicTo(<span class="operator">-</span><span class="number">5</span><span class="operator">,</span> <span class="number">32</span><span class="operator">,</span> <span class="operator">-</span><span class="number">5</span><span class="operator">,</span> <span class="number">42</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">35</span>);
      painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(<span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>NoBrush);
      painter<span class="operator">-</span><span class="operator">&gt;</span>drawPath(path);
  }

</pre>
<p>The Graphics View framework calls the <a href="qgraphicsitem.html#paint">paint()</a> function to paint the contents of the item; the function paints the item in local coordinates.</p>
<p>Note the painting of the ears: whenever a mouse item collides with other mice items its ears are filled with red; otherwise they are filled with dark yellow. We use the <a href="qgraphicsscene.html#collidingItems">QGraphicsScene::collidingItems</a>() function to check if there are any colliding mice. The actual collision detection is handled by the Graphics View framework using shape-shape intersection. All we have to do is to ensure that the <a href="qgraphicsitem.html#shape">QGraphicsItem::shape</a>() function returns an accurate shape for our item:</p>
<pre class="cpp">

  <span class="type"><a href="../qtgui/qpainterpath.html">QPainterPath</a></span> Mouse<span class="operator">::</span>shape() <span class="keyword">const</span>
  {
      <span class="type"><a href="../qtgui/qpainterpath.html">QPainterPath</a></span> path;
      path<span class="operator">.</span>addRect(<span class="operator">-</span><span class="number">10</span><span class="operator">,</span> <span class="operator">-</span><span class="number">20</span><span class="operator">,</span> <span class="number">20</span><span class="operator">,</span> <span class="number">40</span>);
      <span class="keyword">return</span> path;
  }

</pre>
<p>Because the complexity of arbitrary shape-shape intersection grows with an order of magnitude when the shapes are complex, this operation can be noticably time consuming. An alternative approach is to reimplement the <a href="qgraphicsitem.html#collidesWithItem">collidesWithItem()</a> function to provide your own custom item and shape collision algorithm.</p>
<p>This completes the <code>Mouse</code> class implementation; it is now ready for use. Let's take a look at the <code>main()</code> function to see how to implement a scene for the mice and a view for displaying the contents of the scene.</p>
<a name="the-main-function"></a>
<h2 id="the-main-function">The Main() Function</h2>
<p>The <code>main()</code> function provides the main application window, as well as creating the items, their scene, and a corresponding view.</p>
<pre class="cpp">

  <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span><span class="operator">*</span>argv)
  {
      <span class="type"><a href="qapplication.html">QApplication</a></span> app(argc<span class="operator">,</span> argv);

</pre>
<p>First, we create an application object and create the scene:</p>
<pre class="cpp">

      <span class="type"><a href="qgraphicsscene.html">QGraphicsScene</a></span> scene;
      scene<span class="operator">.</span>setSceneRect(<span class="operator">-</span><span class="number">300</span><span class="operator">,</span> <span class="operator">-</span><span class="number">300</span><span class="operator">,</span> <span class="number">600</span><span class="operator">,</span> <span class="number">600</span>);

</pre>
<p>The <a href="qgraphicsscene.html">QGraphicsScene</a> class serves as a container for QGraphicsItems. It also provides functionality that lets you efficiently determine the location of items as well as determining which items are visible within an arbitrary area on the scene.</p>
<p>When creating a scene it is recommended to set the scene's rectangle; the rectangle that defines the extent of the scene. It is primarily used by <a href="qgraphicsview.html">QGraphicsView</a> to determine the view's default scrollable area, and by <a href="qgraphicsscene.html">QGraphicsScene</a> to manage item indexing. If not explicitly set, the scene's default rectangle will be the largest bounding rectangle of all the items on the scene since the scene was created. This means that the rectangle will grow when items are added or moved in the scene, but it will never shrink.</p>
<pre class="cpp">

      scene<span class="operator">.</span>setItemIndexMethod(<span class="type"><a href="qgraphicsscene.html">QGraphicsScene</a></span><span class="operator">::</span>NoIndex);

</pre>
<p>The item index function is used to speed up item discovery. <a href="qgraphicsscene.html#ItemIndexMethod-enum">NoIndex</a> implies that item location is of linear complexity, as all items on the scene are searched. Adding, moving and removing items, however, is done in constant time. This approach is ideal for dynamic scenes, where many items are added, moved or removed continuously. The alternative is <a href="qgraphicsscene.html#ItemIndexMethod-enum">BspTreeIndex</a>, which makes use of a binary search to achieve item location algorithms that are of an order closer to logarithmic complexity.</p>
<pre class="cpp">

      <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> MouseCount; <span class="operator">+</span><span class="operator">+</span>i) {
          Mouse <span class="operator">*</span>mouse <span class="operator">=</span> <span class="keyword">new</span> Mouse;
          mouse<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="operator">::</span>sin((i <span class="operator">*</span> <span class="number">6.28</span>) <span class="operator">/</span> MouseCount) <span class="operator">*</span> <span class="number">200</span><span class="operator">,</span>
                        <span class="operator">::</span>cos((i <span class="operator">*</span> <span class="number">6.28</span>) <span class="operator">/</span> MouseCount) <span class="operator">*</span> <span class="number">200</span>);
          scene<span class="operator">.</span>addItem(mouse);
      }

</pre>
<p>Then we add the mice to the scene.</p>
<pre class="cpp">

      <span class="type"><a href="qgraphicsview.html">QGraphicsView</a></span> view(<span class="operator">&amp;</span>scene);
      view<span class="operator">.</span>setRenderHint(<span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span><span class="operator">::</span>Antialiasing);
      view<span class="operator">.</span>setBackgroundBrush(<span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span>(<span class="string">&quot;:/images/cheese.jpg&quot;</span>));

</pre>
<p>To be able to view the scene, we must also create a <a href="qgraphicsview.html">QGraphicsView</a> widget. The <a href="qgraphicsview.html">QGraphicsView</a> class visualizes the contents of a scene in a scrollable viewport. We also ensure that the contents are rendered using antialiasing, and we create the cheese background by setting the view's background brush.</p>
<p>The image used for the background is stored as a binary file in the application's executable using Qt's <a href="../qtcore/resources.html">resource system</a>. The <a href="../qtgui/qpixmap.html">QPixmap</a> constructor accepts both file names that refer to actual files on disk and file names that refer to the application's embedded resources.</p>
<pre class="cpp">

      view<span class="operator">.</span>setCacheMode(<span class="type"><a href="qgraphicsview.html">QGraphicsView</a></span><span class="operator">::</span>CacheBackground);
      view<span class="operator">.</span>setViewportUpdateMode(<span class="type"><a href="qgraphicsview.html">QGraphicsView</a></span><span class="operator">::</span>BoundingRectViewportUpdate);
      view<span class="operator">.</span>setDragMode(<span class="type"><a href="qgraphicsview.html">QGraphicsView</a></span><span class="operator">::</span>ScrollHandDrag);

</pre>
<p>Then we set the cache mode; <a href="qgraphicsview.html">QGraphicsView</a> can cache pre-rendered content in a pixmap, which is then drawn onto the viewport. The purpose of such caching is to speed up the total rendering time for areas that are slow to render, for example: texture, gradient, and alpha blended backgrounds. The <a href="qgraphicsview.html#CacheModeFlag-enum">CacheMode</a> property holds which parts of the view are cached, and the <a href="qgraphicsview.html#CacheModeFlag-enum">CacheBackground</a> flag enables caching of the view's background.</p>
<p>By setting the <a href="qgraphicsview.html#dragMode-prop">dragMode</a> property, we define what should happen when the user clicks on the scene background and drags the mouse. The <a href="qgraphicsview.html#DragMode-enum">ScrollHandDrag</a> flag makes the cursor change into a pointing hand, and dragging the mouse around will scroll the scrollbars.</p>
<pre class="cpp">

      view<span class="operator">.</span>setWindowTitle(QT_TRANSLATE_NOOP(<span class="type"><a href="qgraphicsview.html">QGraphicsView</a></span><span class="operator">,</span> <span class="string">&quot;Colliding Mice&quot;</span>));
      view<span class="operator">.</span>resize(<span class="number">400</span><span class="operator">,</span> <span class="number">300</span>);
      view<span class="operator">.</span>show();

      <span class="type"><a href="../qtcore/qtimer.html">QTimer</a></span> timer;
      <span class="type"><a href="../qtcore/qobject.html">QObject</a></span><span class="operator">::</span>connect(<span class="operator">&amp;</span>timer<span class="operator">,</span> SIGNAL(timeout())<span class="operator">,</span> <span class="operator">&amp;</span>scene<span class="operator">,</span> SLOT(advance()));
      timer<span class="operator">.</span>start(<span class="number">1000</span> <span class="operator">/</span> <span class="number">33</span>);

      <span class="keyword">return</span> app<span class="operator">.</span>exec();
  }

</pre>
<p>In the end, we set the application window's title and size before we enter the main event loop using the <a href="qapplication.html#exec">QApplication::exec</a>() function.</p>
<p>Finally, we create a <a href="../qtcore/qtimer.html">QTimer</a> and connect its timeout() signal to the advance() slot of the scene. Every time the timer fires, the scene will advance one frame.</p>
<p>We then tell the timer to fire every 1000/33 milliseconds. This will give us a frame rate of 30 frames a second, which is fast enough for most animations. Doing the animation with a single timer connection to advance the scene ensures that all the mice are moved at one point and, more importantly, only one update is sent to the screen after all the mice have moved.</p>
<p>文件：</p>
<ul>
<li><a href="qtwidgets-graphicsview-collidingmice-collidingmice-pro.html">graphicsview/collidingmice/collidingmice.pro</a></li>
<li><a href="qtwidgets-graphicsview-collidingmice-main-cpp.html">graphicsview/collidingmice/main.cpp</a></li>
<li><a href="qtwidgets-graphicsview-collidingmice-mice-qrc.html">graphicsview/collidingmice/mice.qrc</a></li>
<li><a href="qtwidgets-graphicsview-collidingmice-mouse-cpp.html">graphicsview/collidingmice/mouse.cpp</a></li>
<li><a href="qtwidgets-graphicsview-collidingmice-mouse-h.html">graphicsview/collidingmice/mouse.h</a></li>
</ul>
<p>图片：</p>
<ul>
<li><a href="images/used-in-examples/graphicsview/collidingmice/images/cheese.jpg">graphicsview/collidingmice/images/cheese.jpg</a></li>
</ul>
</div>
<!-- @@@graphicsview/collidingmice -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
