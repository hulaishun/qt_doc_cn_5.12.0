<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qplaintextedit.cpp -->
  <title>QPlainTextEdit Class | Qt部件模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtwidgets-index.html">Qt部件</a></td><td ><a href="qtwidgets-module.html">C++类</a></td><td >QPlainTextEdit</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#reimplemented-public-functions">重新实现的公共函数</a></li>
<li class="level1"><a href="#public-slots">公共槽函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#protected-functions">保护函数</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">重新实现的保护函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#introduction-and-concepts">Introduction and Concepts</a></li>
<li class="level2"><a href="#using-qplaintextedit-as-a-display-widget">Using QPlainTextEdit as a Display Widget</a></li>
<li class="level2"><a href="#using-qplaintextedit-as-an-editor">Using QPlainTextEdit as an Editor</a></li>
<li class="level2"><a href="#differences-to-qtextedit">Differences to QTextEdit</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QPlainTextEdit Class</h1>
<!-- $$$QPlainTextEdit-brief -->
<p>The <a href="qplaintextedit.html">QPlainTextEdit</a> class provides a widget that is used to edit and display plain text. <a href="#details">更多详情...</a></p>
<!-- @@@QPlainTextEdit -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QPlainTextEdit&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += widgets</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 4.4</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="qabstractscrollarea.html">QAbstractScrollArea</a></td></tr></table></div><ul>
<li><a href="qplaintextedit-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qplaintextedit-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#LineWrapMode-enum">LineWrapMode</a></b> { NoWrap, WidgetWidth }</td></tr>
</table></div>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<div class="table"><table class="propsummary">
<tr><td class="topAlign"><ul>
<li class="fn"><b><a href="qplaintextedit.html#backgroundVisible-prop">backgroundVisible</a></b> : bool</li>
<li class="fn"><b><a href="qplaintextedit.html#blockCount-prop">blockCount</a></b> : const int</li>
<li class="fn"><b><a href="qplaintextedit.html#centerOnScroll-prop">centerOnScroll</a></b> : bool</li>
<li class="fn"><b><a href="qplaintextedit.html#cursorWidth-prop">cursorWidth</a></b> : int</li>
<li class="fn"><b><a href="qplaintextedit.html#documentTitle-prop">documentTitle</a></b> : QString</li>
<li class="fn"><b><a href="qplaintextedit.html#lineWrapMode-prop">lineWrapMode</a></b> : LineWrapMode</li>
<li class="fn"><b><a href="qplaintextedit.html#maximumBlockCount-prop">maximumBlockCount</a></b> : int</li>
<li class="fn"><b><a href="qplaintextedit.html#overwriteMode-prop">overwriteMode</a></b> : bool</li>
</ul></td><td class="topAlign"><ul>
<li class="fn"><b><a href="qplaintextedit.html#placeholderText-prop">placeholderText</a></b> : QString</li>
<li class="fn"><b><a href="qplaintextedit.html#plainText-prop">plainText</a></b> : QString</li>
<li class="fn"><b><a href="qplaintextedit.html#readOnly-prop">readOnly</a></b> : bool</li>
<li class="fn"><b><a href="qplaintextedit.html#tabChangesFocus-prop">tabChangesFocus</a></b> : bool</li>
<li class="fn"><b><a href="qplaintextedit.html#tabStopDistance-prop">tabStopDistance</a></b> : qreal</li>
<li class="fn"><b><a href="qplaintextedit.html#textInteractionFlags-prop">textInteractionFlags</a></b> : Qt::TextInteractionFlags</li>
<li class="fn"><b><a href="qplaintextedit.html#undoRedoEnabled-prop">undoRedoEnabled</a></b> : bool</li>
<li class="fn"><b><a href="qplaintextedit.html#wordWrapMode-prop">wordWrapMode</a></b> : QTextOption::WrapMode</li>
</ul>
</td></tr>
</table></div>
<ul>
<li class="fn">3 个属性继承于 <a href="qabstractscrollarea.html#properties">QAbstractScrollArea</a></li>
<li class="fn">6 个属性继承于 <a href="qframe.html#properties">QFrame</a></li>
<li class="fn">59 个属性继承于 <a href="qwidget.html#properties">QWidget</a></li>
<li class="fn">1 个属性继承于 <a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#QPlainTextEdit">QPlainTextEdit</a></b>(QWidget *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#QPlainTextEdit-1">QPlainTextEdit</a></b>(const QString &amp;<i>text</i>, QWidget *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#dtor.QPlainTextEdit">~QPlainTextEdit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#anchorAt">anchorAt</a></b>(const QPoint &amp;<i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#backgroundVisible-prop">backgroundVisible</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#blockCount-prop">blockCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#canPaste">canPaste</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#centerOnScroll-prop">centerOnScroll</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMenu *</td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#createStandardContextMenu">createStandardContextMenu</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMenu *</td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#createStandardContextMenu-1">createStandardContextMenu</a></b>(const QPoint &amp;<i>position</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTextCharFormat </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#currentCharFormat">currentCharFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTextCursor </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#cursorForPosition">cursorForPosition</a></b>(const QPoint &amp;<i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRect </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#cursorRect">cursorRect</a></b>(const QTextCursor &amp;<i>cursor</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRect </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#cursorRect-1">cursorRect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#cursorWidth-prop">cursorWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTextDocument *</td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#document">document</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#documentTitle-prop">documentTitle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#ensureCursorVisible">ensureCursorVisible</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QTextEdit::ExtraSelection&gt; </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#extraSelections">extraSelections</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#find">find</a></b>(const QString &amp;<i>exp</i>, QTextDocument::FindFlags <i>options</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#find-1">find</a></b>(const QRegExp &amp;<i>exp</i>, QTextDocument::FindFlags <i>options</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#readOnly-prop">isReadOnly</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#undoRedoEnabled-prop">isUndoRedoEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPlainTextEdit::LineWrapMode </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#lineWrapMode-prop">lineWrapMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#loadResource">loadResource</a></b>(int <i>type</i>, const QUrl &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#maximumBlockCount-prop">maximumBlockCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#mergeCurrentCharFormat">mergeCurrentCharFormat</a></b>(const QTextCharFormat &amp;<i>modifier</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#moveCursor">moveCursor</a></b>(QTextCursor::MoveOperation <i>operation</i>, QTextCursor::MoveMode <i>mode</i> = QTextCursor::MoveAnchor)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#overwriteMode-prop">overwriteMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#placeholderText-prop">placeholderText</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#print">print</a></b>(QPagedPaintDevice *<i>printer</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#backgroundVisible-prop">setBackgroundVisible</a></b>(bool <i>visible</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#centerOnScroll-prop">setCenterOnScroll</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#setCurrentCharFormat">setCurrentCharFormat</a></b>(const QTextCharFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#cursorWidth-prop">setCursorWidth</a></b>(int <i>width</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#setDocument">setDocument</a></b>(QTextDocument *<i>document</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#documentTitle-prop">setDocumentTitle</a></b>(const QString &amp;<i>title</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#setExtraSelections">setExtraSelections</a></b>(const QList&lt;QTextEdit::ExtraSelection&gt; &amp;<i>selections</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#lineWrapMode-prop">setLineWrapMode</a></b>(QPlainTextEdit::LineWrapMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#maximumBlockCount-prop">setMaximumBlockCount</a></b>(int <i>maximum</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#overwriteMode-prop">setOverwriteMode</a></b>(bool <i>overwrite</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#placeholderText-prop">setPlaceholderText</a></b>(const QString &amp;<i>placeholderText</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#readOnly-prop">setReadOnly</a></b>(bool <i>ro</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#tabChangesFocus-prop">setTabChangesFocus</a></b>(bool <i>b</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#tabStopDistance-prop">setTabStopDistance</a></b>(qreal <i>distance</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#setTextCursor">setTextCursor</a></b>(const QTextCursor &amp;<i>cursor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#textInteractionFlags-prop">setTextInteractionFlags</a></b>(Qt::TextInteractionFlags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#undoRedoEnabled-prop">setUndoRedoEnabled</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#wordWrapMode-prop">setWordWrapMode</a></b>(QTextOption::WrapMode <i>policy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#tabChangesFocus-prop">tabChangesFocus</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#tabStopDistance-prop">tabStopDistance</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTextCursor </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#textCursor">textCursor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::TextInteractionFlags </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#textInteractionFlags-prop">textInteractionFlags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#toPlainText">toPlainText</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTextOption::WrapMode </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#wordWrapMode-prop">wordWrapMode</a></b>() const</td></tr>
</table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">重新实现的公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#inputMethodQuery">inputMethodQuery</a></b>(Qt::InputMethodQuery <i>property</i>) const override</td></tr>
</table></div>
<ul>
<li class="fn">20 个公共函数继承于 <a href="qabstractscrollarea.html#public-functions">QAbstractScrollArea</a></li>
<li class="fn">14 个公共函数继承于 <a href="qframe.html#public-functions">QFrame</a></li>
<li class="fn">214 个公共函数继承于 <a href="qwidget.html#public-functions">QWidget</a></li>
<li class="fn">31 个公共函数继承于 <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
<li class="fn">14 个公共函数继承于 <a href="../qtgui/qpaintdevice.html#public-functions">QPaintDevice</a></li>
</ul>
<a name="public-slots"></a>
<h2 id="public-slots">公共槽函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#appendHtml">appendHtml</a></b>(const QString &amp;<i>html</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#appendPlainText">appendPlainText</a></b>(const QString &amp;<i>text</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#centerCursor">centerCursor</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#clear">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#copy">copy</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#cut">cut</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#insertPlainText">insertPlainText</a></b>(const QString &amp;<i>text</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#paste">paste</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#redo">redo</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#selectAll">selectAll</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#setPlainText">setPlainText</a></b>(const QString &amp;<i>text</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#undo">undo</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#zoomIn">zoomIn</a></b>(int <i>range</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#zoomOut">zoomOut</a></b>(int <i>range</i> = 1)</td></tr>
</table></div>
<ul>
<li class="fn">19 个公共槽函数继承于 <a href="qwidget.html#public-slots">QWidget</a></li>
<li class="fn">1 个公共槽函数继承于 <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#blockCountChanged">blockCountChanged</a></b>(int <i>newBlockCount</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#copyAvailable">copyAvailable</a></b>(bool <i>yes</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#cursorPositionChanged">cursorPositionChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#modificationChanged">modificationChanged</a></b>(bool <i>changed</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#redoAvailable">redoAvailable</a></b>(bool <i>available</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#selectionChanged">selectionChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#textChanged">textChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#undoAvailable">undoAvailable</a></b>(bool <i>available</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#updateRequest">updateRequest</a></b>(const QRect &amp;<i>rect</i>, int <i>dy</i>)</td></tr>
</table></div>
<ul>
<li class="fn">3 个信号继承于 <a href="qwidget.html#signals">QWidget</a></li>
<li class="fn">2 个信号继承于 <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">1 个静态公共成员继承于 <a href="qabstractscrollarea.html#static-public-members">QAbstractScrollArea</a></li>
<li class="fn">1 个静态公共成员继承于 <a href="qframe.html#static-public-members">QFrame</a></li>
<li class="fn">6 个静态公共成员继承于 <a href="qwidget.html#static-public-members">QWidget</a></li>
<li class="fn">9 个静态公共成员继承于 <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="protected-functions"></a>
<h2 id="protected-functions">保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#blockBoundingGeometry">blockBoundingGeometry</a></b>(const QTextBlock &amp;<i>block</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#blockBoundingRect">blockBoundingRect</a></b>(const QTextBlock &amp;<i>block</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#canInsertFromMimeData">canInsertFromMimeData</a></b>(const QMimeData *<i>source</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#contentOffset">contentOffset</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QMimeData *</td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#createMimeDataFromSelection">createMimeDataFromSelection</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTextBlock </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#firstVisibleBlock">firstVisibleBlock</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractTextDocumentLayout::PaintContext </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#getPaintContext">getPaintContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#insertFromMimeData">insertFromMimeData</a></b>(const QMimeData *<i>source</i>)</td></tr>
</table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">重新实现的保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#changeEvent">changeEvent</a></b>(QEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#contextMenuEvent">contextMenuEvent</a></b>(QContextMenuEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#dragEnterEvent">dragEnterEvent</a></b>(QDragEnterEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#dragLeaveEvent">dragLeaveEvent</a></b>(QDragLeaveEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#dragMoveEvent">dragMoveEvent</a></b>(QDragMoveEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#dropEvent">dropEvent</a></b>(QDropEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#focusInEvent">focusInEvent</a></b>(QFocusEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#focusNextPrevChild">focusNextPrevChild</a></b>(bool <i>next</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#focusOutEvent">focusOutEvent</a></b>(QFocusEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#inputMethodEvent">inputMethodEvent</a></b>(QInputMethodEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#keyPressEvent">keyPressEvent</a></b>(QKeyEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#keyReleaseEvent">keyReleaseEvent</a></b>(QKeyEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#mouseMoveEvent">mouseMoveEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#mousePressEvent">mousePressEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#mouseReleaseEvent">mouseReleaseEvent</a></b>(QMouseEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#paintEvent">paintEvent</a></b>(QPaintEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#resizeEvent">resizeEvent</a></b>(QResizeEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#scrollContentsBy">scrollContentsBy</a></b>(int <i>dx</i>, int <i>dy</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#showEvent">showEvent</a></b>(<i>QShowEvent *</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qplaintextedit.html#wheelEvent">wheelEvent</a></b>(QWheelEvent *<i>e</i>) override</td></tr>
</table></div>
<ul>
<li class="fn">20 个保护函数继承于 <a href="qabstractscrollarea.html#protected-functions">QAbstractScrollArea</a></li>
<li class="fn">4 个保护函数继承于 <a href="qframe.html#protected-functions">QFrame</a></li>
<li class="fn">35 个保护函数继承于 <a href="qwidget.html#protected-functions">QWidget</a></li>
<li class="fn">9 个保护函数继承于 <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 个保护函数继承于 <a href="../qtgui/qpaintdevice.html#protected-functions">QPaintDevice</a></li>
</ul>
<h3>其他继承而来的成员</h3>
<ul>
<li class="fn">1 个公共变量继承于 <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">1 个保护槽函数继承于 <a href="qwidget.html#protected-slots">QWidget</a></li>
<li class="fn">2 个保护变量继承于 <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
<li class="fn">1 个保护类型继承于 <a href="../qtgui/qpaintdevice.html#protected-variables">QPaintDevice</a></li>
</ul>
<a name="details"></a>
<!-- $$$QPlainTextEdit-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qplaintextedit.html">QPlainTextEdit</a> class provides a widget that is used to edit and display plain text.</p>
<a name="introduction-and-concepts"></a>
<h3 >Introduction and Concepts</h3>
<p><a href="qplaintextedit.html">QPlainTextEdit</a> is an advanced viewer/editor supporting plain text. It is optimized to handle large documents and to respond quickly to user input.</p>
<p>QPlainText uses very much the same technology and concepts as <a href="qtextedit.html">QTextEdit</a>, but is optimized for plain text handling.</p>
<p><a href="qplaintextedit.html">QPlainTextEdit</a> works on paragraphs and characters. A paragraph is a formatted string which is word-wrapped to fit into the width of the widget. By default when reading plain text, one newline signifies a paragraph. A document consists of zero or more paragraphs. Paragraphs are separated by hard line breaks. Each character within a paragraph has its own attributes, for example, font and color.</p>
<p>The shape of the mouse cursor on a <a href="qplaintextedit.html">QPlainTextEdit</a> is <a href="../qtcore/qt.html#CursorShape-enum">Qt::IBeamCursor</a> by default. It can be changed through the <a href="qabstractscrollarea.html#viewport">viewport</a>()'s cursor property.</p>
<a name="using-qplaintextedit-as-a-display-widget"></a>
<h3 >Using QPlainTextEdit as a Display Widget</h3>
<p>The text is set or replaced using <a href="qplaintextedit.html#setPlainText">setPlainText</a>() which deletes the existing text and replaces it with the text passed to <a href="qplaintextedit.html#setPlainText">setPlainText</a>().</p>
<p>Text can be inserted using the <a href="../qtgui/qtextcursor.html">QTextCursor</a> class or using the convenience functions <a href="qplaintextedit.html#insertPlainText">insertPlainText</a>(), <a href="qplaintextedit.html#appendPlainText">appendPlainText</a>() or <a href="qplaintextedit.html#paste">paste</a>().</p>
<p>By default, the text edit wraps words at whitespace to fit within the text edit widget. The <a href="qplaintextedit.html#lineWrapMode-prop">setLineWrapMode</a>() function is used to specify the kind of line wrap you want, <a href="qplaintextedit.html#LineWrapMode-enum">WidgetWidth</a> or <a href="qplaintextedit.html#LineWrapMode-enum">NoWrap</a> if you don't want any wrapping. If you use word wrap to the widget's width <a href="qplaintextedit.html#LineWrapMode-enum">WidgetWidth</a>, you can specify whether to break on whitespace or anywhere with <a href="qplaintextedit.html#wordWrapMode-prop">setWordWrapMode</a>().</p>
<p>The <a href="qplaintextedit.html#find">find</a>() function can be used to find and select a given string within the text.</p>
<p>If you want to limit the total number of paragraphs in a <a href="qplaintextedit.html">QPlainTextEdit</a>, as it is for example useful in a log viewer, then you can use the <a href="qplaintextedit.html#maximumBlockCount-prop">maximumBlockCount</a> property. The combination of <a href="qplaintextedit.html#maximumBlockCount-prop">setMaximumBlockCount</a>() 和 <a href="qplaintextedit.html#appendPlainText">appendPlainText</a>() turns <a href="qplaintextedit.html">QPlainTextEdit</a> into an efficient viewer for log text. The scrolling can be reduced with the <a href="qplaintextedit.html#centerOnScroll-prop">centerOnScroll</a>() property, making the log viewer even faster. Text can be formatted in a limited way, either using a syntax highlighter (see below), or by appending html-formatted text with <a href="qplaintextedit.html#appendHtml">appendHtml</a>(). While <a href="qplaintextedit.html">QPlainTextEdit</a> does not support complex rich text rendering with tables and floats, it does support limited paragraph-based formatting that you may need in a log viewer.</p>
<a name="read-only-key-bindings"></a>
<h4 >Read-only Key Bindings</h4>
<p>When <a href="qplaintextedit.html">QPlainTextEdit</a> is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >按键</th><th >动作</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="../qtcore/qt.html#ArrowType-enum">Qt::UpArrow</a></td><td >Moves one line up.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qt.html#ArrowType-enum">Qt::DownArrow</a></td><td >Moves one line down.</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qt.html#ArrowType-enum">Qt::LeftArrow</a></td><td >Moves one character to the left.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qt.html#ArrowType-enum">Qt::RightArrow</a></td><td >Moves one character to the right.</td></tr>
<tr valign="top" class="odd"><td >PageUp</td><td >Moves one (viewport) page up.</td></tr>
<tr valign="top" class="even"><td >PageDown</td><td >Moves one (viewport) page down.</td></tr>
<tr valign="top" class="odd"><td >Home</td><td >Moves to the beginning of the text.</td></tr>
<tr valign="top" class="even"><td >End</td><td >Moves to the end of the text.</td></tr>
<tr valign="top" class="odd"><td >Alt+Wheel</td><td >Scrolls the page horizontally (the Wheel is the mouse wheel).</td></tr>
<tr valign="top" class="even"><td >Ctrl+Wheel</td><td >Zooms the text.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+A</td><td >Selects all text.</td></tr>
</table></div>
<a name="using-qplaintextedit-as-an-editor"></a>
<h3 >Using QPlainTextEdit as an Editor</h3>
<p>All the information about using <a href="qplaintextedit.html">QPlainTextEdit</a> as a display widget also applies here.</p>
<p>Selection of text is handled by the <a href="../qtgui/qtextcursor.html">QTextCursor</a> class, which provides functionality for creating selections, retrieving the text contents or deleting selections. You can retrieve the object that corresponds with the user-visible cursor using the <a href="qplaintextedit.html#textCursor">textCursor</a>() method. If you want to set a selection in <a href="qplaintextedit.html">QPlainTextEdit</a> just create one on a <a href="../qtgui/qtextcursor.html">QTextCursor</a> object and then make that cursor the visible cursor using <a href="qwidget.html#cursor-prop">setCursor</a>(). The selection can be copied to the clipboard with <a href="qplaintextedit.html#copy">copy</a>(), or cut to the clipboard with <a href="qplaintextedit.html#cut">cut</a>(). The entire text can be selected using <a href="qplaintextedit.html#selectAll">selectAll</a>().</p>
<p><a href="qplaintextedit.html">QPlainTextEdit</a> holds a <a href="../qtgui/qtextdocument.html">QTextDocument</a> object which can be retrieved using the <a href="qplaintextedit.html#document">document</a>() method. You can also set your own document object using <a href="qplaintextedit.html#setDocument">setDocument</a>(). <a href="../qtgui/qtextdocument.html">QTextDocument</a> emits a <a href="qplaintextedit.html#textChanged">textChanged</a>() signal if the text changes and it also provides a isModified() function which will return true if the text has been modified since it was either loaded or since the last call to setModified with false as argument. In addition it provides methods for undo and redo.</p>
<a name="syntax-highlighting"></a>
<h4 >Syntax Highlighting</h4>
<p>Just like <a href="qtextedit.html">QTextEdit</a>, <a href="qplaintextedit.html">QPlainTextEdit</a> works together with <a href="../qtgui/qsyntaxhighlighter.html">QSyntaxHighlighter</a>.</p>
<a name="editing-key-bindings"></a>
<h4 >Editing Key Bindings</h4>
<p>The list of key bindings which are implemented for editing:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >按键</th><th >动作</th></tr></thead>
<tr valign="top" class="odd"><td >Backspace</td><td >Deletes the character to the left of the cursor.</td></tr>
<tr valign="top" class="even"><td >Delete</td><td >Deletes the character to the right of the cursor.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+C</td><td >Copy the selected text to the clipboard.</td></tr>
<tr valign="top" class="even"><td >Ctrl+Insert</td><td >Copy the selected text to the clipboard.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+K</td><td >Deletes to the end of the line.</td></tr>
<tr valign="top" class="even"><td >Ctrl+V</td><td >Pastes the clipboard text into text edit.</td></tr>
<tr valign="top" class="odd"><td >Shift+Insert</td><td >Pastes the clipboard text into text edit.</td></tr>
<tr valign="top" class="even"><td >Ctrl+X</td><td >Deletes the selected text and copies it to the clipboard.</td></tr>
<tr valign="top" class="odd"><td >Shift+Delete</td><td >Deletes the selected text and copies it to the clipboard.</td></tr>
<tr valign="top" class="even"><td >Ctrl+Z</td><td >Undoes the last operation.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+Y</td><td >Redoes the last operation.</td></tr>
<tr valign="top" class="even"><td >LeftArrow</td><td >Moves the cursor one character to the left.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+LeftArrow</td><td >Moves the cursor one word to the left.</td></tr>
<tr valign="top" class="even"><td >RightArrow</td><td >Moves the cursor one character to the right.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+RightArrow</td><td >Moves the cursor one word to the right.</td></tr>
<tr valign="top" class="even"><td >UpArrow</td><td >Moves the cursor one line up.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+UpArrow</td><td >Moves the cursor one word up.</td></tr>
<tr valign="top" class="even"><td >DownArrow</td><td >Moves the cursor one line down.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+Down Arrow</td><td >Moves the cursor one word down.</td></tr>
<tr valign="top" class="even"><td >PageUp</td><td >Moves the cursor one page up.</td></tr>
<tr valign="top" class="odd"><td >PageDown</td><td >Moves the cursor one page down.</td></tr>
<tr valign="top" class="even"><td >Home</td><td >Moves the cursor to the beginning of the line.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+Home</td><td >Moves the cursor to the beginning of the text.</td></tr>
<tr valign="top" class="even"><td >End</td><td >Moves the cursor to the end of the line.</td></tr>
<tr valign="top" class="odd"><td >Ctrl+End</td><td >Moves the cursor to the end of the text.</td></tr>
<tr valign="top" class="even"><td >Alt+Wheel</td><td >Scrolls the page horizontally (the Wheel is the mouse wheel).</td></tr>
<tr valign="top" class="odd"><td >Ctrl+Wheel</td><td >Zooms the text.</td></tr>
</table></div>
<p>To select (mark) text hold down the Shift key whilst pressing one of the movement keystrokes, for example, <i>Shift+Right Arrow</i> will select the character to the right, and <i>Shift+Ctrl+Right Arrow</i> will select the word to the right, etc.</p>
<a name="differences-to-qtextedit"></a>
<h3 >Differences to QTextEdit</h3>
<p><a href="qplaintextedit.html">QPlainTextEdit</a> is a thin class, implemented by using most of the technology that is behind <a href="qtextedit.html">QTextEdit</a> 和 <a href="../qtgui/qtextdocument.html">QTextDocument</a>. Its performance benefits over <a href="qtextedit.html">QTextEdit</a> stem mostly from using a different and simplified text layout called <a href="qplaintextdocumentlayout.html">QPlainTextDocumentLayout</a> on the text document (see <a href="../qtgui/qtextdocument.html#setDocumentLayout">QTextDocument::setDocumentLayout</a>()). The plain text document layout does not support tables nor embedded frames, and <i>replaces a pixel-exact height calculation with a line-by-line respectively paragraph-by-paragraph scrolling approach</i>. This makes it possible to handle significantly larger documents, and still resize the editor with line wrap enabled in real time. It also makes for a fast log viewer (see <a href="qplaintextedit.html#maximumBlockCount-prop">setMaximumBlockCount</a>()).</p>
</div>
<p><b> 参见 </b><a href="../qtgui/qtextdocument.html">QTextDocument</a>, <a href="../qtgui/qtextcursor.html">QTextCursor</a>, <a href="qtwidgets-mainwindows-application-example.html">Application Example</a>, <a href="qtwidgets-widgets-codeeditor-example.html">Code Editor Example</a>, <a href="qtwidgets-richtext-syntaxhighlighter-example.html">Syntax Highlighter Example</a>, 和 <a href="../qtgui/richtext.html">富文本处理</a>.</p>
<!-- @@@QPlainTextEdit -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$LineWrapMode$$$NoWrap$$$WidgetWidth -->
<h3 class="fn" id="LineWrapMode-enum"><a name="LineWrapMode-enum"></a>enum QPlainTextEdit::<span class="name">LineWrapMode</span></h3>
<div class="table"><table class="valuelist"><tr><th class="tblConst">常量</th><th class="tblVal">值</th></tr>
<tr><td class="topAlign"><code>QPlainTextEdit::NoWrap</code></td><td class="topAlign tblval"><code>0</code></td></tr>
<tr><td class="topAlign"><code>QPlainTextEdit::WidgetWidth</code></td><td class="topAlign tblval"><code>1</code></td></tr>
</table></div>
<!-- @@@LineWrapMode -->
</div>
<div class="prop">
<h2>属性文档</h2>
<!-- $$$backgroundVisible-prop$$$backgroundVisible$$$setBackgroundVisiblebool -->
<h3 class="fn" id="backgroundVisible-prop"><a name="backgroundVisible-prop"></a><span class="name">backgroundVisible</span> : <span class="type">bool</span></h3>
<p>This property holds whether the palette background is visible outside the document area</p>
<p>If set to true, the plain text edit paints the palette background on the viewport area not covered by the text document. Otherwise, if set to false, it won't. The feature makes it possible for the user to visually distinguish between the area of the document, painted with the base color of the palette, and the empty area not covered by any document.</p>
<p>The default is false.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>backgroundVisible</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setBackgroundVisible</b></span>(bool <i>visible</i>)</td></tr>
</table></div>
<!-- @@@backgroundVisible -->
<!-- $$$blockCount-prop$$$blockCount -->
<h3 class="fn" id="blockCount-prop"><a name="blockCount-prop"></a><span class="name">blockCount</span> : const <span class="type">int</span></h3>
<p>This property holds the number of text blocks in the document.</p>
<p>By default, in an empty document, this property contains a value of 1.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>blockCount</b></span>() const</td></tr>
</table></div>
<!-- @@@blockCount -->
<!-- $$$centerOnScroll-prop$$$centerOnScroll$$$setCenterOnScrollbool -->
<h3 class="fn" id="centerOnScroll-prop"><a name="centerOnScroll-prop"></a><span class="name">centerOnScroll</span> : <span class="type">bool</span></h3>
<p>This property holds whether the cursor should be centered on screen</p>
<p>If set to true, the plain text edit scrolls the document vertically to make the cursor visible at the center of the viewport. This also allows the text edit to scroll below the end of the document. Otherwise, if set to false, the plain text edit scrolls the smallest amount possible to ensure the cursor is visible. The same algorithm is applied to any new line appended through <a href="qplaintextedit.html#appendPlainText">appendPlainText</a>().</p>
<p>The default is false.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>centerOnScroll</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setCenterOnScroll</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<p><b> 参见 </b><a href="qplaintextedit.html#centerCursor">centerCursor</a>() 和 <a href="qplaintextedit.html#ensureCursorVisible">ensureCursorVisible</a>().</p>
<!-- @@@centerOnScroll -->
<!-- $$$cursorWidth-prop$$$cursorWidth$$$setCursorWidthint -->
<h3 class="fn" id="cursorWidth-prop"><a name="cursorWidth-prop"></a><span class="name">cursorWidth</span> : <span class="type">int</span></h3>
<p>This property specifies the width of the cursor in pixels. The default value is 1.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>cursorWidth</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setCursorWidth</b></span>(int <i>width</i>)</td></tr>
</table></div>
<!-- @@@cursorWidth -->
<!-- $$$documentTitle-prop$$$documentTitle$$$setDocumentTitleconstQString& -->
<h3 class="fn" id="documentTitle-prop"><a name="documentTitle-prop"></a><span class="name">documentTitle</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p>This property holds the title of the document parsed from the text.</p>
<p>默认情况下，此属性包含一个空字符串。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>documentTitle</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setDocumentTitle</b></span>(const QString &amp;<i>title</i>)</td></tr>
</table></div>
<!-- @@@documentTitle -->
<!-- $$$lineWrapMode-prop$$$lineWrapMode$$$setLineWrapModeQPlainTextEdit::LineWrapMode -->
<h3 class="fn" id="lineWrapMode-prop"><a name="lineWrapMode-prop"></a><span class="name">lineWrapMode</span> : <span class="type"><a href="qplaintextedit.html#LineWrapMode-enum">LineWrapMode</a></span></h3>
<p>This property holds the line wrap mode</p>
<p>默认模式为 <aa href="qplaintextedit.html#LineWrapMode-enum">WidgetWidth</a> which causes words to be wrapped at the right edge of the text edit. Wrapping occurs at whitespace, keeping whole words intact. If you want wrapping to occur within words use <a href="qplaintextedit.html#wordWrapMode-prop">setWordWrapMode</a>().</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QPlainTextEdit::LineWrapMode </td><td class="memItemRight bottomAlign"><span class="name"><b>lineWrapMode</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setLineWrapMode</b></span>(QPlainTextEdit::LineWrapMode <i>mode</i>)</td></tr>
</table></div>
<!-- @@@lineWrapMode -->
<!-- $$$maximumBlockCount-prop$$$maximumBlockCount$$$setMaximumBlockCountint -->
<h3 class="fn" id="maximumBlockCount-prop"><a name="maximumBlockCount-prop"></a><span class="name">maximumBlockCount</span> : <span class="type">int</span></h3>
<p>This property holds the limit for blocks in the document.</p>
<p>Specifies the maximum number of blocks the document may have. If there are more blocks in the document that specified with this property blocks are removed from the beginning of the document.</p>
<p>A negative or zero value specifies that the document may contain an unlimited amount of blocks.</p>
<p>The default value is 0.</p>
<p>Note that setting this property will apply the limit immediately to the document contents. Setting this property also disables the undo redo history.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>maximumBlockCount</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMaximumBlockCount</b></span>(int <i>maximum</i>)</td></tr>
</table></div>
<!-- @@@maximumBlockCount -->
<!-- $$$overwriteMode-prop$$$overwriteMode$$$setOverwriteModebool -->
<h3 class="fn" id="overwriteMode-prop"><a name="overwriteMode-prop"></a><span class="name">overwriteMode</span> : <span class="type">bool</span></h3>
<p>This property holds whether text entered by the user will overwrite existing text</p>
<p>As with many text editors, the plain text editor widget can be configured to insert or overwrite existing text with new text entered by the user.</p>
<p>If this property is <code>true</code>, existing text is overwritten, character-for-character by new text; otherwise, text is inserted at the cursor position, displacing existing text.</p>
<p>By default, this property is <code>false</code> (new text does not overwrite existing text).</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>overwriteMode</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setOverwriteMode</b></span>(bool <i>overwrite</i>)</td></tr>
</table></div>
<!-- @@@overwriteMode -->
<!-- $$$placeholderText-prop$$$placeholderText$$$setPlaceholderTextconstQString& -->
<h3 class="fn" id="placeholderText-prop"><a name="placeholderText-prop"></a><span class="name">placeholderText</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p>This property holds the editor placeholder text</p>
<p>Setting this property makes the editor display a grayed-out placeholder text as long as the <a href="qplaintextedit.html#document">document</a>() is empty.</p>
<p>默认情况下，此属性包含一个空字符串。</p>
<p>这个属性是在Qt 5.3版本中新增引入的。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>placeholderText</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setPlaceholderText</b></span>(const QString &amp;<i>placeholderText</i>)</td></tr>
</table></div>
<p><b> 参见 </b><a href="qplaintextedit.html#document">document</a>().</p>
<!-- @@@placeholderText -->
<!-- $$$plainText-prop$$$toPlainText$$$setPlainTextconstQString&$$$textChanged -->
<h3 class="fn" id="plainText-prop"><a name="plainText-prop"></a><span class="name">plainText</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p>This property gets and sets the plain text editor's contents. The previous contents are removed and undo/redo history is reset when this property is set.</p>
<p>By default, for an editor with no contents, this property contains an empty string.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qplaintextedit.html#toPlainText">toPlainText</a></b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qplaintextedit.html#setPlainText">setPlainText</a></b></span>(const QString &amp;<i>text</i>)</td></tr>
</table></div>
<p><b>通知信号：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qplaintextedit.html#textChanged">textChanged</a></b></span>()</td></tr>
</table></div>
<!-- @@@plainText -->
<!-- $$$readOnly-prop$$$isReadOnly$$$setReadOnlybool -->
<h3 class="fn" id="readOnly-prop"><a name="readOnly-prop"></a><span class="name">readOnly</span> : <span class="type">bool</span></h3>
<p>This property holds whether the text edit is read-only</p>
<p>In a read-only text edit the user can only navigate through the text and select text; modifying the text is not possible.</p>
<p>此属性的默认值为false。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isReadOnly</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setReadOnly</b></span>(bool <i>ro</i>)</td></tr>
</table></div>
<!-- @@@readOnly -->
<!-- $$$tabChangesFocus-prop$$$tabChangesFocus$$$setTabChangesFocusbool -->
<h3 class="fn" id="tabChangesFocus-prop"><a name="tabChangesFocus-prop"></a><span class="name">tabChangesFocus</span> : <span class="type">bool</span></h3>
<p>This property holds whether <b>Tab</b> changes focus or is accepted as input</p>
<p>In some occasions text edits should not allow the user to input tabulators or change indentation using the <b>Tab</b> key, as this breaks the focus chain. The default is false.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>tabChangesFocus</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTabChangesFocus</b></span>(bool <i>b</i>)</td></tr>
</table></div>
<!-- @@@tabChangesFocus -->
<!-- $$$tabStopDistance-prop$$$tabStopDistance$$$setTabStopDistanceqreal -->
<h3 class="fn" id="tabStopDistance-prop"><a name="tabStopDistance-prop"></a><span class="name">tabStopDistance</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>This property holds the tab stop distance in pixels</p>
<p>By default, this property contains a value of 80.</p>
<p>这个属性是在Qt 5.10版本中新增引入的。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>tabStopDistance</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTabStopDistance</b></span>(qreal <i>distance</i>)</td></tr>
</table></div>
<!-- @@@tabStopDistance -->
<!-- $$$textInteractionFlags-prop$$$textInteractionFlags$$$setTextInteractionFlagsQt::TextInteractionFlags -->
<h3 class="fn" id="textInteractionFlags-prop"><a name="textInteractionFlags-prop"></a><span class="name">textInteractionFlags</span> : <span class="type">Qt::TextInteractionFlags</span></h3>
<p>Specifies how the label should interact with user input if it displays text.</p>
<p>If the flags contain either <a href="../qtcore/qt.html#TextInteractionFlag-enum">Qt::LinksAccessibleByKeyboard</a> or <a href="../qtcore/qt.html#TextInteractionFlag-enum">Qt::TextSelectableByKeyboard</a> then the focus policy is also automatically set to <a href="../qtcore/qt.html#FocusPolicy-enum">Qt::ClickFocus</a>.</p>
<p>The default value depends on whether the <a href="qplaintextedit.html">QPlainTextEdit</a> is read-only or editable.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::TextInteractionFlags </td><td class="memItemRight bottomAlign"><span class="name"><b>textInteractionFlags</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTextInteractionFlags</b></span>(Qt::TextInteractionFlags <i>flags</i>)</td></tr>
</table></div>
<!-- @@@textInteractionFlags -->
<!-- $$$undoRedoEnabled-prop$$$isUndoRedoEnabled$$$setUndoRedoEnabledbool -->
<h3 class="fn" id="undoRedoEnabled-prop"><a name="undoRedoEnabled-prop"></a><span class="name">undoRedoEnabled</span> : <span class="type">bool</span></h3>
<p>This property holds whether undo and redo are enabled</p>
<p>Users are only able to undo or redo actions if this property is true, and if there is an action that can be undone (or redone).</p>
<p>此属性的默认值为 <code>true</code>。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isUndoRedoEnabled</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setUndoRedoEnabled</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<!-- @@@undoRedoEnabled -->
<!-- $$$wordWrapMode-prop$$$wordWrapMode$$$setWordWrapModeQTextOption::WrapMode -->
<h3 class="fn" id="wordWrapMode-prop"><a name="wordWrapMode-prop"></a><span class="name">wordWrapMode</span> : <span class="type"><a href="../qtgui/qtextoption.html#WrapMode-enum">QTextOption::WrapMode</a></span></h3>
<p>This property holds the mode <a href="qplaintextedit.html">QPlainTextEdit</a> will use when wrapping text by words</p>
<p>默认情况下，此属性被设置为 <a href="../qtgui/qtextoption.html#WrapMode-enum">QTextOption::WrapAtWordBoundaryOrAnywhere</a>.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QTextOption::WrapMode </td><td class="memItemRight bottomAlign"><span class="name"><b>wordWrapMode</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWordWrapMode</b></span>(QTextOption::WrapMode <i>policy</i>)</td></tr>
</table></div>
<p><b> 参见 </b><a href="../qtgui/qtextoption.html#WrapMode-enum">QTextOption::WrapMode</a>.</p>
<!-- @@@wordWrapMode -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QPlainTextEdit[overload1]$$$QPlainTextEditQWidget* -->
<h3 class="fn" id="QPlainTextEdit"><a name="QPlainTextEdit"></a>QPlainTextEdit::<span class="name">QPlainTextEdit</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs an empty <a href="qplaintextedit.html">QPlainTextEdit</a> with parent <i>parent</i>.</p>
<!-- @@@QPlainTextEdit -->
<!-- $$$QPlainTextEdit$$$QPlainTextEditconstQString&QWidget* -->
<h3 class="fn" id="QPlainTextEdit-1"><a name="QPlainTextEdit-1"></a>QPlainTextEdit::<span class="name">QPlainTextEdit</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>text</i>, <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a <a href="qplaintextedit.html">QPlainTextEdit</a> with parent <i>parent</i>. The text edit will display the plain text <i>text</i>.</p>
<!-- @@@QPlainTextEdit -->
<!-- $$$~QPlainTextEdit[overload1]$$$~QPlainTextEdit -->
<h3 class="fn" id="dtor.QPlainTextEdit"><a name="dtor.QPlainTextEdit"></a><code>[虚函数] </code>QPlainTextEdit::<span class="name">~QPlainTextEdit</span>()</h3>
<p>析构函数。</p>
<!-- @@@~QPlainTextEdit -->
<!-- $$$anchorAt[overload1]$$$anchorAtconstQPoint& -->
<h3 class="fn" id="anchorAt"><a name="anchorAt"></a><span class="type"><a href="../qtcore/qstring.html">QString</a></span> QPlainTextEdit::<span class="name">anchorAt</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>pos</i>) const</h3>
<p>Returns the reference of the anchor at position <i>pos</i>, or an empty string if no anchor exists at that point.</p>
<p>这个函数是在Qt 4.7版本中新增引入的。</p>
<!-- @@@anchorAt -->
<!-- $$$appendHtml[overload1]$$$appendHtmlconstQString& -->
<h3 class="fn" id="appendHtml"><a name="appendHtml"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">appendHtml</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>html</i>)</h3>
<p>Appends a new paragraph with <i>html</i> to the end of the text edit.</p>
<p><a href="qplaintextedit.html#appendPlainText">appendPlainText</a>()</p>
<!-- @@@appendHtml -->
<!-- $$$appendPlainText[overload1]$$$appendPlainTextconstQString& -->
<h3 class="fn" id="appendPlainText"><a name="appendPlainText"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">appendPlainText</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>text</i>)</h3>
<p>Appends a new paragraph with <i>text</i> to the end of the text edit.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#appendHtml">appendHtml</a>().</p>
<!-- @@@appendPlainText -->
<!-- $$$blockBoundingGeometry[overload1]$$$blockBoundingGeometryconstQTextBlock& -->
<h3 class="fn" id="blockBoundingGeometry"><a name="blockBoundingGeometry"></a><code>[保护函数] </code><span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> QPlainTextEdit::<span class="name">blockBoundingGeometry</span>(const <span class="type"><a href="../qtgui/qtextblock.html">QTextBlock</a></span> &amp;<i>block</i>) const</h3>
<p>Returns the bounding rectangle of the text <i>block</i> in content coordinates. Translate the rectangle with the <a href="qplaintextedit.html#contentOffset">contentOffset</a>() to get visual coordinates on the viewport.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#firstVisibleBlock">firstVisibleBlock</a>() 和 <a href="qplaintextedit.html#blockBoundingRect">blockBoundingRect</a>().</p>
<!-- @@@blockBoundingGeometry -->
<!-- $$$blockBoundingRect[overload1]$$$blockBoundingRectconstQTextBlock& -->
<h3 class="fn" id="blockBoundingRect"><a name="blockBoundingRect"></a><code>[保护函数] </code><span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> QPlainTextEdit::<span class="name">blockBoundingRect</span>(const <span class="type"><a href="../qtgui/qtextblock.html">QTextBlock</a></span> &amp;<i>block</i>) const</h3>
<p>Returns the bounding rectangle of the text <i>block</i> in the block's own coordinates.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#blockBoundingGeometry">blockBoundingGeometry</a>().</p>
<!-- @@@blockBoundingRect -->
<!-- $$$blockCountChanged[overload1]$$$blockCountChangedint -->
<h3 class="fn" id="blockCountChanged"><a name="blockCountChanged"></a><code>[信号] </code><span class="type">void</span> QPlainTextEdit::<span class="name">blockCountChanged</span>(<span class="type">int</span> <i>newBlockCount</i>)</h3>
<p>This signal is emitted whenever the block count changes. The new block count is passed in <i>newBlockCount</i>.</p>
<!-- @@@blockCountChanged -->
<!-- $$$canInsertFromMimeData[overload1]$$$canInsertFromMimeDataconstQMimeData* -->
<h3 class="fn" id="canInsertFromMimeData"><a name="canInsertFromMimeData"></a><code>[虚保护函数] </code><span class="type">bool</span> QPlainTextEdit::<span class="name">canInsertFromMimeData</span>(const <span class="type"><a href="../qtcore/qmimedata.html">QMimeData</a></span> *<i>source</i>) const</h3>
<p>This function returns <code>true</code> if the contents of the MIME data object, specified by <i>source</i>, can be decoded and inserted into the document. It is called for example when during a drag operation the mouse enters this widget and it is necessary to determine whether it is possible to accept the drag.</p>
<!-- @@@canInsertFromMimeData -->
<!-- $$$canPaste[overload1]$$$canPaste -->
<h3 class="fn" id="canPaste"><a name="canPaste"></a><span class="type">bool</span> QPlainTextEdit::<span class="name">canPaste</span>() const</h3>
<p>Returns whether text can be pasted from the clipboard into the textedit.</p>
<!-- @@@canPaste -->
<!-- $$$centerCursor[overload1]$$$centerCursor -->
<h3 class="fn" id="centerCursor"><a name="centerCursor"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">centerCursor</span>()</h3>
<p>Scrolls the document in order to center the cursor vertically.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#ensureCursorVisible">ensureCursorVisible</a>() 和 <a href="qplaintextedit.html#centerOnScroll-prop">centerOnScroll</a>.</p>
<!-- @@@centerCursor -->
<!-- $$$changeEvent[overload1]$$$changeEventQEvent* -->
<h3 class="fn" id="changeEvent"><a name="changeEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">changeEvent</span>(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qframe.html#changeEvent">QFrame::changeEvent</a>().</p>
<!-- @@@changeEvent -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear"><a name="clear"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">clear</span>()</h3>
<p>Deletes all the text in the text edit.</p>
<p>Note that the undo/redo history is cleared by this function.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#cut">cut</a>() 和 <a href="qplaintextedit.html#setPlainText">setPlainText</a>().</p>
<!-- @@@clear -->
<!-- $$$contentOffset[overload1]$$$contentOffset -->
<h3 class="fn" id="contentOffset"><a name="contentOffset"></a><code>[保护函数] </code><span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> QPlainTextEdit::<span class="name">contentOffset</span>() const</h3>
<p>Returns the content's origin in viewport coordinates.</p>
<p>The origin of the content of a plain text edit is always the top left corner of the first visible text block. The content offset is different from (0,0) when the text has been scrolled horizontally, or when the first visible block has been scrolled partially off the screen, i.e&#x2e; the visible text does not start with the first line of the first visible block, or when the first visible block is the very first block and the editor displays a margin.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#firstVisibleBlock">firstVisibleBlock</a>(), <a href="qabstractscrollarea.html#horizontalScrollBar">horizontalScrollBar</a>(), 和 <a href="qabstractscrollarea.html#verticalScrollBar">verticalScrollBar</a>().</p>
<!-- @@@contentOffset -->
<!-- $$$contextMenuEvent[overload1]$$$contextMenuEventQContextMenuEvent* -->
<h3 class="fn" id="contextMenuEvent"><a name="contextMenuEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">contextMenuEvent</span>(<span class="type"><a href="../qtgui/qcontextmenuevent.html">QContextMenuEvent</a></span> *<i>event</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#contextMenuEvent">QAbstractScrollArea::contextMenuEvent</a>().</p>
<p>Shows the standard context menu created with <a href="qplaintextedit.html#createStandardContextMenu">createStandardContextMenu</a>().</p>
<p>If you do not want the text edit to have a context menu, you can set its <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a> to <a href="../qtcore/qt.html#ContextMenuPolicy-enum">Qt::NoContextMenu</a>. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call <a href="qplaintextedit.html#createStandardContextMenu">createStandardContextMenu</a>() and extend the menu returned.</p>
<p>Information about the event is passed in the <i>event</i> object.</p>
<pre class="cpp">

  <span class="type">void</span> MyQPlainTextEdit<span class="operator">::</span>contextMenuEvent(<span class="type"><a href="../qtgui/qcontextmenuevent.html">QContextMenuEvent</a></span> <span class="operator">*</span>event)
  {
      <span class="type"><a href="qmenu.html">QMenu</a></span> <span class="operator">*</span>menu <span class="operator">=</span> createStandardContextMenu();
      menu<span class="operator">-</span><span class="operator">&gt;</span>addAction(tr(<span class="string">&quot;My Menu Item&quot;</span>));
      <span class="comment">//...</span>
      menu<span class="operator">-</span><span class="operator">&gt;</span>exec(event<span class="operator">-</span><span class="operator">&gt;</span>globalPos());
      <span class="keyword">delete</span> menu;
  }

</pre>
<!-- @@@contextMenuEvent -->
<!-- $$$copy[overload1]$$$copy -->
<h3 class="fn" id="copy"><a name="copy"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">copy</span>()</h3>
<p>Copies any selected text to the clipboard.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#copyAvailable">copyAvailable</a>().</p>
<!-- @@@copy -->
<!-- $$$copyAvailable[overload1]$$$copyAvailablebool -->
<h3 class="fn" id="copyAvailable"><a name="copyAvailable"></a><code>[信号] </code><span class="type">void</span> QPlainTextEdit::<span class="name">copyAvailable</span>(<span class="type">bool</span> <i>yes</i>)</h3>
<p>This signal is emitted when text is selected or de-selected in the text edit.</p>
<p>When text is selected this signal will be emitted with <i>yes</i> set to true. If no text has been selected or if the selected text is de-selected this signal is emitted with <i>yes</i> set to false.</p>
<p>If <i>yes</i> is true then <a href="qplaintextedit.html#copy">copy</a>() can be used to copy the selection to the clipboard. If <i>yes</i> is false then <a href="qplaintextedit.html#copy">copy</a>() does nothing.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#selectionChanged">selectionChanged</a>().</p>
<!-- @@@copyAvailable -->
<!-- $$$createMimeDataFromSelection[overload1]$$$createMimeDataFromSelection -->
<h3 class="fn" id="createMimeDataFromSelection"><a name="createMimeDataFromSelection"></a><code>[虚保护函数] </code><span class="type"><a href="../qtcore/qmimedata.html">QMimeData</a></span> *QPlainTextEdit::<span class="name">createMimeDataFromSelection</span>() const</h3>
<p>This function returns a new MIME data object to represent the contents of the text edit's current selection. It is called when the selection needs to be encapsulated into a new <a href="../qtcore/qmimedata.html">QMimeData</a> object; for example, when a drag and drop operation is started, or when data is copied to the clipboard.</p>
<p>If you reimplement this function, note that the ownership of the returned <a href="../qtcore/qmimedata.html">QMimeData</a> object is passed to the caller. The selection can be retrieved by using the <a href="qplaintextedit.html#textCursor">textCursor</a>() function.</p>
<!-- @@@createMimeDataFromSelection -->
<!-- $$$createStandardContextMenu[overload1]$$$createStandardContextMenu -->
<h3 class="fn" id="createStandardContextMenu"><a name="createStandardContextMenu"></a><span class="type"><a href="qmenu.html">QMenu</a></span> *QPlainTextEdit::<span class="name">createStandardContextMenu</span>()</h3>
<p>This function creates the standard context menu which is shown when the user clicks on the text edit with the right mouse button. It is called from the default <a href="qplaintextedit.html#contextMenuEvent">contextMenuEvent</a>() handler. The popup menu's ownership is transferred to the caller.</p>
<p>We recommend that you use the createStandardContextMenu(<a href="../qtcore/qpoint.html">QPoint</a>) version instead which will enable the actions that are sensitive to where the user clicked.</p>
<!-- @@@createStandardContextMenu -->
<!-- $$$createStandardContextMenu$$$createStandardContextMenuconstQPoint& -->
<h3 class="fn" id="createStandardContextMenu-1"><a name="createStandardContextMenu-1"></a><span class="type"><a href="qmenu.html">QMenu</a></span> *QPlainTextEdit::<span class="name">createStandardContextMenu</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>position</i>)</h3>
<p>This function creates the standard context menu which is shown when the user clicks on the text edit with the right mouse button. It is called from the default <a href="qplaintextedit.html#contextMenuEvent">contextMenuEvent</a>() handler and it takes the <i>position</i> in document coordinates where the mouse click was. This can enable actions that are sensitive to the position where the user clicked. The popup menu's ownership is transferred to the caller.</p>
<p>这个函数是在Qt 5.5版本中新增引入的。</p>
<!-- @@@createStandardContextMenu -->
<!-- $$$currentCharFormat[overload1]$$$currentCharFormat -->
<h3 class="fn" id="currentCharFormat"><a name="currentCharFormat"></a><span class="type"><a href="../qtgui/qtextcharformat.html">QTextCharFormat</a></span> QPlainTextEdit::<span class="name">currentCharFormat</span>() const</h3>
<p>Returns the char format that is used when inserting new text.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#setCurrentCharFormat">setCurrentCharFormat</a>().</p>
<!-- @@@currentCharFormat -->
<!-- $$$cursorForPosition[overload1]$$$cursorForPositionconstQPoint& -->
<h3 class="fn" id="cursorForPosition"><a name="cursorForPosition"></a><span class="type"><a href="../qtgui/qtextcursor.html">QTextCursor</a></span> QPlainTextEdit::<span class="name">cursorForPosition</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>pos</i>) const</h3>
<p>returns a <a href="../qtgui/qtextcursor.html">QTextCursor</a> at position <i>pos</i> (in viewport coordinates).</p>
<!-- @@@cursorForPosition -->
<!-- $$$cursorPositionChanged[overload1]$$$cursorPositionChanged -->
<h3 class="fn" id="cursorPositionChanged"><a name="cursorPositionChanged"></a><code>[信号] </code><span class="type">void</span> QPlainTextEdit::<span class="name">cursorPositionChanged</span>()</h3>
<p>This signal is emitted whenever the position of the cursor changed.</p>
<!-- @@@cursorPositionChanged -->
<!-- $$$cursorRect[overload1]$$$cursorRectconstQTextCursor& -->
<h3 class="fn" id="cursorRect"><a name="cursorRect"></a><span class="type"><a href="../qtcore/qrect.html">QRect</a></span> QPlainTextEdit::<span class="name">cursorRect</span>(const <span class="type"><a href="../qtgui/qtextcursor.html">QTextCursor</a></span> &amp;<i>cursor</i>) const</h3>
<p>returns a rectangle (in viewport coordinates) that includes the <i>cursor</i>.</p>
<!-- @@@cursorRect -->
<!-- $$$cursorRect$$$cursorRect -->
<h3 class="fn" id="cursorRect-1"><a name="cursorRect-1"></a><span class="type"><a href="../qtcore/qrect.html">QRect</a></span> QPlainTextEdit::<span class="name">cursorRect</span>() const</h3>
<p>returns a rectangle (in viewport coordinates) that includes the cursor of the text edit.</p>
<!-- @@@cursorRect -->
<!-- $$$cut[overload1]$$$cut -->
<h3 class="fn" id="cut"><a name="cut"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">cut</span>()</h3>
<p>Copies the selected text to the clipboard and deletes it from the text edit.</p>
<p>If there is no selected text nothing happens.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#copy">copy</a>() 和 <a href="qplaintextedit.html#paste">paste</a>().</p>
<!-- @@@cut -->
<!-- $$$document[overload1]$$$document -->
<h3 class="fn" id="document"><a name="document"></a><span class="type"><a href="../qtgui/qtextdocument.html">QTextDocument</a></span> *QPlainTextEdit::<span class="name">document</span>() const</h3>
<p>Returns a pointer to the underlying document.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#setDocument">setDocument</a>().</p>
<!-- @@@document -->
<!-- $$$dragEnterEvent[overload1]$$$dragEnterEventQDragEnterEvent* -->
<h3 class="fn" id="dragEnterEvent"><a name="dragEnterEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">dragEnterEvent</span>(<span class="type"><a href="../qtgui/qdragenterevent.html">QDragEnterEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#dragEnterEvent">QAbstractScrollArea::dragEnterEvent</a>().</p>
<!-- @@@dragEnterEvent -->
<!-- $$$dragLeaveEvent[overload1]$$$dragLeaveEventQDragLeaveEvent* -->
<h3 class="fn" id="dragLeaveEvent"><a name="dragLeaveEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">dragLeaveEvent</span>(<span class="type"><a href="../qtgui/qdragleaveevent.html">QDragLeaveEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#dragLeaveEvent">QAbstractScrollArea::dragLeaveEvent</a>().</p>
<!-- @@@dragLeaveEvent -->
<!-- $$$dragMoveEvent[overload1]$$$dragMoveEventQDragMoveEvent* -->
<h3 class="fn" id="dragMoveEvent"><a name="dragMoveEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">dragMoveEvent</span>(<span class="type"><a href="../qtgui/qdragmoveevent.html">QDragMoveEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#dragMoveEvent">QAbstractScrollArea::dragMoveEvent</a>().</p>
<!-- @@@dragMoveEvent -->
<!-- $$$dropEvent[overload1]$$$dropEventQDropEvent* -->
<h3 class="fn" id="dropEvent"><a name="dropEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">dropEvent</span>(<span class="type"><a href="../qtgui/qdropevent.html">QDropEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#dropEvent">QAbstractScrollArea::dropEvent</a>().</p>
<!-- @@@dropEvent -->
<!-- $$$ensureCursorVisible[overload1]$$$ensureCursorVisible -->
<h3 class="fn" id="ensureCursorVisible"><a name="ensureCursorVisible"></a><span class="type">void</span> QPlainTextEdit::<span class="name">ensureCursorVisible</span>()</h3>
<p>Ensures that the cursor is visible by scrolling the text edit if necessary.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#centerCursor">centerCursor</a>() 和 <a href="qplaintextedit.html#centerOnScroll-prop">centerOnScroll</a>.</p>
<!-- @@@ensureCursorVisible -->
<!-- $$$extraSelections[overload1]$$$extraSelections -->
<h3 class="fn" id="extraSelections"><a name="extraSelections"></a><span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qtextedit-extraselection.html">QTextEdit::ExtraSelection</a></span>&gt; QPlainTextEdit::<span class="name">extraSelections</span>() const</h3>
<p>Returns previously set extra selections.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#setExtraSelections">setExtraSelections</a>().</p>
<!-- @@@extraSelections -->
<!-- $$$find[overload1]$$$findconstQString&QTextDocument::FindFlags -->
<h3 class="fn" id="find"><a name="find"></a><span class="type">bool</span> QPlainTextEdit::<span class="name">find</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>exp</i>, <span class="type"><a href="../qtgui/qtextdocument.html#FindFlag-enum">QTextDocument::FindFlags</a></span> <i>options</i> = ...)</h3>
<p>Finds the next occurrence of the string, <i>exp</i>, using the given <i>options</i>. Returns <code>true</code> if <i>exp</i> was found and changes the cursor to select the match; otherwise returns <code>false</code>.</p>
<!-- @@@find -->
<!-- $$$find$$$findconstQRegExp&QTextDocument::FindFlags -->
<h3 class="fn" id="find-1"><a name="find-1"></a><span class="type">bool</span> QPlainTextEdit::<span class="name">find</span>(const <span class="type"><a href="../qtcore/qregexp.html">QRegExp</a></span> &amp;<i>exp</i>, <span class="type"><a href="../qtgui/qtextdocument.html#FindFlag-enum">QTextDocument::FindFlags</a></span> <i>options</i> = ...)</h3>
<p>这是一个重载函数。</p>
<p>Finds the next occurrence, matching the regular expression, <i>exp</i>, using the given <i>options</i>. The <a href="../qtgui/qtextdocument.html#FindFlag-enum">QTextDocument::FindCaseSensitively</a> option is ignored for this overload, use <a href="../qtcore/qregexp.html#caseSensitivity">QRegExp::caseSensitivity</a> instead.</p>
<p>Returns <code>true</code> if a match was found and changes the cursor to select the match; otherwise returns <code>false</code>.</p>
<p>这个函数是在Qt 5.3版本中新增引入的。</p>
<!-- @@@find -->
<!-- $$$firstVisibleBlock[overload1]$$$firstVisibleBlock -->
<h3 class="fn" id="firstVisibleBlock"><a name="firstVisibleBlock"></a><code>[保护函数] </code><span class="type"><a href="../qtgui/qtextblock.html">QTextBlock</a></span> QPlainTextEdit::<span class="name">firstVisibleBlock</span>() const</h3>
<p>Returns the first visible block.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#blockBoundingRect">blockBoundingRect</a>().</p>
<!-- @@@firstVisibleBlock -->
<!-- $$$focusInEvent[overload1]$$$focusInEventQFocusEvent* -->
<h3 class="fn" id="focusInEvent"><a name="focusInEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">focusInEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html">QFocusEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qwidget.html#focusInEvent">QWidget::focusInEvent</a>().</p>
<!-- @@@focusInEvent -->
<!-- $$$focusNextPrevChild[overload1]$$$focusNextPrevChildbool -->
<h3 class="fn" id="focusNextPrevChild"><a name="focusNextPrevChild"></a><code>[重载虚保护函数] </code><span class="type">bool</span> QPlainTextEdit::<span class="name">focusNextPrevChild</span>(<span class="type">bool</span> <i>next</i>)</h3>
<p>重新实现了父类函数接口 <a href="qwidget.html#focusNextPrevChild">QWidget::focusNextPrevChild</a>().</p>
<!-- @@@focusNextPrevChild -->
<!-- $$$focusOutEvent[overload1]$$$focusOutEventQFocusEvent* -->
<h3 class="fn" id="focusOutEvent"><a name="focusOutEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">focusOutEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html">QFocusEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qwidget.html#focusOutEvent">QWidget::focusOutEvent</a>().</p>
<!-- @@@focusOutEvent -->
<!-- $$$getPaintContext[overload1]$$$getPaintContext -->
<h3 class="fn" id="getPaintContext"><a name="getPaintContext"></a><code>[保护函数] </code><span class="type"><a href="../qtgui/qabstracttextdocumentlayout-paintcontext.html">QAbstractTextDocumentLayout::PaintContext</a></span> QPlainTextEdit::<span class="name">getPaintContext</span>() const</h3>
<p>Returns the paint context for the <a href="qabstractscrollarea.html#viewport">viewport</a>(), useful only when reimplementing <a href="qplaintextedit.html#paintEvent">paintEvent</a>().</p>
<!-- @@@getPaintContext -->
<!-- $$$inputMethodEvent[overload1]$$$inputMethodEventQInputMethodEvent* -->
<h3 class="fn" id="inputMethodEvent"><a name="inputMethodEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">inputMethodEvent</span>(<span class="type"><a href="../qtgui/qinputmethodevent.html">QInputMethodEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qwidget.html#inputMethodEvent">QWidget::inputMethodEvent</a>().</p>
<!-- @@@inputMethodEvent -->
<!-- $$$inputMethodQuery[overload1]$$$inputMethodQueryQt::InputMethodQuery -->
<h3 class="fn" id="inputMethodQuery"><a name="inputMethodQuery"></a><code>[重载虚函数] </code><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QPlainTextEdit::<span class="name">inputMethodQuery</span>(<span class="type">Qt::InputMethodQuery</span> <i>property</i>) const</h3>
<p>重新实现了父类函数接口 <a href="qwidget.html#inputMethodQuery">QWidget::inputMethodQuery</a>().</p>
<!-- @@@inputMethodQuery -->
<!-- $$$insertFromMimeData[overload1]$$$insertFromMimeDataconstQMimeData* -->
<h3 class="fn" id="insertFromMimeData"><a name="insertFromMimeData"></a><code>[虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">insertFromMimeData</span>(const <span class="type"><a href="../qtcore/qmimedata.html">QMimeData</a></span> *<i>source</i>)</h3>
<p>This function inserts the contents of the MIME data object, specified by <i>source</i>, into the text edit at the current cursor position. It is called whenever text is inserted as the result of a clipboard paste operation, or when the text edit accepts data from a drag and drop operation.</p>
<!-- @@@insertFromMimeData -->
<!-- $$$insertPlainText[overload1]$$$insertPlainTextconstQString& -->
<h3 class="fn" id="insertPlainText"><a name="insertPlainText"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">insertPlainText</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>text</i>)</h3>
<p>Convenience slot that inserts <i>text</i> at the current cursor position.</p>
<p>It is equivalent to</p>
<pre class="cpp">

  edit<span class="operator">-</span><span class="operator">&gt;</span>textCursor()<span class="operator">.</span>insertText(text);

</pre>
<!-- @@@insertPlainText -->
<!-- $$$keyPressEvent[overload1]$$$keyPressEventQKeyEvent* -->
<h3 class="fn" id="keyPressEvent"><a name="keyPressEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">keyPressEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html">QKeyEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#keyPressEvent">QAbstractScrollArea::keyPressEvent</a>().</p>
<!-- @@@keyPressEvent -->
<!-- $$$keyReleaseEvent[overload1]$$$keyReleaseEventQKeyEvent* -->
<h3 class="fn" id="keyReleaseEvent"><a name="keyReleaseEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">keyReleaseEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html">QKeyEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qwidget.html#keyReleaseEvent">QWidget::keyReleaseEvent</a>().</p>
<!-- @@@keyReleaseEvent -->
<!-- $$$loadResource[overload1]$$$loadResourceintconstQUrl& -->
<h3 class="fn" id="loadResource"><a name="loadResource"></a><code>[虚函数] </code><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QPlainTextEdit::<span class="name">loadResource</span>(<span class="type">int</span> <i>type</i>, const <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> &amp;<i>name</i>)</h3>
<p>Loads the resource specified by the given <i>type</i> and <i>name</i>.</p>
<p>This function is an extension of <a href="../qtgui/qtextdocument.html#loadResource">QTextDocument::loadResource</a>().</p>
<p><b> 参见 </b><a href="../qtgui/qtextdocument.html#loadResource">QTextDocument::loadResource</a>().</p>
<!-- @@@loadResource -->
<!-- $$$mergeCurrentCharFormat[overload1]$$$mergeCurrentCharFormatconstQTextCharFormat& -->
<h3 class="fn" id="mergeCurrentCharFormat"><a name="mergeCurrentCharFormat"></a><span class="type">void</span> QPlainTextEdit::<span class="name">mergeCurrentCharFormat</span>(const <span class="type"><a href="../qtgui/qtextcharformat.html">QTextCharFormat</a></span> &amp;<i>modifier</i>)</h3>
<p>Merges the properties specified in <i>modifier</i> into the current character format by calling <a href="../qtgui/qtextcursor.html#mergeCharFormat">QTextCursor::mergeCharFormat</a> on the editor's cursor. If the editor has a selection then the properties of <i>modifier</i> are directly applied to the selection.</p>
<p><b> 参见 </b><a href="../qtgui/qtextcursor.html#mergeCharFormat">QTextCursor::mergeCharFormat</a>().</p>
<!-- @@@mergeCurrentCharFormat -->
<!-- $$$modificationChanged[overload1]$$$modificationChangedbool -->
<h3 class="fn" id="modificationChanged"><a name="modificationChanged"></a><code>[信号] </code><span class="type">void</span> QPlainTextEdit::<span class="name">modificationChanged</span>(<span class="type">bool</span> <i>changed</i>)</h3>
<p>This signal is emitted whenever the content of the document changes in a way that affects the modification state. If <i>changed</i> is true, the document has been modified; otherwise it is false.</p>
<p>For example, calling setModified(false) on a document and then inserting text causes the signal to get emitted. If you undo that operation, causing the document to return to its original unmodified state, the signal will get emitted again.</p>
<!-- @@@modificationChanged -->
<!-- $$$mouseDoubleClickEvent[overload1]$$$mouseDoubleClickEventQMouseEvent* -->
<h3 class="fn" id="mouseDoubleClickEvent"><a name="mouseDoubleClickEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#mouseDoubleClickEvent">QAbstractScrollArea::mouseDoubleClickEvent</a>().</p>
<!-- @@@mouseDoubleClickEvent -->
<!-- $$$mouseMoveEvent[overload1]$$$mouseMoveEventQMouseEvent* -->
<h3 class="fn" id="mouseMoveEvent"><a name="mouseMoveEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#mouseMoveEvent">QAbstractScrollArea::mouseMoveEvent</a>().</p>
<!-- @@@mouseMoveEvent -->
<!-- $$$mousePressEvent[overload1]$$$mousePressEventQMouseEvent* -->
<h3 class="fn" id="mousePressEvent"><a name="mousePressEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">mousePressEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#mousePressEvent">QAbstractScrollArea::mousePressEvent</a>().</p>
<!-- @@@mousePressEvent -->
<!-- $$$mouseReleaseEvent[overload1]$$$mouseReleaseEventQMouseEvent* -->
<h3 class="fn" id="mouseReleaseEvent"><a name="mouseReleaseEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#mouseReleaseEvent">QAbstractScrollArea::mouseReleaseEvent</a>().</p>
<!-- @@@mouseReleaseEvent -->
<!-- $$$moveCursor[overload1]$$$moveCursorQTextCursor::MoveOperationQTextCursor::MoveMode -->
<h3 class="fn" id="moveCursor"><a name="moveCursor"></a><span class="type">void</span> QPlainTextEdit::<span class="name">moveCursor</span>(<span class="type"><a href="../qtgui/qtextcursor.html#MoveOperation-enum">QTextCursor::MoveOperation</a></span> <i>operation</i>, <span class="type"><a href="../qtgui/qtextcursor.html#MoveMode-enum">QTextCursor::MoveMode</a></span> <i>mode</i> = QTextCursor::MoveAnchor)</h3>
<p>Moves the cursor by performing the given <i>operation</i>.</p>
<p>If <i>mode</i> is <a href="../qtgui/qtextcursor.html#MoveMode-enum">QTextCursor::KeepAnchor</a>, the cursor selects the text it moves over. This is the same effect that the user achieves when they hold down the Shift key and move the cursor with the cursor keys.</p>
<p><b> 参见 </b><a href="../qtgui/qtextcursor.html#movePosition">QTextCursor::movePosition</a>().</p>
<!-- @@@moveCursor -->
<!-- $$$paintEvent[overload1]$$$paintEventQPaintEvent* -->
<h3 class="fn" id="paintEvent"><a name="paintEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">paintEvent</span>(<span class="type"><a href="../qtgui/qpaintevent.html">QPaintEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#paintEvent">QAbstractScrollArea::paintEvent</a>().</p>
<!-- @@@paintEvent -->
<!-- $$$paste[overload1]$$$paste -->
<h3 class="fn" id="paste"><a name="paste"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">paste</span>()</h3>
<p>Pastes the text from the clipboard into the text edit at the current cursor position.</p>
<p>If there is no text in the clipboard nothing happens.</p>
<p>To change the behavior of this function, i.e&#x2e; to modify what <a href="qplaintextedit.html">QPlainTextEdit</a> can paste and how it is being pasted, reimplement the virtual <a href="qplaintextedit.html#canInsertFromMimeData">canInsertFromMimeData</a>() 和 <a href="qplaintextedit.html#insertFromMimeData">insertFromMimeData</a>() functions.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#cut">cut</a>() 和 <a href="qplaintextedit.html#copy">copy</a>().</p>
<!-- @@@paste -->
<!-- $$$print[overload1]$$$printQPagedPaintDevice* -->
<h3 class="fn" id="print"><a name="print"></a><span class="type">void</span> QPlainTextEdit::<span class="name">print</span>(<span class="type"><a href="../qtgui/qpagedpaintdevice.html">QPagedPaintDevice</a></span> *<i>printer</i>) const</h3>
<p>Convenience function to print the text edit's document to the given <i>printer</i>. This is equivalent to calling the print method on the document directly except that this function also supports QPrinter::Selection as print range.</p>
<p><b> 参见 </b><a href="../qtgui/qtextdocument.html#print">QTextDocument::print</a>().</p>
<!-- @@@print -->
<!-- $$$redo[overload1]$$$redo -->
<h3 class="fn" id="redo"><a name="redo"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">redo</span>()</h3>
<p>Redoes the last operation.</p>
<p>If there is no operation to redo, i.e&#x2e; there is no redo step in the undo/redo history, nothing happens.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#undo">undo</a>().</p>
<!-- @@@redo -->
<!-- $$$redoAvailable[overload1]$$$redoAvailablebool -->
<h3 class="fn" id="redoAvailable"><a name="redoAvailable"></a><code>[信号] </code><span class="type">void</span> QPlainTextEdit::<span class="name">redoAvailable</span>(<span class="type">bool</span> <i>available</i>)</h3>
<p>This signal is emitted whenever redo operations become available (<i>available</i> is true) or unavailable (<i>available</i> is false).</p>
<!-- @@@redoAvailable -->
<!-- $$$resizeEvent[overload1]$$$resizeEventQResizeEvent* -->
<h3 class="fn" id="resizeEvent"><a name="resizeEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">resizeEvent</span>(<span class="type"><a href="../qtgui/qresizeevent.html">QResizeEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#resizeEvent">QAbstractScrollArea::resizeEvent</a>().</p>
<!-- @@@resizeEvent -->
<!-- $$$scrollContentsBy[overload1]$$$scrollContentsByintint -->
<h3 class="fn" id="scrollContentsBy"><a name="scrollContentsBy"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">scrollContentsBy</span>(<span class="type">int</span> <i>dx</i>, <span class="type">int</span> <i>dy</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#scrollContentsBy">QAbstractScrollArea::scrollContentsBy</a>().</p>
<!-- @@@scrollContentsBy -->
<!-- $$$selectAll[overload1]$$$selectAll -->
<h3 class="fn" id="selectAll"><a name="selectAll"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">selectAll</span>()</h3>
<p>Selects all text.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#copy">copy</a>(), <a href="qplaintextedit.html#cut">cut</a>(), 和 <a href="qplaintextedit.html#textCursor">textCursor</a>().</p>
<!-- @@@selectAll -->
<!-- $$$selectionChanged[overload1]$$$selectionChanged -->
<h3 class="fn" id="selectionChanged"><a name="selectionChanged"></a><code>[信号] </code><span class="type">void</span> QPlainTextEdit::<span class="name">selectionChanged</span>()</h3>
<p>只要选中内容发生变化，就会触发该信号。</p>
<p><b> 参见 </b><a href="qplaintextedit.html#copyAvailable">copyAvailable</a>().</p>
<!-- @@@selectionChanged -->
<!-- $$$setCurrentCharFormat[overload1]$$$setCurrentCharFormatconstQTextCharFormat& -->
<h3 class="fn" id="setCurrentCharFormat"><a name="setCurrentCharFormat"></a><span class="type">void</span> QPlainTextEdit::<span class="name">setCurrentCharFormat</span>(const <span class="type"><a href="../qtgui/qtextcharformat.html">QTextCharFormat</a></span> &amp;<i>format</i>)</h3>
<p>Sets the char format that is be used when inserting new text to <i>format</i> by calling <a href="../qtgui/qtextcursor.html#setCharFormat">QTextCursor::setCharFormat</a>() on the editor's cursor. If the editor has a selection then the char format is directly applied to the selection.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#currentCharFormat">currentCharFormat</a>().</p>
<!-- @@@setCurrentCharFormat -->
<!-- $$$setDocument[overload1]$$$setDocumentQTextDocument* -->
<h3 class="fn" id="setDocument"><a name="setDocument"></a><span class="type">void</span> QPlainTextEdit::<span class="name">setDocument</span>(<span class="type"><a href="../qtgui/qtextdocument.html">QTextDocument</a></span> *<i>document</i>)</h3>
<p>Makes <i>document</i> the new document of the text editor.</p>
<p>The parent <a href="../qtcore/qobject.html">QObject</a> of the provided document remains the owner of the object. If the current document is a child of the text editor, then it is deleted.</p>
<p>The document must have a document layout that inherits <a href="qplaintextdocumentlayout.html">QPlainTextDocumentLayout</a> (see <a href="../qtgui/qtextdocument.html#setDocumentLayout">QTextDocument::setDocumentLayout</a>()).</p>
<p><b> 参见 </b><a href="qplaintextedit.html#document">document</a>().</p>
<!-- @@@setDocument -->
<!-- $$$setExtraSelections[overload1]$$$setExtraSelectionsconstQList<QTextEdit::ExtraSelection>& -->
<h3 class="fn" id="setExtraSelections"><a name="setExtraSelections"></a><span class="type">void</span> QPlainTextEdit::<span class="name">setExtraSelections</span>(const <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qtextedit-extraselection.html">QTextEdit::ExtraSelection</a></span>&gt; &amp;<i>selections</i>)</h3>
<p>This function allows temporarily marking certain regions in the document with a given color, specified as <i>selections</i>. This can be useful for example in a programming editor to mark a whole line of text with a given background color to indicate the existence of a breakpoint.</p>
<p><b> 参见 </b><a href="qtextedit-extraselection.html">QTextEdit::ExtraSelection</a> 和 <a href="qplaintextedit.html#extraSelections">extraSelections</a>().</p>
<!-- @@@setExtraSelections -->
<!-- $$$setPlainText -->
<h3 class="fn" id="setPlainText"><a name="setPlainText"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">setPlainText</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>text</i>)</h3>
<p>Changes the text of the text edit to the string <i>text</i>. Any previous text is removed.</p>
<p><i>text</i> is interpreted as plain text.</p>
<p>Note that the undo/redo history is cleared by this function.</p>
<p><b>注意：</b> 此设置函数来自于属性 <a href="qplaintextedit.html#plainText-prop">plainText</a>. </p><p><b> 参见 </b><a href="qplaintextedit.html#toPlainText">toPlainText</a>().</p>
<!-- @@@setPlainText -->
<!-- $$$setTextCursor[overload1]$$$setTextCursorconstQTextCursor& -->
<h3 class="fn" id="setTextCursor"><a name="setTextCursor"></a><span class="type">void</span> QPlainTextEdit::<span class="name">setTextCursor</span>(const <span class="type"><a href="../qtgui/qtextcursor.html">QTextCursor</a></span> &amp;<i>cursor</i>)</h3>
<p>Sets the visible <i>cursor</i>.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#textCursor">textCursor</a>().</p>
<!-- @@@setTextCursor -->
<!-- $$$showEvent[overload1]$$$showEventQShowEvent* -->
<h3 class="fn" id="showEvent"><a name="showEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">showEvent</span>(<i>QShowEvent *</i>)</h3>
<p>重新实现了父类函数接口 <a href="qwidget.html#showEvent">QWidget::showEvent</a>().</p>
<!-- @@@showEvent -->
<!-- $$$textChanged -->
<h3 class="fn" id="textChanged"><a name="textChanged"></a><code>[信号] </code><span class="type">void</span> QPlainTextEdit::<span class="name">textChanged</span>()</h3>
<p>This signal is emitted whenever the document's content changes; for example, when text is inserted or deleted, or when formatting is applied.</p>
<p><b>注意：</b> 此通知信号来自于属性 <a href="qplaintextedit.html#plainText-prop">plainText</a>. </p><!-- @@@textChanged -->
<!-- $$$textCursor[overload1]$$$textCursor -->
<h3 class="fn" id="textCursor"><a name="textCursor"></a><span class="type"><a href="../qtgui/qtextcursor.html">QTextCursor</a></span> QPlainTextEdit::<span class="name">textCursor</span>() const</h3>
<p>Returns a copy of the <a href="../qtgui/qtextcursor.html">QTextCursor</a> that represents the currently visible cursor. Note that changes on the returned cursor do not affect <a href="qplaintextedit.html">QPlainTextEdit</a>'s cursor; use <a href="qplaintextedit.html#setTextCursor">setTextCursor</a>() to update the visible cursor.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#setTextCursor">setTextCursor</a>().</p>
<!-- @@@textCursor -->
<!-- $$$toPlainText -->
<h3 class="fn" id="toPlainText"><a name="toPlainText"></a><span class="type"><a href="../qtcore/qstring.html">QString</a></span> QPlainTextEdit::<span class="name">toPlainText</span>() const</h3>
<p>Returns the text of the text edit as plain text.</p>
<p><b>注意：</b> 此获取函数来自于属性 <a href="qplaintextedit.html#plainText-prop">plainText</a>. </p><p><b> 参见 </b><a href="qplaintextedit.html#setPlainText">QPlainTextEdit::setPlainText</a>().</p>
<!-- @@@toPlainText -->
<!-- $$$undo[overload1]$$$undo -->
<h3 class="fn" id="undo"><a name="undo"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">undo</span>()</h3>
<p>Undoes the last operation.</p>
<p>If there is no operation to undo, i.e&#x2e; there is no undo step in the undo/redo history, nothing happens.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#redo">redo</a>().</p>
<!-- @@@undo -->
<!-- $$$undoAvailable[overload1]$$$undoAvailablebool -->
<h3 class="fn" id="undoAvailable"><a name="undoAvailable"></a><code>[信号] </code><span class="type">void</span> QPlainTextEdit::<span class="name">undoAvailable</span>(<span class="type">bool</span> <i>available</i>)</h3>
<p>This signal is emitted whenever undo operations become available (<i>available</i> is true) or unavailable (<i>available</i> is false).</p>
<!-- @@@undoAvailable -->
<!-- $$$updateRequest[overload1]$$$updateRequestconstQRect&int -->
<h3 class="fn" id="updateRequest"><a name="updateRequest"></a><code>[信号] </code><span class="type">void</span> QPlainTextEdit::<span class="name">updateRequest</span>(const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span> &amp;<i>rect</i>, <span class="type">int</span> <i>dy</i>)</h3>
<p>This signal is emitted when the text document needs an update of the specified <i>rect</i>. If the text is scrolled, <i>rect</i> will cover the entire viewport area. If the text is scrolled vertically, <i>dy</i> carries the amount of pixels the viewport was scrolled.</p>
<p>The purpose of the signal is to support extra widgets in plain text edit subclasses that e.g&#x2e; show line numbers, breakpoints, or other extra information.</p>
<!-- @@@updateRequest -->
<!-- $$$wheelEvent[overload1]$$$wheelEventQWheelEvent* -->
<h3 class="fn" id="wheelEvent"><a name="wheelEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">wheelEvent</span>(<span class="type"><a href="../qtgui/qwheelevent.html">QWheelEvent</a></span> *<i>e</i>)</h3>
<p>重新实现了父类函数接口 <a href="qabstractscrollarea.html#wheelEvent">QAbstractScrollArea::wheelEvent</a>().</p>
<!-- @@@wheelEvent -->
<!-- $$$zoomIn[overload1]$$$zoomInint -->
<h3 class="fn" id="zoomIn"><a name="zoomIn"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">zoomIn</span>(<span class="type">int</span> <i>range</i> = 1)</h3>
<p>Zooms in on the text by making the base font size <i>range</i> points larger and recalculating all font sizes to be the new size. This does not change the size of any images.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#zoomOut">zoomOut</a>().</p>
<!-- @@@zoomIn -->
<!-- $$$zoomOut[overload1]$$$zoomOutint -->
<h3 class="fn" id="zoomOut"><a name="zoomOut"></a><code>[槽函数] </code><span class="type">void</span> QPlainTextEdit::<span class="name">zoomOut</span>(<span class="type">int</span> <i>range</i> = 1)</h3>
<p>Zooms out on the text by making the base font size <i>range</i> points smaller and recalculating all font sizes to be the new size. This does not change the size of any images.</p>
<p><b> 参见 </b><a href="qplaintextedit.html#zoomIn">zoomIn</a>().</p>
<!-- @@@zoomOut -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
