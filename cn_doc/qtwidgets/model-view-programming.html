<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- model-view-programming.qdoc -->
  <title>Model/View Programming | Qt部件模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtwidgets-index.html">Qt部件</a></td><td >模型/视图的编程</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#introduction-to-model-view-programming">模型/视图编程简介</a></li>
<li class="level2"><a href="#the-model-view-architecture">模型/视图架构</a></li>
<li class="level1"><a href="#using-models-and-views">使用模型和视图</a></li>
<li class="level2"><a href="#two-models-included-in-qt">Qt中包含的两个模型</a></li>
<li class="level2"><a href="#using-views-with-an-existing-model">使用现有模型的视图</a></li>
<li class="level1"><a href="#model-classes">模型类</a></li>
<li class="level2"><a href="#basic-concepts">基本概念</a></li>
<li class="level2"><a href="#using-model-indexes">使用模型索引</a></li>
<li class="level2"><a href="#further-reading">进一步读取</a></li>
<li class="level1"><a href="#view-classes">视图类</a></li>
<li class="level2"><a href="#concepts">概念</a></li>
<li class="level2"><a href="#using-an-existing-view">使用现有视图</a></li>
<li class="level2"><a href="#handling-selections-of-items">选择项的处理</a></li>
<li class="level1"><a href="#delegate-classes">委托类</a></li>
<li class="level2"><a href="#concepts">概念</a></li>
<li class="level2"><a href="#using-an-existing-delegate">使用现有委托</a></li>
<li class="level2"><a href="#a-simple-delegate">简单委托</a></li>
<li class="level1"><a href="#handling-selections-in-item-views">处理项目视图中的选择</a></li>
<li class="level2"><a href="#concepts">概念</a></li>
<li class="level2"><a href="#using-a-selection-model">使用选择模型</a></li>
<li class="level1"><a href="#creating-new-models">创建新模型</a></li>
<li class="level2"><a href="#designing-a-model">设计模型</a></li>
<li class="level2"><a href="#a-read-only-example-model">只读的样例模型</a></li>
<li class="level2"><a href="#an-editable-model">可编辑的模型</a></li>
<li class="level2"><a href="#next-steps">下一步</a></li>
<li class="level1"><a href="#item-view-convenience-classes">项目视图的便利类</a></li>
<li class="level2"><a href="#list-widgets">列表部件</a></li>
<li class="level2"><a href="#tree-widgets">树形部件</a></li>
<li class="level2"><a href="#table-widgets">表格部件</a></li>
<li class="level2"><a href="#common-features">常用功能</a></li>
<li class="level1"><a href="#using-drag-and-drop-with-item-views">项目视图中使用拖放</a></li>
<li class="level2"><a href="#using-convenience-views">使用便利视图</a></li>
<li class="level2"><a href="#using-model-view-classes">使用模型/视图类</a></li>
<li class="level1"><a href="#proxy-models">代理模型</a></li>
<li class="level2"><a href="#using-proxy-models">使用代理模型</a></li>
<li class="level2"><a href="#customizing-proxy-models">自定义代理模型</a></li>
<li class="level1"><a href="#model-subclassing-reference">模型子类化参考</a></li>
<li class="level2"><a href="#item-data-handling">项数据处理</a></li>
<li class="level2"><a href="#read-only-access">只读访问</a></li>
<li class="level2"><a href="#navigation-and-model-index-creation">模型索引的导航和创建</a></li>
<li class="level2"><a href="#drag-and-drop-support-and-mime-type-handling">支持拖放和处理MIME类型</a></li>
<li class="level2"><a href="#performance-optimization-for-large-amounts-of-data">大量数据的性能优化</a></li>
<li class="level1"><a href="#the-model-view-classes">模型/视图类</a></li>
<li class="level1"><a href="#related-examples">相关样例</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">模型/视图的编程</h1>
<span class="subtitle"></span>
<!-- $$$model-view-programming.html-description -->
<div class="descr"> <a name="details"></a>
<a name="introduction-to-model-view-programming"></a>
<h2 id="introduction-to-model-view-programming">模型/视图编程简介</h2>
<p>Qt contains a set of item view classes that use a model/view architecture to manage the relationship between data and the way it is presented to the user. The separation of functionality introduced by this architecture gives developers greater flexibility to customize the presentation of items, and provides a standard model interface to allow a wide range of data sources to be used with existing item views. In this document, we give a brief introduction to the model/view paradigm, outline the concepts involved, and describe the architecture of the item view system. Each of the components in the architecture is explained, and examples are given that show how to use the classes provided.</p>
<a name="the-model-view-architecture"></a>
<h3 >模型/视图架构</h3>
<p>Model-View-Controller (MVC) is a design pattern originating from Smalltalk that is often used when building user interfaces. In <a href="guibooks.html#design-patterns">Design Patterns</a>, Gamma et al. write:</p>
<blockquote><p>MVC consists of three kinds of objects. The Model is the application object, the View is its screen presentation, and the Controller defines the way the user interface reacts to user input. Before MVC, user interface designs tended to lump these objects together. MVC decouples them to increase flexibility and reuse.</p>
</blockquote>
<p>If the view and the controller objects are combined, the result is the model/view architecture. This still separates the way that data is stored from the way that it is presented to the user, but provides a simpler framework based on the same principles. This separation makes it possible to display the same data in several different views, and to implement new types of views, without changing the underlying data structures. To allow flexible handling of user input, we introduce the concept of the <i>delegate</i>. The advantage of having a delegate in this framework is that it allows the way items of data are rendered and edited to be customized.</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><img src="images/modelview-overview.png" alt="" /></td><td ><b>模型/视图架构</b><p>The model communicates with a source of data, providing an <i>interface</i> for the other components in the architecture. The nature of the communication depends on the type of data source, and the way the model is implemented.</p>
<p>The view obtains <i>model indexes</i> from the model; these are references to items of data. By supplying model indexes to the model, the view can retrieve items of data from the data source.</p>
<p>In standard views, a <i>delegate</i> renders the items of data. When an item is edited, the delegate communicates with the model directly using model indexes.</p>
</td></tr>
</table></div>
<p>Generally, the model/view classes can be separated into the three groups described above: models, views, and delegates. Each of these components is defined by <i>abstract</i> classes that provide common interfaces and, in some cases, default implementations of features. Abstract classes are meant to be subclassed in order to provide the full set of functionality expected by other components; this also allows specialized components to be written.</p>
<p>Models, views, and delegates communicate with each other using <i>signals and slots</i>:</p>
<ul>
<li>Signals from the model inform the view about changes to the data held by the data source.</li>
<li>Signals from the view provide information about the user's interaction with the items being displayed.</li>
<li>Signals from the delegate are used during editing to tell the model and view about the state of the editor.</li>
</ul>
<a name="models"></a>
<h4 >模型</h4>
<p>All item models are based on the <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> class. This class defines an interface that is used by views and delegates to access data. The data itself does not have to be stored in the model; it can be held in a data structure or repository provided by a separate class, a file, a database, or some other application component.</p>
<p>The basic concepts surrounding models are presented in the section on <a href="model-view-programming.html#model-classes">模型类</a>.</p>
<p><a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> provides an interface to data that is flexible enough to handle views that represent data in the form of tables, lists, and trees. However, when implementing new models for list and table-like data structures, the <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a> 和 <a href="../qtcore/qabstracttablemodel.html">QAbstractTableModel</a> classes are better starting points because they provide appropriate default implementations of common functions. Each of these classes can be subclassed to provide models that support specialized kinds of lists and tables.</p>
<p>The process of subclassing models is discussed in the section on <a href="model-view-programming.html#creating-new-models">创建新模型</a>.</p>
<p>Qt provides some ready-made models that can be used to handle items of data:</p>
<ul>
<li><a href="../qtcore/qstringlistmodel.html">QStringListModel</a> is used to store a simple list of <a href="../qtcore/qstring.html">QString</a> items.</li>
<li><a href="../qtgui/qstandarditemmodel.html">QStandardItemModel</a> manages more complex tree structures of items, each of which can contain arbitrary data.</li>
<li><a href="qfilesystemmodel.html">QFileSystemModel</a> provides information about files and directories in the local filing system.</li>
<li><a href="../qtsql/qsqlquerymodel.html">QSqlQueryModel</a>, <a href="../qtsql/qsqltablemodel.html">QSqlTableModel</a>, 和 <a href="../qtsql/qsqlrelationaltablemodel.html">QSqlRelationalTableModel</a> are used to access databases using model/view conventions.</li>
</ul>
<p>If these standard models do not meet your requirements, you can subclass <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>, <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a>, or <a href="../qtcore/qabstracttablemodel.html">QAbstractTableModel</a> to create your own custom models.</p>
<a name="views"></a>
<h4 >视图</h4>
<p>Complete implementations are provided for different kinds of views: <a href="qlistview.html">QListView</a> displays a list of items, <a href="qtableview.html">QTableView</a> displays data from a model in a table, and <a href="qtreeview.html">QTreeView</a> shows model items of data in a hierarchical list. Each of these classes is based on the <a href="qabstractitemview.html">QAbstractItemView</a> abstract base class. Although these classes are ready-to-use implementations, they can also be subclassed to provide customized views.</p>
<p>The available views are examined in the section on <a href="model-view-programming.html#view-classes">视图类</a>.</p>
<a name="delegates"></a>
<h4 >委托</h4>
<p><a href="qabstractitemdelegate.html">QAbstractItemDelegate</a> is the abstract base class for delegates in the model/view framework. The default delegate implementation is provided by <a href="qstyleditemdelegate.html">QStyledItemDelegate</a>, and this is used as the default delegate by Qt's standard views. However, <a href="qstyleditemdelegate.html">QStyledItemDelegate</a> 和 <a href="qitemdelegate.html">QItemDelegate</a> are independent alternatives to painting and providing editors for items in views. The difference between them is that <a href="qstyleditemdelegate.html">QStyledItemDelegate</a> uses the current style to paint its items. We therefore recommend using <a href="qstyleditemdelegate.html">QStyledItemDelegate</a> as the base class when implementing custom delegates or when working with Qt style sheets.</p>
<p>Delegates are described in the section on <a href="model-view-programming.html#delegate-classes">委托类</a>.</p>
<a name="sorting"></a>
<h4 >排序</h4>
<p>There are two ways of approaching sorting in the model/view architecture; which approach to choose depends on your underlying model.</p>
<p>If your model is sortable, i.e, if it reimplements the <a href="../qtcore/qabstractitemmodel.html#sort">QAbstractItemModel::sort</a>() function, both <a href="qtableview.html">QTableView</a> 和 <a href="qtreeview.html">QTreeView</a> provide an API that allows you to sort your model data programmatically. In addition, you can enable interactive sorting (i.e&#x2e; allowing the users to sort the data by clicking the view's headers), by connecting the <a href="qheaderview.html#sortIndicatorChanged">QHeaderView::sortIndicatorChanged</a>() signal to the <a href="qtableview.html#sortByColumn">QTableView::sortByColumn</a>() slot or the <a href="qtreeview.html#sortByColumn">QTreeView::sortByColumn</a>() slot, respectively.</p>
<p>The alternative approach, if your model does not have the required interface or if you want to use a list view to present your data, is to use a proxy model to transform the structure of your model before presenting the data in the view. This is covered in detail in the section on <a href="model-view-programming.html#proxy-models">代理模型</a>.</p>
<a name="convenience-classes"></a>
<h4 >便利类</h4>
<p>A number of <i>convenience</i> classes are derived from the standard view classes for the benefit of applications that rely on Qt's item-based item view and table classes. They are not intended to be subclassed.</p>
<p>Examples of such classes include <a href="qlistwidget.html">QListWidget</a>, <a href="qtreewidget.html">QTreeWidget</a>, 和 <a href="qtablewidget.html">QTableWidget</a>.</p>
<p>These classes are less flexible than the view classes, and cannot be used with arbitrary models. We recommend that you use a model/view approach to handling data in item views unless you strongly need an item-based set of classes.</p>
<p>If you wish to take advantage of the features provided by the model/view approach while still using an item-based interface, consider using view classes, such as <a href="qlistview.html">QListView</a>, <a href="qtableview.html">QTableView</a>, 和 <a href="qtreeview.html">QTreeView</a> with <a href="../qtgui/qstandarditemmodel.html">QStandardItemModel</a>.</p>
<a name="using-models-and-views"></a>
<h2 id="using-models-and-views">使用模型和视图</h2>
<p>The following sections explain how to use the model/view pattern in Qt. Each section includes an example and is followed by a section showing how to create new components.</p>
<a name="two-models-included-in-qt"></a>
<h3 >Qt中包含的两个模型</h3>
<p>Two of the standard models provided by Qt are <a href="../qtgui/qstandarditemmodel.html">QStandardItemModel</a> 和 <a href="qfilesystemmodel.html">QFileSystemModel</a>. <a href="../qtgui/qstandarditemmodel.html">QStandardItemModel</a> is a multi-purpose model that can be used to represent various different data structures needed by list, table, and tree views. This model also holds the items of data. <a href="qfilesystemmodel.html">QFileSystemModel</a> is a model that maintains information about the contents of a directory. As a result, it does not hold any items of data itself, but simply represents files and directories on the local filing system.</p>
<p><a href="qfilesystemmodel.html">QFileSystemModel</a> provides a ready-to-use model to experiment with, and can be easily configured to use existing data. Using this model, we can show how to set up a model for use with ready-made views, and explore how to manipulate data using model indexes.</p>
<a name="using-views-with-an-existing-model"></a>
<h3 >使用现有模型的视图</h3>
<p>The <a href="qlistview.html">QListView</a> 和 <a href="qtreeview.html">QTreeView</a> classes are the most suitable views to use with <a href="qfilesystemmodel.html">QFileSystemModel</a>. The example presented below displays the contents of a directory in a tree view next to the same information in a list view. The views share the user's selection so that the selected items are highlighted in both views.</p>
<p class="centerAlign"><img src="images/shareddirmodel.png" alt="" /></p><p>We set up a <a href="qfilesystemmodel.html">QFileSystemModel</a> so that it is ready for use, and create some views to display the contents of a directory. This shows the simplest way to use a model. The construction and use of the model is performed from within a single <code>main()</code> function:</p>
<pre class="cpp">

  <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>argv<span class="operator">[</span><span class="operator">]</span>)
  {
      <span class="type"><a href="qapplication.html">QApplication</a></span> app(argc<span class="operator">,</span> argv);
      <span class="type"><a href="qsplitter.html">QSplitter</a></span> <span class="operator">*</span>splitter <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qsplitter.html">QSplitter</a></span>;

      <span class="type"><a href="qfilesystemmodel.html">QFileSystemModel</a></span> <span class="operator">*</span>model <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qfilesystemmodel.html">QFileSystemModel</a></span>;
      model<span class="operator">-</span><span class="operator">&gt;</span>setRootPath(<span class="type"><a href="../qtcore/qdir.html">QDir</a></span><span class="operator">::</span>currentPath());

</pre>
<p>The model is set up to use data from a certain file system. The call to <a href="qfilesystemmodel.html#setRootPath">setRootPath()</a> tells the model which drive on the file system to expose to the views.</p>
<p>We create two views so that we can examine the items held in the model in two different ways:</p>
<pre class="cpp">

      <span class="type"><a href="qtreeview.html">QTreeView</a></span> <span class="operator">*</span>tree <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtreeview.html">QTreeView</a></span>(splitter);
      tree<span class="operator">-</span><span class="operator">&gt;</span>setModel(model);
      tree<span class="operator">-</span><span class="operator">&gt;</span>setRootIndex(model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="type"><a href="../qtcore/qdir.html">QDir</a></span><span class="operator">::</span>currentPath()));

      <span class="type"><a href="qlistview.html">QListView</a></span> <span class="operator">*</span>list <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qlistview.html">QListView</a></span>(splitter);
      list<span class="operator">-</span><span class="operator">&gt;</span>setModel(model);
      list<span class="operator">-</span><span class="operator">&gt;</span>setRootIndex(model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="type"><a href="../qtcore/qdir.html">QDir</a></span><span class="operator">::</span>currentPath()));

</pre>
<p>The views are constructed in the same way as other widgets. Setting up a view to display the items in the model is simply a matter of calling its <a href="qabstractitemview.html#setModel">setModel()</a> function with the directory model as the argument. We filter the data supplied by the model by calling the <a href="qabstractitemview.html#setRootIndex">setRootIndex()</a> function on each view, passing a suitable <i>model index</i> from the file system model for the current directory.</p>
<p>The <code>index()</code> function used in this case is unique to <a href="qfilesystemmodel.html">QFileSystemModel</a>; we supply it with a directory and it returns a model index. Model indexes are discussed in <a href="model-view-programming.html#model-classes">模型类</a>.</p>
<p>The rest of the function just displays the views within a splitter widget, and runs the application's event loop:</p>
<pre class="cpp">

      splitter<span class="operator">-</span><span class="operator">&gt;</span>setWindowTitle(<span class="string">&quot;Two views onto the same file system model&quot;</span>);
      splitter<span class="operator">-</span><span class="operator">&gt;</span>show();
      <span class="keyword">return</span> app<span class="operator">.</span>exec();
  }

</pre>
<p>In the above example, we neglected to mention how to handle selections of items. This subject is covered in more detail in the section about <a href="model-view-programming.html#handling-selections-in-item-views">处理项目视图中的选择</a>.</p>
<a name="model-classes"></a>
<h2 id="model-classes">模型类</h2>
<p>Before examining how selections are handled, you may find it useful to examine the concepts used in the model/view framework.</p>
<a name="basic-concepts"></a>
<h3 >基本概念</h3>
<p>In the model/view architecture, the model provides a standard interface that views and delegates use to access data. In Qt, the standard interface is defined by the <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> class. No matter how the items of data are stored in any underlying data structure, all subclasses of <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> represent the data as a hierarchical structure containing tables of items. Views use this <i>convention</i> to access items of data in the model, but they are not restricted in the way that they present this information to the user.</p>
<p class="centerAlign"><img src="images/modelview-models.png" alt="" /></p><p>Models also notify any attached views about changes to data through the signals and slots mechanism.</p>
<p>This section describes some basic concepts that are central to the way items of data are accessed by other components via a model class. More advanced concepts are discussed in later sections.</p>
<a name="model-indexes"></a>
<h4 >模型索引</h4>
<p>To ensure that the representation of the data is kept separate from the way it is accessed, the concept of a <i>model index</i> is introduced. Each piece of information that can be obtained via a model is represented by a model index. Views and delegates use these indexes to request items of data to display.</p>
<p>As a result, only the model needs to know how to obtain data, and the type of data managed by the model can be defined fairly generally. Model indexes contain a pointer to the model that created them, and this prevents confusion when working with more than one model.</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a></span> <span class="operator">*</span>model <span class="operator">=</span> index<span class="operator">.</span>model();

</pre>
<p>Model indexes provide <i>temporary</i> references to pieces of information, and can be used to retrieve or modify data via the model. Since models may reorganize their internal structures from time to time, model indexes may become invalid, and <i>should not be stored</i>. If a long-term reference to a piece of information is required, a <i>persistent model index</i> must be created. This provides a reference to the information that the model keeps up-to-date. Temporary model indexes are provided by the <a href="../qtcore/qmodelindex.html">QModelIndex</a> class, and persistent model indexes are provided by the <a href="../qtcore/qpersistentmodelindex.html">QPersistentModelIndex</a> class.</p>
<p>To obtain a model index that corresponds to an item of data, three properties must be specified to the model: a row number, a column number, and the model index of a parent item. The following sections describe and explain these properties in detail.</p>
<a name="rows-and-columns"></a>
<h4 >行和列</h4>
<p>In its most basic form, a model can be accessed as a simple table in which items are located by their row and column numbers. <i>This does not mean that the underlying pieces of data are stored in an array structure</i>; the use of row and column numbers is only a convention to allow components to communicate with each other. We can retrieve information about any given item by specifying its row and column numbers to the model, and we receive an index that represents the item:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> index <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(row<span class="operator">,</span> column<span class="operator">,</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);

</pre>
<p>Models that provide interfaces to simple, single level data structures like lists and tables do not need any other information to be provided but, as the above code indicates, we need to supply more information when obtaining a model index.</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><img src="images/modelview-tablemodel.png" alt="" /></td><td ><b>Rows and columns</b><p>The diagram shows a representation of a basic table model in which each item is located by a pair of row and column numbers. We obtain a model index that refers to an item of data by passing the relevant row and column numbers to the model.</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> indexA <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
  <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> indexB <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
  <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> indexC <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">2</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());

</pre>
<p>Top level items in a model are always referenced by specifying <code>QModelIndex()</code> as their parent item. This is discussed in the next section.</p>
</td></tr>
</table></div>
<a name="parents-of-items"></a>
<h4 >项目的父亲</h4>
<p>The table-like interface to item data provided by models is ideal when using data in a table or list view; the row and column number system maps exactly to the way the views display items. However, structures such as tree views require the model to expose a more flexible interface to the items within. As a result, each item can also be the parent of another table of items, in much the same way that a top-level item in a tree view can contain another list of items.</p>
<p>When requesting an index for a model item, we must provide some information about the item's parent. Outside the model, the only way to refer to an item is through a model index, so a parent model index must also be given:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> index <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(row<span class="operator">,</span> column<span class="operator">,</span> parent);

</pre>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><img src="images/modelview-treemodel.png" alt="" /></td><td ><b>Parents, rows, and columns</b><p>The diagram shows a representation of a tree model in which each item is referred to by a parent, a row number, and a column number.</p>
<p>Items &quot;A&quot; and &quot;C&quot; are represented as top-level siblings in the model:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> indexA <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
  <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> indexC <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">2</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());

</pre>
<p>Item &quot;A&quot; has a number of children. A model index for item &quot;B&quot; is obtained with the following code:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> indexB <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> indexA);

</pre>
</td></tr>
</table></div>
<a name="item-roles"></a>
<h4 >项目的角色</h4>
<p>Items in a model can perform various <i>roles</i> for other components, allowing different kinds of data to be supplied for different situations. For example, <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::DisplayRole</a> is used to access a string that can be displayed as text in a view. Typically, items contain data for a number of different roles, and the standard roles are defined by <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::ItemDataRole</a>.</p>
<p>We can ask the model for the item's data by passing it the model index corresponding to the item, and by specifying a role to obtain the type of data we want:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> value <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>data(index<span class="operator">,</span> role);

</pre>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><img src="images/modelview-roles.png" alt="" /></td><td ><b>Item roles</b><p>The role indicates to the model which type of data is being referred to. Views can display the roles in different ways, so it is important to supply appropriate information for each role.</p>
<p>The <a href="model-view-programming.html#creating-new-models">创建新模型</a> section covers some specific uses of roles in more detail.</p>
</td></tr>
</table></div>
<p>Most common uses for item data are covered by the standard roles defined in <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::ItemDataRole</a>. By supplying appropriate item data for each role, models can provide hints to views and delegates about how items should be presented to the user. Different kinds of views have the freedom to interpret or ignore this information as required. It is also possible to define additional roles for application-specific purposes.</p>
<a name="summary"></a>
<h4 >总述</h4>
<ul>
<li>Model indexes give views and delegates information about the location of items provided by models in a way that is independent of any underlying data structures.</li>
<li>Items are referred to by their row and column numbers, and by the model index of their parent items.</li>
<li>Model indexes are constructed by models at the request of other components, such as views and delegates.</li>
<li>If a valid model index is specified for the parent item when an index is requested using <a href="../qtcore/qabstractitemmodel.html#index">index()</a>, the index returned refers to an item beneath that parent item in the model. The index obtained refers to a child of that item.</li>
<li>If an invalid model index is specified for the parent item when an index is requested using <a href="../qtcore/qabstractitemmodel.html#index">index()</a>, the index returned refers to a top-level item in the model.</li>
<li>The <a href="../qtcore/qt.html#ItemDataRole-enum">role</a> distinguishes between the different kinds of data associated with an item.</li>
</ul>
<a name="using-model-indexes"></a>
<h3 >使用模型索引</h3>
<p>To demonstrate how data can be retrieved from a model, using model indexes, we set up a <a href="qfilesystemmodel.html">QFileSystemModel</a> without a view and display the names of files and directories in a widget. Although this does not show a normal way of using a model, it demonstrates the conventions used by models when dealing with model indexes.</p>
<p>We construct a file system model in the following way:</p>
<pre class="cpp">

      <span class="type"><a href="qfilesystemmodel.html">QFileSystemModel</a></span> <span class="operator">*</span>model <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qfilesystemmodel.html">QFileSystemModel</a></span>;
      <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> parentIndex <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="type"><a href="../qtcore/qdir.html">QDir</a></span><span class="operator">::</span>currentPath());
      <span class="type">int</span> numRows <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>rowCount(parentIndex);

</pre>
<p>In this case, we set up a default <a href="qfilesystemmodel.html">QFileSystemModel</a>, obtain a parent index using a specific implementation of <a href="qfilesystemmodel.html#index">index()</a> provided by that model, and we count the number of rows in the model using the <a href="qfilesystemmodel.html#rowCount">rowCount()</a> function.</p>
<p>For simplicity, we are only interested in the items in the first column of the model. We examine each row in turn, obtaining a model index for the first item in each row, and read the data stored for that item in the model.</p>
<pre class="cpp">

      <span class="keyword">for</span> (<span class="type">int</span> row <span class="operator">=</span> <span class="number">0</span>; row <span class="operator">&lt;</span> numRows; <span class="operator">+</span><span class="operator">+</span>row) {
          <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> index <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(row<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> parentIndex);

</pre>
<p>To obtain a model index, we specify the row number, column number (zero for the first column), and the appropriate model index for the parent of all the items that we want. The text stored in each item is retrieved using the model's <a href="qfilesystemmodel.html#data">data()</a> function. We specify the model index and the <a href="../qtcore/qt.html#ItemDataRole-enum">DisplayRole</a> to obtain data for the item in the form of a string.</p>
<pre class="cpp">

          <span class="type"><a href="../qtcore/qstring.html">QString</a></span> text <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>data(index<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DisplayRole)<span class="operator">.</span>toString();
          <span class="comment">// Display the text in a widget.</span>

      }

</pre>
<p>The above example demonstrates the basic principles used to retrieve data from a model:</p>
<ul>
<li>The dimensions of a model can be found using <a href="../qtcore/qabstractitemmodel.html#rowCount">rowCount()</a> 和 <a href="../qtcore/qabstractitemmodel.html#columnCount">columnCount()</a>. These functions generally require a parent model index to be specified.</li>
<li>Model indexes are used to access items in the model. The row, column, and parent model index are needed to specify the item.</li>
<li>To access top-level items in a model, specify a null model index as the parent index with <code>QModelIndex()</code>.</li>
<li>Items contain data for different roles. To obtain the data for a particular role, both the model index and the role must be supplied to the model.</li>
</ul>
<a name="further-reading"></a>
<h3 >进一步读取</h3>
<p>New models can be created by implementing the standard interface provided by <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>. In the <a href="model-view-programming.html#creating-new-models">创建新模型</a> section, we demonstrate this by creating a convenient ready-to-use model for holding lists of strings.</p>
<a name="view-classes"></a>
<h2 id="view-classes">视图类</h2>
<a name="concepts"></a>
<h3 >概念</h3>
<p>In the model/view architecture, the view obtains items of data from the model and presents them to the user. The way that the data is presented need not resemble the representation of the data provided by the model, and may be <i>completely different</i> from the underlying data structure used to store items of data.</p>
<p>The separation of content and presentation is achieved by the use of a standard model interface provided by <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>, a standard view interface provided by <a href="qabstractitemview.html">QAbstractItemView</a>, and the use of model indexes that represent items of data in a general way. Views typically manage the overall layout of the data obtained from models. They may render individual items of data themselves, or use <a href="model-view-programming.html#delegate-classes">delegates</a> to handle both rendering and editing features.</p>
<p>As well as presenting data, views handle navigation between items, and some aspects of item selection. The views also implement basic user interface features, such as context menus and drag and drop. A view can provide default editing facilities for items, or it may work with a <a href="model-view-programming.html#delegate-classes">delegate</a> to provide a custom editor.</p>
<p>A view can be constructed without a model, but a model must be provided before it can display useful information. Views keep track of the items that the user has selected through the use of <a href="model-view-programming.html#handling-selections-in-item-views">selections</a> which can be maintained separately for each view, or shared between multiple views.</p>
<p>Some views, such as <a href="qtableview.html">QTableView</a> 和 <a href="qtreeview.html">QTreeView</a>, display headers as well as items. These are also implemented by a view class, <a href="qheaderview.html">QHeaderView</a>. Headers usually access the same model as the view that contains them. They retrieve data from the model using the <a href="../qtcore/qabstractitemmodel.html#headerData">QAbstractItemModel::headerData</a>() function, and usually display header information in the form of a label. New headers can be subclassed from the <a href="qheaderview.html">QHeaderView</a> class to provide more specialized labels for views.</p>
<a name="using-an-existing-view"></a>
<h3 >使用现有视图</h3>
<p>Qt provides three ready-to-use view classes that present data from models in ways that are familiar to most users. <a href="qlistview.html">QListView</a> can display items from a model as a simple list, or in the form of a classic icon view. <a href="qtreeview.html">QTreeView</a> displays items from a model as a hierarchy of lists, allowing deeply nested structures to be represented in a compact way. <a href="qtableview.html">QTableView</a> presents items from a model in the form of a table, much like the layout of a spreadsheet application.</p>
<p class="centerAlign"><img src="images/standard-views.png" alt="" /></p><p>The default behavior of the standard views shown above should be sufficient for most applications. They provide basic editing facilities, and can be customized to suit the needs of more specialized user interfaces.</p>
<a name="using-a-model"></a>
<h4 >使用模型</h4>
<p>We take the string list model that <a href="model-view-programming.html#creating-new-models">we created as an example model</a>, set it up with some data, and construct a view to display the contents of the model. This can all be performed within a single function:</p>
<pre class="cpp">

  <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>argv<span class="operator">[</span><span class="operator">]</span>)
  {
      <span class="type"><a href="qapplication.html">QApplication</a></span> app(argc<span class="operator">,</span> argv);

  <span class="comment">// Unindented for quoting purposes:</span>
  <span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> numbers;
  numbers <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;One&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Three&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Four&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Five&quot;</span>;

  <span class="type"><a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a></span> <span class="operator">*</span>model <span class="operator">=</span> <span class="keyword">new</span> StringListModel(numbers);

</pre>
<p>Note that the <code>StringListModel</code> is declared as a <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>. This allows us to use the abstract interface to the model, and ensures that the code still works, even if we replace the string list model with a different model.</p>
<p>The list view provided by <a href="qlistview.html">QListView</a> is sufficient for presenting the items in the string list model. We construct the view, and set up the model using the following lines of code:</p>
<pre class="cpp">

  <span class="type"><a href="qlistview.html">QListView</a></span> <span class="operator">*</span>view <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qlistview.html">QListView</a></span>;
  view<span class="operator">-</span><span class="operator">&gt;</span>setModel(model);

</pre>
<p>The view is shown in the normal way:</p>
<pre class="cpp">

      view<span class="operator">-</span><span class="operator">&gt;</span>show();
      <span class="keyword">return</span> app<span class="operator">.</span>exec();
  }

</pre>
<p>The view renders the contents of a model, accessing data via the model's interface. When the user tries to edit an item, the view uses a default delegate to provide an editor widget.</p>
<p class="centerAlign"><img src="images/stringlistmodel.png" alt="" /></p><p>The above image shows how a <a href="qlistview.html">QListView</a> represents the data in the string list model. Since the model is editable, the view automatically allows each item in the list to be edited using the default delegate.</p>
<a name="using-multiple-views-of-a-model"></a>
<h4 >使用模型的多个视图</h4>
<p>Providing multiple views onto the same model is simply a matter of setting the same model for each view. In the following code we create two table views, each using the same simple table model which we have created for this example:</p>
<pre class="cpp">

      <span class="type"><a href="qtableview.html">QTableView</a></span> <span class="operator">*</span>firstTableView <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtableview.html">QTableView</a></span>;
      <span class="type"><a href="qtableview.html">QTableView</a></span> <span class="operator">*</span>secondTableView <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtableview.html">QTableView</a></span>;

      firstTableView<span class="operator">-</span><span class="operator">&gt;</span>setModel(model);
      secondTableView<span class="operator">-</span><span class="operator">&gt;</span>setModel(model);

</pre>
<p>The use of signals and slots in the model/view architecture means that changes to the model can be propagated to all the attached views, ensuring that we can always access the same data regardless of the view being used.</p>
<p class="centerAlign"><img src="images/sharedmodel-tableviews.png" alt="" /></p><p>The above image shows two different views onto the same model, each containing a number of selected items. Although the data from the model is shown consistently across view, each view maintains its own internal selection model. This can be useful in certain situations but, for many applications, a shared selection model is desirable.</p>
<a name="handling-selections-of-items"></a>
<h3 >选择项的处理</h3>
<p>The mechanism for handling selections of items within views is provided by the <a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a> class. All of the standard views construct their own selection models by default, and interact with them in the normal way. The selection model being used by a view can be obtained through the <a href="qabstractitemview.html#selectionModel">selectionModel()</a> function, and a replacement selection model can be specified with <a href="qabstractitemview.html#setSelectionModel">setSelectionModel()</a>. The ability to control the selection model used by a view is useful when we want to provide multiple consistent views onto the same model data.</p>
<p>Generally, unless you are subclassing a model or view, you don't need to manipulate the contents of selections directly. However, the interface to the selection model can be accessed, if required, and this is explored in <a href="model-view-programming.html#handling-selections-in-item-views">处理项目视图中的选择</a>.</p>
<a name="sharing-selections-among-views"></a>
<h4 >在视图之间共享选择</h4>
<p>Although it is convenient that the view classes provide their own selection models by default, when we use more than one view onto the same model it is often desirable that both the model's data and the user's selection are shown consistently in all views. Since the view classes allow their internal selection models to be replaced, we can achieve a unified selection between views with the following line:</p>
<pre class="cpp">

      secondTableView<span class="operator">-</span><span class="operator">&gt;</span>setSelectionModel(firstTableView<span class="operator">-</span><span class="operator">&gt;</span>selectionModel());

</pre>
<p>The second view is given the selection model for the first view. Both views now operate on the same selection model, keeping both the data and the selected items synchronized.</p>
<p class="centerAlign"><img src="images/sharedselection-tableviews.png" alt="" /></p><p>In the example shown above, two views of the same type were used to display the same model's data. However, if two different types of view were used, the selected items may be represented very differently in each view; for example, a contiguous selection in a table view can be represented as a fragmented set of highlighted items in a tree view.</p>
<a name="delegate-classes"></a>
<h2 id="delegate-classes">委托类</h2>
<a name="concepts"></a>
<h3 >概念</h3>
<p>Unlike the Model-View-Controller pattern, the model/view design does not include a completely separate component for managing interaction with the user. Generally, the view is responsible for the presentation of model data to the user, and for processing user input. To allow some flexibility in the way this input is obtained, the interaction is performed by delegates. These components provide input capabilities and are also responsible for rendering individual items in some views. The standard interface for controlling delegates is defined in the <a href="qabstractitemdelegate.html">QAbstractItemDelegate</a> class.</p>
<p>Delegates are expected to be able to render their contents themselves by implementing the <a href="qitemdelegate.html#paint">paint()</a> 和 <a href="qitemdelegate.html#sizeHint">sizeHint()</a> functions. However, simple widget-based delegates can subclass <a href="qitemdelegate.html">QItemDelegate</a> instead of <a href="qabstractitemdelegate.html">QAbstractItemDelegate</a>, and take advantage of the default implementations of these functions.</p>
<p>Editors for delegates can be implemented either by using widgets to manage the editing process or by handling events directly. The first approach is covered later in this section, and it is also shown in the <a href="qtwidgets-itemviews-spinboxdelegate-example.html">Spin Box Delegate</a> example.</p>
<p>The <a href="qtwidgets-itemviews-pixelator-example.html">Pixelator</a> example shows how to create a custom delegate that performs specialized rendering for a table view.</p>
<a name="using-an-existing-delegate"></a>
<h3 >使用现有委托</h3>
<p>The standard views provided with Qt use instances of <a href="qitemdelegate.html">QItemDelegate</a> to provide editing facilities. This default implementation of the delegate interface renders items in the usual style for each of the standard views: <a href="qlistview.html">QListView</a>, <a href="qtableview.html">QTableView</a>, 和 <a href="qtreeview.html">QTreeView</a>.</p>
<p>All the standard roles are handled by the default delegate used by the standard views. The way these are interpreted is described in the <a href="qitemdelegate.html">QItemDelegate</a> documentation.</p>
<p>The delegate used by a view is returned by the <a href="qabstractitemview.html#itemDelegate">itemDelegate()</a> function. The <a href="qabstractitemview.html#setItemDelegate">setItemDelegate()</a> function allows you to install a custom delegate for a standard view, and it is necessary to use this function when setting the delegate for a custom view.</p>
<a name="a-simple-delegate"></a>
<h3 >简单委托</h3>
<p>The delegate implemented here uses a <a href="qspinbox.html">QSpinBox</a> to provide editing facilities, and is mainly intended for use with models that display integers. Although we set up a custom integer-based table model for this purpose, we could easily have used <a href="../qtgui/qstandarditemmodel.html">QStandardItemModel</a> instead, since the custom delegate controls data entry. We construct a table view to display the contents of the model, and this will use the custom delegate for editing.</p>
<p class="centerAlign"><img src="images/spinboxdelegate-example.png" alt="" /></p><p>We subclass the delegate from <a href="qstyleditemdelegate.html">QStyledItemDelegate</a> because we do not want to write custom display functions. However, we must still provide functions to manage the editor widget:</p>
<pre class="cpp">

  <span class="keyword">class</span> SpinBoxDelegate : <span class="keyword">public</span> <span class="type"><a href="qstyleditemdelegate.html">QStyledItemDelegate</a></span>
  {
      Q_OBJECT

  <span class="keyword">public</span>:
      SpinBoxDelegate(<span class="type"><a href="../qtcore/qobject.html">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>);

      <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>createEditor(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>parent<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstyleoptionviewitem.html">QStyleOptionViewItem</a></span> <span class="operator">&amp;</span>option<span class="operator">,</span>
                            <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span> override;

      <span class="type">void</span> setEditorData(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>editor<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span> override;
      <span class="type">void</span> setModelData(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>editor<span class="operator">,</span> <span class="type"><a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a></span> <span class="operator">*</span>model<span class="operator">,</span>
                        <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span> override;

      <span class="type">void</span> updateEditorGeometry(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>editor<span class="operator">,</span>
          <span class="keyword">const</span> <span class="type"><a href="qstyleoptionviewitem.html">QStyleOptionViewItem</a></span> <span class="operator">&amp;</span>option<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span> override;
  };

</pre>
<p>Note that no editor widgets are set up when the delegate is constructed. We only construct an editor widget when it is needed.</p>
<a name="providing-an-editor"></a>
<h4 >提供编辑器</h4>
<p>In this example, when the table view needs to provide an editor, it asks the delegate to provide an editor widget that is appropriate for the item being modified. The <a href="qabstractitemdelegate.html#createEditor">createEditor()</a> function is supplied with everything that the delegate needs to be able to set up a suitable widget:</p>
<pre class="cpp">

  <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>SpinBoxDelegate<span class="operator">::</span>createEditor(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>parent<span class="operator">,</span>
      <span class="keyword">const</span> <span class="type"><a href="qstyleoptionviewitem.html">QStyleOptionViewItem</a></span> <span class="operator">&amp;</span><span class="comment">/* option */</span><span class="operator">,</span>
      <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span><span class="comment">/* index */</span>) <span class="keyword">const</span>
  {
      <span class="type"><a href="qspinbox.html">QSpinBox</a></span> <span class="operator">*</span>editor <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qspinbox.html">QSpinBox</a></span>(parent);
      editor<span class="operator">-</span><span class="operator">&gt;</span>setFrame(<span class="keyword">false</span>);
      editor<span class="operator">-</span><span class="operator">&gt;</span>setMinimum(<span class="number">0</span>);
      editor<span class="operator">-</span><span class="operator">&gt;</span>setMaximum(<span class="number">100</span>);

      <span class="keyword">return</span> editor;
  }

</pre>
<p>Note that we do not need to keep a pointer to the editor widget because the view takes responsibility for destroying it when it is no longer needed.</p>
<p>We install the delegate's default event filter on the editor to ensure that it provides the standard editing shortcuts that users expect. Additional shortcuts can be added to the editor to allow more sophisticated behavior; these are discussed in the section on <a href="model-view-programming.html#editinghints">Editing Hints</a>.</p>
<p>The view ensures that the editor's data and geometry are set correctly by calling functions that we define later for these purposes. We can create different editors depending on the model index supplied by the view. For example, if we have a column of integers and a column of strings we could return either a <code>QSpinBox</code> or a <code>QLineEdit</code>, depending on which column is being edited.</p>
<p>The delegate must provide a function to copy model data into the editor. In this example, we read the data stored in the <a href="../qtcore/qt.html#ItemDataRole-enum">display role</a>, and set the value in the spin box accordingly.</p>
<pre class="cpp">

  <span class="type">void</span> SpinBoxDelegate<span class="operator">::</span>setEditorData(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>editor<span class="operator">,</span>
                                      <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span>
  {
      <span class="type">int</span> value <span class="operator">=</span> index<span class="operator">.</span>model()<span class="operator">-</span><span class="operator">&gt;</span>data(index<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>EditRole)<span class="operator">.</span>toInt();

      <span class="type"><a href="qspinbox.html">QSpinBox</a></span> <span class="operator">*</span>spinBox <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="qspinbox.html">QSpinBox</a></span><span class="operator">*</span><span class="operator">&gt;</span>(editor);
      spinBox<span class="operator">-</span><span class="operator">&gt;</span>setValue(value);
  }

</pre>
<p>In this example, we know that the editor widget is a spin box, but we could have provided different editors for different types of data in the model, in which case we would need to cast the widget to the appropriate type before accessing its member functions.</p>
<a name="submitting-data-to-the-model"></a>
<h4 >提交数据到模型</h4>
<p>When the user has finished editing the value in the spin box, the view asks the delegate to store the edited value in the model by calling the <a href="qabstractitemdelegate.html#setModelData">setModelData()</a> function.</p>
<pre class="cpp">

  <span class="type">void</span> SpinBoxDelegate<span class="operator">::</span>setModelData(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>editor<span class="operator">,</span> <span class="type"><a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a></span> <span class="operator">*</span>model<span class="operator">,</span>
                                     <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span>
  {
      <span class="type"><a href="qspinbox.html">QSpinBox</a></span> <span class="operator">*</span>spinBox <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="qspinbox.html">QSpinBox</a></span><span class="operator">*</span><span class="operator">&gt;</span>(editor);
      spinBox<span class="operator">-</span><span class="operator">&gt;</span>interpretText();
      <span class="type">int</span> value <span class="operator">=</span> spinBox<span class="operator">-</span><span class="operator">&gt;</span>value();

      model<span class="operator">-</span><span class="operator">&gt;</span>setData(index<span class="operator">,</span> value<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>EditRole);
  }

</pre>
<p>Since the view manages the editor widgets for the delegate, we only need to update the model with the contents of the editor supplied. In this case, we ensure that the spin box is up-to-date, and update the model with the value it contains using the index specified.</p>
<p>The standard <a href="qitemdelegate.html">QItemDelegate</a> class informs the view when it has finished editing by emitting the <a href="qabstractitemdelegate.html#closeEditor">closeEditor()</a> signal. The view ensures that the editor widget is closed and destroyed. In this example, we only provide simple editing facilities, so we need never emit this signal.</p>
<p>All the operations on data are performed through the interface provided by <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>. This makes the delegate mostly independent from the type of data it manipulates, but some assumptions must be made in order to use certain types of editor widgets. In this example, we have assumed that the model always contains integer values, but we can still use this delegate with different kinds of models because <a href="../qtcore/qvariant.html">QVariant</a> provides sensible default values for unexpected data.</p>
<a name="updating-the-editor-s-geometry"></a>
<h4 >更新编辑器尺寸</h4>
<p>It is the responsibility of the delegate to manage the editor's geometry. The geometry must be set when the editor is created, and when the item's size or position in the view is changed. Fortunately, the view provides all the necessary geometry information inside a <a href="qstyleoptionviewitem.html">view option</a> object.</p>
<pre class="cpp">

  <span class="type">void</span> SpinBoxDelegate<span class="operator">::</span>updateEditorGeometry(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>editor<span class="operator">,</span>
      <span class="keyword">const</span> <span class="type"><a href="qstyleoptionviewitem.html">QStyleOptionViewItem</a></span> <span class="operator">&amp;</span>option<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span><span class="comment">/* index */</span>) <span class="keyword">const</span>
  {
      editor<span class="operator">-</span><span class="operator">&gt;</span>setGeometry(option<span class="operator">.</span>rect);
  }

</pre>
<p>In this case, we just use the geometry information provided by the view option in the item rectangle. A delegate that renders items with several elements would not use the item rectangle directly. It would position the editor in relation to the other elements in the item.</p>
<a name="editinghints"></a><a name="editing-hints"></a>
<h4 >编辑提示</h4>
<p>After editing, delegates should provide hints to the other components about the result of the editing process, and provide hints that will assist any subsequent editing operations. This is achieved by emitting the <a href="qabstractitemdelegate.html#closeEditor">closeEditor()</a> signal with a suitable hint. This is taken care of by the default <a href="qitemdelegate.html">QItemDelegate</a> event filter which we installed on the spin box when it was constructed.</p>
<p>The behavior of the spin box could be adjusted to make it more user friendly. In the default event filter supplied by <a href="qitemdelegate.html">QItemDelegate</a>, if the user hits <b>Return</b> to confirm their choice in the spin box, the delegate commits the value to the model and closes the spin box. We can change this behavior by installing our own event filter on the spin box, and provide editing hints that suit our needs; for example, we might emit <a href="qabstractitemdelegate.html#closeEditor">closeEditor()</a> with the <a href="qabstractitemdelegate.html#EndEditHint-enum">EditNextItem</a> hint to automatically start editing the next item in the view.</p>
<p>Another approach that does not require the use of an event filter is to provide our own editor widget, perhaps subclassing <a href="qspinbox.html">QSpinBox</a> for convenience. This alternative approach would give us more control over how the editor widget behaves at the cost of writing additional code. It is usually easier to install an event filter in the delegate if you need to customize the behavior of a standard Qt editor widget.</p>
<p>Delegates do not have to emit these hints, but those that do not will be less integrated into applications, and will be less usable than those that emit hints to support common editing actions.</p>
<a name="handling-selections-in-item-views"></a>
<h2 id="handling-selections-in-item-views">处理项目视图中的选择</h2>
<a name="concepts"></a>
<h3 >概念</h3>
<p>The selection model used in the item view classes provides a general description of selections based on the facilities of the model/view architecture. Although the standard classes for manipulating selections are sufficient for the item views provided, the selection model allows you to create specialized selection models to suit the requirements for your own item models and views.</p>
<p>Information about the items selected in a view is stored in an instance of the <a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a> class. This maintains model indexes for items in a single model, and is independent of any views. Since there can be many views onto a model, it is possible to share selections between views, allowing applications to show multiple views in a consistent way.</p>
<p>Selections are made up of <i>selection ranges</i>. These efficiently maintain information about large selections of items by recording only the starting and ending model indexes for each range of selected items. Non-contiguous selections of items are constructed by using more than one selection range to describe the selection.</p>
<p>Selections are applied to a collection of model indexes held by a selection model. The most recent selection of items applied is known as the <i>current selection</i>. The effects of this selection can be modified even after its application through the use of certain types of selection commands. These are discussed later in this section.</p>
<a name="current-item-and-selected-items"></a>
<h4 >当前项和选择项</h4>
<p>In a view, there is always a current item and a selected item - two independent states. An item can be the current item and selected at the same time. The view is responsible for ensuring that there is always a current item as keyboard navigation, for example, requires a current item.</p>
<p>The table below highlights the differences between current item and selected items.</p>
<div class="table"><table class="generic" width="70%">
 <thead><tr class="qt-style"><th >Current Item</th><th >Selected Items</th></tr></thead>
<tr valign="top" class="odd"><td >There can only be one current item.</td><td >There can be multiple selected items.</td></tr>
<tr valign="top" class="even"><td >The current item will be changed with key navigation or mouse button clicks.</td><td >The selected state of items is set or unset, depending on several pre-defined modes - e.g&#x2e;, single selection, multiple selection, etc. - when the user interacts with the items.</td></tr>
<tr valign="top" class="odd"><td >The current item will be edited if the edit key, <b>F2</b>, is pressed or the item is double-clicked (provided that editing is enabled).</td><td >The current item can be used together with an anchor to specify a range that should be selected or deselected (or a combination of the two).</td></tr>
<tr valign="top" class="even"><td >The current item is indicated by the focus rectangle.</td><td >The selected items are indicated with the selection rectangle.</td></tr>
</table></div>
<p>When manipulating selections, it is often helpful to think of <a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a> as a record of the selection state of all the items in an item model. Once a selection model is set up, collections of items can be selected, deselected, or their selection states can be toggled without the need to know which items are already selected. The indexes of all selected items can be retrieved at any time, and other components can be informed of changes to the selection model via the signals and slots mechanism.</p>
<a name="using-a-selection-model"></a>
<h3 >使用选择模型</h3>
<p>The standard view classes provide default selection models that can be used in most applications. A selection model belonging to one view can be obtained using the view's <a href="qabstractitemview.html#selectionModel">selectionModel()</a> function, and shared between many views with <a href="qabstractitemview.html#setSelectionModel">setSelectionModel()</a>, so the construction of new selection models is generally not required.</p>
<p>A selection is created by specifying a model, and a pair of model indexes to a <a href="../qtcore/qitemselection.html">QItemSelection</a>. This uses the indexes to refer to items in the given model, and interprets them as the top-left and bottom-right items in a block of selected items. To apply the selection to items in a model requires the selection to be submitted to a selection model; this can be achieved in a number of ways, each having a different effect on the selections already present in the selection model.</p>
<a name="selecting-items"></a>
<h4 >选择项</h4>
<p>To demonstrate some of the principal features of selections, we construct an instance of a custom table model with 32 items in total, and open a table view onto its data:</p>
<pre class="cpp">

      TableModel <span class="operator">*</span>model <span class="operator">=</span> <span class="keyword">new</span> TableModel(<span class="number">8</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="operator">&amp;</span>app);

      <span class="type"><a href="qtableview.html">QTableView</a></span> <span class="operator">*</span>table <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtableview.html">QTableView</a></span>(<span class="number">0</span>);
      table<span class="operator">-</span><span class="operator">&gt;</span>setModel(model);

      <span class="type"><a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a></span> <span class="operator">*</span>selectionModel <span class="operator">=</span> table<span class="operator">-</span><span class="operator">&gt;</span>selectionModel();

</pre>
<p>The table view's default selection model is retrieved for later use. We do not modify any items in the model, but instead select a few items that the view will display at the top-left of the table. To do this, we need to retrieve the model indexes corresponding to the top-left and bottom-right items in the region to be selected:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> topLeft;
      <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> bottomRight;

      topLeft <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
      bottomRight <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">5</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());

</pre>
<p>To select these items in the model, and see the corresponding change in the table view, we need to construct a selection object then apply it to the selection model:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qitemselection.html">QItemSelection</a></span> selection(topLeft<span class="operator">,</span> bottomRight);
      selectionModel<span class="operator">-</span><span class="operator">&gt;</span>select(selection<span class="operator">,</span> <span class="type"><a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a></span><span class="operator">::</span>Select);

</pre>
<p>The selection is applied to the selection model using a command defined by a combination of <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">selection flags</a>. In this case, the flags used cause the items recorded in the selection object to be included in the selection model, regardless of their previous state. The resulting selection is shown by the view.</p>
<p class="centerAlign"><img src="images/selected-items1.png" alt="" /></p><p>The selection of items can be modified using various operations that are defined by the selection flags. The selection that results from these operations may have a complex structure, but it is represented efficiently by the selection model. The use of different selection flags to manipulate the selected items is described when we examine how to update a selection.</p>
<a name="reading-the-selection-state"></a>
<h4 >读取选择状态</h4>
<p>The model indexes stored in the selection model can be read using the <a href="../qtcore/qitemselectionmodel.html#selectedIndexes">selectedIndexes()</a> function. This returns an unsorted list of model indexes that we can iterate over as long as we know which model they are for:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qmodelindex.html#QModelIndexList-typedef">QModelIndexList</a></span> indexes <span class="operator">=</span> selectionModel<span class="operator">-</span><span class="operator">&gt;</span>selectedIndexes();
      <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> index;

      foreach(index<span class="operator">,</span> indexes) {
          <span class="type"><a href="../qtcore/qstring.html">QString</a></span> text <span class="operator">=</span> <span class="type"><a href="../qtcore/qstring.html">QString</a></span>(<span class="string">&quot;(%1,%2)&quot;</span>)<span class="operator">.</span>arg(index<span class="operator">.</span>row())<span class="operator">.</span>arg(index<span class="operator">.</span>column());
          model<span class="operator">-</span><span class="operator">&gt;</span>setData(index<span class="operator">,</span> text);
      }

</pre>
<p>The above code uses Qt's convenient <a href="../qtcore/containers.html">foreach keyword</a> to iterate over, and modify, the items corresponding to the indexes returned by the selection model.</p>
<p>The selection model emits signals to indicate changes in the selection. These notify other components about changes to both the selection as a whole and the currently focused item in the item model. We can connect the <a href="../qtcore/qitemselectionmodel.html#selectionChanged">selectionChanged()</a> signal to a slot, and examine the items in the model that are selected or deselected when the selection changes. The slot is called with two <a href="../qtcore/qitemselection.html">QItemSelection</a> objects: one contains a list of indexes that correspond to newly selected items; the other contains indexes that correspond to newly deselected items.</p>
<p>In the following code, we provide a slot that receives the <a href="../qtcore/qitemselectionmodel.html#selectionChanged">selectionChanged()</a> signal, fills in the selected items with a string, and clears the contents of the deselected items.</p>
<pre class="cpp">

  <span class="type">void</span> MainWindow<span class="operator">::</span>updateSelection(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qitemselection.html">QItemSelection</a></span> <span class="operator">&amp;</span>selected<span class="operator">,</span>
      <span class="keyword">const</span> <span class="type"><a href="../qtcore/qitemselection.html">QItemSelection</a></span> <span class="operator">&amp;</span>deselected)
  {
      <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> index;
      <span class="type"><a href="../qtcore/qmodelindex.html#QModelIndexList-typedef">QModelIndexList</a></span> items <span class="operator">=</span> selected<span class="operator">.</span>indexes();

      foreach (index<span class="operator">,</span> items) {
          <span class="type"><a href="../qtcore/qstring.html">QString</a></span> text <span class="operator">=</span> <span class="type"><a href="../qtcore/qstring.html">QString</a></span>(<span class="string">&quot;(%1,%2)&quot;</span>)<span class="operator">.</span>arg(index<span class="operator">.</span>row())<span class="operator">.</span>arg(index<span class="operator">.</span>column());
          model<span class="operator">-</span><span class="operator">&gt;</span>setData(index<span class="operator">,</span> text);
      }

      items <span class="operator">=</span> deselected<span class="operator">.</span>indexes();

      foreach (index<span class="operator">,</span> items)
          model<span class="operator">-</span><span class="operator">&gt;</span>setData(index<span class="operator">,</span> <span class="string">&quot;&quot;</span>);
  }

</pre>
<p>We can keep track of the currently focused item by connecting the <a href="../qtcore/qitemselectionmodel.html#currentChanged">currentChanged()</a> signal to a slot that is called with two model indexes. These correspond to the previously focused item, and the currently focused item.</p>
<p>In the following code, we provide a slot that receives the <a href="../qtcore/qitemselectionmodel.html#currentChanged">currentChanged()</a> signal, and uses the information provided to update the status bar of a <a href="qmainwindow.html">QMainWindow</a>:</p>
<pre class="cpp">

  <span class="type">void</span> MainWindow<span class="operator">::</span>changeCurrent(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>current<span class="operator">,</span>
      <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>previous)
  {
      statusBar()<span class="operator">-</span><span class="operator">&gt;</span>showMessage(
          tr(<span class="string">&quot;Moved from (%1,%2) to (%3,%4)&quot;</span>)
              <span class="operator">.</span>arg(previous<span class="operator">.</span>row())<span class="operator">.</span>arg(previous<span class="operator">.</span>column())
              <span class="operator">.</span>arg(current<span class="operator">.</span>row())<span class="operator">.</span>arg(current<span class="operator">.</span>column()));
  }

</pre>
<p>Monitoring selections made by the user is straightforward with these signals, but we can also update the selection model directly.</p>
<a name="updating-a-selection"></a>
<h4 >更新选择</h4>
<p>Selection commands are provided by a combination of selection flags, defined by <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">QItemSelectionModel::SelectionFlag</a>. Each selection flag tells the selection model how to update its internal record of selected items when either of the <a href="../qtcore/qitemselection.html#select">select()</a> functions are called. The most commonly used flag is the <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Select</a> flag which instructs the selection model to record the specified items as being selected. The <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Toggle</a> flag causes the selection model to invert the state of the specified items, selecting any deselected items given, and deselecting any currently selected items. The <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Deselect</a> flag deselects all the specified items.</p>
<p>Individual items in the selection model are updated by creating a selection of items, and applying them to the selection model. In the following code, we apply a second selection of items to the table model shown above, using the <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Toggle</a> command to invert the selection state of the items given.</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qitemselection.html">QItemSelection</a></span> toggleSelection;

      topLeft <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">2</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
      bottomRight <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">7</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
      toggleSelection<span class="operator">.</span>select(topLeft<span class="operator">,</span> bottomRight);

      selectionModel<span class="operator">-</span><span class="operator">&gt;</span>select(toggleSelection<span class="operator">,</span> <span class="type"><a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a></span><span class="operator">::</span>Toggle);

</pre>
<p>The results of this operation are displayed in the table view, providing a convenient way of visualizing what we have achieved:</p>
<p class="centerAlign"><img src="images/selected-items2.png" alt="" /></p><p>By default, the selection commands only operate on the individual items specified by the model indexes. However, the flag used to describe the selection command can be combined with additional flags to change entire rows and columns. For example if you call <a href="../qtcore/qitemselectionmodel.html#select-1">select()</a> with only one index, but with a command that is a combination of <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Select</a> 和 <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Rows</a>, the entire row containing the item referred to is selected. The following code demonstrates the use of the <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Rows</a> 和 <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Columns</a> flags:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qitemselection.html">QItemSelection</a></span> columnSelection;

      topLeft <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
      bottomRight <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">0</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());

      columnSelection<span class="operator">.</span>select(topLeft<span class="operator">,</span> bottomRight);

      selectionModel<span class="operator">-</span><span class="operator">&gt;</span>select(columnSelection<span class="operator">,</span>
          <span class="type"><a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a></span><span class="operator">::</span>Select <span class="operator">|</span> <span class="type"><a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a></span><span class="operator">::</span>Columns);

      <span class="type"><a href="../qtcore/qitemselection.html">QItemSelection</a></span> rowSelection;

      topLeft <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
      bottomRight <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());

      rowSelection<span class="operator">.</span>select(topLeft<span class="operator">,</span> bottomRight);

      selectionModel<span class="operator">-</span><span class="operator">&gt;</span>select(rowSelection<span class="operator">,</span>
          <span class="type"><a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a></span><span class="operator">::</span>Select <span class="operator">|</span> <span class="type"><a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a></span><span class="operator">::</span>Rows);

</pre>
<p>Although only four indexes are supplied to the selection model, the use of the <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Columns</a> 和 <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Rows</a> selection flags means that two columns and two rows are selected. The following image shows the result of these two selections:</p>
<p class="centerAlign"><img src="images/selected-items3.png" alt="" /></p><p>The commands performed on the example model have all involved accumulating a selection of items in the model. It is also possible to clear the selection, or to replace the current selection with a new one.</p>
<p>To replace the current selection with a new selection, combine the other selection flags with the <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Current</a> flag. A command using this flag instructs the selection model to replace its current collection of model indexes with those specified in a call to <a href="../qtcore/qitemselectionmodel.html#select-1">select()</a>. To clear all selections before you start adding new ones, combine the other selection flags with the <a href="../qtcore/qitemselectionmodel.html#SelectionFlag-enum">Clear</a> flag. This has the effect of resetting the selection model's collection of model indexes.</p>
<a name="selecting-all-items-in-a-model"></a>
<h4 >选择模型中的所有项</h4>
<p>To select all items in a model, it is necessary to create a selection for each level of the model that covers all items in that level. We do this by retrieving the indexes corresponding to the top-left and bottom-right items with a given parent index:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> topLeft <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> parent);
      <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> bottomRight <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(model<span class="operator">-</span><span class="operator">&gt;</span>rowCount(parent)<span class="operator">-</span><span class="number">1</span><span class="operator">,</span>
          model<span class="operator">-</span><span class="operator">&gt;</span>columnCount(parent)<span class="operator">-</span><span class="number">1</span><span class="operator">,</span> parent);

</pre>
<p>A selection is constructed with these indexes and the model. The corresponding items are then selected in the selection model:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qitemselection.html">QItemSelection</a></span> selection(topLeft<span class="operator">,</span> bottomRight);
      selectionModel<span class="operator">-</span><span class="operator">&gt;</span>select(selection<span class="operator">,</span> <span class="type"><a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a></span><span class="operator">::</span>Select);

</pre>
<p>This needs to be performed for all levels in the model. For top-level items, we would define the parent index in the usual way:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> parent <span class="operator">=</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>();

</pre>
<p>For hierarchical models, the <a href="../qtcore/qabstractitemmodel.html#hasChildren">hasChildren()</a> function is used to determine whether any given item is the parent of another level of items.</p>
<a name="creating-new-models"></a>
<h2 id="creating-new-models">创建新模型</h2>
<p>The separation of functionality between the model/view components allows models to be created that can take advantage of existing views. This approach lets us present data from a variety of sources using standard graphical user interface components, such as <a href="qlistview.html">QListView</a>, <a href="qtableview.html">QTableView</a>, 和 <a href="qtreeview.html">QTreeView</a>.</p>
<p>The <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> class provides an interface that is flexible enough to support data sources that arrange information in hierarchical structures, allowing for the possibility that data will be inserted, removed, modified, or sorted in some way. It also provides support for drag and drop operations.</p>
<p>The <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a> 和 <a href="../qtcore/qabstracttablemodel.html">QAbstractTableModel</a> classes provide support for interfaces to simpler non-hierarchical data structures, and are easier to use as a starting point for simple list and table models.</p>
<p>In this section, we create a simple read-only model to explore the basic principles of the model/view architecture. Later in this section, we adapt this simple model so that items can be modified by the user.</p>
<p>For an example of a more complex model, see the <a href="qtwidgets-itemviews-simpletreemodel-example.html">Simple Tree Model</a> example.</p>
<p>The requirements of <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> subclasses is described in more detail in the <a href="model-view-programming.html#model-subclassing-reference">模型子类化参考</a> document.</p>
<a name="designing-a-model"></a>
<h3 >设计模型</h3>
<p>When creating a new model for an existing data structure, it is important to consider which type of model should be used to provide an interface onto the data. If the data structure can be represented as a list or table of items, you can subclass <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a> or <a href="../qtcore/qabstracttablemodel.html">QAbstractTableModel</a> since these classes provide suitable default implementations for many functions.</p>
<p>However, if the underlying data structure can only be represented by a hierarchical tree structure, it is necessary to subclass <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>. This approach is taken in the <a href="qtwidgets-itemviews-simpletreemodel-example.html">Simple Tree Model</a> example.</p>
<p>In this section, we implement a simple model based on a list of strings, so the <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a> provides an ideal base class on which to build.</p>
<p>Whatever form the underlying data structure takes, it is usually a good idea to supplement the standard <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> API in specialized models with one that allows more natural access to the underlying data structure. This makes it easier to populate the model with data, yet still enables other general model/view components to interact with it using the standard API. The model described below provides a custom constructor for just this purpose.</p>
<a name="a-read-only-example-model"></a>
<h3 >只读的样例模型</h3>
<p>The model implemented here is a simple, non-hierarchical, read-only data model based on the standard <a href="../qtcore/qstringlistmodel.html">QStringListModel</a> class. It has a <a href="../qtcore/qstringlist.html">QStringList</a> as its internal data source, and implements only what is needed to make a functioning model. To make the implementation easier, we subclass <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a> because it defines sensible default behavior for list models, and it exposes a simpler interface than the <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> class.</p>
<p>When implementing a model it is important to remember that <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> does not store any data itself, it merely presents an interface that the views use to access the data. For a minimal read-only model it is only necessary to implement a few functions as there are default implementations for most of the interface. The class declaration is as follows:</p>
<pre class="cpp">

  <span class="keyword">class</span> StringListModel : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a></span>
  {
      Q_OBJECT

  <span class="keyword">public</span>:
      StringListModel(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> <span class="operator">&amp;</span>strings<span class="operator">,</span> <span class="type"><a href="../qtcore/qobject.html">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr)
          : <span class="type"><a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a></span>(parent)<span class="operator">,</span> stringList(strings) {}

      <span class="type">int</span> rowCount(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>parent <span class="operator">=</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>()) <span class="keyword">const</span> override;
      <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> data(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index<span class="operator">,</span> <span class="type">int</span> role) <span class="keyword">const</span> override;
      <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> headerData(<span class="type">int</span> section<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>Orientation orientation<span class="operator">,</span>
                          <span class="type">int</span> role <span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DisplayRole) <span class="keyword">const</span> override;

  <span class="keyword">private</span>:
      <span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> stringList;
  };

</pre>
<p>Apart from the model's constructor, we only need to implement two functions: <a href="../qtcore/qabstractitemmodel.html#rowCount">rowCount()</a> returns the number of rows in the model and <a href="../qtcore/qabstractitemmodel.html#data">data()</a> returns an item of data corresponding to a specified model index.</p>
<p>Well behaved models also implement <a href="../qtcore/qabstractitemmodel.html#headerData">headerData()</a> to give tree and table views something to display in their headers.</p>
<p>Note that this is a non-hierarchical model, so we don't have to worry about the parent-child relationships. If our model was hierarchical, we would also have to implement the <a href="../qtcore/qabstractitemmodel.html#index">index()</a> 和 <a href="../qtcore/qabstractitemmodel.html#parent">parent()</a> functions.</p>
<p>The list of strings is stored internally in the <code>stringList</code> private member variable.</p>
<a name="dimensions-of-the-model"></a>
<h4 >模型的尺寸</h4>
<p>We want the number of rows in the model to be the same as the number of strings in the string list. We implement the <a href="../qtcore/qabstractitemmodel.html#rowCount">rowCount()</a> function with this in mind:</p>
<pre class="cpp">

  <span class="type">int</span> StringListModel<span class="operator">::</span>rowCount(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>parent) <span class="keyword">const</span>
  {
      <span class="keyword">return</span> stringList<span class="operator">.</span>count();
  }

</pre>
<p>Since the model is non-hierarchical, we can safely ignore the model index corresponding to the parent item. By default, models derived from <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a> only contain one column, so we do not need to reimplement the <a href="../qtcore/qabstractitemmodel.html#columnCount">columnCount()</a> function.</p>
<a name="model-headers-and-data"></a>
<h4 >模型的表头及其数据</h4>
<p>For items in the view, we want to return the strings in the string list. The <a href="../qtcore/qabstractitemmodel.html#data">data()</a> function is responsible for returning the item of data that corresponds to the index argument:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> StringListModel<span class="operator">::</span>data(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index<span class="operator">,</span> <span class="type">int</span> role) <span class="keyword">const</span>
  {
      <span class="keyword">if</span> (<span class="operator">!</span>index<span class="operator">.</span>isValid())
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>();

      <span class="keyword">if</span> (index<span class="operator">.</span>row() <span class="operator">&gt;</span><span class="operator">=</span> stringList<span class="operator">.</span>size())
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>();

      <span class="keyword">if</span> (role <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DisplayRole)
          <span class="keyword">return</span> stringList<span class="operator">.</span>at(index<span class="operator">.</span>row());
      <span class="keyword">else</span>
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>();
  }

</pre>
<p>We only return a valid <a href="../qtcore/qvariant.html">QVariant</a> if the model index supplied is valid, the row number is within the range of items in the string list, and the requested role is one that we support.</p>
<p>Some views, such as <a href="qtreeview.html">QTreeView</a> 和 <a href="qtableview.html">QTableView</a>, are able to display headers along with the item data. If our model is displayed in a view with headers, we want the headers to show the row and column numbers. We can provide information about the headers by subclassing the <a href="../qtcore/qabstractitemmodel.html#headerData">headerData()</a> function:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> StringListModel<span class="operator">::</span>headerData(<span class="type">int</span> section<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>Orientation orientation<span class="operator">,</span>
                                       <span class="type">int</span> role) <span class="keyword">const</span>
  {
      <span class="keyword">if</span> (role <span class="operator">!</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DisplayRole)
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>();

      <span class="keyword">if</span> (orientation <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>Horizontal)
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qstring.html#QStringLiteral">QStringLiteral</a></span>(<span class="string">&quot;Column %1&quot;</span>)<span class="operator">.</span>arg(section);
      <span class="keyword">else</span>
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qstring.html#QStringLiteral">QStringLiteral</a></span>(<span class="string">&quot;Row %1&quot;</span>)<span class="operator">.</span>arg(section);
  }

</pre>
<p>Again, we return a valid <a href="../qtcore/qvariant.html">QVariant</a> only if the role is one that we support. The orientation of the header is also taken into account when deciding the exact data to return.</p>
<p>Not all views display headers with the item data, and those that do may be configured to hide them. Nonetheless, it is recommended that you implement the <a href="../qtcore/qabstractitemmodel.html#headerData">headerData()</a> function to provide relevant information about the data provided by the model.</p>
<p>An item can have several roles, giving out different data depending on the role specified. The items in our model only have one role, <a href="../qtcore/qt.html#ItemDataRole-enum">DisplayRole</a>, so we return the data for items irrespective of the role specified. However, we could reuse the data we provide for the <a href="../qtcore/qt.html#ItemDataRole-enum">DisplayRole</a> in other roles, such as the <a href="../qtcore/qt.html#ItemDataRole-enum">ToolTipRole</a> that views can use to display information about items in a tooltip.</p>
<a name="an-editable-model"></a>
<h3 >可编辑的模型</h3>
<p>The read-only model shows how simple choices could be presented to the user but, for many applications, an editable list model is much more useful. We can modify the read-only model to make the items editable by changing the data() function we implemented for read-only, and by implementing two extra functions: <a href="../qtcore/qabstractitemmodel.html#flags">flags()</a> 和 <a href="../qtcore/qabstractitemmodel.html#setData">setData()</a>. The following function declarations are added to the class definition:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>ItemFlags flags(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span> override;
      bool setData(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> <span class="operator">&amp;</span>value<span class="operator">,</span>
                   <span class="type">int</span> role <span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>EditRole) override;

</pre>
<a name="making-the-model-editable"></a>
<h4 >使模型可编辑</h4>
<p>A delegate checks whether an item is editable before creating an editor. The model must let the delegate know that its items are editable. We do this by returning the correct flags for each item in the model; in this case, we enable all items and make them both selectable and editable:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>ItemFlags StringListModel<span class="operator">::</span>flags(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span>
  {
      <span class="keyword">if</span> (<span class="operator">!</span>index<span class="operator">.</span>isValid())
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>ItemIsEnabled;

      <span class="keyword">return</span> <span class="type"><a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a></span><span class="operator">::</span>flags(index) <span class="operator">|</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>ItemIsEditable;
  }

</pre>
<p>Note that we do not have to know how the delegate performs the actual editing process. We only have to provide a way for the delegate to set the data in the model. This is achieved through the <a href="../qtcore/qabstractitemmodel.html#setData">setData()</a> function:</p>
<pre class="cpp">

  bool StringListModel<span class="operator">::</span>setData(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index<span class="operator">,</span>
                                <span class="keyword">const</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> <span class="operator">&amp;</span>value<span class="operator">,</span> <span class="type">int</span> role)
  {
      <span class="keyword">if</span> (index<span class="operator">.</span>isValid() <span class="operator">&amp;</span><span class="operator">&amp;</span> role <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>EditRole) {

          stringList<span class="operator">.</span>replace(index<span class="operator">.</span>row()<span class="operator">,</span> value<span class="operator">.</span>toString());
          <span class="keyword">emit</span> dataChanged(index<span class="operator">,</span> index<span class="operator">,</span> {role});
          <span class="keyword">return</span> <span class="keyword">true</span>;
      }
      <span class="keyword">return</span> <span class="keyword">false</span>;
  }

</pre>
<p>In this model, the item in the string list that corresponds to the model index is replaced by the value provided. However, before we can modify the string list, we must make sure that the index is valid, the item is of the correct type, and that the role is supported. By convention, we insist that the role is the <a href="../qtcore/qt.html#ItemDataRole-enum">EditRole</a> since this is the role used by the standard item delegate. For boolean values, however, you can use <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::CheckStateRole</a> and set the <a href="../qtcore/qt.html#ItemFlag-enum">Qt::ItemIsUserCheckable</a> flag; a checkbox is then used for editing the value. The underlying data in this model is the same for all roles, so this detail just makes it easier to integrate the model with standard components.</p>
<p>When the data has been set, the model must let the views know that some data has changed. This is done by emitting the <a href="../qtcore/qabstractitemmodel.html#dataChanged">dataChanged()</a> signal. Since only one item of data has changed, the range of items specified in the signal is limited to just one model index.</p>
<p>Also the data() function needs to be changed to add the <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::EditRole</a> test:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> StringListModel<span class="operator">::</span>data(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index<span class="operator">,</span> <span class="type">int</span> role) <span class="keyword">const</span>
  {
      <span class="keyword">if</span> (<span class="operator">!</span>index<span class="operator">.</span>isValid())
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>();

      <span class="keyword">if</span> (index<span class="operator">.</span>row() <span class="operator">&gt;</span><span class="operator">=</span> stringList<span class="operator">.</span>size())
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>();

      <span class="keyword">if</span> (role <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DisplayRole <span class="operator">|</span><span class="operator">|</span> role <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>EditRole)
          <span class="keyword">return</span> stringList<span class="operator">.</span>at(index<span class="operator">.</span>row());
      <span class="keyword">else</span>
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span>();
  }

</pre>
<a name="inserting-and-removing-rows"></a>
<h4 >插入和删除行</h4>
<p>It is possible to change the number of rows and columns in a model. In the string list model it only makes sense to change the number of rows, so we only reimplement the functions for inserting and removing rows. These are declared in the class definition:</p>
<pre class="cpp">

      bool insertRows(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> rows<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index <span class="operator">=</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>()) override;
      bool removeRows(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> rows<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index <span class="operator">=</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>()) override;

</pre>
<p>Since rows in this model correspond to strings in a list, the <code>insertRows()</code> function inserts a number of empty strings into the string list before the specified position. The number of strings inserted is equivalent to the number of rows specified.</p>
<p>The parent index is normally used to determine where in the model the rows should be added. In this case, we only have a single top-level list of strings, so we just insert empty strings into that list.</p>
<pre class="cpp">

  bool StringListModel<span class="operator">::</span>insertRows(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> rows<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>parent)
  {
      beginInsertRows(<span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>()<span class="operator">,</span> position<span class="operator">,</span> position<span class="operator">+</span>rows<span class="operator">-</span><span class="number">1</span>);

      <span class="keyword">for</span> (<span class="type">int</span> row <span class="operator">=</span> <span class="number">0</span>; row <span class="operator">&lt;</span> rows; <span class="operator">+</span><span class="operator">+</span>row) {
          stringList<span class="operator">.</span>insert(position<span class="operator">,</span> <span class="string">&quot;&quot;</span>);
      }

      endInsertRows();
      <span class="keyword">return</span> <span class="keyword">true</span>;
  }

</pre>
<p>The model first calls the <a href="../qtcore/qabstractitemmodel.html#beginInsertRows">beginInsertRows()</a> function to inform other components that the number of rows is about to change. The function specifies the row numbers of the first and last new rows to be inserted, and the model index for their parent item. After changing the string list, it calls <a href="../qtcore/qabstractitemmodel.html#endInsertRows">endInsertRows()</a> to complete the operation and inform other components that the dimensions of the model have changed, returning true to indicate success.</p>
<p>The function to remove rows from the model is also simple to write. The rows to be removed from the model are specified by the position and the number of rows given. We ignore the parent index to simplify our implementation, and just remove the corresponding items from the string list.</p>
<pre class="cpp">

  bool StringListModel<span class="operator">::</span>removeRows(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> rows<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>parent)
  {
      beginRemoveRows(<span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>()<span class="operator">,</span> position<span class="operator">,</span> position<span class="operator">+</span>rows<span class="operator">-</span><span class="number">1</span>);

      <span class="keyword">for</span> (<span class="type">int</span> row <span class="operator">=</span> <span class="number">0</span>; row <span class="operator">&lt;</span> rows; <span class="operator">+</span><span class="operator">+</span>row) {
          stringList<span class="operator">.</span>removeAt(position);
      }

      endRemoveRows();
      <span class="keyword">return</span> <span class="keyword">true</span>;
  }

</pre>
<p>The <a href="../qtcore/qabstractitemmodel.html#beginRemoveRows">beginRemoveRows()</a> function is always called before any underlying data is removed, and specifies the first and last rows to be removed. This allows other components to access the data before it becomes unavailable. After the rows have been removed, the model emits <a href="../qtcore/qabstractitemmodel.html#endRemoveRows">endRemoveRows()</a> to finish the operation and let other components know that the dimensions of the model have changed.</p>
<a name="next-steps"></a>
<h3 >下一步</h3>
<p>We can display the data provided by this model, or any other model, using the <a href="qlistview.html">QListView</a> class to present the model's items in the form of a vertical list. For the string list model, this view also provides a default editor so that the items can be manipulated. We examine the possibilities made available by the standard view classes in <a href="model-view-programming.html#view-classes">视图类</a>.</p>
<p>The <a href="model-view-programming.html#model-subclassing-reference">模型子类化参考</a> document discusses the requirements of <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> subclasses in more detail, and provides a guide to the virtual functions that must be implemented to enable various features in different types of models.</p>
<a name="item-view-convenience-classes"></a>
<h2 id="item-view-convenience-classes">项目视图的便利类</h2>
<p>The item-based widgets have names which reflect their uses: <code>QListWidget</code> provides a list of items, <code>QTreeWidget</code> displays a multi-level tree structure, and <code>QTableWidget</code> provides a table of cell items. Each class inherits the behavior of the <code>QAbstractItemView</code> class which implements common behavior for item selection and header management.</p>
<a name="list-widgets"></a>
<h3 >列表部件</h3>
<p>Single level lists of items are typically displayed using a <code>QListWidget</code> and a number of <code>QListWidgetItem</code>s. A list widget is constructed in the same way as any other widget:</p>
<pre class="cpp">

      QListWidget *listWidget = new QListWidget(this);

</pre>
<p>List items can be added directly to the list widget when they are constructed:</p>
<pre class="cpp">

      <span class="keyword">new</span> <span class="type"><a href="qlistwidgetitem.html">QListWidgetItem</a></span>(tr(<span class="string">&quot;Sycamore&quot;</span>)<span class="operator">,</span> listWidget);
      <span class="keyword">new</span> <span class="type"><a href="qlistwidgetitem.html">QListWidgetItem</a></span>(tr(<span class="string">&quot;Chestnut&quot;</span>)<span class="operator">,</span> listWidget);
      <span class="keyword">new</span> <span class="type"><a href="qlistwidgetitem.html">QListWidgetItem</a></span>(tr(<span class="string">&quot;Mahogany&quot;</span>)<span class="operator">,</span> listWidget);

</pre>
<p>They can also be constructed without a parent list widget and added to a list at some later time:</p>
<pre class="cpp">

      <span class="type"><a href="qlistwidgetitem.html">QListWidgetItem</a></span> <span class="operator">*</span>newItem <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qlistwidgetitem.html">QListWidgetItem</a></span>;
      newItem<span class="operator">-</span><span class="operator">&gt;</span>setText(itemText);
      listWidget<span class="operator">-</span><span class="operator">&gt;</span>insertItem(row<span class="operator">,</span> newItem);

</pre>
<p>Each item in a list can display a text label and an icon. The colors and font used to render the text can be changed to provide a customized appearance for items. Tooltips, status tips, and &quot;What's This?&quot; help are all easily configured to ensure that the list is properly integrated into the application.</p>
<pre class="cpp">

      newItem<span class="operator">-</span><span class="operator">&gt;</span>setToolTip(toolTipText);
      newItem<span class="operator">-</span><span class="operator">&gt;</span>setStatusTip(toolTipText);
      newItem<span class="operator">-</span><span class="operator">&gt;</span>setWhatsThis(whatsThisText);

</pre>
<p>By default, items in a list are presented in the order of their creation. Lists of items can be sorted according to the criteria given in <a href="../qtcore/qt.html#SortOrder-enum">Qt::SortOrder</a> to produce a list of items that is sorted in forward or reverse alphabetical order:</p>
<pre class="cpp">

      listWidget<span class="operator">-</span><span class="operator">&gt;</span>sortItems(<span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>AscendingOrder);
      listWidget<span class="operator">-</span><span class="operator">&gt;</span>sortItems(<span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DescendingOrder);

</pre>
<a name="tree-widgets"></a>
<h3 >树形部件</h3>
<p>Trees or hierarchical lists of items are provided by the <code>QTreeWidget</code> and <code>QTreeWidgetItem</code> classes. Each item in the tree widget can have child items of its own, and can display a number of columns of information. Tree widgets are created just like any other widget:</p>
<pre class="cpp">

      QTreeWidget *treeWidget = new QTreeWidget(this);

</pre>
<p>Before items can be added to the tree widget, the number of columns must be set. For example, we could define two columns, and create a header to provide labels at the top of each column:</p>
<pre class="cpp">

      treeWidget<span class="operator">-</span><span class="operator">&gt;</span>setColumnCount(<span class="number">2</span>);
      <span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> headers;
      headers <span class="operator">&lt;</span><span class="operator">&lt;</span> tr(<span class="string">&quot;Subject&quot;</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> tr(<span class="string">&quot;Default&quot;</span>);
      treeWidget<span class="operator">-</span><span class="operator">&gt;</span>setHeaderLabels(headers);

</pre>
<p>The easiest way to set up the labels for each section is to supply a string list. For more sophisticated headers, you can construct a tree item, decorate it as you wish, and use that as the tree widget's header.</p>
<p>Top-level items in the tree widget are constructed with the tree widget as their parent widget. They can be inserted in an arbitrary order, or you can ensure that they are listed in a particular order by specifying the previous item when constructing each item:</p>
<pre class="cpp">

      <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span> <span class="operator">*</span>cities <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span>(treeWidget);
      cities<span class="operator">-</span><span class="operator">&gt;</span>setText(<span class="number">0</span><span class="operator">,</span> tr(<span class="string">&quot;Cities&quot;</span>));
      <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span> <span class="operator">*</span>osloItem <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span>(cities);
      osloItem<span class="operator">-</span><span class="operator">&gt;</span>setText(<span class="number">0</span><span class="operator">,</span> tr(<span class="string">&quot;Oslo&quot;</span>));
      osloItem<span class="operator">-</span><span class="operator">&gt;</span>setText(<span class="number">1</span><span class="operator">,</span> tr(<span class="string">&quot;Yes&quot;</span>));

      <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span> <span class="operator">*</span>planets <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span>(treeWidget<span class="operator">,</span> cities);

</pre>
<p>Tree widgets deal with top-level items slightly differently to other items from deeper within the tree. Items can be removed from the top level of the tree by calling the tree widget's <a href="qtreewidget.html#takeTopLevelItem">takeTopLevelItem()</a> function, but items from lower levels are removed by calling their parent item's <a href="qtreewidgetitem.html#takeChild">takeChild()</a> function. Items are inserted in the top level of the tree with the <a href="qtreewidget.html#insertTopLevelItem">insertTopLevelItem()</a> function. At lower levels in the tree, the parent item's <a href="qtreewidgetitem.html#insertChild">insertChild()</a> function is used.</p>
<p>It is easy to move items around between the top level and lower levels in the tree. We just need to check whether the items are top-level items or not, and this information is supplied by each item's <code>parent()</code> function. For example, we can remove the current item in the tree widget regardless of its location:</p>
<pre class="cpp">

      <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span> <span class="operator">*</span>parent <span class="operator">=</span> currentItem<span class="operator">-</span><span class="operator">&gt;</span>parent();
      <span class="type">int</span> index;

      <span class="keyword">if</span> (parent) {
          index <span class="operator">=</span> parent<span class="operator">-</span><span class="operator">&gt;</span>indexOfChild(treeWidget<span class="operator">-</span><span class="operator">&gt;</span>currentItem());
          <span class="keyword">delete</span> parent<span class="operator">-</span><span class="operator">&gt;</span>takeChild(index);
      } <span class="keyword">else</span> {
          index <span class="operator">=</span> treeWidget<span class="operator">-</span><span class="operator">&gt;</span>indexOfTopLevelItem(treeWidget<span class="operator">-</span><span class="operator">&gt;</span>currentItem());
          <span class="keyword">delete</span> treeWidget<span class="operator">-</span><span class="operator">&gt;</span>takeTopLevelItem(index);
      }

</pre>
<p>Inserting the item somewhere else in the tree widget follows the same pattern:</p>
<pre class="cpp">

      <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span> <span class="operator">*</span>parent <span class="operator">=</span> currentItem<span class="operator">-</span><span class="operator">&gt;</span>parent();
      <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span> <span class="operator">*</span>newItem;
      <span class="keyword">if</span> (parent)
          newItem <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span>(parent<span class="operator">,</span> treeWidget<span class="operator">-</span><span class="operator">&gt;</span>currentItem());
      <span class="keyword">else</span>
          newItem <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span>(treeWidget<span class="operator">,</span> treeWidget<span class="operator">-</span><span class="operator">&gt;</span>currentItem());

</pre>
<a name="table-widgets"></a>
<h3 >表格部件</h3>
<p>Tables of items similar to those found in spreadsheet applications are constructed with the <code>QTableWidget</code> and <code>QTableWidgetItem</code>. These provide a scrolling table widget with headers and items to use within it.</p>
<p>Tables can be created with a set number of rows and columns, or these can be added to an unsized table as they are needed.</p>
<pre class="cpp">

      <span class="type"><a href="qtablewidget.html">QTableWidget</a></span> <span class="operator">*</span>tableWidget;
      tableWidget <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtablewidget.html">QTableWidget</a></span>(<span class="number">12</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="keyword">this</span>);

</pre>
<p>Items are constructed outside the table before being added to the table at the required location:</p>
<pre class="cpp">

      <span class="type"><a href="qtablewidgetitem.html">QTableWidgetItem</a></span> <span class="operator">*</span>newItem <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtablewidgetitem.html">QTableWidgetItem</a></span>(tr(<span class="string">&quot;%1&quot;</span>)<span class="operator">.</span>arg(
          pow(row<span class="operator">,</span> column<span class="operator">+</span><span class="number">1</span>)));
      tableWidget<span class="operator">-</span><span class="operator">&gt;</span>setItem(row<span class="operator">,</span> column<span class="operator">,</span> newItem);

</pre>
<p>Horizontal and vertical headers can be added to the table by constructing items outside the table and using them as headers:</p>
<pre class="cpp">

      <span class="type"><a href="qtablewidgetitem.html">QTableWidgetItem</a></span> <span class="operator">*</span>valuesHeaderItem <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qtablewidgetitem.html">QTableWidgetItem</a></span>(tr(<span class="string">&quot;Values&quot;</span>));
      tableWidget<span class="operator">-</span><span class="operator">&gt;</span>setHorizontalHeaderItem(<span class="number">0</span><span class="operator">,</span> valuesHeaderItem);

</pre>
<p>Note that the rows and columns in the table begin at zero.</p>
<a name="common-features"></a>
<h3 >常用功能</h3>
<p>There are a number of item-based features common to each of the convenience classes that are available through the same interfaces in each class. We present these in the following sections with some examples for different widgets. Look at the list of <a href="model-view-programming.html#model-view-classes">模型/视图类</a> for each of the widgets for more details about the use of each function used.</p>
<a name="hidden-items"></a>
<h4 >隐藏项</h4>
<p>It is sometimes useful to be able to hide items in an item view widget rather than remove them. Items for all of the above widgets can be hidden and later shown again. You can determine whether an item is hidden by calling the isItemHidden() function, and items can be hidden with <code>setItemHidden()</code>.</p>
<p>Since this operation is item-based, the same function is available for all three convenience classes.</p>
<a name="selections"></a>
<h4 >选择</h4>
<p>The way items are selected is controlled by the widget's selection mode (<a href="qabstractitemview.html#SelectionMode-enum">QAbstractItemView::SelectionMode</a>). This property controls whether the user can select one or many items and, in many-item selections, whether the selection must be a continuous range of items. The selection mode works in the same way for all of the above widgets.</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/selection-single.png" alt="" /></p></td><td ><b>Single item selections:</b> Where the user needs to choose a single item from a widget, the default <code>SingleSelection</code> mode is most suitable. In this mode, the current item and the selected item are the same.</td></tr>
<tr valign="top" class="even"><td ><p class="centerAlign"><img src="images/selection-multi.png" alt="" /></p></td><td ><b>Multi-item selections:</b> In this mode, the user can toggle the selection state of any item in the widget without changing the existing selection, much like the way non-exclusive checkboxes can be toggled independently.</td></tr>
<tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/selection-extended.png" alt="" /></p></td><td ><b>Extended selections:</b> Widgets that often require many adjacent items to be selected, such as those found in spreadsheets, require the <code>ExtendedSelection</code> mode. In this mode, continuous ranges of items in the widget can be selected with both the mouse and the keyboard. Complex selections, involving many items that are not adjacent to other selected items in the widget, can also be created if modifier keys are used.<p>If the user selects an item without using a modifier key, the existing selection is cleared.</p>
</td></tr>
</table></div>
<p>The selected items in a widget are read using the <code>selectedItems()</code> function, providing a list of relevant items that can be iterated over. For example, we can find the sum of all the numeric values within a list of selected items with the following code:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qtablewidgetitem.html">QTableWidgetItem</a></span> <span class="operator">*</span><span class="operator">&gt;</span> selected <span class="operator">=</span> tableWidget<span class="operator">-</span><span class="operator">&gt;</span>selectedItems();
      <span class="type"><a href="qtablewidgetitem.html">QTableWidgetItem</a></span> <span class="operator">*</span>item;
      <span class="type">int</span> number <span class="operator">=</span> <span class="number">0</span>;
      <span class="type">double</span> total <span class="operator">=</span> <span class="number">0</span>;

      foreach (item<span class="operator">,</span> selected) {
          bool ok;
          <span class="type">double</span> value <span class="operator">=</span> item<span class="operator">-</span><span class="operator">&gt;</span>text()<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok);

          <span class="keyword">if</span> (ok <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>item<span class="operator">-</span><span class="operator">&gt;</span>text()<span class="operator">.</span>isEmpty()) {
              total <span class="operator">+</span><span class="operator">=</span> value;
              number<span class="operator">+</span><span class="operator">+</span>;
          }
      }

</pre>
<p>Note that for the single selection mode, the current item will be in the selection. In the multi-selection and extended selection modes, the current item may not lie within the selection, depending on the way the user formed the selection.</p>
<a name="searching"></a>
<h4 >查询</h4>
<p>It is often useful to be able to find items within an item view widget, either as a developer or as a service to present to users. All three item view convenience classes provide a common <code>findItems()</code> function to make this as consistent and simple as possible.</p>
<p>Items are searched for by the text that they contain according to criteria specified by a selection of values from <a href="../qtcore/qt.html#MatchFlag-enum">Qt::MatchFlags</a>. We can obtain a list of matching items with the <code>findItems()</code> function:</p>
<pre class="cpp">

      <span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span> <span class="operator">*</span>item;
      <span class="type"><a href="../qtcore/qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qtreewidgetitem.html">QTreeWidgetItem</a></span> <span class="operator">*</span><span class="operator">&gt;</span> found <span class="operator">=</span> treeWidget<span class="operator">-</span><span class="operator">&gt;</span>findItems(
          itemText<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>MatchWildcard);

      foreach (item<span class="operator">,</span> found) {
          treeWidget<span class="operator">-</span><span class="operator">&gt;</span>setItemSelected(item<span class="operator">,</span> <span class="keyword">true</span>);
          <span class="comment">// Show the item-&gt;text(0) for each item.</span>
      }

</pre>
<p>The above code causes items in a tree widget to be selected if they contain the text given in the search string. This pattern can also be used in the list and table widgets.</p>
<a name="using-drag-and-drop-with-item-views"></a>
<h2 id="using-drag-and-drop-with-item-views">项目视图中使用拖放</h2>
<p>Qt's drag and drop infrastructure is fully supported by the model/view framework. Items in lists, tables, and trees can be dragged within the views, and data can be imported and exported as MIME-encoded data.</p>
<p>The standard views automatically support internal drag and drop, where items are moved around to change the order in which they are displayed. By default, drag and drop is not enabled for these views because they are configured for the simplest, most common uses. To allow items to be dragged around, certain properties of the view need to be enabled, and the items themselves must also allow dragging to occur.</p>
<p>The requirements for a model that only allows items to be exported from a view, and which does not allow data to be dropped into it, are fewer than those for a fully-enabled drag and drop model.</p>
<p>See also the <a href="model-view-programming.html#model-subclassing-reference">模型子类化参考</a> for more information about enabling drag and drop support in new models.</p>
<a name="using-convenience-views"></a>
<h3 >使用便利视图</h3>
<p>Each of the types of item used with <a href="qlistwidget.html">QListWidget</a>, <a href="qtablewidget.html">QTableWidget</a>, 和 <a href="qtreewidget.html">QTreeWidget</a> is configured to use a different set of flags by default. For example, each <a href="qlistwidgetitem.html">QListWidgetItem</a> or <a href="qtreewidgetitem.html">QTreeWidgetItem</a> is initially enabled, checkable, selectable, and can be used as the source of a drag and drop operation; each <a href="qtablewidgetitem.html">QTableWidgetItem</a> can also be edited and used as the target of a drag and drop operation.</p>
<p>Although all of the standard items have one or both flags set for drag and drop, you generally need to set various properties in the view itself to take advantage of the built-in support for drag and drop:</p>
<ul>
<li>To enable item dragging, set the view's <a href="qabstractitemview.html#dragEnabled-prop">dragEnabled</a> property to <code>true</code>.</li>
<li>To allow the user to drop either internal or external items within the view, set the view's <a href="qabstractscrollarea.html#viewport">viewport()</a>'s <a href="qwidget.html#acceptDrops-prop">acceptDrops</a> property to <code>true</code>.</li>
<li>To show the user where the item currently being dragged will be placed if dropped, set the view's <a href="qabstractitemview.html#showDropIndicator-prop">showDropIndicator</a> property. This provides the user with continuously updating information about item placement within the view.</li>
</ul>
<p>For example, we can enable drag and drop in a list widget with the following lines of code:</p>
<pre class="cpp">

  <span class="type"><a href="qlistwidget.html">QListWidget</a></span> <span class="operator">*</span>listWidget <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qlistwidget.html">QListWidget</a></span>(<span class="keyword">this</span>);
  listWidget<span class="operator">-</span><span class="operator">&gt;</span>setSelectionMode(<span class="type"><a href="qabstractitemview.html">QAbstractItemView</a></span><span class="operator">::</span>SingleSelection);
  listWidget<span class="operator">-</span><span class="operator">&gt;</span>setDragEnabled(<span class="keyword">true</span>);
  listWidget<span class="operator">-</span><span class="operator">&gt;</span>viewport()<span class="operator">-</span><span class="operator">&gt;</span>setAcceptDrops(<span class="keyword">true</span>);
  listWidget<span class="operator">-</span><span class="operator">&gt;</span>setDropIndicatorShown(<span class="keyword">true</span>);

</pre>
<p>The result is a list widget which allows the items to be copied around within the view, and even lets the user drag items between views containing the same type of data. In both situations, the items are copied rather than moved.</p>
<p>To enable the user to move the items around within the view, we must set the list widget's <a href="qabstractitemview.html#dragDropMode-prop">dragDropMode</a>:</p>
<pre class="cpp">

  listWidget<span class="operator">-</span><span class="operator">&gt;</span>setDragDropMode(<span class="type"><a href="qabstractitemview.html">QAbstractItemView</a></span><span class="operator">::</span>InternalMove);

</pre>
<a name="using-model-view-classes"></a>
<h3 >使用模型/视图类</h3>
<p>Setting up a view for drag and drop follows the same pattern used with the convenience views. For example, a <a href="qlistview.html">QListView</a> can be set up in the same way as a <a href="qlistwidget.html">QListWidget</a>:</p>
<pre class="cpp">

  <span class="type"><a href="qlistview.html">QListView</a></span> <span class="operator">*</span>listView <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qlistview.html">QListView</a></span>(<span class="keyword">this</span>);
  listView<span class="operator">-</span><span class="operator">&gt;</span>setSelectionMode(<span class="type"><a href="qabstractitemview.html">QAbstractItemView</a></span><span class="operator">::</span>ExtendedSelection);
  listView<span class="operator">-</span><span class="operator">&gt;</span>setDragEnabled(<span class="keyword">true</span>);
  listView<span class="operator">-</span><span class="operator">&gt;</span>setAcceptDrops(<span class="keyword">true</span>);
  listView<span class="operator">-</span><span class="operator">&gt;</span>setDropIndicatorShown(<span class="keyword">true</span>);

</pre>
<p>Since access to the data displayed by the view is controlled by a model, the model used also has to provide support for drag and drop operations. The actions supported by a model can be specified by reimplementing the <a href="../qtcore/qabstractitemmodel.html#supportedDropActions">QAbstractItemModel::supportedDropActions</a>() function. For example, copy and move operations are enabled with the following code:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DropActions DragDropListModel<span class="operator">::</span>supportedDropActions() <span class="keyword">const</span>
  {
      <span class="keyword">return</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>CopyAction <span class="operator">|</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>MoveAction;
  }

</pre>
<p>Although any combination of values from <a href="../qtcore/qt.html#DropAction-enum">Qt::DropActions</a> can be given, the model needs to be written to support them. For example, to allow <a href="../qtcore/qt.html#DropAction-enum">Qt::MoveAction</a> to be used properly with a list model, the model must provide an implementation of <a href="../qtcore/qabstractitemmodel.html#removeRows">QAbstractItemModel::removeRows</a>(), either directly or by inheriting the implementation from its base class.</p>
<a name="enabling-drag-and-drop-for-items"></a>
<h4 >启用项目拖放</h4>
<p>Models indicate to views which items can be dragged, and which will accept drops, by reimplementing the <a href="../qtcore/qabstractitemmodel.html#flags">QAbstractItemModel::flags</a>() function to provide suitable flags.</p>
<p>For example, a model which provides a simple list based on <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a> can enable drag and drop for each of the items by ensuring that the flags returned contain the <a href="../qtcore/qt.html#ItemFlag-enum">Qt::ItemIsDragEnabled</a> 和 <a href="../qtcore/qt.html#ItemFlag-enum">Qt::ItemIsDropEnabled</a> values:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>ItemFlags DragDropListModel<span class="operator">::</span>flags(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span>
  {
      <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>ItemFlags defaultFlags <span class="operator">=</span> <span class="type"><a href="../qtcore/qstringlistmodel.html">QStringListModel</a></span><span class="operator">::</span>flags(index);

      <span class="keyword">if</span> (index<span class="operator">.</span>isValid())
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>ItemIsDragEnabled <span class="operator">|</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>ItemIsDropEnabled <span class="operator">|</span> defaultFlags;
      <span class="keyword">else</span>
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>ItemIsDropEnabled <span class="operator">|</span> defaultFlags;
  }

</pre>
<p>Note that items can be dropped into the top level of the model, but dragging is only enabled for valid items.</p>
<p>In the above code, since the model is derived from <a href="../qtcore/qstringlistmodel.html">QStringListModel</a>, we obtain a default set of flags by calling its implementation of the flags() function.</p>
<a name="encoding-exported-data"></a>
<h4 >编码导出数据</h4>
<p>When items of data are exported from a model in a drag and drop operation, they are encoded into an appropriate format corresponding to one or more MIME types. Models declare the MIME types that they can use to supply items by reimplementing the <a href="../qtcore/qabstractitemmodel.html#mimeTypes">QAbstractItemModel::mimeTypes</a>() function, returning a list of standard MIME types.</p>
<p>For example, a model that only provides plain text would provide the following implementation:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> DragDropListModel<span class="operator">::</span>mimeTypes() <span class="keyword">const</span>
  {
      <span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> types;
      types <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;application/vnd.text.list&quot;</span>;
      <span class="keyword">return</span> types;
  }

</pre>
<p>The model must also provide code to encode data in the advertised format. This is achieved by reimplementing the <a href="../qtcore/qabstractitemmodel.html#mimeData">QAbstractItemModel::mimeData</a>() function to provide a <a href="../qtcore/qmimedata.html">QMimeData</a> object, just as in any other drag and drop operation.</p>
<p>The following code shows how each item of data, corresponding to a given list of indexes, is encoded as plain text and stored in a <a href="../qtcore/qmimedata.html">QMimeData</a> object.</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qmimedata.html">QMimeData</a></span> <span class="operator">*</span>DragDropListModel<span class="operator">::</span>mimeData(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html#QModelIndexList-typedef">QModelIndexList</a></span> <span class="operator">&amp;</span>indexes) <span class="keyword">const</span>
  {
      <span class="type"><a href="../qtcore/qmimedata.html">QMimeData</a></span> <span class="operator">*</span>mimeData <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qmimedata.html">QMimeData</a></span>();
      <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> encodedData;

      <span class="type"><a href="../qtcore/qdatastream.html">QDataStream</a></span> stream(<span class="operator">&amp;</span>encodedData<span class="operator">,</span> <span class="type"><a href="../qtcore/qiodevice.html">QIODevice</a></span><span class="operator">::</span>WriteOnly);

      foreach (<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>index<span class="operator">,</span> indexes) {
          <span class="keyword">if</span> (index<span class="operator">.</span>isValid()) {
              <span class="type"><a href="../qtcore/qstring.html">QString</a></span> text <span class="operator">=</span> data(index<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DisplayRole)<span class="operator">.</span>toString();
              stream <span class="operator">&lt;</span><span class="operator">&lt;</span> text;
          }
      }

      mimeData<span class="operator">-</span><span class="operator">&gt;</span>setData(<span class="string">&quot;application/vnd.text.list&quot;</span><span class="operator">,</span> encodedData);
      <span class="keyword">return</span> mimeData;
  }

</pre>
<p>Since a list of model indexes is supplied to the function, this approach is general enough to be used in both hierarchical and non-heirarchical models.</p>
<p>Note that custom datatypes must be declared as <a href="../qtcore/qmetaobject.html">meta objects</a> and that stream operators must be implemented for them. See the <a href="../qtcore/qmetaobject.html">QMetaObject</a> class description for details.</p>
<a name="inserting-dropped-data-into-a-model"></a>
<h4 >插入已删除数据到模型</h4>
<p>The way that any given model handles dropped data depends on both its type (list, table, or tree) and the way its contents is likely to be presented to the user. Generally, the approach taken to accommodate dropped data should be the one that most suits the model's underlying data store.</p>
<p>Different types of model tend to handle dropped data in different ways. List and table models only provide a flat structure in which items of data are stored. As a result, they may insert new rows (and columns) when data is dropped on an existing item in a view, or they may overwrite the item's contents in the model using some of the data supplied. Tree models are often able to add child items containing new data to their underlying data stores, and will therefore behave more predictably as far as the user is concerned.</p>
<p>Dropped data is handled by a model's reimplementation of <a href="../qtcore/qabstractitemmodel.html#dropMimeData">QAbstractItemModel::dropMimeData</a>(). For example, a model that handles a simple list of strings can provide an implementation that handles data dropped onto existing items separately to data dropped into the top level of the model (i.e&#x2e;, onto an invalid item).</p>
<p>Models can forbid dropping on certain items, or depending on the dropped data, by reimplementing <a href="../qtcore/qabstractitemmodel.html#canDropMimeData">QAbstractItemModel::canDropMimeData</a>().</p>
<p>The model first has to make sure that the operation should be acted on, the data supplied is in a format that can be used, and that its destination within the model is valid:</p>
<pre class="cpp">

  bool DragDropListModel<span class="operator">::</span>canDropMimeData(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmimedata.html">QMimeData</a></span> <span class="operator">*</span>data<span class="operator">,</span>
      <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DropAction action<span class="operator">,</span> <span class="type">int</span> row<span class="operator">,</span> <span class="type">int</span> column<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>parent)
  {
      Q_UNUSED(action);
      Q_UNUSED(row);
      Q_UNUSED(parent);

      <span class="keyword">if</span> (<span class="operator">!</span>data<span class="operator">-</span><span class="operator">&gt;</span>hasFormat(<span class="string">&quot;application/vnd.text.list&quot;</span>))
          <span class="keyword">return</span> <span class="keyword">false</span>;

      <span class="keyword">if</span> (column <span class="operator">&gt;</span> <span class="number">0</span>)
          <span class="keyword">return</span> <span class="keyword">false</span>;

      <span class="keyword">return</span> <span class="keyword">true</span>;
  }
  bool DragDropListModel<span class="operator">::</span>dropMimeData(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qmimedata.html">QMimeData</a></span> <span class="operator">*</span>data<span class="operator">,</span>
      <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>DropAction action<span class="operator">,</span> <span class="type">int</span> row<span class="operator">,</span> <span class="type">int</span> column<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> <span class="operator">&amp;</span>parent)
  {
      <span class="keyword">if</span> (<span class="operator">!</span>canDropMimeData(data<span class="operator">,</span> action<span class="operator">,</span> row<span class="operator">,</span> column<span class="operator">,</span> parent))
          <span class="keyword">return</span> <span class="keyword">false</span>;

      <span class="keyword">if</span> (action <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>IgnoreAction)
          <span class="keyword">return</span> <span class="keyword">true</span>;

</pre>
<p>A simple one column string list model can indicate failure if the data supplied is not plain text, or if the column number given for the drop is invalid.</p>
<p>The data to be inserted into the model is treated differently depending on whether it is dropped onto an existing item or not. In this simple example, we want to allow drops between existing items, before the first item in the list, and after the last item.</p>
<p>When a drop occurs, the model index corresponding to the parent item will either be valid, indicating that the drop occurred on an item, or it will be invalid, indicating that the drop occurred somewhere in the view that corresponds to top level of the model.</p>
<pre class="cpp">

      <span class="type">int</span> beginRow;

      <span class="keyword">if</span> (row <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>)
          beginRow <span class="operator">=</span> row;

</pre>
<p>We initially examine the row number supplied to see if we can use it to insert items into the model, regardless of whether the parent index is valid or not.</p>
<pre class="cpp">

      <span class="keyword">else</span> <span class="keyword">if</span> (parent<span class="operator">.</span>isValid())
          beginRow <span class="operator">=</span> parent<span class="operator">.</span>row();

</pre>
<p>If the parent model index is valid, the drop occurred on an item. In this simple list model, we find out the row number of the item and use that value to insert dropped items into the top level of the model.</p>
<pre class="cpp">

      <span class="keyword">else</span>
          beginRow <span class="operator">=</span> rowCount(<span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());

</pre>
<p>When a drop occurs elsewhere in the view, and the row number is unusable, we append items to the top level of the model.</p>
<p>In hierarchical models, when a drop occurs on an item, it would be better to insert new items into the model as children of that item. In the simple example shown here, the model only has one level, so this approach is not appropriate.</p>
<a name="decoding-imported-data"></a>
<h4 >解码导入数据</h4>
<p>Each implementation of <a href="../qtcore/qabstractitemmodel.html#dropMimeData">dropMimeData()</a> must also decode the data and insert it into the model's underlying data structure.</p>
<p>For a simple string list model, the encoded items can be decoded and streamed into a <a href="../qtcore/qstringlist.html">QStringList</a>:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> encodedData <span class="operator">=</span> data<span class="operator">-</span><span class="operator">&gt;</span>data(<span class="string">&quot;application/vnd.text.list&quot;</span>);
      <span class="type"><a href="../qtcore/qdatastream.html">QDataStream</a></span> stream(<span class="operator">&amp;</span>encodedData<span class="operator">,</span> <span class="type"><a href="../qtcore/qiodevice.html">QIODevice</a></span><span class="operator">::</span>ReadOnly);
      <span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> newItems;
      <span class="type">int</span> rows <span class="operator">=</span> <span class="number">0</span>;

      <span class="keyword">while</span> (<span class="operator">!</span>stream<span class="operator">.</span>atEnd()) {
          <span class="type"><a href="../qtcore/qstring.html">QString</a></span> text;
          stream <span class="operator">&gt;</span><span class="operator">&gt;</span> text;
          newItems <span class="operator">&lt;</span><span class="operator">&lt;</span> text;
          <span class="operator">+</span><span class="operator">+</span>rows;
      }

</pre>
<p>The strings can then be inserted into the underlying data store. For consistency, this can be done through the model's own interface:</p>
<pre class="cpp">

      insertRows(beginRow<span class="operator">,</span> rows<span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
      foreach (<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html">QString</a></span> <span class="operator">&amp;</span>text<span class="operator">,</span> newItems) {
          <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span> idx <span class="operator">=</span> index(beginRow<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qmodelindex.html">QModelIndex</a></span>());
          setData(idx<span class="operator">,</span> text);
          beginRow<span class="operator">+</span><span class="operator">+</span>;
      }

      <span class="keyword">return</span> <span class="keyword">true</span>;
  }

</pre>
<p>Note that the model will typically need to provide implementations of the <a href="../qtcore/qabstractitemmodel.html#insertRows">QAbstractItemModel::insertRows</a>() 和 <a href="../qtcore/qabstractitemmodel.html#setData">QAbstractItemModel::setData</a>() functions.</p>
<a name="proxy-models"></a>
<h2 id="proxy-models">代理模型</h2>
<p>In the model/view framework, items of data supplied by a single model can be shared by any number of views, and each of these can possibly represent the same information in completely different ways. Custom views and delegates are effective ways to provide radically different representations of the same data. However, applications often need to provide conventional views onto processed versions of the same data, such as differently-sorted views onto a list of items.</p>
<p>Although it seems appropriate to perform sorting and filtering operations as internal functions of views, this approach does not allow multiple views to share the results of such potentially costly operations. The alternative approach, involving sorting within the model itself, leads to the similar problem where each view has to display items of data that are organized according to the most recent processing operation.</p>
<p>To solve this problem, the model/view framework uses proxy models to manage the information supplied between individual models and views. Proxy models are components that behave like ordinary models from the perspective of a view, and access data from source models on behalf of that view. The signals and slots used by the model/view framework ensure that each view is updated appropriately no matter how many proxy models are placed between itself and the source model.</p>
<a name="using-proxy-models"></a>
<h3 >使用代理模型</h3>
<p>Proxy models can be inserted between an existing model and any number of views. Qt is supplied with a standard proxy model, <a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a>, that is usually instantiated and used directly, but can also be subclassed to provide custom filtering and sorting behavior. The <a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a> class can be used in the following way:</p>
<pre class="cpp">

      <span class="type"><a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a></span> <span class="operator">*</span>filterModel <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a></span>(parent);
      filterModel<span class="operator">-</span><span class="operator">&gt;</span>setSourceModel(stringListModel);

      <span class="type"><a href="qlistview.html">QListView</a></span> <span class="operator">*</span>filteredView <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qlistview.html">QListView</a></span>;
      filteredView<span class="operator">-</span><span class="operator">&gt;</span>setModel(filterModel);

</pre>
<p>Since proxy models inherit from <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>, they can be connected to any kind of view, and can be shared between views. They can also be used to process the information obtained from other proxy models in a pipeline arrangement.</p>
<p>The <a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a> class is designed to be instantiated and used directly in applications. More specialized proxy models can be created by subclassing this classes and implementing the required comparison operations.</p>
<a name="customizing-proxy-models"></a>
<h3 >自定义代理模型</h3>
<p>Generally, the type of processing used in a proxy model involves mapping each item of data from its original location in the source model to either a different location in the proxy model. In some models, some items may have no corresponding location in the proxy model; these models are <i>filtering</i> proxy models. Views access items using model indexes provided by the proxy model, and these contain no information about the source model or the locations of the original items in that model.</p>
<p><a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a> enables data from a source model to be filtered before being supplied to views, and also allows the contents of a source model to be supplied to views as pre-sorted data.</p>
<a name="custom-filtering-models"></a>
<h4 >自定义过滤模型</h4>
<p>The <a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a> class provides a filtering model that is fairly versatile, and which can be used in a variety of common situations. For advanced users, <a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a> can be subclassed, providing a mechanism that enables custom filters to be implemented.</p>
<p>Subclasses of <a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a> can reimplement two virtual functions that are called whenever a model index from the proxy model is requested or used:</p>
<ul>
<li><a href="../qtcore/qsortfilterproxymodel.html#filterAcceptsColumn">filterAcceptsColumn()</a> is used to filter specific columns from part of the source model.</li>
<li><a href="../qtcore/qsortfilterproxymodel.html#filterAcceptsRow">filterAcceptsRow()</a> is used to filter specific rows from part of the source model.</li>
</ul>
<p>The default implementations of the above functions in <a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a> return true to ensure that all items are passed through to views; reimplementations of these functions should return false to filter out individual rows and columns.</p>
<a name="custom-sorting-models"></a>
<h4 >自定义排序模型</h4>
<p><a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a> instances use Qt's built-in qStableSort() function to set up mappings between items in the source model and those in the proxy model, allowing a sorted hierarchy of items to be exposed to views without modifying the structure of the source model. To provide custom sorting behavior, reimplement the <a href="../qtcore/qsortfilterproxymodel.html#lessThan">lessThan()</a> function to perform custom comparisons.</p>
<a name="model-subclassing-reference"></a>
<h2 id="model-subclassing-reference">模型子类化参考</h2>
<p>Model subclasses need to provide implementations of many of the virtual functions defined in the <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> base class. The number of these functions that need to be implemented depends on the type of model - whether it supplies views with a simple list, a table, or a complex hierarchy of items. Models that inherit from <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a> 和 <a href="../qtcore/qabstracttablemodel.html">QAbstractTableModel</a> can take advantage of the default implementations of functions provided by those classes. Models that expose items of data in tree-like structures must provide implementations for many of the virtual functions in <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>.</p>
<p>The functions that need to be implemented in a model subclass can be divided into three groups:</p>
<ul>
<li><b>Item data handling:</b> All models need to implement functions to enable views and delegates to query the dimensions of the model, examine items, and retrieve data.</li>
<li><b>Navigation and index creation:</b> Hierarchical models need to provide functions that views can call to navigate the tree-like structures they expose, and obtain model indexes for items.</li>
<li><b>Drag and drop support and MIME type handling:</b> Models inherit functions that control the way that internal and external drag and drop operations are performed. These functions allow items of data to be described in terms of MIME types that other components and applications can understand.</li>
</ul>
<a name="item-data-handling"></a>
<h3 >项数据处理</h3>
<p>Models can provide varying levels of access to the data they provide: They can be simple read-only components, some models may support resizing operations, and others may allow items to be edited.</p>
<a name="read-only-access"></a>
<h3 >只读访问</h3>
<p>To provide read-only access to data provided by a model, the following functions <i>must</i> be implemented in the model's subclass:</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#flags">flags()</a></td><td >Used by other components to obtain information about each item provided by the model. In many models, the combination of flags should include <a href="../qtcore/qt.html#ItemFlag-enum">Qt::ItemIsEnabled</a> 和 <a href="../qtcore/qt.html#ItemFlag-enum">Qt::ItemIsSelectable</a>.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qabstractitemmodel.html#data">data()</a></td><td >Used to supply item data to views and delegates. Generally, models only need to supply data for <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::DisplayRole</a> and any application-specific user roles, but it is also good practice to provide data for <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::ToolTipRole</a>, <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::AccessibleTextRole</a>, 和 <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::AccessibleDescriptionRole</a>. See the <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::ItemDataRole</a> enum documentation for information about the types associated with each role.</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#headerData">headerData()</a></td><td >Provides views with information to show in their headers. The information is only retrieved by views that can display header information.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qabstractitemmodel.html#rowCount">rowCount()</a></td><td >Provides the number of rows of data exposed by the model.</td></tr>
</table></div>
<p>These four functions must be implemented in all types of model, including list models (<a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a> subclasses) and table models (<a href="../qtcore/qabstracttablemodel.html">QAbstractTableModel</a> subclasses).</p>
<p>Additionally, the following functions <i>must</i> be implemented in direct subclasses of <a href="../qtcore/qabstracttablemodel.html">QAbstractTableModel</a> 和 <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>:</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#columnCount">columnCount()</a></td><td >Provides the number of columns of data exposed by the model. List models do not provide this function because it is already implemented in <a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a>.</td></tr>
</table></div>
<a name="editable-items"></a>
<h4 >项可编辑</h4>
<p>Editable models allow items of data to be modified, and may also provide functions to allow rows and columns to be inserted and removed. To enable editing, the following functions must be implemented correctly:</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#flags">flags()</a></td><td >Must return an appropriate combination of flags for each item. In particular, the value returned by this function must include <a href="../qtcore/qt.html#ItemFlag-enum">Qt::ItemIsEditable</a> in addition to the values applied to items in a read-only model.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qabstractitemmodel.html#setData">setData()</a></td><td >Used to modify the item of data associated with a specified model index. To be able to accept user input, provided by user interface elements, this function must handle data associated with <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::EditRole</a>. The implementation may also accept data associated with many different kinds of roles specified by <a href="../qtcore/qt.html#ItemDataRole-enum">Qt::ItemDataRole</a>. After changing the item of data, models must emit the <a href="../qtcore/qabstractitemmodel.html#dataChanged">dataChanged()</a> signal to inform other components of the change.</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#setHeaderData">setHeaderData()</a></td><td >Used to modify horizontal and vertical header information. After changing the item of data, models must emit the <a href="../qtcore/qabstractitemmodel.html#headerDataChanged">headerDataChanged()</a> signal to inform other components of the change.</td></tr>
</table></div>
<a name="resizable-models"></a>
<h4 >Resizable models</h4>
<p>All types of model can support the insertion and removal of rows. Table models and hierarchical models can also support the insertion and removal of columns. It is important to notify other components about changes to the model's dimensions both <i>before</i> and <i>after</i> they occur. As a result, the following functions can be implemented to allow the model to be resized, but implementations must ensure that the appropriate functions are called to notify attached views and delegates:</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#insertRows">insertRows()</a></td><td >Used to add new rows and items of data to all types of model. Implementations must call <a href="../qtcore/qabstractitemmodel.html#beginInsertRows">beginInsertRows()</a> <i>before</i> inserting new rows into any underlying data structures, and call <a href="../qtcore/qabstractitemmodel.html#endInsertRows">endInsertRows()</a> <i>immediately afterwards</i>.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qabstractitemmodel.html#removeRows">removeRows()</a></td><td >Used to remove rows and the items of data they contain from all types of model. Implementations must call <a href="../qtcore/qabstractitemmodel.html#beginRemoveRows">beginRemoveRows()</a> <i>before</i> rows are removed from any underlying data structures, and call <a href="../qtcore/qabstractitemmodel.html#endRemoveRows">endRemoveRows()</a> <i>immediately afterwards</i>.</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#insertColumns">insertColumns()</a></td><td >Used to add new columns and items of data to table models and hierarchical models. Implementations must call <a href="../qtcore/qabstractitemmodel.html#beginInsertColumns">beginInsertColumns()</a> <i>before</i> inserting new columns into any underlying data structures, and call <a href="../qtcore/qabstractitemmodel.html#endInsertColumns">endInsertColumns()</a> <i>immediately afterwards</i>.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qabstractitemmodel.html#removeColumns">removeColumns()</a></td><td >Used to remove columns and the items of data they contain from table models and hierarchical models. Implementations must call <a href="../qtcore/qabstractitemmodel.html#beginRemoveColumns">beginRemoveColumns()</a> <i>before</i> columns are removed from any underlying data structures, and call <a href="../qtcore/qabstractitemmodel.html#endRemoveColumns">endRemoveColumns()</a> <i>immediately afterwards</i>.</td></tr>
</table></div>
<p>Generally, these functions should return true if the operation was successful. However, there may be cases where the operation only partly succeeded; for example, if less than the specified number of rows could be inserted. In such cases, the model should return false to indicate failure to enable any attached components to handle the situation.</p>
<p>The signals emitted by the functions called in implementations of the resizing API give attached components the chance to take action before any data becomes unavailable. The encapsulation of insert and remove operations with begin and end functions also enable the model to manage <a href="../qtcore/qpersistentmodelindex.html">persistent model indexes</a> correctly.</p>
<p>Normally, the begin and end functions are capable of informing other components about changes to the model's underlying structure. For more complex changes to the model's structure, perhaps involving internal reorganization, sorting of data or any other structural change, it is necessary to perform the following sequence:</p>
<ul>
<li>Emit the <a href="../qtcore/qabstractitemmodel.html#layoutAboutToBeChanged">layoutAboutToBeChanged()</a> signal</li>
<li>Update internal data which represents the structure of the model.</li>
<li>Update persistent indexes using <a href="../qtcore/qabstractitemmodel.html#changePersistentIndexList">changePersistentIndexList()</a></li>
<li>Emit the <a href="../qtcore/qabstractitemmodel.html#layoutChanged">layoutChanged()</a> signal.</li>
</ul>
<p>This sequence can be used for any structural update in lieu of the more high-level and convenient protected methods. For example, if a model of two million rows needs to have all odd numbered rows removed, that is 1 million discountiguous ranges of 1 element each. It would be possible to use beginRemoveRows and endRemoveRows 1 million times, but that would obviously be inefficient. Instead, this can be signalled as a single layout change which updates all necessary persistent indexes at once.</p>
<a name="lazy-population-of-model-data"></a>
<h4 >Lazy population of model data</h4>
<p>Lazy population of model data effectively allows requests for information about the model to be deferred until it is actually needed by views.</p>
<p>Some models need to obtain data from remote sources, or must perform time-consuming operations to obtain information about the way the data is organized. Since views generally request as much information as possible in order to accurately display model data, it can be useful to restrict the amount of information returned to them to reduce unnecessary follow-up requests for data.</p>
<p>In hierarchical models where finding the number of children of a given item is an expensive operation, it is useful to ensure that the model's <a href="../qtcore/qabstractitemmodel.html#rowCount">rowCount()</a> implementation is only called when necessary. In such cases, the <a href="../qtcore/qabstractitemmodel.html#hasChildren">hasChildren()</a> function can be reimplemented to provide an inexpensive way for views to check for the presence of children and, in the case of <a href="qtreeview.html">QTreeView</a>, draw the appropriate decoration for their parent item.</p>
<p>Whether the reimplementation of <a href="../qtcore/qabstractitemmodel.html#hasChildren">hasChildren()</a> returns <code>true</code> or <code>false</code>, it may not be necessary for the view to call <a href="../qtcore/qabstractitemmodel.html#rowCount">rowCount()</a> to find out how many children are present. For example, <a href="qtreeview.html">QTreeView</a> does not need to know how many children there are if the parent item has not been expanded to show them.</p>
<p>If it is known that many items will have children, reimplementing <a href="../qtcore/qabstractitemmodel.html#hasChildren">hasChildren()</a> to unconditionally return <code>true</code> is sometimes a useful approach to take. This ensures that each item can be later examined for children while making initial population of model data as fast as possible. The only disadvantage is that items without children may be displayed incorrectly in some views until the user attempts to view the non-existent child items.</p>
<a name="navigation-and-model-index-creation"></a>
<h3 >模型索引的导航和创建</h3>
<p>Hierarchical models need to provide functions that views can call to navigate the tree-like structures they expose, and obtain model indexes for items.</p>
<a name="parents-and-children"></a>
<h4 >父与子</h4>
<p>Since the structure exposed to views is determined by the underlying data structure, it is up to each model subclass to create its own model indexes by providing implementations of the following functions:</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#index">index()</a></td><td >Given a model index for a parent item, this function allows views and delegates to access children of that item. If no valid child item - corresponding to the specified row, column, and parent model index, can be found, the function must return QModelIndex(), which is an invalid model index.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qabstractitemmodel.html#parent">parent()</a></td><td >Provides a model index corresponding to the parent of any given child item. If the model index specified corresponds to a top-level item in the model, or if there is no valid parent item in the model, the function must return an invalid model index, created with the empty QModelIndex() constructor.</td></tr>
</table></div>
<p>Both functions above use the <a href="../qtcore/qabstractitemmodel.html#createIndex-1">createIndex()</a> factory function to generate indexes for other components to use. It is normal for models to supply some unique identifier to this function to ensure that the model index can be re-associated with its corresponding item later on.</p>
<a name="drag-and-drop-support-and-mime-type-handling"></a>
<h3 >支持拖放和处理MIME类型</h3>
<p>The model/view classes support drag and drop operations, providing default behavior that is sufficient for many applications. However, it is also possible to customize the way items are encoded during drag and drop operations, whether they are copied or moved by default, and how they are inserted into existing models.</p>
<p>Additionally, the convenience view classes implement specialized behavior that should closely follow that expected by existing developers. The <a href="model-view-programming.html#convenience-views">Convenience Views</a> section provides an overview of this behavior.</p>
<a name="mime-data"></a>
<h4 >MIME数据</h4>
<p>By default, the built-in models and views use an internal MIME type (<code>application/x-qabstractitemmodeldatalist</code>) to pass around information about model indexes. This specifies data for a list of items, containing the row and column numbers of each item, and information about the roles that each item supports.</p>
<p>Data encoded using this MIME type can be obtained by calling <a href="../qtcore/qabstractitemmodel.html#mimeData">QAbstractItemModel::mimeData</a>() with a <a href="../qtcore/qmodelindex.html#QModelIndexList-typedef">QModelIndexList</a> containing the items to be serialized.</p>
<p>When implementing drag and drop support in a custom model, it is possible to export items of data in specialized formats by reimplementing the following function:</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#mimeData">mimeData()</a></td><td >This function can be reimplemented to return data in formats other than the default <code>application/x-qabstractitemmodeldatalist</code> internal MIME type.<p>Subclasses can obtain the default <a href="../qtcore/qmimedata.html">QMimeData</a> object from the base class and add data to it in additional formats.</p>
</td></tr>
</table></div>
<p>For many models, it is useful to provide the contents of items in common format represented by MIME types such as <code>text/plain</code> and <code>image/png</code>. Note that images, colors and HTML documents can easily be added to a <a href="../qtcore/qmimedata.html">QMimeData</a> object with the <a href="../qtcore/qmimedata.html#setImageData">QMimeData::setImageData</a>(), <a href="../qtcore/qmimedata.html#setColorData">QMimeData::setColorData</a>(), 和 <a href="../qtcore/qmimedata.html#setHtml">QMimeData::setHtml</a>() functions.</p>
<a name="accepting-dropped-data"></a>
<h4 >接收放置的数据</h4>
<p>When a drag and drop operation is performed over a view, the underlying model is queried to determine which types of operation it supports and the MIME types it can accept. This information is provided by the <a href="../qtcore/qabstractitemmodel.html#supportedDropActions">QAbstractItemModel::supportedDropActions</a>() 和 <a href="../qtcore/qabstractitemmodel.html#mimeTypes">QAbstractItemModel::mimeTypes</a>() functions. Models that do not override the implementations provided by <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a> support copy operations and the default internal MIME type for items.</p>
<p>When serialized item data is dropped onto a view, the data is inserted into the current model using its implementation of <a href="../qtcore/qabstractitemmodel.html#dropMimeData">QAbstractItemModel::dropMimeData</a>(). The default implementation of this function will never overwrite any data in the model; instead, it tries to insert the items of data either as siblings of an item, or as children of that item.</p>
<p>To take advantage of <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>'s default implementation for the built-in MIME type, new models must provide reimplementations of the following functions:</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#insertRows">insertRows()</a></td><td  rowspan=" 2">These functions enable the model to automatically insert new data using the existing implementation provided by <a href="../qtcore/qabstractitemmodel.html#dropMimeData">QAbstractItemModel::dropMimeData</a>().</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qabstractitemmodel.html#insertColumns">insertColumns()</a></td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#setData">setData()</a></td><td >Allows the new rows and columns to be populated with items.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qabstractitemmodel.html#setItemData">setItemData()</a></td><td >This function provides more efficient support for populating new items.</td></tr>
</table></div>
<p>To accept other forms of data, these functions must be reimplemented:</p>
<div class="table"><table class="generic" width="70%">
 <tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#supportedDropActions">supportedDropActions()</a></td><td >Used to return a combination of <a href="../qtcore/qt.html#DropAction-enum">drop actions</a>, indicating the types of drag and drop operations that the model accepts.</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qabstractitemmodel.html#mimeTypes">mimeTypes()</a></td><td >Used to return a list of MIME types that can be decoded and handled by the model. Generally, the MIME types that are supported for input into the model are the same as those that it can use when encoding data for use by external components.</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qabstractitemmodel.html#dropMimeData">dropMimeData()</a></td><td >Performs the actual decoding of the data transferred by drag and drop operations, determines where in the model it will be set, and inserts new rows and columns where necessary. How this function is implemented in subclasses depends on the requirements of the data exposed by each model.</td></tr>
</table></div>
<p>If the implementation of the <a href="../qtcore/qabstractitemmodel.html#dropMimeData">dropMimeData()</a> function changes the dimensions of a model by inserting or removing rows or columns, or if items of data are modified, care must be taken to ensure that all relevant signals are emitted. It can be useful to simply call reimplementations of other functions in the subclass, such as <a href="../qtcore/qabstractitemmodel.html#setData">setData()</a>, <a href="../qtcore/qabstractitemmodel.html#insertRows">insertRows()</a>, 和 <a href="../qtcore/qabstractitemmodel.html#insertColumns">insertColumns()</a>, to ensure that the model behaves consistently.</p>
<p>In order to ensure drag operations work properly, it is important to reimplement the following functions that remove data from the model:</p>
<ul>
<li><a href="../qtcore/qabstractitemmodel.html#removeRows">removeRows()</a></li>
<li><a href="../qtcore/qabstractitemmodel.html#removeRow">removeRow()</a></li>
<li><a href="../qtcore/qabstractitemmodel.html#removeColumns">removeColumns()</a></li>
<li><a href="../qtcore/qabstractitemmodel.html#removeColumn">removeColumn()</a></li>
</ul>
<p>For more information about drag and drop with item views, refer to <a href="model-view-programming.html#using-drag-and-drop-with-item-views">Using drag and drop with item views</a>.</p>
<a name="convenience-views"></a>
<h4 >Convenience views</h4>
<p>The convenience views (<a href="qlistwidget.html">QListWidget</a>, <a href="qtablewidget.html">QTableWidget</a>, 和 <a href="qtreewidget.html">QTreeWidget</a>) override the default drag and drop functionality to provide less flexible, but more natural behavior that is appropriate for many applications. For example, since it is more common to drop data into cells in a <a href="qtablewidget.html">QTableWidget</a>, replacing the existing contents with the data being transferred, the underlying model will set the data of the target items rather than insert new rows and columns into the model. For more information on drag and drop in convenience views, you can see <a href="model-view-programming.html#using-drag-and-drop-with-item-views">Using drag and drop with item views</a>.</p>
<a name="performance-optimization-for-large-amounts-of-data"></a>
<h3 >大量数据的性能优化</h3>
<p>The <a href="../qtcore/qabstractitemmodel.html#canFetchMore">canFetchMore()</a> function checks if the parent has more data available and returns <code>true</code> or false accordingly. The <a href="../qtcore/qabstractitemmodel.html#fetchMore">fetchMore()</a> function fetches data based on the parent specified. Both these functions can be combined, for example, in a database query involving incremental data to populate a <a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a>. We reimplement <a href="../qtcore/qabstractitemmodel.html#canFetchMore">canFetchMore()</a> to indicate if there is more data to be fetched and <a href="../qtcore/qabstractitemmodel.html#fetchMore">fetchMore()</a> to populate the model as required.</p>
<p>Another example would be dynamically populated tree models, where we reimplement <a href="../qtcore/qabstractitemmodel.html#fetchMore">fetchMore()</a> when a branch in the tree model is expanded.</p>
<p>If your reimplementation of <a href="../qtcore/qabstractitemmodel.html#fetchMore">fetchMore()</a> adds rows to the model, you need to call <a href="../qtcore/qabstractitemmodel.html#beginInsertRows">beginInsertRows()</a> 和 <a href="../qtcore/qabstractitemmodel.html#endInsertRows">endInsertRows()</a>. Also, both <a href="../qtcore/qabstractitemmodel.html#canFetchMore">canFetchMore()</a> 和 <a href="../qtcore/qabstractitemmodel.html#fetchMore">fetchMore()</a> must be reimplemented as their default implementation returns false and does nothing.</p>
<a name="model-view-classes"></a><a name="the-model-view-classes"></a>
<h2 id="the-model-view-classes">模型/视图类</h2>
<p>These classes use the model/view design pattern in which the underlying data (in the model) is kept separate from the way the data is presented and manipulated by the user (in the view).</p>
<div class="table"><table class="annotated">
<tr class="odd topAlign"><td class="tblName"><p><a href="qabstractitemdelegate.html">QAbstractItemDelegate</a></p></td><td class="tblDescr"><p>Used to display and edit data items from a model</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="../qtcore/qabstractitemmodel.html">QAbstractItemModel</a></p></td><td class="tblDescr"><p>项模型类的抽象接口</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qabstractitemview.html">QAbstractItemView</a></p></td><td class="tblDescr"><p>The basic functionality for item view classes</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="../qtcore/qabstractlistmodel.html">QAbstractListModel</a></p></td><td class="tblDescr"><p>能被子类化用于创建一维列表模型的抽象模型</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="../qtcore/qabstractproxymodel.html">QAbstractProxyModel</a></p></td><td class="tblDescr"><p>用于排序、过滤和其他数据处理任务的代理项模型的基类</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="../qtcore/qabstracttablemodel.html">QAbstractTableModel</a></p></td><td class="tblDescr"><p>能被子类化用于创建表格模型的抽象模型</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qcolumnview.html">QColumnView</a></p></td><td class="tblDescr"><p>Model/view implementation of a column view</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qdatawidgetmapper.html">QDataWidgetMapper</a></p></td><td class="tblDescr"><p>Mapping between a section of a data model to widgets</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qfilesystemmodel.html">QFileSystemModel</a></p></td><td class="tblDescr"><p>Data model for the local filesystem</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qheaderview.html">QHeaderView</a></p></td><td class="tblDescr"><p>Header row or header column for item views</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="../qtcore/qidentityproxymodel.html">QIdentityProxyModel</a></p></td><td class="tblDescr"><p>源模型未修改的代理模型</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qitemdelegate.html">QItemDelegate</a></p></td><td class="tblDescr"><p>Display and editing facilities for data items from a model</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qitemeditorcreator.html">QItemEditorCreator</a></p></td><td class="tblDescr"><p>Makes it possible to create item editor creator bases without subclassing QItemEditorCreatorBase</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qitemeditorcreatorbase.html">QItemEditorCreatorBase</a></p></td><td class="tblDescr"><p>Abstract base class that must be subclassed when implementing new item editor creators</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qitemeditorfactory.html">QItemEditorFactory</a></p></td><td class="tblDescr"><p>Widgets for editing item data in views and delegates</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="../qtcore/qitemselection.html">QItemSelection</a></p></td><td class="tblDescr"><p>关于模型中已选元素项的管理信息</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="../qtcore/qitemselectionmodel.html">QItemSelectionModel</a></p></td><td class="tblDescr"><p>跟踪视图选定元素项</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="../qtcore/qitemselectionrange.html">QItemSelectionRange</a></p></td><td class="tblDescr"><p>关于模型中已选元素项范围的管理信息</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qlistview.html">QListView</a></p></td><td class="tblDescr"><p>List or icon view onto a model</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qlistwidget.html">QListWidget</a></p></td><td class="tblDescr"><p>Item-based list widget</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qlistwidgetitem.html">QListWidgetItem</a></p></td><td class="tblDescr"><p>Item for use with the QListWidget item view class</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="../qtcore/qmodelindex.html">QModelIndex</a></p></td><td class="tblDescr"><p>用于在数据模型中定位数据</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="../qtcore/qpersistentmodelindex.html">QPersistentModelIndex</a></p></td><td class="tblDescr"><p>用于在数据模型中定位数据</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="../qtcore/qsortfilterproxymodel.html">QSortFilterProxyModel</a></p></td><td class="tblDescr"><p>支持对另一个模型和视图之间传递的数据所进行的排序和过滤操作</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="../qtgui/qstandarditem.html">QStandardItem</a></p></td><td class="tblDescr"><p>Item for use with the QStandardItemModel class</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qstandarditemeditorcreator.html">QStandardItemEditorCreator</a></p></td><td class="tblDescr"><p>The possibility to register widgets without having to subclass QItemEditorCreatorBase</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="../qtgui/qstandarditemmodel.html">QStandardItemModel</a></p></td><td class="tblDescr"><p>Generic model for storing custom data</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="../qtcore/qstringlistmodel.html">QStringListModel</a></p></td><td class="tblDescr"><p>支持字符串到视图的模型</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qstyleditemdelegate.html">QStyledItemDelegate</a></p></td><td class="tblDescr"><p>Display and editing facilities for data items from a model</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qtableview.html">QTableView</a></p></td><td class="tblDescr"><p>Default model/view implementation of a table view</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qtablewidget.html">QTableWidget</a></p></td><td class="tblDescr"><p>Item-based table view with a default model</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qtablewidgetitem.html">QTableWidgetItem</a></p></td><td class="tblDescr"><p>Item for use with the QTableWidget class</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qtablewidgetselectionrange.html">QTableWidgetSelectionRange</a></p></td><td class="tblDescr"><p>Way to interact with selection in a model without using model indexes and a selection model</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qtreeview.html">QTreeView</a></p></td><td class="tblDescr"><p>Default model/view implementation of a tree view</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qtreewidget.html">QTreeWidget</a></p></td><td class="tblDescr"><p>Tree view that uses a predefined tree model</p></td></tr>
<tr class="even topAlign"><td class="tblName"><p><a href="qtreewidgetitem.html">QTreeWidgetItem</a></p></td><td class="tblDescr"><p>Item for use with the QTreeWidget convenience class</p></td></tr>
<tr class="odd topAlign"><td class="tblName"><p><a href="qtreewidgetitemiterator.html">QTreeWidgetItemIterator</a></p></td><td class="tblDescr"><p>Way to iterate over the items in a QTreeWidget instance</p></td></tr>
</table></div>
<a name="related-examples"></a>
<h2 id="related-examples">相关样例</h2>
<ul>
<li><a href="qtwidgets-itemviews-dirview-example.html">Dir View</a></li>
<li><a href="qtwidgets-itemviews-spinboxdelegate-example.html">Spin Box Delegate</a></li>
<li><a href="qtwidgets-itemviews-pixelator-example.html">Pixelator</a></li>
<li><a href="qtwidgets-itemviews-simpletreemodel-example.html">Simple Tree Model</a></li>
<li><a href="qtwidgets-itemviews-chart-example.html">Chart</a></li>
</ul>
</div>
<p><b> 参见 </b><a href="qtwidgets-itemviews-puzzle-example.html">Item Views Puzzle Example</a>.</p>
<!-- @@@model-view-programming.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
