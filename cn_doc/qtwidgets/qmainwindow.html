<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qmainwindow.cpp -->
  <title>QMainWindow Class | Qt部件模块 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtwidgets-index.html">Qt部件</a></td><td ><a href="qtwidgets-module.html">C++类</a></td><td >QMainWindow</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#public-slots">公共槽函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">重新实现的保护函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#qt-main-window-framework">Qt Main Window Framework</a></li>
<li class="level2"><a href="#creating-main-window-components">Creating Main Window Components</a></li>
<li class="level2"><a href="#storing-state">Storing State</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QMainWindow Class</h1>
<!-- $$$QMainWindow-brief -->
<p>The <a href="qmainwindow.html">QMainWindow</a> class provides a main application window. <a href="#details">更多详情...</a></p>
<!-- @@@QMainWindow -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QMainWindow&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += widgets</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="qwidget.html">QWidget</a></td></tr></table></div><ul>
<li><a href="qmainwindow-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qmainwindow-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#DockOption-enum">DockOption</a></b> { AnimatedDocks, AllowNestedDocks, AllowTabbedDocks, ForceTabbedDocks, VerticalTabs, GroupedDragging }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#DockOption-enum">DockOptions</a></b></td></tr>
</table></div>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<div class="table"><table class="propsummary">
<tr><td class="topAlign"><ul>
<li class="fn"><b><a href="qmainwindow.html#animated-prop">animated</a></b> : bool</li>
<li class="fn"><b><a href="qmainwindow.html#dockNestingEnabled-prop">dockNestingEnabled</a></b> : bool</li>
<li class="fn"><b><a href="qmainwindow.html#dockOptions-prop">dockOptions</a></b> : DockOptions</li>
<li class="fn"><b><a href="qmainwindow.html#documentMode-prop">documentMode</a></b> : bool</li>
</ul></td><td class="topAlign"><ul>
<li class="fn"><b><a href="qmainwindow.html#iconSize-prop">iconSize</a></b> : QSize</li>
<li class="fn"><b><a href="qmainwindow.html#tabShape-prop">tabShape</a></b> : QTabWidget::TabShape</li>
<li class="fn"><b><a href="qmainwindow.html#toolButtonStyle-prop">toolButtonStyle</a></b> : Qt::ToolButtonStyle</li>
<li class="fn"><b><a href="qmainwindow.html#unifiedTitleAndToolBarOnMac-prop">unifiedTitleAndToolBarOnMac</a></b> : bool</li>
</ul>
</td></tr>
</table></div>
<ul>
<li class="fn">59 个属性继承于 <a href="qwidget.html#properties">QWidget</a></li>
<li class="fn">1 个属性继承于 <a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#QMainWindow">QMainWindow</a></b>(QWidget *<i>parent</i> = nullptr, Qt::WindowFlags <i>flags</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#dtor.QMainWindow">~QMainWindow</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#addDockWidget">addDockWidget</a></b>(Qt::DockWidgetArea <i>area</i>, QDockWidget *<i>dockwidget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#addDockWidget-1">addDockWidget</a></b>(Qt::DockWidgetArea <i>area</i>, QDockWidget *<i>dockwidget</i>, Qt::Orientation <i>orientation</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#addToolBar">addToolBar</a></b>(Qt::ToolBarArea <i>area</i>, QToolBar *<i>toolbar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#addToolBar-1">addToolBar</a></b>(QToolBar *<i>toolbar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QToolBar *</td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#addToolBar-2">addToolBar</a></b>(const QString &amp;<i>title</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#addToolBarBreak">addToolBarBreak</a></b>(Qt::ToolBarArea <i>area</i> = Qt::TopToolBarArea)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#centralWidget">centralWidget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::DockWidgetArea </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#corner">corner</a></b>(Qt::Corner <i>corner</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QMenu *</td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#createPopupMenu">createPopupMenu</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMainWindow::DockOptions </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#dockOptions-prop">dockOptions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::DockWidgetArea </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#dockWidgetArea">dockWidgetArea</a></b>(QDockWidget *<i>dockwidget</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#documentMode-prop">documentMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#iconSize-prop">iconSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#insertToolBar">insertToolBar</a></b>(QToolBar *<i>before</i>, QToolBar *<i>toolbar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#insertToolBarBreak">insertToolBarBreak</a></b>(QToolBar *<i>before</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#animated-prop">isAnimated</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#dockNestingEnabled-prop">isDockNestingEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMenuBar *</td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#menuBar">menuBar</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#menuWidget">menuWidget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#removeDockWidget">removeDockWidget</a></b>(QDockWidget *<i>dockwidget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#removeToolBar">removeToolBar</a></b>(QToolBar *<i>toolbar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#removeToolBarBreak">removeToolBarBreak</a></b>(QToolBar *<i>before</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#resizeDocks">resizeDocks</a></b>(const QList&lt;QDockWidget *&gt; &amp;<i>docks</i>, const QList&lt;int&gt; &amp;<i>sizes</i>, Qt::Orientation <i>orientation</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#restoreDockWidget">restoreDockWidget</a></b>(QDockWidget *<i>dockwidget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#restoreState">restoreState</a></b>(const QByteArray &amp;<i>state</i>, int <i>version</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#saveState">saveState</a></b>(int <i>version</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#setCentralWidget">setCentralWidget</a></b>(QWidget *<i>widget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#setCorner">setCorner</a></b>(Qt::Corner <i>corner</i>, Qt::DockWidgetArea <i>area</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#dockOptions-prop">setDockOptions</a></b>(QMainWindow::DockOptions <i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#documentMode-prop">setDocumentMode</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#iconSize-prop">setIconSize</a></b>(const QSize &amp;<i>iconSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#setMenuBar">setMenuBar</a></b>(QMenuBar *<i>menuBar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#setMenuWidget">setMenuWidget</a></b>(QWidget *<i>menuBar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#setStatusBar">setStatusBar</a></b>(QStatusBar *<i>statusbar</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#setTabPosition">setTabPosition</a></b>(Qt::DockWidgetAreas <i>areas</i>, QTabWidget::TabPosition <i>tabPosition</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#tabShape-prop">setTabShape</a></b>(QTabWidget::TabShape <i>tabShape</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#toolButtonStyle-prop">setToolButtonStyle</a></b>(Qt::ToolButtonStyle <i>toolButtonStyle</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#splitDockWidget">splitDockWidget</a></b>(QDockWidget *<i>first</i>, QDockWidget *<i>second</i>, Qt::Orientation <i>orientation</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStatusBar *</td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#statusBar">statusBar</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTabWidget::TabPosition </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#tabPosition">tabPosition</a></b>(Qt::DockWidgetArea <i>area</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTabWidget::TabShape </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#tabShape-prop">tabShape</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QDockWidget *&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#tabifiedDockWidgets">tabifiedDockWidgets</a></b>(QDockWidget *<i>dockwidget</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#tabifyDockWidget">tabifyDockWidget</a></b>(QDockWidget *<i>first</i>, QDockWidget *<i>second</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#takeCentralWidget">takeCentralWidget</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::ToolBarArea </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#toolBarArea">toolBarArea</a></b>(QToolBar *<i>toolbar</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#toolBarBreak">toolBarBreak</a></b>(QToolBar *<i>toolbar</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::ToolButtonStyle </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#toolButtonStyle-prop">toolButtonStyle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#unifiedTitleAndToolBarOnMac-prop">unifiedTitleAndToolBarOnMac</a></b>() const</td></tr>
</table></div>
<ul>
<li class="fn">214 个公共函数继承于 <a href="qwidget.html#public-functions">QWidget</a></li>
<li class="fn">31 个公共函数继承于 <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
<li class="fn">14 个公共函数继承于 <a href="../qtgui/qpaintdevice.html#public-functions">QPaintDevice</a></li>
</ul>
<a name="public-slots"></a>
<h2 id="public-slots">公共槽函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#animated-prop">setAnimated</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#dockNestingEnabled-prop">setDockNestingEnabled</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#unifiedTitleAndToolBarOnMac-prop">setUnifiedTitleAndToolBarOnMac</a></b>(bool <i>set</i>)</td></tr>
</table></div>
<ul>
<li class="fn">19 个公共槽函数继承于 <a href="qwidget.html#public-slots">QWidget</a></li>
<li class="fn">1 个公共槽函数继承于 <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#iconSizeChanged">iconSizeChanged</a></b>(const QSize &amp;<i>iconSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#tabifiedDockWidgetActivated">tabifiedDockWidgetActivated</a></b>(QDockWidget *<i>dockWidget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#toolButtonStyleChanged">toolButtonStyleChanged</a></b>(Qt::ToolButtonStyle <i>toolButtonStyle</i>)</td></tr>
</table></div>
<ul>
<li class="fn">3 个信号继承于 <a href="qwidget.html#signals">QWidget</a></li>
<li class="fn">2 个信号继承于 <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">6 个静态公共成员继承于 <a href="qwidget.html#static-public-members">QWidget</a></li>
<li class="fn">9 个静态公共成员继承于 <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">重新实现的保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#contextMenuEvent">contextMenuEvent</a></b>(QContextMenuEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmainwindow.html#event">event</a></b>(QEvent *<i>event</i>) override</td></tr>
</table></div>
<ul>
<li class="fn">35 个保护函数继承于 <a href="qwidget.html#protected-functions">QWidget</a></li>
<li class="fn">9 个保护函数继承于 <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 个保护函数继承于 <a href="../qtgui/qpaintdevice.html#protected-functions">QPaintDevice</a></li>
</ul>
<h3>其他继承而来的成员</h3>
<ul>
<li class="fn">1 个公共变量继承于 <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">35 个保护函数继承于 <a href="qwidget.html#protected-functions">QWidget</a></li>
<li class="fn">9 个保护函数继承于 <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 个保护函数继承于 <a href="../qtgui/qpaintdevice.html#protected-functions">QPaintDevice</a></li>
<li class="fn">1 个保护槽函数继承于 <a href="qwidget.html#protected-slots">QWidget</a></li>
<li class="fn">2 个保护变量继承于 <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
<li class="fn">1 个保护类型继承于 <a href="../qtgui/qpaintdevice.html#protected-variables">QPaintDevice</a></li>
</ul>
<a name="details"></a>
<!-- $$$QMainWindow-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qmainwindow.html">QMainWindow</a> class provides a main application window.</p>
<a name="qt-main-window-framework"></a>
<h3 >Qt Main Window Framework</h3>
<p>A main window provides a framework for building an application's user interface. Qt has <a href="qmainwindow.html">QMainWindow</a> and its <a href="widget-classes.html#main-window-and-related-classes">related classes</a> for main window management. <a href="qmainwindow.html">QMainWindow</a> has its own layout to which you can add <a href="qtoolbar.html">QToolBar</a>s, <a href="qdockwidget.html">QDockWidget</a>s, a <a href="qmenubar.html">QMenuBar</a>, and a <a href="qstatusbar.html">QStatusBar</a>. The layout has a center area that can be occupied by any kind of widget. You can see an image of the layout below.</p>
<p class="centerAlign"><img src="images/mainwindowlayout.png" alt="" /></p><p><b>注意： </b>Creating a main window without a central widget is not supported. You must have a central widget even if it is just a placeholder.</p><a name="creating-main-window-components"></a>
<h3 >Creating Main Window Components</h3>
<p>A central widget will typically be a standard Qt widget such as a <a href="qtextedit.html">QTextEdit</a> or a <a href="qgraphicsview.html">QGraphicsView</a>. Custom widgets can also be used for advanced applications. You set the central widget with <code>setCentralWidget()</code>.</p>
<p>Main windows have either a single (SDI) or multiple (MDI) document interface. You create MDI applications in Qt by using a <a href="qmdiarea.html">QMdiArea</a> as the central widget.</p>
<p>We will now examine each of the other widgets that can be added to a main window. We give examples on how to create and add them.</p>
<a name="creating-menus"></a>
<h4 >Creating Menus</h4>
<p>Qt implements menus in <a href="qmenu.html">QMenu</a> 和 <a href="qmainwindow.html">QMainWindow</a> keeps them in a <a href="qmenubar.html">QMenuBar</a>. <a href="qaction.html">QAction</a>s are added to the menus, which display them as menu items.</p>
<p>You can add new menus to the main window's menu bar by calling <code>menuBar()</code>, which returns the <a href="qmenubar.html">QMenuBar</a> for the window, and then add a menu with <a href="qmenubar.html#addMenu">QMenuBar::addMenu</a>().</p>
<p><a href="qmainwindow.html">QMainWindow</a> comes with a default menu bar, but you can also set one yourself with <code>setMenuBar()</code>. If you wish to implement a custom menu bar (i.e&#x2e;, not use the <a href="qmenubar.html">QMenuBar</a> widget), you can set it with <code>setMenuWidget()</code>.</p>
<p>An example of how to create menus follows:</p>
<pre class="cpp">

      <span class="type">void</span> MainWindow<span class="operator">::</span>createMenus()
      {
          fileMenu <span class="operator">=</span> menuBar()<span class="operator">-</span><span class="operator">&gt;</span>addMenu(tr(<span class="string">&quot;&amp;File&quot;</span>));
          fileMenu<span class="operator">-</span><span class="operator">&gt;</span>addAction(newAct);
          fileMenu<span class="operator">-</span><span class="operator">&gt;</span>addAction(openAct);
          fileMenu<span class="operator">-</span><span class="operator">&gt;</span>addAction(saveAct);

</pre>
<p>The <code>createPopupMenu()</code> function creates popup menus when the main window receives context menu events. The default implementation generates a menu with the checkable actions from the dock widgets and toolbars. You can reimplement <code>createPopupMenu()</code> for a custom menu.</p>
<a name="creating-toolbars"></a>
<h4 >Creating Toolbars</h4>
<p>Toolbars are implemented in the <a href="qtoolbar.html">QToolBar</a> class. You add a toolbar to a main window with <code>addToolBar()</code>.</p>
<p>You control the initial position of toolbars by assigning them to a specific <a href="../qtcore/qt.html#ToolBarArea-enum">Qt::ToolBarArea</a>. You can split an area by inserting a toolbar break - think of this as a line break in text editing - with <code>addToolBarBreak()</code> or <code>insertToolBarBreak()</code>. You can also restrict placement by the user with <a href="qtoolbar.html#allowedAreas-prop">QToolBar::setAllowedAreas</a>() 和 <a href="qtoolbar.html#movable-prop">QToolBar::setMovable</a>().</p>
<p>The size of toolbar icons can be retrieved with <code>iconSize()</code>. The sizes are platform dependent; you can set a fixed size with <code>setIconSize()</code>. You can alter the appearance of all tool buttons in the toolbars with <code>setToolButtonStyle()</code>.</p>
<p>An example of toolbar creation follows:</p>
<pre class="cpp">

      <span class="type">void</span> MainWindow<span class="operator">::</span>createToolBars()
      {
          fileToolBar <span class="operator">=</span> addToolBar(tr(<span class="string">&quot;File&quot;</span>));
          fileToolBar<span class="operator">-</span><span class="operator">&gt;</span>addAction(newAct);

</pre>
<a name="creating-dock-widgets"></a>
<h4 >Creating Dock Widgets</h4>
<p>Dock widgets are implemented in the <a href="qdockwidget.html">QDockWidget</a> class. A dock widget is a window that can be docked into the main window. You add dock widgets to a main window with <code>addDockWidget()</code>.</p>
<p>There are four dock widget areas as given by the <a href="../qtcore/qt.html#DockWidgetArea-enum">Qt::DockWidgetArea</a> enum: left, right, top, and bottom. You can specify which dock widget area that should occupy the corners where the areas overlap with <code>setCorner()</code>. By default each area can only contain one row (vertical or horizontal) of dock widgets, but if you enable nesting with <code>setDockNestingEnabled()</code>, dock widgets can be added in either direction.</p>
<p>Two dock widgets may also be stacked on top of each other. A <a href="qtabbar.html">QTabBar</a> is then used to select which of the widgets should be displayed.</p>
<p>We give an example of how to create and add dock widgets to a main window:</p>
<pre class="cpp">

      <span class="type"><a href="qdockwidget.html">QDockWidget</a></span> <span class="operator">*</span>dockWidget <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qdockwidget.html">QDockWidget</a></span>(tr(<span class="string">&quot;Dock Widget&quot;</span>)<span class="operator">,</span> <span class="keyword">this</span>);
      dockWidget<span class="operator">-</span><span class="operator">&gt;</span>setAllowedAreas(<span class="type">Qt</span><span class="operator">::</span>LeftDockWidgetArea <span class="operator">|</span>
                                  <span class="type">Qt</span><span class="operator">::</span>RightDockWidgetArea);
      dockWidget<span class="operator">-</span><span class="operator">&gt;</span>setWidget(dockWidgetContents);
      addDockWidget(<span class="type">Qt</span><span class="operator">::</span>LeftDockWidgetArea<span class="operator">,</span> dockWidget);

</pre>
<a name="the-status-bar"></a>
<h4 >The Status Bar</h4>
<p>You can set a status bar with <code>setStatusBar()</code>, but one is created the first time <code>statusBar()</code> (which returns the main window's status bar) is called. See <a href="qstatusbar.html">QStatusBar</a> for information on how to use it.</p>
<a name="storing-state"></a>
<h3 >Storing State</h3>
<p><a href="qmainwindow.html">QMainWindow</a> can store the state of its layout with <code>saveState()</code>; it can later be retrieved with <code>restoreState()</code>. It is the position and size (relative to the size of the main window) of the toolbars and dock widgets that are stored.</p>
</div>
<p><b> 参见 </b><a href="qmenubar.html">QMenuBar</a>, <a href="qtoolbar.html">QToolBar</a>, <a href="qstatusbar.html">QStatusBar</a>, <a href="qdockwidget.html">QDockWidget</a>, <a href="qtwidgets-mainwindows-application-example.html">Application Example</a>, <a href="qtwidgets-mainwindows-dockwidgets-example.html">Dock Widgets Example</a>, <a href="qtwidgets-mainwindows-mdi-example.html">MDI Example</a>, <a href="qtwidgets-mainwindows-sdi-example.html">SDI Example</a>, 和 <a href="qtwidgets-mainwindows-menus-example.html">Menus Example</a>.</p>
<!-- @@@QMainWindow -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$DockOption$$$AnimatedDocks$$$AllowNestedDocks$$$AllowTabbedDocks$$$ForceTabbedDocks$$$VerticalTabs$$$GroupedDragging -->
<h3 class="flags" id="DockOption-enum"><a name="DockOption-enum"></a>enum QMainWindow::<span class="name">DockOption</span><br/>flags QMainWindow::<span class="name">DockOptions</span></h3>
<p>This enum contains flags that specify the docking behavior of <a href="qmainwindow.html">QMainWindow</a>.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QMainWindow::AnimatedDocks</code></td><td class="topAlign tblval"><code>0x01</code></td><td class="topAlign">Identical to the <a href="qmainwindow.html#animated-prop">animated</a> property.</td></tr>
<tr><td class="topAlign"><code>QMainWindow::AllowNestedDocks</code></td><td class="topAlign tblval"><code>0x02</code></td><td class="topAlign">Identical to the <a href="qmainwindow.html#dockNestingEnabled-prop">dockNestingEnabled</a> property.</td></tr>
<tr><td class="topAlign"><code>QMainWindow::AllowTabbedDocks</code></td><td class="topAlign tblval"><code>0x04</code></td><td class="topAlign">The user can drop one dock widget &quot;on top&quot; of another. The two widgets are stacked and a tab bar appears for selecting which one is visible.</td></tr>
<tr><td class="topAlign"><code>QMainWindow::ForceTabbedDocks</code></td><td class="topAlign tblval"><code>0x08</code></td><td class="topAlign">Each dock area contains a single stack of tabbed dock widgets. In other words, dock widgets cannot be placed next to each other in a dock area. If this option is set, AllowNestedDocks has no effect.</td></tr>
<tr><td class="topAlign"><code>QMainWindow::VerticalTabs</code></td><td class="topAlign tblval"><code>0x10</code></td><td class="topAlign">The two vertical dock areas on the sides of the main window show their tabs vertically. If this option is not set, all dock areas show their tabs at the bottom. Implies AllowTabbedDocks. See also <a href="qmainwindow.html#setTabPosition">setTabPosition</a>().</td></tr>
<tr><td class="topAlign"><code>QMainWindow::GroupedDragging</code></td><td class="topAlign tblval"><code>0x20</code></td><td class="topAlign">When dragging the titlebar of a dock, all the tabs that are tabbed with it are going to be dragged. Implies AllowTabbedDocks. Does not work well if some QDockWidgets have restrictions in which area they are allowed. (This enum value was added in Qt 5.6&#x2e;)</td></tr>
</table></div>
<p>These options only control how dock widgets may be dropped in a <a href="qmainwindow.html">QMainWindow</a>. They do not re-arrange the dock widgets to conform with the specified options. For this reason they should be set before any dock widgets are added to the main window. Exceptions to this are the AnimatedDocks and VerticalTabs options, which may be set at any time.</p>
<p>这个枚举类型是在Qt 4.3版本中引入或修改的。</p>
<p>The DockOptions type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;DockOption&gt;. It stores an OR combination of DockOption values.</p>
<!-- @@@DockOption -->
</div>
<div class="prop">
<h2>属性文档</h2>
<!-- $$$animated-prop$$$isAnimated$$$setAnimatedbool -->
<h3 class="fn" id="animated-prop"><a name="animated-prop"></a><span class="name">animated</span> : <span class="type">bool</span></h3>
<p>This property holds whether manipulating dock widgets and tool bars is animated</p>
<p>When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes <a href="qmainwindow.html">QMainWindow</a> to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions.</p>
<p>By default, this property is set. It may be cleared if the main window contains widgets which are slow at resizing or repainting themselves.</p>
<p>Setting this property is identical to setting the <a href="qmainwindow.html#DockOption-enum">AnimatedDocks</a> option using <a href="qmainwindow.html#dockOptions-prop">setDockOptions</a>().</p>
<p>这个属性是在Qt 4.2版本中新增引入的。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isAnimated</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAnimated</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<!-- @@@animated -->
<!-- $$$dockNestingEnabled-prop$$$isDockNestingEnabled$$$setDockNestingEnabledbool -->
<h3 class="fn" id="dockNestingEnabled-prop"><a name="dockNestingEnabled-prop"></a><span class="name">dockNestingEnabled</span> : <span class="type">bool</span></h3>
<p>This property holds whether docks can be nested</p>
<p>If this property is <code>false</code>, dock areas can only contain a single row (horizontal or vertical) of dock widgets. If this property is <code>true</code>, the area occupied by a dock widget can be split in either direction to contain more dock widgets.</p>
<p>Dock nesting is only necessary in applications that contain a lot of dock widgets. It gives the user greater freedom in organizing their main window. However, dock nesting leads to more complex (and less intuitive) behavior when a dock widget is dragged over the main window, since there are more ways in which a dropped dock widget may be placed in the dock area.</p>
<p>Setting this property is identical to setting the <a href="qmainwindow.html#DockOption-enum">AllowNestedDocks</a> option using <a href="qmainwindow.html#dockOptions-prop">setDockOptions</a>().</p>
<p>这个属性是在Qt 4.2版本中新增引入的。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isDockNestingEnabled</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setDockNestingEnabled</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<!-- @@@dockNestingEnabled -->
<!-- $$$dockOptions-prop$$$dockOptions$$$setDockOptionsQMainWindow::DockOptions -->
<h3 class="fn" id="dockOptions-prop"><a name="dockOptions-prop"></a><span class="name">dockOptions</span> : <span class="type"><a href="qmainwindow.html#DockOption-enum">DockOptions</a></span></h3>
<p>This property holds the docking behavior of <a href="qmainwindow.html">QMainWindow</a></p>
<p>默认值为 <a href="qmainwindow.html#DockOption-enum">AnimatedDocks</a> | <a href="qmainwindow.html#DockOption-enum">AllowTabbedDocks</a>.</p>
<p>这个属性是在Qt 4.3版本中新增引入的。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QMainWindow::DockOptions </td><td class="memItemRight bottomAlign"><span class="name"><b>dockOptions</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setDockOptions</b></span>(QMainWindow::DockOptions <i>options</i>)</td></tr>
</table></div>
<!-- @@@dockOptions -->
<!-- $$$documentMode-prop$$$documentMode$$$setDocumentModebool -->
<h3 class="fn" id="documentMode-prop"><a name="documentMode-prop"></a><span class="name">documentMode</span> : <span class="type">bool</span></h3>
<p>This property holds whether the tab bar for tabbed dockwidgets is set to document mode.</p>
<p>The default is false.</p>
<p>这个属性是在Qt 4.5版本中新增引入的。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>documentMode</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setDocumentMode</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<p><b> 参见 </b><a href="qtabbar.html#documentMode-prop">QTabBar::documentMode</a>.</p>
<!-- @@@documentMode -->
<!-- $$$iconSize-prop$$$iconSize$$$setIconSizeconstQSize& -->
<h3 class="fn" id="iconSize-prop"><a name="iconSize-prop"></a><span class="name">iconSize</span> : <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p>size of toolbar icons in this mainwindow.</p>
<p>The default is the default tool bar icon size of the GUI style. Note that the icons used must be at least of this size as the icons are only scaled down.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>iconSize</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setIconSize</b></span>(const QSize &amp;<i>iconSize</i>)</td></tr>
</table></div>
<!-- @@@iconSize -->
<!-- $$$tabShape-prop$$$tabShape$$$setTabShapeQTabWidget::TabShape -->
<h3 class="fn" id="tabShape-prop"><a name="tabShape-prop"></a><span class="name">tabShape</span> : <span class="type"><a href="qtabwidget.html#TabShape-enum">QTabWidget::TabShape</a></span></h3>
<p>This property holds the tab shape used for tabbed dock widgets.</p>
<p>默认值为 <a href="qtabwidget.html#TabShape-enum">QTabWidget::Rounded</a>.</p>
<p>这个属性是在Qt 4.5版本中新增引入的。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QTabWidget::TabShape </td><td class="memItemRight bottomAlign"><span class="name"><b>tabShape</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTabShape</b></span>(QTabWidget::TabShape <i>tabShape</i>)</td></tr>
</table></div>
<p><b> 参见 </b><a href="qmainwindow.html#setTabPosition">setTabPosition</a>().</p>
<!-- @@@tabShape -->
<!-- $$$toolButtonStyle-prop$$$toolButtonStyle$$$setToolButtonStyleQt::ToolButtonStyle -->
<h3 class="fn" id="toolButtonStyle-prop"><a name="toolButtonStyle-prop"></a><span class="name">toolButtonStyle</span> : <span class="type">Qt::ToolButtonStyle</span></h3>
<p>style of toolbar buttons in this mainwindow.</p>
<p>To have the style of toolbuttons follow the system settings, set this property to <a href="../qtcore/qt.html#ToolButtonStyle-enum">Qt::ToolButtonFollowStyle</a>. On Unix, the user settings from the desktop environment will be used. On other platforms, <a href="../qtcore/qt.html#ToolButtonStyle-enum">Qt::ToolButtonFollowStyle</a> means icon only.</p>
<p>默认值为 <a href="../qtcore/qt.html#ToolButtonStyle-enum">Qt::ToolButtonIconOnly</a>.</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::ToolButtonStyle </td><td class="memItemRight bottomAlign"><span class="name"><b>toolButtonStyle</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setToolButtonStyle</b></span>(Qt::ToolButtonStyle <i>toolButtonStyle</i>)</td></tr>
</table></div>
<!-- @@@toolButtonStyle -->
<!-- $$$unifiedTitleAndToolBarOnMac-prop$$$unifiedTitleAndToolBarOnMac$$$setUnifiedTitleAndToolBarOnMacbool -->
<h3 class="fn" id="unifiedTitleAndToolBarOnMac-prop"><a name="unifiedTitleAndToolBarOnMac-prop"></a><span class="name">unifiedTitleAndToolBarOnMac</span> : <span class="type">bool</span></h3>
<p>This property holds whether the window uses the unified title and toolbar look on <a href="../qtdoc/internationalization.html#macos">macOS</a></p>
<p>Note that the Qt 5 implementation has several limitations compared to Qt 4:</p>
<ul>
<li>Use in windows with OpenGL content is not supported. This includes QGLWidget and <a href="qopenglwidget.html">QOpenGLWidget</a>.</li>
<li>Using dockable or movable toolbars may result in painting errors and is not recommended</li>
</ul>
<p>这个属性是在Qt 5.2版本中新增引入的。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>unifiedTitleAndToolBarOnMac</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setUnifiedTitleAndToolBarOnMac</b></span>(bool <i>set</i>)</td></tr>
</table></div>
<!-- @@@unifiedTitleAndToolBarOnMac -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QMainWindow[overload1]$$$QMainWindowQWidget*Qt::WindowFlags -->
<h3 class="fn" id="QMainWindow"><a name="QMainWindow"></a>QMainWindow::<span class="name">QMainWindow</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i> = nullptr, <span class="type">Qt::WindowFlags</span> <i>flags</i> = ...)</h3>
<p>Constructs a <a href="qmainwindow.html">QMainWindow</a> with the given <i>parent</i> and the specified widget <i>flags</i>.</p>
<p><a href="qmainwindow.html">QMainWindow</a> sets the <a href="../qtcore/qt.html#WindowType-enum">Qt::Window</a> flag itself, and will hence always be created as a top-level widget.</p>
<!-- @@@QMainWindow -->
<!-- $$$~QMainWindow[overload1]$$$~QMainWindow -->
<h3 class="fn" id="dtor.QMainWindow"><a name="dtor.QMainWindow"></a><code>[虚函数] </code>QMainWindow::<span class="name">~QMainWindow</span>()</h3>
<p>Destroys the main window.</p>
<!-- @@@~QMainWindow -->
<!-- $$$addDockWidget[overload1]$$$addDockWidgetQt::DockWidgetAreaQDockWidget* -->
<h3 class="fn" id="addDockWidget"><a name="addDockWidget"></a><span class="type">void</span> QMainWindow::<span class="name">addDockWidget</span>(<span class="type">Qt::DockWidgetArea</span> <i>area</i>, <span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>dockwidget</i>)</h3>
<p>Adds the given <i>dockwidget</i> to the specified <i>area</i>.</p>
<!-- @@@addDockWidget -->
<!-- $$$addDockWidget$$$addDockWidgetQt::DockWidgetAreaQDockWidget*Qt::Orientation -->
<h3 class="fn" id="addDockWidget-1"><a name="addDockWidget-1"></a><span class="type">void</span> QMainWindow::<span class="name">addDockWidget</span>(<span class="type">Qt::DockWidgetArea</span> <i>area</i>, <span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>dockwidget</i>, <span class="type">Qt::Orientation</span> <i>orientation</i>)</h3>
<p>Adds <i>dockwidget</i> into the given <i>area</i> in the direction specified by the <i>orientation</i>.</p>
<!-- @@@addDockWidget -->
<!-- $$$addToolBar[overload1]$$$addToolBarQt::ToolBarAreaQToolBar* -->
<h3 class="fn" id="addToolBar"><a name="addToolBar"></a><span class="type">void</span> QMainWindow::<span class="name">addToolBar</span>(<span class="type">Qt::ToolBarArea</span> <i>area</i>, <span class="type"><a href="qtoolbar.html">QToolBar</a></span> *<i>toolbar</i>)</h3>
<p>Adds the <i>toolbar</i> into the specified <i>area</i> in this main window. The <i>toolbar</i> is placed at the end of the current tool bar block (i.e&#x2e; line). If the main window already manages <i>toolbar</i> then it will only move the toolbar to <i>area</i>.</p>
<p><b> 参见 </b><a href="qmainwindow.html#insertToolBar">insertToolBar</a>(), <a href="qmainwindow.html#addToolBarBreak">addToolBarBreak</a>(), 和 <a href="qmainwindow.html#insertToolBarBreak">insertToolBarBreak</a>().</p>
<!-- @@@addToolBar -->
<!-- $$$addToolBar$$$addToolBarQToolBar* -->
<h3 class="fn" id="addToolBar-1"><a name="addToolBar-1"></a><span class="type">void</span> QMainWindow::<span class="name">addToolBar</span>(<span class="type"><a href="qtoolbar.html">QToolBar</a></span> *<i>toolbar</i>)</h3>
<p>这是一个重载函数。</p>
<p>Equivalent of calling <a href="qmainwindow.html#addToolBar">addToolBar</a>(<a href="../qtcore/qt.html#ToolBarArea-enum">Qt::TopToolBarArea</a>, <i>toolbar</i>)</p>
<!-- @@@addToolBar -->
<!-- $$$addToolBar$$$addToolBarconstQString& -->
<h3 class="fn" id="addToolBar-2"><a name="addToolBar-2"></a><span class="type"><a href="qtoolbar.html">QToolBar</a></span> *QMainWindow::<span class="name">addToolBar</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>title</i>)</h3>
<p>这是一个重载函数。</p>
<p>Creates a <a href="qtoolbar.html">QToolBar</a> object, setting its window title to <i>title</i>, and inserts it into the top toolbar area.</p>
<p><b> 参见 </b><a href="qwidget.html#windowTitle-prop">setWindowTitle</a>().</p>
<!-- @@@addToolBar -->
<!-- $$$addToolBarBreak[overload1]$$$addToolBarBreakQt::ToolBarArea -->
<h3 class="fn" id="addToolBarBreak"><a name="addToolBarBreak"></a><span class="type">void</span> QMainWindow::<span class="name">addToolBarBreak</span>(<span class="type">Qt::ToolBarArea</span> <i>area</i> = Qt::TopToolBarArea)</h3>
<p>Adds a toolbar break to the given <i>area</i> after all the other objects that are present.</p>
<!-- @@@addToolBarBreak -->
<!-- $$$centralWidget[overload1]$$$centralWidget -->
<h3 class="fn" id="centralWidget"><a name="centralWidget"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QMainWindow::<span class="name">centralWidget</span>() const</h3>
<p>Returns the central widget for the main window. This function returns zero if the central widget has not been set.</p>
<p><b> 参见 </b><a href="qmainwindow.html#setCentralWidget">setCentralWidget</a>().</p>
<!-- @@@centralWidget -->
<!-- $$$contextMenuEvent[overload1]$$$contextMenuEventQContextMenuEvent* -->
<h3 class="fn" id="contextMenuEvent"><a name="contextMenuEvent"></a><code>[重载虚保护函数] </code><span class="type">void</span> QMainWindow::<span class="name">contextMenuEvent</span>(<span class="type"><a href="../qtgui/qcontextmenuevent.html">QContextMenuEvent</a></span> *<i>event</i>)</h3>
<p>重新实现了父类函数接口 <a href="qwidget.html#contextMenuEvent">QWidget::contextMenuEvent</a>().</p>
<!-- @@@contextMenuEvent -->
<!-- $$$corner[overload1]$$$cornerQt::Corner -->
<h3 class="fn" id="corner"><a name="corner"></a><span class="type">Qt::DockWidgetArea</span> QMainWindow::<span class="name">corner</span>(<span class="type">Qt::Corner</span> <i>corner</i>) const</h3>
<p>Returns the dock widget area that occupies the specified <i>corner</i>.</p>
<p><b> 参见 </b><a href="qmainwindow.html#setCorner">setCorner</a>().</p>
<!-- @@@corner -->
<!-- $$$createPopupMenu[overload1]$$$createPopupMenu -->
<h3 class="fn" id="createPopupMenu"><a name="createPopupMenu"></a><code>[虚函数] </code><span class="type"><a href="qmenu.html">QMenu</a></span> *QMainWindow::<span class="name">createPopupMenu</span>()</h3>
<p>Returns a popup menu containing checkable entries for the toolbars and dock widgets present in the main window. If there are no toolbars and dock widgets present, this function returns a null pointer.</p>
<p>By default, this function is called by the main window when the user activates a context menu, typically by right-clicking on a toolbar or a dock widget.</p>
<p>If you want to create a custom popup menu, reimplement this function and return a newly-created popup menu. Ownership of the popup menu is transferred to the caller.</p>
<p><b> 参见 </b><a href="qmainwindow.html#addDockWidget">addDockWidget</a>(), <a href="qmainwindow.html#addToolBar">addToolBar</a>(), 和 <a href="qmainwindow.html#menuBar">menuBar</a>().</p>
<!-- @@@createPopupMenu -->
<!-- $$$dockWidgetArea[overload1]$$$dockWidgetAreaQDockWidget* -->
<h3 class="fn" id="dockWidgetArea"><a name="dockWidgetArea"></a><span class="type">Qt::DockWidgetArea</span> QMainWindow::<span class="name">dockWidgetArea</span>(<span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>dockwidget</i>) const</h3>
<p>Returns the <a href="../qtcore/qt.html#DockWidgetArea-enum">Qt::DockWidgetArea</a> for <i>dockwidget</i>. If <i>dockwidget</i> has not been added to the main window, this function returns <code>Qt::NoDockWidgetArea</code>.</p>
<p><b> 参见 </b><a href="qmainwindow.html#addDockWidget">addDockWidget</a>(), <a href="qmainwindow.html#splitDockWidget">splitDockWidget</a>(), 和 <a href="../qtcore/qt.html#DockWidgetArea-enum">Qt::DockWidgetArea</a>.</p>
<!-- @@@dockWidgetArea -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event"><a name="event"></a><code>[重载虚保护函数] </code><span class="type">bool</span> QMainWindow::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>event</i>)</h3>
<p>重新实现了父类函数接口 <a href="qwidget.html#event">QWidget::event</a>().</p>
<!-- @@@event -->
<!-- $$$iconSizeChanged[overload1]$$$iconSizeChangedconstQSize& -->
<h3 class="fn" id="iconSizeChanged"><a name="iconSizeChanged"></a><code>[信号] </code><span class="type">void</span> QMainWindow::<span class="name">iconSizeChanged</span>(const <span class="type"><a href="../qtcore/qsize.html">QSize</a></span> &amp;<i>iconSize</i>)</h3>
<p>This signal is emitted when the size of the icons used in the window is changed. The new icon size is passed in <i>iconSize</i>.</p>
<p>You can connect this signal to other components to help maintain a consistent appearance for your application.</p>
<p><b> 参见 </b><a href="qmainwindow.html#iconSize-prop">setIconSize</a>().</p>
<!-- @@@iconSizeChanged -->
<!-- $$$insertToolBar[overload1]$$$insertToolBarQToolBar*QToolBar* -->
<h3 class="fn" id="insertToolBar"><a name="insertToolBar"></a><span class="type">void</span> QMainWindow::<span class="name">insertToolBar</span>(<span class="type"><a href="qtoolbar.html">QToolBar</a></span> *<i>before</i>, <span class="type"><a href="qtoolbar.html">QToolBar</a></span> *<i>toolbar</i>)</h3>
<p>Inserts the <i>toolbar</i> into the area occupied by the <i>before</i> toolbar so that it appears before it. For example, in normal left-to-right layout operation, this means that <i>toolbar</i> will appear to the left of the toolbar specified by <i>before</i> in a horizontal toolbar area.</p>
<p><b> 参见 </b><a href="qmainwindow.html#insertToolBarBreak">insertToolBarBreak</a>(), <a href="qmainwindow.html#addToolBar">addToolBar</a>(), 和 <a href="qmainwindow.html#addToolBarBreak">addToolBarBreak</a>().</p>
<!-- @@@insertToolBar -->
<!-- $$$insertToolBarBreak[overload1]$$$insertToolBarBreakQToolBar* -->
<h3 class="fn" id="insertToolBarBreak"><a name="insertToolBarBreak"></a><span class="type">void</span> QMainWindow::<span class="name">insertToolBarBreak</span>(<span class="type"><a href="qtoolbar.html">QToolBar</a></span> *<i>before</i>)</h3>
<p>Inserts a toolbar break before the toolbar specified by <i>before</i>.</p>
<!-- @@@insertToolBarBreak -->
<!-- $$$menuBar[overload1]$$$menuBar -->
<h3 class="fn" id="menuBar"><a name="menuBar"></a><span class="type"><a href="qmenubar.html">QMenuBar</a></span> *QMainWindow::<span class="name">menuBar</span>() const</h3>
<p>Returns the menu bar for the main window. This function creates and returns an empty menu bar if the menu bar does not exist.</p>
<p>If you want all windows in a Mac application to share one menu bar, don't use this function to create it, because the menu bar created here will have this <a href="qmainwindow.html">QMainWindow</a> as its parent. Instead, you must create a menu bar that does not have a parent, which you can then share among all the Mac windows. Create a parent-less menu bar this way:</p>
<pre class="cpp">

  <span class="type"><a href="qmenubar.html">QMenuBar</a></span> <span class="operator">*</span>menuBar <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qmenubar.html">QMenuBar</a></span>(<span class="number">0</span>);

</pre>
<p><b> 参见 </b><a href="qmainwindow.html#setMenuBar">setMenuBar</a>().</p>
<!-- @@@menuBar -->
<!-- $$$menuWidget[overload1]$$$menuWidget -->
<h3 class="fn" id="menuWidget"><a name="menuWidget"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QMainWindow::<span class="name">menuWidget</span>() const</h3>
<p>Returns the menu bar for the main window. This function returns null if a menu bar hasn't been constructed yet.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qmainwindow.html#setMenuWidget">setMenuWidget</a>().</p>
<!-- @@@menuWidget -->
<!-- $$$removeDockWidget[overload1]$$$removeDockWidgetQDockWidget* -->
<h3 class="fn" id="removeDockWidget"><a name="removeDockWidget"></a><span class="type">void</span> QMainWindow::<span class="name">removeDockWidget</span>(<span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>dockwidget</i>)</h3>
<p>Removes the <i>dockwidget</i> from the main window layout and hides it. Note that the <i>dockwidget</i> is <i>not</i> deleted.</p>
<!-- @@@removeDockWidget -->
<!-- $$$removeToolBar[overload1]$$$removeToolBarQToolBar* -->
<h3 class="fn" id="removeToolBar"><a name="removeToolBar"></a><span class="type">void</span> QMainWindow::<span class="name">removeToolBar</span>(<span class="type"><a href="qtoolbar.html">QToolBar</a></span> *<i>toolbar</i>)</h3>
<p>Removes the <i>toolbar</i> from the main window layout and hides it. Note that the <i>toolbar</i> is <i>not</i> deleted.</p>
<!-- @@@removeToolBar -->
<!-- $$$removeToolBarBreak[overload1]$$$removeToolBarBreakQToolBar* -->
<h3 class="fn" id="removeToolBarBreak"><a name="removeToolBarBreak"></a><span class="type">void</span> QMainWindow::<span class="name">removeToolBarBreak</span>(<span class="type"><a href="qtoolbar.html">QToolBar</a></span> *<i>before</i>)</h3>
<p>Removes a toolbar break previously inserted before the toolbar specified by <i>before</i>.</p>
<!-- @@@removeToolBarBreak -->
<!-- $$$resizeDocks[overload1]$$$resizeDocksconstQList<QDockWidget*>&constQList<int>&Qt::Orientation -->
<h3 class="fn" id="resizeDocks"><a name="resizeDocks"></a><span class="type">void</span> QMainWindow::<span class="name">resizeDocks</span>(const <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *&gt; &amp;<i>docks</i>, const <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type">int</span>&gt; &amp;<i>sizes</i>, <span class="type">Qt::Orientation</span> <i>orientation</i>)</h3>
<p>Resizes the dock widgets in the list <i>docks</i> to the corresponding size in pixels from the list <i>sizes</i>. If <i>orientation</i> is <a href="../qtcore/qt.html#Orientation-enum">Qt::Horizontal</a>, adjusts the width, otherwise adjusts the height of the dock widgets. The sizes will be adjusted such that the maximum and the minimum sizes are respected and the <a href="qmainwindow.html">QMainWindow</a> itself will not be resized. Any additional/missing space is distributed amongst the widgets according to the relative weight of the sizes.</p>
<p>样例：</p>
<pre class="cpp">

      resizeDocks({blueWidget<span class="operator">,</span> yellowWidget}<span class="operator">,</span> {<span class="number">20</span> <span class="operator">,</span> <span class="number">40</span>}<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>Horizontal);

</pre>
<p>If the blue and the yellow widget are nested on the same level they will be resized such that the yellowWidget is twice as big as the blueWidget</p>
<p>If some widgets are grouped in tabs, only one widget per group should be specified. Widgets not in the list might be changed to repect the constraints.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<!-- @@@resizeDocks -->
<!-- $$$restoreDockWidget[overload1]$$$restoreDockWidgetQDockWidget* -->
<h3 class="fn" id="restoreDockWidget"><a name="restoreDockWidget"></a><span class="type">bool</span> QMainWindow::<span class="name">restoreDockWidget</span>(<span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>dockwidget</i>)</h3>
<p>Restores the state of <i>dockwidget</i> if it is created after the call to <a href="qmainwindow.html#restoreState">restoreState</a>(). Returns <code>true</code> if the state was restored; 否则则返回 <code>false</code>。</p>
<p><b> 参见 </b><a href="qmainwindow.html#restoreState">restoreState</a>() 和 <a href="qmainwindow.html#saveState">saveState</a>().</p>
<!-- @@@restoreDockWidget -->
<!-- $$$restoreState[overload1]$$$restoreStateconstQByteArray&int -->
<h3 class="fn" id="restoreState"><a name="restoreState"></a><span class="type">bool</span> QMainWindow::<span class="name">restoreState</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>state</i>, <span class="type">int</span> <i>version</i> = 0)</h3>
<p>Restores the <i>state</i> of this mainwindow's toolbars and dockwidgets. Also restores the corner settings too. The <i>version</i> number is compared with that stored in <i>state</i>. If they do not match, the mainwindow's state is left unchanged, and this function returns <code>false</code>; otherwise, the state is restored, and this function returns <code>true</code>.</p>
<p>To restore geometry saved using <a href="../qtcore/qsettings.html">QSettings</a>, you can use code like this:</p>
<pre class="cpp">

  <span class="type">void</span> MainWindow<span class="operator">::</span>readSettings()
  {
      <span class="type"><a href="../qtcore/qsettings.html">QSettings</a></span> settings(<span class="string">&quot;MyCompany&quot;</span><span class="operator">,</span> <span class="string">&quot;MyApp&quot;</span>);
      restoreGeometry(settings<span class="operator">.</span>value(<span class="string">&quot;myWidget/geometry&quot;</span>)<span class="operator">.</span>toByteArray());
      restoreState(settings<span class="operator">.</span>value(<span class="string">&quot;myWidget/windowState&quot;</span>)<span class="operator">.</span>toByteArray());
  }

</pre>
<p><b> 参见 </b><a href="qmainwindow.html#saveState">saveState</a>(), <a href="qwidget.html#saveGeometry">QWidget::saveGeometry</a>(), <a href="qwidget.html#restoreGeometry">QWidget::restoreGeometry</a>(), 和 <a href="qmainwindow.html#restoreDockWidget">restoreDockWidget</a>().</p>
<!-- @@@restoreState -->
<!-- $$$saveState[overload1]$$$saveStateint -->
<h3 class="fn" id="saveState"><a name="saveState"></a><span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> QMainWindow::<span class="name">saveState</span>(<span class="type">int</span> <i>version</i> = 0) const</h3>
<p>Saves the current state of this mainwindow's toolbars and dockwidgets. This includes the corner settings which can be set with <a href="qmainwindow.html#setCorner">setCorner</a>(). The <i>version</i> number is stored as part of the data.</p>
<p>The <a href="../qtcore/qobject.html#objectName-prop">objectName</a> property is used to identify each <a href="qtoolbar.html">QToolBar</a> 和 <a href="qdockwidget.html">QDockWidget</a>. You should make sure that this property is unique for each <a href="qtoolbar.html">QToolBar</a> 和 <a href="qdockwidget.html">QDockWidget</a> you add to the <a href="qmainwindow.html">QMainWindow</a></p>
<p>To restore the saved state, pass the return value and <i>version</i> number to <a href="qmainwindow.html#restoreState">restoreState</a>().</p>
<p>To save the geometry when the window closes, you can implement a close event like this:</p>
<pre class="cpp">

  <span class="type">void</span> MyMainWindow<span class="operator">::</span>closeEvent(<span class="type"><a href="../qtgui/qcloseevent.html">QCloseEvent</a></span> <span class="operator">*</span>event)
  {
      <span class="type"><a href="../qtcore/qsettings.html">QSettings</a></span> settings(<span class="string">&quot;MyCompany&quot;</span><span class="operator">,</span> <span class="string">&quot;MyApp&quot;</span>);
      settings<span class="operator">.</span>setValue(<span class="string">&quot;geometry&quot;</span><span class="operator">,</span> saveGeometry());
      settings<span class="operator">.</span>setValue(<span class="string">&quot;windowState&quot;</span><span class="operator">,</span> saveState());
      <span class="type"><a href="qmainwindow.html#QMainWindow">QMainWindow</a></span><span class="operator">::</span>closeEvent(event);
  }

</pre>
<p><b> 参见 </b><a href="qmainwindow.html#restoreState">restoreState</a>(), <a href="qwidget.html#saveGeometry">QWidget::saveGeometry</a>(), 和 <a href="qwidget.html#restoreGeometry">QWidget::restoreGeometry</a>().</p>
<!-- @@@saveState -->
<!-- $$$setCentralWidget[overload1]$$$setCentralWidgetQWidget* -->
<h3 class="fn" id="setCentralWidget"><a name="setCentralWidget"></a><span class="type">void</span> QMainWindow::<span class="name">setCentralWidget</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>widget</i>)</h3>
<p>Sets the given <i>widget</i> to be the main window's central widget.</p>
<p>Note: <a href="qmainwindow.html">QMainWindow</a> takes ownership of the <i>widget</i> pointer and deletes it at the appropriate time.</p>
<p><b> 参见 </b><a href="qmainwindow.html#centralWidget">centralWidget</a>().</p>
<!-- @@@setCentralWidget -->
<!-- $$$setCorner[overload1]$$$setCornerQt::CornerQt::DockWidgetArea -->
<h3 class="fn" id="setCorner"><a name="setCorner"></a><span class="type">void</span> QMainWindow::<span class="name">setCorner</span>(<span class="type">Qt::Corner</span> <i>corner</i>, <span class="type">Qt::DockWidgetArea</span> <i>area</i>)</h3>
<p>Sets the given dock widget <i>area</i> to occupy the specified <i>corner</i>.</p>
<p><b> 参见 </b><a href="qmainwindow.html#corner">corner</a>().</p>
<!-- @@@setCorner -->
<!-- $$$setMenuBar[overload1]$$$setMenuBarQMenuBar* -->
<h3 class="fn" id="setMenuBar"><a name="setMenuBar"></a><span class="type">void</span> QMainWindow::<span class="name">setMenuBar</span>(<span class="type"><a href="qmenubar.html">QMenuBar</a></span> *<i>menuBar</i>)</h3>
<p>Sets the menu bar for the main window to <i>menuBar</i>.</p>
<p>Note: <a href="qmainwindow.html">QMainWindow</a> takes ownership of the <i>menuBar</i> pointer and deletes it at the appropriate time.</p>
<p><b> 参见 </b><a href="qmainwindow.html#menuBar">menuBar</a>().</p>
<!-- @@@setMenuBar -->
<!-- $$$setMenuWidget[overload1]$$$setMenuWidgetQWidget* -->
<h3 class="fn" id="setMenuWidget"><a name="setMenuWidget"></a><span class="type">void</span> QMainWindow::<span class="name">setMenuWidget</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>menuBar</i>)</h3>
<p>Sets the menu bar for the main window to <i>menuBar</i>.</p>
<p><a href="qmainwindow.html">QMainWindow</a> takes ownership of the <i>menuBar</i> pointer and deletes it at the appropriate time.</p>
<p>这个函数是在Qt 4.2版本中新增引入的。</p>
<p><b> 参见 </b><a href="qmainwindow.html#menuWidget">menuWidget</a>().</p>
<!-- @@@setMenuWidget -->
<!-- $$$setStatusBar[overload1]$$$setStatusBarQStatusBar* -->
<h3 class="fn" id="setStatusBar"><a name="setStatusBar"></a><span class="type">void</span> QMainWindow::<span class="name">setStatusBar</span>(<span class="type"><a href="qstatusbar.html">QStatusBar</a></span> *<i>statusbar</i>)</h3>
<p>Sets the status bar for the main window to <i>statusbar</i>.</p>
<p>Setting the status bar to 0 will remove it from the main window. Note that <a href="qmainwindow.html">QMainWindow</a> takes ownership of the <i>statusbar</i> pointer and deletes it at the appropriate time.</p>
<p><b> 参见 </b><a href="qmainwindow.html#statusBar">statusBar</a>().</p>
<!-- @@@setStatusBar -->
<!-- $$$setTabPosition[overload1]$$$setTabPositionQt::DockWidgetAreasQTabWidget::TabPosition -->
<h3 class="fn" id="setTabPosition"><a name="setTabPosition"></a><span class="type">void</span> QMainWindow::<span class="name">setTabPosition</span>(<span class="type">Qt::DockWidgetAreas</span> <i>areas</i>, <span class="type"><a href="qtabwidget.html#TabPosition-enum">QTabWidget::TabPosition</a></span> <i>tabPosition</i>)</h3>
<p>Sets the tab position for the given dock widget <i>areas</i> to the specified <i>tabPosition</i>. By default, all dock areas show their tabs at the bottom.</p>
<p><b>注意： </b>The <a href="qmainwindow.html#DockOption-enum">VerticalTabs</a> dock option overrides the tab positions set by this method.</p><p>这个函数是在Qt 4.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qmainwindow.html#tabPosition">tabPosition</a>() 和 <a href="qmainwindow.html#tabShape-prop">setTabShape</a>().</p>
<!-- @@@setTabPosition -->
<!-- $$$splitDockWidget[overload1]$$$splitDockWidgetQDockWidget*QDockWidget*Qt::Orientation -->
<h3 class="fn" id="splitDockWidget"><a name="splitDockWidget"></a><span class="type">void</span> QMainWindow::<span class="name">splitDockWidget</span>(<span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>first</i>, <span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>second</i>, <span class="type">Qt::Orientation</span> <i>orientation</i>)</h3>
<p>Splits the space covered by the <i>first</i> dock widget into two parts, moves the <i>first</i> dock widget into the first part, and moves the <i>second</i> dock widget into the second part.</p>
<p>The <i>orientation</i> specifies how the space is divided: A <a href="../qtcore/qt.html#Orientation-enum">Qt::Horizontal</a> split places the second dock widget to the right of the first; a <a href="../qtcore/qt.html#Orientation-enum">Qt::Vertical</a> split places the second dock widget below the first.</p>
<p><i>Note</i>: if <i>first</i> is currently in a tabbed docked area, <i>second</i> will be added as a new tab, not as a neighbor of <i>first</i>. This is because a single tab can contain only one dock widget.</p>
<p><i>Note</i>: The <a href="../qtcore/qt.html#LayoutDirection-enum">Qt::LayoutDirection</a> influences the order of the dock widgets in the two parts of the divided area. When right-to-left layout direction is enabled, the placing of the dock widgets will be reversed.</p>
<p><b> 参见 </b><a href="qmainwindow.html#tabifyDockWidget">tabifyDockWidget</a>(), <a href="qmainwindow.html#addDockWidget">addDockWidget</a>(), 和 <a href="qmainwindow.html#removeDockWidget">removeDockWidget</a>().</p>
<!-- @@@splitDockWidget -->
<!-- $$$statusBar[overload1]$$$statusBar -->
<h3 class="fn" id="statusBar"><a name="statusBar"></a><span class="type"><a href="qstatusbar.html">QStatusBar</a></span> *QMainWindow::<span class="name">statusBar</span>() const</h3>
<p>Returns the status bar for the main window. This function creates and returns an empty status bar if the status bar does not exist.</p>
<p><b> 参见 </b><a href="qmainwindow.html#setStatusBar">setStatusBar</a>().</p>
<!-- @@@statusBar -->
<!-- $$$tabPosition[overload1]$$$tabPositionQt::DockWidgetArea -->
<h3 class="fn" id="tabPosition"><a name="tabPosition"></a><span class="type"><a href="qtabwidget.html#TabPosition-enum">QTabWidget::TabPosition</a></span> QMainWindow::<span class="name">tabPosition</span>(<span class="type">Qt::DockWidgetArea</span> <i>area</i>) const</h3>
<p>Returns the tab position for <i>area</i>.</p>
<p><b>注意： </b>The <a href="qmainwindow.html#DockOption-enum">VerticalTabs</a> dock option overrides the tab positions returned by this function.</p><p>这个函数是在Qt 4.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qmainwindow.html#setTabPosition">setTabPosition</a>() 和 <a href="qmainwindow.html#tabShape-prop">tabShape</a>().</p>
<!-- @@@tabPosition -->
<!-- $$$tabifiedDockWidgetActivated[overload1]$$$tabifiedDockWidgetActivatedQDockWidget* -->
<h3 class="fn" id="tabifiedDockWidgetActivated"><a name="tabifiedDockWidgetActivated"></a><code>[信号] </code><span class="type">void</span> QMainWindow::<span class="name">tabifiedDockWidgetActivated</span>(<span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>dockWidget</i>)</h3>
<p>This signal is emitted when the tabified dock widget is activated by selecting the tab. The activated dock widget is passed in <i>dockWidget</i>.</p>
<p>这个函数是在Qt 5.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qmainwindow.html#tabifyDockWidget">tabifyDockWidget</a>() 和 <a href="qmainwindow.html#tabifiedDockWidgets">tabifiedDockWidgets</a>().</p>
<!-- @@@tabifiedDockWidgetActivated -->
<!-- $$$tabifiedDockWidgets[overload1]$$$tabifiedDockWidgetsQDockWidget* -->
<h3 class="fn" id="tabifiedDockWidgets"><a name="tabifiedDockWidgets"></a><span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *&gt; QMainWindow::<span class="name">tabifiedDockWidgets</span>(<span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>dockwidget</i>) const</h3>
<p>Returns the dock widgets that are tabified together with <i>dockwidget</i>.</p>
<p>这个函数是在Qt 4.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qmainwindow.html#tabifyDockWidget">tabifyDockWidget</a>().</p>
<!-- @@@tabifiedDockWidgets -->
<!-- $$$tabifyDockWidget[overload1]$$$tabifyDockWidgetQDockWidget*QDockWidget* -->
<h3 class="fn" id="tabifyDockWidget"><a name="tabifyDockWidget"></a><span class="type">void</span> QMainWindow::<span class="name">tabifyDockWidget</span>(<span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>first</i>, <span class="type"><a href="qdockwidget.html">QDockWidget</a></span> *<i>second</i>)</h3>
<p>Moves <i>second</i> dock widget on top of <i>first</i> dock widget, creating a tabbed docked area in the main window.</p>
<p><b> 参见 </b><a href="qmainwindow.html#tabifiedDockWidgets">tabifiedDockWidgets</a>().</p>
<!-- @@@tabifyDockWidget -->
<!-- $$$takeCentralWidget[overload1]$$$takeCentralWidget -->
<h3 class="fn" id="takeCentralWidget"><a name="takeCentralWidget"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QMainWindow::<span class="name">takeCentralWidget</span>()</h3>
<p>Removes the central widget from this main window.</p>
<p>The ownership of the removed widget is passed to the caller.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@takeCentralWidget -->
<!-- $$$toolBarArea[overload1]$$$toolBarAreaQToolBar* -->
<h3 class="fn" id="toolBarArea"><a name="toolBarArea"></a><span class="type">Qt::ToolBarArea</span> QMainWindow::<span class="name">toolBarArea</span>(<span class="type"><a href="qtoolbar.html">QToolBar</a></span> *<i>toolbar</i>) const</h3>
<p>Returns the <a href="../qtcore/qt.html#ToolBarArea-enum">Qt::ToolBarArea</a> for <i>toolbar</i>. If <i>toolbar</i> has not been added to the main window, this function returns <code>Qt::NoToolBarArea</code>.</p>
<p><b> 参见 </b><a href="qmainwindow.html#addToolBar">addToolBar</a>(), <a href="qmainwindow.html#addToolBarBreak">addToolBarBreak</a>(), 和 <a href="../qtcore/qt.html#ToolBarArea-enum">Qt::ToolBarArea</a>.</p>
<!-- @@@toolBarArea -->
<!-- $$$toolBarBreak[overload1]$$$toolBarBreakQToolBar* -->
<h3 class="fn" id="toolBarBreak"><a name="toolBarBreak"></a><span class="type">bool</span> QMainWindow::<span class="name">toolBarBreak</span>(<span class="type"><a href="qtoolbar.html">QToolBar</a></span> *<i>toolbar</i>) const</h3>
<p>Returns whether there is a toolbar break before the <i>toolbar</i>.</p>
<p><b> 参见 </b><a href="qmainwindow.html#addToolBarBreak">addToolBarBreak</a>() 和 <a href="qmainwindow.html#insertToolBarBreak">insertToolBarBreak</a>().</p>
<!-- @@@toolBarBreak -->
<!-- $$$toolButtonStyleChanged[overload1]$$$toolButtonStyleChangedQt::ToolButtonStyle -->
<h3 class="fn" id="toolButtonStyleChanged"><a name="toolButtonStyleChanged"></a><code>[信号] </code><span class="type">void</span> QMainWindow::<span class="name">toolButtonStyleChanged</span>(<span class="type">Qt::ToolButtonStyle</span> <i>toolButtonStyle</i>)</h3>
<p>This signal is emitted when the style used for tool buttons in the window is changed. The new style is passed in <i>toolButtonStyle</i>.</p>
<p>You can connect this signal to other components to help maintain a consistent appearance for your application.</p>
<p><b> 参见 </b><a href="qmainwindow.html#toolButtonStyle-prop">setToolButtonStyle</a>().</p>
<!-- @@@toolButtonStyleChanged -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
