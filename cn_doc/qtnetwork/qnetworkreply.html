<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qnetworkreply.cpp -->
  <title>QNetworkReply Class | Qt Network 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtnetwork-index.html">Qt网络</a></td><td ><a href="qtnetwork-module.html">C++类</a></td><td >QNetworkReply</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#reimplemented-public-functions">重新实现的公共函数</a></li>
<li class="level1"><a href="#public-slots">公共槽函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#protected-functions">保护函数</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QNetworkReply Class</h1>
<!-- $$$QNetworkReply-brief -->
<p>The <a href="qnetworkreply.html">QNetworkReply</a> class contains the data and headers for a request sent with <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>. <a href="#details">More...</a></p>
<!-- @@@QNetworkReply -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QNetworkReply&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += network</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 4.4</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qiodevice.html">QIODevice</a></td></tr></table></div><ul>
<li><a href="qnetworkreply-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qnetworkreply-obsolete.html">过时的成员</a></li>
</ul>
<p><b>注意：</b> 此类中的所有函数都是 <a href="../qtdoc/threads-reentrancy.html">可重入的。</a></p>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#NetworkError-enum">NetworkError</a></b> { NoError, ConnectionRefusedError, RemoteHostClosedError, HostNotFoundError, ..., UnknownServerError }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#RawHeaderPair-typedef">RawHeaderPair</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#dtor.QNetworkReply">~QNetworkReply</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#attribute">attribute</a></b>(QNetworkRequest::Attribute <i>code</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkReply::NetworkError </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#error">error</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#hasRawHeader">hasRawHeader</a></b>(const QByteArray &amp;<i>headerName</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#header">header</a></b>(QNetworkRequest::KnownHeaders <i>header</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#ignoreSslErrors-1">ignoreSslErrors</a></b>(const QList&lt;QSslError&gt; &amp;<i>errors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#isFinished">isFinished</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#isRunning">isRunning</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkAccessManager *</td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#manager">manager</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkAccessManager::Operation </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#operation">operation</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#rawHeader">rawHeader</a></b>(const QByteArray &amp;<i>headerName</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#rawHeaderList">rawHeaderList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QList&lt;QNetworkReply::RawHeaderPair&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#rawHeaderPairs">rawHeaderPairs</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#readBufferSize">readBufferSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkRequest </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#request">request</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setReadBufferSize">setReadBufferSize</a></b>(qint64 <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setSslConfiguration">setSslConfiguration</a></b>(const QSslConfiguration &amp;<i>config</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslConfiguration </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrl </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#url">url</a></b>() const</td></tr>
</table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">重新实现的公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#close">close</a></b>() override</td></tr>
</table></div>
<ul>
<li class="fn">44 个公共函数继承于 <a href="../qtcore/qiodevice.html#public-functions">QIODevice</a></li>
<li class="fn">31 个公共函数继承于 <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="public-slots"></a>
<h2 id="public-slots">公共槽函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#abort">abort</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">1 个公共槽函数继承于 <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#downloadProgress">downloadProgress</a></b>(qint64 <i>bytesReceived</i>, qint64 <i>bytesTotal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#encrypted">encrypted</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#error-1">error</a></b>(QNetworkReply::NetworkError <i>code</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#finished">finished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#metaDataChanged">metaDataChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#preSharedKeyAuthenticationRequired">preSharedKeyAuthenticationRequired</a></b>(QSslPreSharedKeyAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#redirectAllowed">redirectAllowed</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#redirected">redirected</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#sslErrors">sslErrors</a></b>(const QList&lt;QSslError&gt; &amp;<i>errors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#uploadProgress">uploadProgress</a></b>(qint64 <i>bytesSent</i>, qint64 <i>bytesTotal</i>)</td></tr>
</table></div>
<ul>
<li class="fn">6 个信号继承于 <a href="../qtcore/qiodevice.html#signals">QIODevice</a></li>
<li class="fn">2 个信号继承于 <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">9 个静态公共成员继承于 <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="protected-functions"></a>
<h2 id="protected-functions">保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#QNetworkReply">QNetworkReply</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#ignoreSslErrorsImplementation">ignoreSslErrorsImplementation</a></b>(const QList&lt;QSslError&gt; &amp;<i>errors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setAttribute">setAttribute</a></b>(QNetworkRequest::Attribute <i>code</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setError">setError</a></b>(QNetworkReply::NetworkError <i>errorCode</i>, const QString &amp;<i>errorString</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setFinished">setFinished</a></b>(bool <i>finished</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setHeader">setHeader</a></b>(QNetworkRequest::KnownHeaders <i>header</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setOperation">setOperation</a></b>(QNetworkAccessManager::Operation <i>operation</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setRawHeader">setRawHeader</a></b>(const QByteArray &amp;<i>headerName</i>, const QByteArray &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setRequest">setRequest</a></b>(const QNetworkRequest &amp;<i>request</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setSslConfigurationImplementation">setSslConfigurationImplementation</a></b>(const QSslConfiguration &amp;<i>configuration</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#setUrl">setUrl</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qnetworkreply.html#sslConfigurationImplementation">sslConfigurationImplementation</a></b>(QSslConfiguration &amp;<i>configuration</i>) const</td></tr>
</table></div>
<ul>
<li class="fn">5 个保护函数继承于 <a href="../qtcore/qiodevice.html#protected-functions">QIODevice</a></li>
<li class="fn">9 个保护函数继承于 <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
</ul>
<h3>其他继承而来的成员</h3>
<ul>
<li class="fn">1 个属性继承于 <a href="../qtcore/qobject.html#properties">QObject</a></li>
<li class="fn">1 个公共变量继承于 <a href="../qtcore/qiodevice.html#public-variables">QIODevice</a></li>
<li class="fn">1 个公共变量继承于 <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">2 个保护变量继承于 <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QNetworkReply-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qnetworkreply.html">QNetworkReply</a> class contains the data and headers for a request sent with <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>.</p>
<p>The <a href="qnetworkreply.html">QNetworkReply</a> class contains the data and meta data related to a request posted with <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>. Like <a href="qnetworkrequest.html">QNetworkRequest</a>, it contains a URL and headers (both in parsed and raw form), some information about the reply's state and the contents of the reply itself.</p>
<p><a href="qnetworkreply.html">QNetworkReply</a> is a sequential-access <a href="../qtcore/qiodevice.html">QIODevice</a>, which means that once data is read from the object, it no longer kept by the device. It is therefore the application's responsibility to keep this data if it needs to. Whenever more data is received from the network and processed, the <a href="../qtcore/qiodevice.html#readyRead">readyRead</a>() signal is emitted.</p>
<p>The <a href="qnetworkreply.html#downloadProgress">downloadProgress</a>() signal is also emitted when data is received, but the number of bytes contained in it may not represent the actual bytes received, if any transformation is done to the contents (for example, decompressing and removing the protocol overhead).</p>
<p>Even though <a href="qnetworkreply.html">QNetworkReply</a> is a <a href="../qtcore/qiodevice.html">QIODevice</a> connected to the contents of the reply, it also emits the <a href="qnetworkreply.html#uploadProgress">uploadProgress</a>() signal, which indicates the progress of the upload for operations that have such content.</p>
<p><b>Note: </b>Do not delete the object in the slot connected to the <a href="qnetworkreply.html#error">error</a>() or <a href="qnetworkreply.html#finished">finished</a>() signal. Use <a href="../qtcore/qobject.html#deleteLater">deleteLater</a>().</p></div>
<p><b> 参见 </b><a href="qnetworkrequest.html">QNetworkRequest</a> 和 <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>.</p>
<!-- @@@QNetworkReply -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$NetworkError$$$NoError$$$ConnectionRefusedError$$$RemoteHostClosedError$$$HostNotFoundError$$$TimeoutError$$$OperationCanceledError$$$SslHandshakeFailedError$$$TemporaryNetworkFailureError$$$NetworkSessionFailedError$$$BackgroundRequestNotAllowedError$$$TooManyRedirectsError$$$InsecureRedirectError$$$UnknownNetworkError$$$ProxyConnectionRefusedError$$$ProxyConnectionClosedError$$$ProxyNotFoundError$$$ProxyTimeoutError$$$ProxyAuthenticationRequiredError$$$UnknownProxyError$$$ContentAccessDenied$$$ContentOperationNotPermittedError$$$ContentNotFoundError$$$AuthenticationRequiredError$$$ContentReSendError$$$ContentConflictError$$$ContentGoneError$$$UnknownContentError$$$ProtocolUnknownError$$$ProtocolInvalidOperationError$$$ProtocolFailure$$$InternalServerError$$$OperationNotImplementedError$$$ServiceUnavailableError$$$UnknownServerError -->
<h3 class="fn" id="NetworkError-enum"><a name="NetworkError-enum"></a>enum QNetworkReply::<span class="name">NetworkError</span></h3>
<p>Indicates all possible error conditions found during the processing of the request.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QNetworkReply::NoError</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">no error condition.</td></tr>
</table></div>
<p><b>Note: </b>When the HTTP protocol returns a redirect no error will be reported. You can check if there is a redirect with the <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest::RedirectionTargetAttribute</a> attribute.</p><div class="table"><table class="valuelist"><tr valign="top" class="even"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QNetworkReply::ConnectionRefusedError</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">the remote server refused the connection (the server is not accepting requests)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::RemoteHostClosedError</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">the remote server closed the connection prematurely, before the entire reply was received and processed</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::HostNotFoundError</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">the remote host name was not found (invalid hostname)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::TimeoutError</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">the connection to the remote server timed out</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::OperationCanceledError</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">the operation was canceled via calls to <a href="qnetworkreply.html#abort">abort</a>() or <a href="qnetworkreply.html#close">close</a>() before it was finished.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::SslHandshakeFailedError</code></td><td class="topAlign tblval"><code>6</code></td><td class="topAlign">the SSL/TLS handshake failed and the encrypted channel could not be established. The <a href="qnetworkreply.html#sslErrors">sslErrors</a>() signal should have been emitted.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::TemporaryNetworkFailureError</code></td><td class="topAlign tblval"><code>7</code></td><td class="topAlign">the connection was broken due to disconnection from the network, however the system has initiated roaming to another access point. The request should be resubmitted and will be processed as soon as the connection is re-established.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::NetworkSessionFailedError</code></td><td class="topAlign tblval"><code>8</code></td><td class="topAlign">the connection was broken due to disconnection from the network or failure to start the network.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::BackgroundRequestNotAllowedError</code></td><td class="topAlign tblval"><code>9</code></td><td class="topAlign">the background request is not currently allowed due to platform policy.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::TooManyRedirectsError</code></td><td class="topAlign tblval"><code>10</code></td><td class="topAlign">while following redirects, the maximum limit was reached. The limit is by default set to 50 or as set by QNetworkRequest::setMaxRedirectsAllowed(). (This value was introduced in 5.6&#x2e;)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::InsecureRedirectError</code></td><td class="topAlign tblval"><code>11</code></td><td class="topAlign">while following redirects, the network access API detected a redirect from a encrypted protocol (https) to an unencrypted one (http). (This value was introduced in 5.6&#x2e;)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ProxyConnectionRefusedError</code></td><td class="topAlign tblval"><code>101</code></td><td class="topAlign">the connection to the proxy server was refused (the proxy server is not accepting requests)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ProxyConnectionClosedError</code></td><td class="topAlign tblval"><code>102</code></td><td class="topAlign">the proxy server closed the connection prematurely, before the entire reply was received and processed</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ProxyNotFoundError</code></td><td class="topAlign tblval"><code>103</code></td><td class="topAlign">the proxy host name was not found (invalid proxy hostname)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ProxyTimeoutError</code></td><td class="topAlign tblval"><code>104</code></td><td class="topAlign">the connection to the proxy timed out or the proxy did not reply in time to the request sent</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ProxyAuthenticationRequiredError</code></td><td class="topAlign tblval"><code>105</code></td><td class="topAlign">the proxy requires authentication in order to honour the request but did not accept any credentials offered (if any)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ContentAccessDenied</code></td><td class="topAlign tblval"><code>201</code></td><td class="topAlign">the access to the remote content was denied (similar to HTTP error 403)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ContentOperationNotPermittedError</code></td><td class="topAlign tblval"><code>202</code></td><td class="topAlign">the operation requested on the remote content is not permitted</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ContentNotFoundError</code></td><td class="topAlign tblval"><code>203</code></td><td class="topAlign">the remote content was not found at the server (similar to HTTP error 404)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::AuthenticationRequiredError</code></td><td class="topAlign tblval"><code>204</code></td><td class="topAlign">the remote server requires authentication to serve the content but the credentials provided were not accepted (if any)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ContentReSendError</code></td><td class="topAlign tblval"><code>205</code></td><td class="topAlign">the request needed to be sent again, but this failed for example because the upload data could not be read a second time.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ContentConflictError</code></td><td class="topAlign tblval"><code>206</code></td><td class="topAlign">the request could not be completed due to a conflict with the current state of the resource.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ContentGoneError</code></td><td class="topAlign tblval"><code>207</code></td><td class="topAlign">the requested resource is no longer available at the server.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::InternalServerError</code></td><td class="topAlign tblval"><code>401</code></td><td class="topAlign">the server encountered an unexpected condition which prevented it from fulfilling the request.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::OperationNotImplementedError</code></td><td class="topAlign tblval"><code>402</code></td><td class="topAlign">the server does not support the functionality required to fulfill the request.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ServiceUnavailableError</code></td><td class="topAlign tblval"><code>403</code></td><td class="topAlign">the server is unable to handle the request at this time.</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ProtocolUnknownError</code></td><td class="topAlign tblval"><code>301</code></td><td class="topAlign">the Network Access API cannot honor the request because the protocol is not known</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ProtocolInvalidOperationError</code></td><td class="topAlign tblval"><code>302</code></td><td class="topAlign">the requested operation is invalid for this protocol</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::UnknownNetworkError</code></td><td class="topAlign tblval"><code>99</code></td><td class="topAlign">an unknown network-related error was detected</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::UnknownProxyError</code></td><td class="topAlign tblval"><code>199</code></td><td class="topAlign">an unknown proxy-related error was detected</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::UnknownContentError</code></td><td class="topAlign tblval"><code>299</code></td><td class="topAlign">an unknown error related to the remote content was detected</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::ProtocolFailure</code></td><td class="topAlign tblval"><code>399</code></td><td class="topAlign">a breakdown in protocol was detected (parsing error, invalid or unexpected responses, etc.)</td></tr>
<tr><td class="topAlign"><code>QNetworkReply::UnknownServerError</code></td><td class="topAlign tblval"><code>499</code></td><td class="topAlign">an unknown error related to the server response was detected</td></tr>
</table></div>
<p><b> 参见 </b><a href="qnetworkreply.html#error">error</a>().</p>
<!-- @@@NetworkError -->
<!-- $$$RawHeaderPair -->
<h3 class="fn" id="RawHeaderPair-typedef"><a name="RawHeaderPair-typedef"></a>typedef QNetworkReply::<span class="name">RawHeaderPair</span></h3>
<p>RawHeaderPair is a <a href="../qtcore/qpair.html">QPair</a>&lt;<a href="../qtcore/qbytearray.html">QByteArray</a>, <a href="../qtcore/qbytearray.html">QByteArray</a>&gt; where the first <a href="../qtcore/qbytearray.html">QByteArray</a> is the header name and the second is the header.</p>
<!-- @@@RawHeaderPair -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QNetworkReply[overload1]$$$QNetworkReplyQObject* -->
<h3 class="fn" id="QNetworkReply"><a name="QNetworkReply"></a><code>[protected] </code>QNetworkReply::<span class="name">QNetworkReply</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Creates a <a href="qnetworkreply.html">QNetworkReply</a> object with parent <i>parent</i>.</p>
<p>You cannot directly instantiate <a href="qnetworkreply.html">QNetworkReply</a> objects. Use <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> functions to do that.</p>
<!-- @@@QNetworkReply -->
<!-- $$$~QNetworkReply[overload1]$$$~QNetworkReply -->
<h3 class="fn" id="dtor.QNetworkReply"><a name="dtor.QNetworkReply"></a><code>[virtual] </code>QNetworkReply::<span class="name">~QNetworkReply</span>()</h3>
<p>Disposes of this reply and frees any resources associated with it. If any network connections are still open, they will be closed.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#abort">abort</a>() 和 <a href="qnetworkreply.html#close">close</a>().</p>
<!-- @@@~QNetworkReply -->
<!-- $$$abort[overload1]$$$abort -->
<h3 class="fn" id="abort"><a name="abort"></a><code>[pure virtual slot] </code><span class="type">void</span> QNetworkReply::<span class="name">abort</span>()</h3>
<p>Aborts the operation immediately and close down any network connections still open. Uploads still in progress are also aborted.</p>
<p>The <a href="qnetworkreply.html#finished">finished</a>() signal will also be emitted.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#close">close</a>() 和 <a href="qnetworkreply.html#finished">finished</a>().</p>
<!-- @@@abort -->
<!-- $$$attribute[overload1]$$$attributeQNetworkRequest::Attribute -->
<h3 class="fn" id="attribute"><a name="attribute"></a><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QNetworkReply::<span class="name">attribute</span>(<span class="type"><a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest::Attribute</a></span> <i>code</i>) const</h3>
<p>Returns the attribute associated with the code <i>code</i>. If the attribute has not been set, it returns an invalid <a href="../qtcore/qvariant.html">QVariant</a> (type <a href="../qtcore/qmetatype.html#Type-enum">QMetaType::UnknownType</a>).</p>
<p>You can expect the default values listed in <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest::Attribute</a> to be applied to the values returned by this function.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#setAttribute">setAttribute</a>() 和 <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest::Attribute</a>.</p>
<!-- @@@attribute -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" id="close"><a name="close"></a><code>[override virtual] </code><span class="type">void</span> QNetworkReply::<span class="name">close</span>()</h3>
<p>Reimplemented from <a href="../qtcore/qiodevice.html#close">QIODevice::close</a>().</p>
<p>Closes this device for reading. Unread data is discarded, but the network resources are not discarded until they are finished. In particular, if any upload is in progress, it will continue until it is done.</p>
<p>The <a href="qnetworkreply.html#finished">finished</a>() signal is emitted when all operations are over and the network resources are freed.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#abort">abort</a>() 和 <a href="qnetworkreply.html#finished">finished</a>().</p>
<!-- @@@close -->
<!-- $$$downloadProgress[overload1]$$$downloadProgressqint64qint64 -->
<h3 class="fn" id="downloadProgress"><a name="downloadProgress"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">downloadProgress</span>(<span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> <i>bytesReceived</i>, <span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> <i>bytesTotal</i>)</h3>
<p>This signal is emitted to indicate the progress of the download part of this network request, if there's any. If there's no download associated with this request, this signal will be emitted once with 0 as the value of both <i>bytesReceived</i> and <i>bytesTotal</i>.</p>
<p>The <i>bytesReceived</i> parameter indicates the number of bytes received, while <i>bytesTotal</i> indicates the total number of bytes expected to be downloaded. If the number of bytes to be downloaded is not known, <i>bytesTotal</i> will be -1.</p>
<p>The download is finished when <i>bytesReceived</i> is equal to <i>bytesTotal</i>. At that time, <i>bytesTotal</i> will not be -1.</p>
<p>Note that the values of both <i>bytesReceived</i> and <i>bytesTotal</i> may be different from <a href="../qtcore/qiodevice.html#size">size</a>(), the total number of bytes obtained through <a href="../qtcore/qiodevice.html#read-1">read</a>() or <a href="../qtcore/qiodevice.html#readAll">readAll</a>(), or the value of the header(ContentLengthHeader). The reason for that is that there may be protocol overhead or the data may be compressed during the download.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#uploadProgress">uploadProgress</a>() 和 <a href="../qtcore/qiodevice.html#bytesAvailable">bytesAvailable</a>().</p>
<!-- @@@downloadProgress -->
<!-- $$$encrypted[overload1]$$$encrypted -->
<h3 class="fn" id="encrypted"><a name="encrypted"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">encrypted</span>()</h3>
<p>This signal is emitted when an SSL/TLS session has successfully completed the initial handshake. At this point, no user data has been transmitted. The signal can be used to perform additional checks on the certificate chain, for example to notify users when the certificate for a website has changed. If the reply does not match the expected criteria then it should be aborted by calling <a href="qnetworkreply.html#abort">QNetworkReply::abort</a>() by a slot connected to this signal. The SSL configuration in use can be inspected using the <a href="qnetworkreply.html#sslConfiguration">QNetworkReply::sslConfiguration</a>() method.</p>
<p>Internally, <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> may open multiple connections to a server, in order to allow it process requests in parallel. These connections may be reused, which means that the encrypted() signal would not be emitted. This means that you are only guaranteed to receive this signal for the first connection to a site in the lifespan of the <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>.</p>
<p>这个函数是在Qt 5.1版本中新增引入的。</p>
<p><b> 参见 </b><a href="qsslsocket.html#encrypted">QSslSocket::encrypted</a>() 和 <a href="qnetworkaccessmanager.html#encrypted">QNetworkAccessManager::encrypted</a>().</p>
<!-- @@@encrypted -->
<!-- $$$error[overload1]$$$error -->
<h3 class="fn" id="error"><a name="error"></a><span class="type"><a href="qnetworkreply.html#NetworkError-enum">QNetworkReply::NetworkError</a></span> QNetworkReply::<span class="name">error</span>() const</h3>
<p>Returns the error that was found during the processing of this request. If no error was found, returns <a href="qnetworkreply.html#NetworkError-enum">NoError</a>.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#setError">setError</a>().</p>
<!-- @@@error -->
<!-- $$$error$$$errorQNetworkReply::NetworkError -->
<h3 class="fn" id="error-1"><a name="error-1"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">error</span>(<span class="type"><a href="qnetworkreply.html#NetworkError-enum">QNetworkReply::NetworkError</a></span> <i>code</i>)</h3>
<p>This signal is emitted when the reply detects an error in processing. The <a href="qnetworkreply.html#finished">finished</a>() signal will probably follow, indicating that the connection is over.</p>
<p>The <i>code</i> parameter contains the code of the error that was detected. Call <a href="../qtcore/qiodevice.html#errorString">errorString</a>() to obtain a textual representation of the error condition.</p>
<p><b>Note: </b>Do not delete the object in the slot connected to this signal. Use <a href="../qtcore/qobject.html#deleteLater">deleteLater</a>().</p><p><b>Note:</b> Signal <i>error</i> is overloaded in this class. To connect to this signal by using the function pointer syntax, Qt provides a convenient helper for obtaining the function pointer as shown in this example:<pre class="cpp">

  connect(networkReply<span class="operator">,</span> <span class="type">QOverload</span><span class="operator">&lt;</span><span class="type"><a href="qnetworkreply.html#QNetworkReply">QNetworkReply</a></span><span class="operator">::</span>NetworkError<span class="operator">&gt;</span><span class="operator">::</span>of(<span class="operator">&amp;</span><span class="type"><a href="qnetworkreply.html#QNetworkReply">QNetworkReply</a></span><span class="operator">::</span>error)<span class="operator">,</span>
      <span class="operator">[</span><span class="operator">=</span><span class="operator">]</span>(<span class="type"><a href="qnetworkreply.html#QNetworkReply">QNetworkReply</a></span><span class="operator">::</span>NetworkError code){ <span class="comment">/* ... */</span> });

</pre>
<p><b> 参见 </b><a href="qnetworkreply.html#error">error</a>() 和 <a href="../qtcore/qiodevice.html#errorString">errorString</a>().</p>
<!-- @@@error -->
<!-- $$$finished[overload1]$$$finished -->
<h3 class="fn" id="finished"><a name="finished"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">finished</span>()</h3>
<p>This signal is emitted when the reply has finished processing. After this signal is emitted, there will be no more updates to the reply's data or metadata.</p>
<p>Unless <a href="qnetworkreply.html#close">close</a>() or <a href="qnetworkreply.html#abort">abort</a>() have been called, the reply will be still be opened for reading, so the data can be retrieved by calls to <a href="../qtcore/qiodevice.html#read-1">read</a>() or <a href="../qtcore/qiodevice.html#readAll">readAll</a>(). In particular, if no calls to <a href="../qtcore/qiodevice.html#read-1">read</a>() were made as a result of <a href="../qtcore/qiodevice.html#readyRead">readyRead</a>(), a call to <a href="../qtcore/qiodevice.html#readAll">readAll</a>() will retrieve the full contents in a <a href="../qtcore/qbytearray.html">QByteArray</a>.</p>
<p>This signal is emitted in tandem with <a href="qnetworkaccessmanager.html#finished">QNetworkAccessManager::finished</a>() where that signal's reply parameter is this object.</p>
<p><b>Note: </b>Do not delete the object in the slot connected to this signal. Use <a href="../qtcore/qobject.html#deleteLater">deleteLater</a>().</p><p>You can also use <a href="qnetworkreply.html#isFinished">isFinished</a>() to check if a <a href="qnetworkreply.html">QNetworkReply</a> has finished even before you receive the finished() signal.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#setFinished">setFinished</a>(), <a href="qnetworkaccessmanager.html#finished">QNetworkAccessManager::finished</a>(), 和 <a href="qnetworkreply.html#isFinished">isFinished</a>().</p>
<!-- @@@finished -->
<!-- $$$hasRawHeader[overload1]$$$hasRawHeaderconstQByteArray& -->
<h3 class="fn" id="hasRawHeader"><a name="hasRawHeader"></a><span class="type">bool</span> QNetworkReply::<span class="name">hasRawHeader</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>headerName</i>) const</h3>
<p>Returns <code>true</code> if the raw header of name <i>headerName</i> was sent by the remote server</p>
<p><b> 参见 </b><a href="qnetworkreply.html#rawHeader">rawHeader</a>().</p>
<!-- @@@hasRawHeader -->
<!-- $$$header[overload1]$$$headerQNetworkRequest::KnownHeaders -->
<h3 class="fn" id="header"><a name="header"></a><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QNetworkReply::<span class="name">header</span>(<span class="type"><a href="qnetworkrequest.html#KnownHeaders-enum">QNetworkRequest::KnownHeaders</a></span> <i>header</i>) const</h3>
<p>Returns the value of the known header <i>header</i>, if that header was sent by the remote server. If the header was not sent, returns an invalid <a href="../qtcore/qvariant.html">QVariant</a>.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#rawHeader">rawHeader</a>(), <a href="qnetworkreply.html#setHeader">setHeader</a>(), 和 <a href="qnetworkrequest.html#header">QNetworkRequest::header</a>().</p>
<!-- @@@header -->
<!-- $$$ignoreSslErrors[overload1]$$$ignoreSslErrors -->
<h3 class="fn" id="ignoreSslErrors"><a name="ignoreSslErrors"></a><code>[virtual slot] </code><span class="type">void</span> QNetworkReply::<span class="name">ignoreSslErrors</span>()</h3>
<p>If this function is called, SSL errors related to network connection will be ignored, including certificate validation errors.</p>
<p><b>Warning:</b> Be sure to always let the user inspect the errors reported by the <a href="qnetworkreply.html#sslErrors">sslErrors</a>() signal, and only call this method upon confirmation from the user that proceeding is ok. If there are unexpected errors, the reply should be aborted. Calling this method without inspecting the actual errors will most likely pose a security risk for your application. Use it with great care!</p>
<p>This function can be called from the slot connected to the <a href="qnetworkreply.html#sslErrors">sslErrors</a>() signal, which indicates which errors were found.</p>
<p><b>Note: </b>If HTTP Strict Transport Security is enabled for <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>, this function has no effect.</p><p><b> 参见 </b><a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>(), <a href="qnetworkreply.html#sslErrors">sslErrors</a>(), 和 <a href="qsslsocket.html#ignoreSslErrors">QSslSocket::ignoreSslErrors</a>().</p>
<!-- @@@ignoreSslErrors -->
<!-- $$$ignoreSslErrors$$$ignoreSslErrorsconstQList<QSslError>& -->
<h3 class="fn" id="ignoreSslErrors-1"><a name="ignoreSslErrors-1"></a><span class="type">void</span> QNetworkReply::<span class="name">ignoreSslErrors</span>(const <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qsslerror.html">QSslError</a></span>&gt; &amp;<i>errors</i>)</h3>
<p>这是一个重载函数。</p>
<p>If this function is called, the SSL errors given in <i>errors</i> will be ignored.</p>
<p><b>Note: </b>Because most SSL errors are associated with a certificate, for most of them you must set the expected certificate this SSL error is related to. If, for instance, you want to issue a request to a server that uses a self-signed certificate, consider the following snippet:</p><pre class="cpp">

  <span class="type"><a href="../qtcore/qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslcertificate.html">QSslCertificate</a></span><span class="operator">&gt;</span> cert <span class="operator">=</span> <span class="type"><a href="qsslcertificate.html">QSslCertificate</a></span><span class="operator">::</span>fromPath(QLatin1String(<span class="string">&quot;server-certificate.pem&quot;</span>));
  <span class="type"><a href="qsslerror.html">QSslError</a></span> error(<span class="type"><a href="qsslerror.html">QSslError</a></span><span class="operator">::</span>SelfSignedCertificate<span class="operator">,</span> cert<span class="operator">.</span>at(<span class="number">0</span>));
  <span class="type"><a href="../qtcore/qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslerror.html">QSslError</a></span><span class="operator">&gt;</span> expectedSslErrors;
  expectedSslErrors<span class="operator">.</span>append(error);

  <span class="type"><a href="qnetworkreply.html#QNetworkReply">QNetworkReply</a></span> <span class="operator">*</span>reply <span class="operator">=</span> manager<span class="operator">.</span>get(<span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span>(<span class="type"><a href="../qtcore/qurl.html">QUrl</a></span>(<span class="string">&quot;https://server.tld/index.html&quot;</span>)));
  reply<span class="operator">-</span><span class="operator">&gt;</span>ignoreSslErrors(expectedSslErrors);
  <span class="comment">// here connect signals etc.</span>

</pre>
<p>Multiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</p>
<p><b>Note: </b>If HTTP Strict Transport Security is enabled for <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>, this function has no effect.</p><p>这个函数是在Qt 4.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>(), <a href="qnetworkreply.html#sslErrors">sslErrors</a>(), <a href="qsslsocket.html#ignoreSslErrors">QSslSocket::ignoreSslErrors</a>(), 和 <a href="qnetworkaccessmanager.html#setStrictTransportSecurityEnabled">QNetworkAccessManager::setStrictTransportSecurityEnabled</a>().</p>
<!-- @@@ignoreSslErrors -->
<!-- $$$ignoreSslErrorsImplementation[overload1]$$$ignoreSslErrorsImplementationconstQList<QSslError>& -->
<h3 class="fn" id="ignoreSslErrorsImplementation"><a name="ignoreSslErrorsImplementation"></a><code>[virtual protected] </code><span class="type">void</span> QNetworkReply::<span class="name">ignoreSslErrorsImplementation</span>(const <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qsslerror.html">QSslError</a></span>&gt; &amp;<i>errors</i>)</h3>
<p>This virtual method is provided to enable overriding the behavior of <a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>(). <a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>() is a public wrapper for this method. <i>errors</i> contains the errors the user wishes ignored.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>().</p>
<!-- @@@ignoreSslErrorsImplementation -->
<!-- $$$isFinished[overload1]$$$isFinished -->
<h3 class="fn" id="isFinished"><a name="isFinished"></a><span class="type">bool</span> QNetworkReply::<span class="name">isFinished</span>() const</h3>
<p>Returns <code>true</code> when the reply has finished or was aborted.</p>
<p>这个函数是在Qt 4.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnetworkreply.html#isRunning">isRunning</a>().</p>
<!-- @@@isFinished -->
<!-- $$$isRunning[overload1]$$$isRunning -->
<h3 class="fn" id="isRunning"><a name="isRunning"></a><span class="type">bool</span> QNetworkReply::<span class="name">isRunning</span>() const</h3>
<p>Returns <code>true</code> when the request is still processing and the reply has not finished or was aborted yet.</p>
<p>这个函数是在Qt 4.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnetworkreply.html#isFinished">isFinished</a>().</p>
<!-- @@@isRunning -->
<!-- $$$manager[overload1]$$$manager -->
<h3 class="fn" id="manager"><a name="manager"></a><span class="type"><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a></span> *QNetworkReply::<span class="name">manager</span>() const</h3>
<p>Returns the <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> that was used to create this <a href="qnetworkreply.html">QNetworkReply</a> object. Initially, it is also the parent object.</p>
<!-- @@@manager -->
<!-- $$$metaDataChanged[overload1]$$$metaDataChanged -->
<h3 class="fn" id="metaDataChanged"><a name="metaDataChanged"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">metaDataChanged</span>()</h3>
<p>This signal is emitted whenever the metadata in this reply changes. metadata is any information that is not the content (data) itself, including the network headers. In the majority of cases, the metadata will be known fully by the time the first byte of data is received. However, it is possible to receive updates of headers or other metadata during the processing of the data.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#header">header</a>(), <a href="qnetworkreply.html#rawHeaderList">rawHeaderList</a>(), <a href="qnetworkreply.html#rawHeader">rawHeader</a>(), 和 <a href="qnetworkreply.html#hasRawHeader">hasRawHeader</a>().</p>
<!-- @@@metaDataChanged -->
<!-- $$$operation[overload1]$$$operation -->
<h3 class="fn" id="operation"><a name="operation"></a><span class="type"><a href="qnetworkaccessmanager.html#Operation-enum">QNetworkAccessManager::Operation</a></span> QNetworkReply::<span class="name">operation</span>() const</h3>
<p>Returns the operation that was posted for this reply.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#setOperation">setOperation</a>().</p>
<!-- @@@operation -->
<!-- $$$preSharedKeyAuthenticationRequired[overload1]$$$preSharedKeyAuthenticationRequiredQSslPreSharedKeyAuthenticator* -->
<h3 class="fn" id="preSharedKeyAuthenticationRequired"><a name="preSharedKeyAuthenticationRequired"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">preSharedKeyAuthenticationRequired</span>(<span class="type"><a href="qsslpresharedkeyauthenticator.html">QSslPreSharedKeyAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p>This signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</p>
<p>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <i>authenticator</i> object according to their needs.</p>
<p><b>Note: </b>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</p><p><b>Note: </b>The <i>authenticator</i> object is owned by the reply and must not be deleted by the application.</p><p>这个函数是在Qt 5.5版本中新增引入的。</p>
<p><b> 参见 </b><a href="qsslpresharedkeyauthenticator.html">QSslPreSharedKeyAuthenticator</a>.</p>
<!-- @@@preSharedKeyAuthenticationRequired -->
<!-- $$$rawHeader[overload1]$$$rawHeaderconstQByteArray& -->
<h3 class="fn" id="rawHeader"><a name="rawHeader"></a><span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> QNetworkReply::<span class="name">rawHeader</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>headerName</i>) const</h3>
<p>Returns the raw contents of the header <i>headerName</i> as sent by the remote server. If there is no such header, returns an empty byte array, which may be indistinguishable from an empty header. Use <a href="qnetworkreply.html#hasRawHeader">hasRawHeader</a>() to verify if the server sent such header field.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#setRawHeader">setRawHeader</a>(), <a href="qnetworkreply.html#hasRawHeader">hasRawHeader</a>(), 和 <a href="qnetworkreply.html#header">header</a>().</p>
<!-- @@@rawHeader -->
<!-- $$$rawHeaderList[overload1]$$$rawHeaderList -->
<h3 class="fn" id="rawHeaderList"><a name="rawHeaderList"></a><span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span>&gt; QNetworkReply::<span class="name">rawHeaderList</span>() const</h3>
<p>Returns a list of headers fields that were sent by the remote server, in the order that they were sent. Duplicate headers are merged together and take place of the latter duplicate.</p>
<!-- @@@rawHeaderList -->
<!-- $$$rawHeaderPairs[overload1]$$$rawHeaderPairs -->
<h3 class="fn" id="rawHeaderPairs"><a name="rawHeaderPairs"></a>const <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qnetworkreply.html#RawHeaderPair-typedef">QNetworkReply::RawHeaderPair</a></span>&gt; &amp;QNetworkReply::<span class="name">rawHeaderPairs</span>() const</h3>
<p>Returns a list of raw header pairs.</p>
<!-- @@@rawHeaderPairs -->
<!-- $$$readBufferSize[overload1]$$$readBufferSize -->
<h3 class="fn" id="readBufferSize"><a name="readBufferSize"></a><span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> QNetworkReply::<span class="name">readBufferSize</span>() const</h3>
<p>Returns the size of the read buffer, in bytes.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#setReadBufferSize">setReadBufferSize</a>().</p>
<!-- @@@readBufferSize -->
<!-- $$$redirectAllowed[overload1]$$$redirectAllowed -->
<h3 class="fn" id="redirectAllowed"><a name="redirectAllowed"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">redirectAllowed</span>()</h3>
<p>When client code handling the <a href="qnetworkreply.html#redirected">redirected</a>() signal has verified the new URL, it emits this signal to allow the redirect to go ahead. This protocol applies to network requests whose redirects policy is set to <a href="qnetworkrequest.html#RedirectPolicy-enum">QNetworkRequest::UserVerifiedRedirectPolicy</a></p>
<p>这个函数是在Qt 5.9版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnetworkrequest.html#RedirectPolicy-enum">QNetworkRequest::UserVerifiedRedirectPolicy</a>, <a href="qnetworkaccessmanager.html#setRedirectPolicy">QNetworkAccessManager::setRedirectPolicy</a>(), 和 <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest::RedirectPolicyAttribute</a>.</p>
<!-- @@@redirectAllowed -->
<!-- $$$redirected[overload1]$$$redirectedconstQUrl& -->
<h3 class="fn" id="redirected"><a name="redirected"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">redirected</span>(const <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> &amp;<i>url</i>)</h3>
<p>This signal is emitted if the <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest::FollowRedirectsAttribute</a> was set in the request and the server responded with a 3xx status (specifically 301, 302, 303, 305, 307 or 308 status code) with a valid url in the location header, indicating a HTTP redirect. The <i>url</i> parameter contains the new redirect url as returned by the server in the location header.</p>
<p>这个函数是在Qt 5.6版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest::FollowRedirectsAttribute</a>.</p>
<!-- @@@redirected -->
<!-- $$$request[overload1]$$$request -->
<h3 class="fn" id="request"><a name="request"></a><span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> QNetworkReply::<span class="name">request</span>() const</h3>
<p>Returns the request that was posted for this reply. In special, note that the URL for the request may be different than that of the reply.</p>
<p><b> 参见 </b><a href="qnetworkrequest.html#url">QNetworkRequest::url</a>(), <a href="qnetworkreply.html#url">url</a>(), 和 <a href="qnetworkreply.html#setRequest">setRequest</a>().</p>
<!-- @@@request -->
<!-- $$$setAttribute[overload1]$$$setAttributeQNetworkRequest::AttributeconstQVariant& -->
<h3 class="fn" id="setAttribute"><a name="setAttribute"></a><code>[protected] </code><span class="type">void</span> QNetworkReply::<span class="name">setAttribute</span>(<span class="type"><a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest::Attribute</a></span> <i>code</i>, const <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Sets the attribute <i>code</i> to have value <i>value</i>. If <i>code</i> was previously set, it will be overridden. If <i>value</i> is an invalid <a href="../qtcore/qvariant.html">QVariant</a>, the attribute will be unset.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#attribute">attribute</a>() 和 <a href="qnetworkrequest.html#setAttribute">QNetworkRequest::setAttribute</a>().</p>
<!-- @@@setAttribute -->
<!-- $$$setError[overload1]$$$setErrorQNetworkReply::NetworkErrorconstQString& -->
<h3 class="fn" id="setError"><a name="setError"></a><code>[protected] </code><span class="type">void</span> QNetworkReply::<span class="name">setError</span>(<span class="type"><a href="qnetworkreply.html#NetworkError-enum">QNetworkReply::NetworkError</a></span> <i>errorCode</i>, const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>errorString</i>)</h3>
<p>Sets the error condition to be <i>errorCode</i>. The human-readable message is set with <i>errorString</i>.</p>
<p>Calling setError() does not emit the error(<a href="qnetworkreply.html#NetworkError-enum">QNetworkReply::NetworkError</a>) signal.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#error">error</a>() 和 <a href="../qtcore/qiodevice.html#errorString">errorString</a>().</p>
<!-- @@@setError -->
<!-- $$$setFinished[overload1]$$$setFinishedbool -->
<h3 class="fn" id="setFinished"><a name="setFinished"></a><code>[protected] </code><span class="type">void</span> QNetworkReply::<span class="name">setFinished</span>(<span class="type">bool</span> <i>finished</i>)</h3>
<p>Sets the reply as <i>finished</i>.</p>
<p>After having this set the replies data must not change.</p>
<p>这个函数是在Qt 4.8版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnetworkreply.html#finished">finished</a>() 和 <a href="qnetworkreply.html#isFinished">isFinished</a>().</p>
<!-- @@@setFinished -->
<!-- $$$setHeader[overload1]$$$setHeaderQNetworkRequest::KnownHeadersconstQVariant& -->
<h3 class="fn" id="setHeader"><a name="setHeader"></a><code>[protected] </code><span class="type">void</span> QNetworkReply::<span class="name">setHeader</span>(<span class="type"><a href="qnetworkrequest.html#KnownHeaders-enum">QNetworkRequest::KnownHeaders</a></span> <i>header</i>, const <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Sets the known header <i>header</i> to be of value <i>value</i>. The corresponding raw form of the header will be set as well.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#header">header</a>(), <a href="qnetworkreply.html#setRawHeader">setRawHeader</a>(), 和 <a href="qnetworkrequest.html#setHeader">QNetworkRequest::setHeader</a>().</p>
<!-- @@@setHeader -->
<!-- $$$setOperation[overload1]$$$setOperationQNetworkAccessManager::Operation -->
<h3 class="fn" id="setOperation"><a name="setOperation"></a><code>[protected] </code><span class="type">void</span> QNetworkReply::<span class="name">setOperation</span>(<span class="type"><a href="qnetworkaccessmanager.html#Operation-enum">QNetworkAccessManager::Operation</a></span> <i>operation</i>)</h3>
<p>Sets the associated operation for this object to be <i>operation</i>. This value will be returned by <a href="qnetworkreply.html#operation">operation</a>().</p>
<p><b>Note: </b>The operation should be set when this object is created and not changed again.</p><p><b> 参见 </b><a href="qnetworkreply.html#operation">operation</a>() 和 <a href="qnetworkreply.html#setRequest">setRequest</a>().</p>
<!-- @@@setOperation -->
<!-- $$$setRawHeader[overload1]$$$setRawHeaderconstQByteArray&constQByteArray& -->
<h3 class="fn" id="setRawHeader"><a name="setRawHeader"></a><code>[protected] </code><span class="type">void</span> QNetworkReply::<span class="name">setRawHeader</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>headerName</i>, const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>value</i>)</h3>
<p>Sets the raw header <i>headerName</i> to be of value <i>value</i>. If <i>headerName</i> was previously set, it is overridden. Multiple HTTP headers of the same name are functionally equivalent to one single header with the values concatenated, separated by commas.</p>
<p>If <i>headerName</i> matches a known header, the value <i>value</i> will be parsed and the corresponding parsed form will also be set.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#rawHeader">rawHeader</a>(), <a href="qnetworkreply.html#header">header</a>(), <a href="qnetworkreply.html#setHeader">setHeader</a>(), 和 <a href="qnetworkrequest.html#setRawHeader">QNetworkRequest::setRawHeader</a>().</p>
<!-- @@@setRawHeader -->
<!-- $$$setReadBufferSize[overload1]$$$setReadBufferSizeqint64 -->
<h3 class="fn" id="setReadBufferSize"><a name="setReadBufferSize"></a><code>[virtual] </code><span class="type">void</span> QNetworkReply::<span class="name">setReadBufferSize</span>(<span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> <i>size</i>)</h3>
<p>Sets the size of the read buffer to be <i>size</i> bytes. The read buffer is the buffer that holds data that is being downloaded off the network, before it is read with <a href="../qtcore/qiodevice.html#read-1">QIODevice::read</a>(). Setting the buffer size to 0 will make the buffer unlimited in size.</p>
<p><a href="qnetworkreply.html">QNetworkReply</a> will try to stop reading from the network once this buffer is full (i.e&#x2e;, <a href="../qtcore/qiodevice.html#bytesAvailable">bytesAvailable</a>() returns <i>size</i> or more), thus causing the download to throttle down as well. If the buffer is not limited in size, <a href="qnetworkreply.html">QNetworkReply</a> will try to download as fast as possible from the network.</p>
<p>Unlike <a href="qabstractsocket.html#setReadBufferSize">QAbstractSocket::setReadBufferSize</a>(), <a href="qnetworkreply.html">QNetworkReply</a> cannot guarantee precision in the read buffer size. That is, <a href="../qtcore/qiodevice.html#bytesAvailable">bytesAvailable</a>() can return more than <i>size</i>.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#readBufferSize">readBufferSize</a>().</p>
<!-- @@@setReadBufferSize -->
<!-- $$$setRequest[overload1]$$$setRequestconstQNetworkRequest& -->
<h3 class="fn" id="setRequest"><a name="setRequest"></a><code>[protected] </code><span class="type">void</span> QNetworkReply::<span class="name">setRequest</span>(const <span class="type"><a href="qnetworkrequest.html">QNetworkRequest</a></span> &amp;<i>request</i>)</h3>
<p>Sets the associated request for this object to be <i>request</i>. This value will be returned by <a href="qnetworkreply.html#request">request</a>().</p>
<p><b>Note: </b>The request should be set when this object is created and not changed again.</p><p><b> 参见 </b><a href="qnetworkreply.html#request">request</a>() 和 <a href="qnetworkreply.html#setOperation">setOperation</a>().</p>
<!-- @@@setRequest -->
<!-- $$$setSslConfiguration[overload1]$$$setSslConfigurationconstQSslConfiguration& -->
<h3 class="fn" id="setSslConfiguration"><a name="setSslConfiguration"></a><span class="type">void</span> QNetworkReply::<span class="name">setSslConfiguration</span>(const <span class="type"><a href="qsslconfiguration.html">QSslConfiguration</a></span> &amp;<i>config</i>)</h3>
<p>Sets the SSL configuration for the network connection associated with this request, if possible, to be that of <i>config</i>.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>().</p>
<!-- @@@setSslConfiguration -->
<!-- $$$setSslConfigurationImplementation[overload1]$$$setSslConfigurationImplementationconstQSslConfiguration& -->
<h3 class="fn" id="setSslConfigurationImplementation"><a name="setSslConfigurationImplementation"></a><code>[virtual protected] </code><span class="type">void</span> QNetworkReply::<span class="name">setSslConfigurationImplementation</span>(const <span class="type"><a href="qsslconfiguration.html">QSslConfiguration</a></span> &amp;<i>configuration</i>)</h3>
<p>This virtual method is provided to enable overriding the behavior of <a href="qnetworkreply.html#setSslConfiguration">setSslConfiguration</a>(). <a href="qnetworkreply.html#setSslConfiguration">setSslConfiguration</a>() is a public wrapper for this method. If you override this method use <i>configuration</i> to set the SSL configuration.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnetworkreply.html#sslConfigurationImplementation">sslConfigurationImplementation</a>() 和 <a href="qnetworkreply.html#setSslConfiguration">setSslConfiguration</a>().</p>
<!-- @@@setSslConfigurationImplementation -->
<!-- $$$setUrl[overload1]$$$setUrlconstQUrl& -->
<h3 class="fn" id="setUrl"><a name="setUrl"></a><code>[protected] </code><span class="type">void</span> QNetworkReply::<span class="name">setUrl</span>(const <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> &amp;<i>url</i>)</h3>
<p>Sets the URL being processed to be <i>url</i>. Normally, the URL matches that of the request that was posted, but for a variety of reasons it can be different (for example, a file path being made absolute or canonical).</p>
<p><b> 参见 </b><a href="qnetworkreply.html#url">url</a>(), <a href="qnetworkreply.html#request">request</a>(), 和 <a href="qnetworkrequest.html#url">QNetworkRequest::url</a>().</p>
<!-- @@@setUrl -->
<!-- $$$sslConfiguration[overload1]$$$sslConfiguration -->
<h3 class="fn" id="sslConfiguration"><a name="sslConfiguration"></a><span class="type"><a href="qsslconfiguration.html">QSslConfiguration</a></span> QNetworkReply::<span class="name">sslConfiguration</span>() const</h3>
<p>Returns the SSL configuration and state associated with this reply, if SSL was used. It will contain the remote server's certificate, its certificate chain leading to the Certificate Authority as well as the encryption ciphers in use.</p>
<p>The peer's certificate and its certificate chain will be known by the time <a href="qnetworkreply.html#sslErrors">sslErrors</a>() is emitted, if it's emitted.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#setSslConfiguration">setSslConfiguration</a>().</p>
<!-- @@@sslConfiguration -->
<!-- $$$sslConfigurationImplementation[overload1]$$$sslConfigurationImplementationQSslConfiguration& -->
<h3 class="fn" id="sslConfigurationImplementation"><a name="sslConfigurationImplementation"></a><code>[virtual protected] </code><span class="type">void</span> QNetworkReply::<span class="name">sslConfigurationImplementation</span>(<span class="type"><a href="qsslconfiguration.html">QSslConfiguration</a></span> &amp;<i>configuration</i>) const</h3>
<p>This virtual method is provided to enable overriding the behavior of <a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>(). <a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>() is a public wrapper for this method. The configuration will be returned in <i>configuration</i>.</p>
<p>这个函数是在Qt 5.0版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnetworkreply.html#setSslConfigurationImplementation">setSslConfigurationImplementation</a>() 和 <a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>().</p>
<!-- @@@sslConfigurationImplementation -->
<!-- $$$sslErrors[overload1]$$$sslErrorsconstQList<QSslError>& -->
<h3 class="fn" id="sslErrors"><a name="sslErrors"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">sslErrors</span>(const <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qsslerror.html">QSslError</a></span>&gt; &amp;<i>errors</i>)</h3>
<p>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The <i>errors</i> parameter contains the list of errors.</p>
<p>To indicate that the errors are not fatal and that the connection should proceed, the <a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</p>
<p>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see <a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call <a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>().</p>
<p><b> 参见 </b><a href="qsslsocket.html#sslErrors">QSslSocket::sslErrors</a>(), <a href="qnetworkaccessmanager.html#sslErrors">QNetworkAccessManager::sslErrors</a>(), <a href="qnetworkreply.html#sslConfiguration">sslConfiguration</a>(), 和 <a href="qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>().</p>
<!-- @@@sslErrors -->
<!-- $$$uploadProgress[overload1]$$$uploadProgressqint64qint64 -->
<h3 class="fn" id="uploadProgress"><a name="uploadProgress"></a><code>[signal] </code><span class="type">void</span> QNetworkReply::<span class="name">uploadProgress</span>(<span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> <i>bytesSent</i>, <span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> <i>bytesTotal</i>)</h3>
<p>This signal is emitted to indicate the progress of the upload part of this network request, if there's any. If there's no upload associated with this request, this signal will not be emitted.</p>
<p>The <i>bytesSent</i> parameter indicates the number of bytes uploaded, while <i>bytesTotal</i> indicates the total number of bytes to be uploaded. If the number of bytes to be uploaded could not be determined, <i>bytesTotal</i> will be -1.</p>
<p>The upload is finished when <i>bytesSent</i> is equal to <i>bytesTotal</i>. At that time, <i>bytesTotal</i> will not be -1.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#downloadProgress">downloadProgress</a>().</p>
<!-- @@@uploadProgress -->
<!-- $$$url[overload1]$$$url -->
<h3 class="fn" id="url"><a name="url"></a><span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> QNetworkReply::<span class="name">url</span>() const</h3>
<p>Returns the URL of the content downloaded or uploaded. Note that the URL may be different from that of the original request. If the <a href="qnetworkrequest.html#Attribute-enum">QNetworkRequest::FollowRedirectsAttribute</a> was set in the request, then this function returns the current url that the network API is accessing, i.e the url emitted in the <a href="qnetworkreply.html#redirected">QNetworkReply::redirected</a> signal.</p>
<p><b> 参见 </b><a href="qnetworkreply.html#request">request</a>(), <a href="qnetworkreply.html#setUrl">setUrl</a>(), <a href="qnetworkrequest.html#url">QNetworkRequest::url</a>(), 和 <a href="qnetworkreply.html#redirected">redirected</a>().</p>
<!-- @@@url -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
