<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qnearfieldmanager.cpp -->
  <title>QNearFieldManager Class | Qt NFC 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtnfc-index.html">Qt NFC</a></td><td ><a href="qtnfc-module.html">C++类</a></td><td >QNearFieldManager</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt5.12.0参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
<li class="level2"><a href="#automatically-launching-ndef-message-handlers">Automatically launching NDEF message handlers</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QNearFieldManager Class</h1>
<!-- $$$QNearFieldManager-brief -->
<p>The <a href="qnearfieldmanager.html">QNearFieldManager</a> class provides access to notifications for NFC events. <a href="#details">更多详情...</a></p>
<!-- @@@QNearFieldManager -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QNearFieldManager&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += nfc</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.2</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html">QObject</a></td></tr></table></div><ul>
<li><a href="qnearfieldmanager-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qnearfieldmanager-obsolete.html">过时的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#AdapterState-enum">AdapterState</a></b> { Offline, TurningOn, Online, TurningOff }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#TargetAccessMode-enum">TargetAccessMode</a></b> { NoTargetAccess, NdefReadTargetAccess, NdefWriteTargetAccess, TagTypeSpecificTargetAccess }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#TargetAccessMode-enum">TargetAccessModes</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#QNearFieldManager">QNearFieldManager</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#dtor.QNearFieldManager">~QNearFieldManager</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#isAvailable">isAvailable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#isSupported">isSupported</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#registerNdefMessageHandler">registerNdefMessageHandler</a></b>(QObject *<i>object</i>, const char *<i>method</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#registerNdefMessageHandler-1">registerNdefMessageHandler</a></b>(QNdefRecord::TypeNameFormat <i>typeNameFormat</i>, const QByteArray &amp;<i>type</i>, QObject *<i>object</i>, const char *<i>method</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#registerNdefMessageHandler-2">registerNdefMessageHandler</a></b>(const QNdefFilter &amp;<i>filter</i>, QObject *<i>object</i>, const char *<i>method</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#setTargetAccessModes">setTargetAccessModes</a></b>(QNearFieldManager::TargetAccessModes <i>accessModes</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#startTargetDetection">startTargetDetection</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#stopTargetDetection">stopTargetDetection</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNearFieldManager::TargetAccessModes </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#targetAccessModes">targetAccessModes</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#unregisterNdefMessageHandler">unregisterNdefMessageHandler</a></b>(int <i>handlerId</i>)</td></tr>
</table></div>
<ul>
<li class="fn">31 个公共函数继承于 <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#adapterStateChanged">adapterStateChanged</a></b>(QNearFieldManager::AdapterState <i>state</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#targetDetected">targetDetected</a></b>(QNearFieldTarget *<i>target</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#targetLost">targetLost</a></b>(QNearFieldTarget *<i>target</i>)</td></tr>
</table></div>
<ul>
<li class="fn">2 个信号继承于 <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qnearfieldmanager.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">9 个静态公共成员继承于 <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<h3>其他继承成员有</h3>
<ul>
<li class="fn">1 个属性继承于 <a href="../qtcore/qobject.html#properties">QObject</a></li>
<li class="fn">1 个公共槽函数继承于 <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 个公共变量继承于 <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">9 个保护函数继承于 <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">2 个保护变量继承于 <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QNearFieldManager-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qnearfieldmanager.html">QNearFieldManager</a> class provides access to notifications for NFC events.</p>
<p>NFC Forum devices support two modes of communications. The first mode, peer-to-peer communications, is used to communicate between two NFC Forum devices. The second mode, master/slave communications, is used to communicate between an NFC Forum device and an NFC Forum Tag or Contactless Card. The <a href="qnearfieldmanager.html#targetDetected">targetDetected</a>() signal is emitted when a target device enters communications range. Communications can be initiated from the slot connected to this signal.</p>
<p>NFC Forum devices generally operate as the master in master/slave communications. Some devices are also capable of operating as the slave, so called Card Emulation mode. In this mode the local NFC device emulates a NFC Forum Tag or Contactless Card.</p>
<p>NFC Forum Tags can contain one or more messages in a standardized format. These messages are encapsulated by the <a href="qndefmessage.html">QNdefMessage</a> class. Use the <a href="qnearfieldmanager.html#registerNdefMessageHandler">registerNdefMessageHandler</a>() functions to register message handlers with particular criteria. Handlers can be unregistered with the <a href="qnearfieldmanager.html#unregisterNdefMessageHandler">unregisterNdefMessageHandler</a>() function.</p>
<p>Applications can connect to the <a href="qnearfieldmanager.html#targetDetected">targetDetected</a>() 和 <a href="qnearfieldmanager.html#targetLost">targetLost</a>() signals to get notified when an NFC Forum Tag enters or leaves proximity. Before these signals are emitted target detection must be started with the <a href="qnearfieldmanager.html#startTargetDetection">startTargetDetection</a>() function. Target detection can be stopped with the <a href="qnearfieldmanager.html#stopTargetDetection">stopTargetDetection</a>() function. Before a detected target can be accessed it is necessary to request access rights. This must be done before the target device is touched. The <a href="qnearfieldmanager.html#setTargetAccessModes">setTargetAccessModes</a>() function is used to set the types of access the application wants to perform on the detected target. When access is no longer required the target access modes should be set to <a href="qnearfieldmanager.html#TargetAccessMode-enum">NoTargetAccess</a> as other applications may be blocked from accessing targets. The current target access modes can be retried with the <a href="qnearfieldmanager.html#targetAccessModes">targetAccessModes</a>() function.</p>
<a name="automatically-launching-ndef-message-handlers"></a>
<h4 >Automatically launching NDEF message handlers</h4>
<p>On some platforms it is possible to pre-register an application to receive NDEF messages matching a given criteria. This is useful to get the system to automatically launch your application when a matching NDEF message is received. This removes the need to have the user manually launch NDEF handling applications, prior to touching a tag, or to have those applications always running and using system resources.</p>
<p>The process of registering the handler is different for each platform. Please refer to the platform documentation on how such a registration may be done. If the application has been registered as an NDEF message handler, the application only needs to call the <a href="qnearfieldmanager.html#registerNdefMessageHandler">registerNdefMessageHandler</a>() function:</p>
<pre class="cpp">

  <span class="type"><a href="qnearfieldmanager.html#QNearFieldManager">QNearFieldManager</a></span> <span class="operator">*</span>manager <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qnearfieldmanager.html#QNearFieldManager">QNearFieldManager</a></span>(<span class="keyword">this</span>);
  manager<span class="operator">-</span><span class="operator">&gt;</span>registerNdefMessageHandler(<span class="keyword">this</span><span class="operator">,</span>
              SLOT(handleNdefMessage(<span class="type"><a href="qndefmessage.html">QNdefMessage</a></span><span class="operator">,</span><span class="type"><a href="qnearfieldtarget.html">QNearFieldTarget</a></span><span class="operator">*</span>)));

</pre>
<p>Automatically launching NDEF message handlers is supported on <a href="nfc-android.html">Android</a>.</p>
<a name="nfc-on-linux"></a>
<h5 >NFC on Linux</h5>
<p>The <a href="https://01.org/linux-nfc">Linux NFC project</a> provides software to support NFC on Linux platforms. The neard daemon will allow access to the supported hardware via DBus interfaces. <a href="qtnfc-module.html">QtNfc</a> requires neard version 0.14 which can be built from source or installed via the appropriate Linux package manager. Not all API features are currently supported. To allow <a href="qtnfc-module.html">QtNfc</a> to access the DBus interfaces the neard daemon has to be running. In case of problems debug output can be enabled by enabling categorized logging for 'qt.nfc.neard'.</p>
</div>
<!-- @@@QNearFieldManager -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$AdapterState$$$Offline$$$TurningOn$$$Online$$$TurningOff -->
<h3 class="fn" id="AdapterState-enum"><a name="AdapterState-enum"></a>enum QNearFieldManager::<span class="name">AdapterState</span></h3>
<p>This enum describes the different states a NFC adapter can have.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QNearFieldManager::Offline</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">The nfc adapter is offline.</td></tr>
<tr><td class="topAlign"><code>QNearFieldManager::TurningOn</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">The nfc adapter is turning on.</td></tr>
<tr><td class="topAlign"><code>QNearFieldManager::Online</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">The nfc adapter is online.</td></tr>
<tr><td class="topAlign"><code>QNearFieldManager::TurningOff</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">The nfc adapter is turning off.</td></tr>
</table></div>
<p>这个枚举类型是在Qt 5.12版本中引入或修改的。</p>
<!-- @@@AdapterState -->
<!-- $$$TargetAccessMode$$$NoTargetAccess$$$NdefReadTargetAccess$$$NdefWriteTargetAccess$$$TagTypeSpecificTargetAccess -->
<h3 class="flags" id="TargetAccessMode-enum"><a name="TargetAccessMode-enum"></a>enum QNearFieldManager::<span class="name">TargetAccessMode</span><br/>flags QNearFieldManager::<span class="name">TargetAccessModes</span></h3>
<p>This enum describes the different access modes an application can have.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QNearFieldManager::NoTargetAccess</code></td><td class="topAlign tblval"><code>0x00</code></td><td class="topAlign">The application cannot access NFC capabilities.</td></tr>
<tr><td class="topAlign"><code>QNearFieldManager::NdefReadTargetAccess</code></td><td class="topAlign tblval"><code>0x01</code></td><td class="topAlign">The application can read NDEF messages from targets by calling <a href="qnearfieldtarget.html#readNdefMessages">QNearFieldTarget::readNdefMessages</a>().</td></tr>
<tr><td class="topAlign"><code>QNearFieldManager::NdefWriteTargetAccess</code></td><td class="topAlign tblval"><code>0x02</code></td><td class="topAlign">The application can write NDEF messages to targets by calling <a href="qnearfieldtarget.html#writeNdefMessages">QNearFieldTarget::writeNdefMessages</a>().</td></tr>
<tr><td class="topAlign"><code>QNearFieldManager::TagTypeSpecificTargetAccess</code></td><td class="topAlign tblval"><code>0x04</code></td><td class="topAlign">The application can access targets using raw commands by calling <a href="qnearfieldtarget.html#sendCommand">QNearFieldTarget::sendCommand</a>().</td></tr>
</table></div>
<p>The TargetAccessModes type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;TargetAccessMode&gt;. It stores an OR combination of TargetAccessMode values.</p>
<!-- @@@TargetAccessMode -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QNearFieldManager[overload1]$$$QNearFieldManagerQObject* -->
<h3 class="fn" id="QNearFieldManager"><a name="QNearFieldManager"></a>QNearFieldManager::<span class="name">QNearFieldManager</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new near field manager with <i>parent</i>.</p>
<!-- @@@QNearFieldManager -->
<!-- $$$~QNearFieldManager[overload1]$$$~QNearFieldManager -->
<h3 class="fn" id="dtor.QNearFieldManager"><a name="dtor.QNearFieldManager"></a><code>[虚函数] </code>QNearFieldManager::<span class="name">~QNearFieldManager</span>()</h3>
<p>Destroys the near field manager.</p>
<!-- @@@~QNearFieldManager -->
<!-- $$$adapterStateChanged[overload1]$$$adapterStateChangedQNearFieldManager::AdapterState -->
<h3 class="fn" id="adapterStateChanged"><a name="adapterStateChanged"></a><code>[信号] </code><span class="type">void</span> QNearFieldManager::<span class="name">adapterStateChanged</span>(<span class="type"><a href="qnearfieldmanager.html#AdapterState-enum">QNearFieldManager::AdapterState</a></span> <i>state</i>)</h3>
<p>This signal is emitted whenever the state of the NFC adapter changed.</p>
<p><b>注意： </b>Currently, this signal is only emitted on Android.</p><p>这个函数是在Qt 5.12版本中新增引入的。</p>
<!-- @@@adapterStateChanged -->
<!-- $$$isAvailable[overload1]$$$isAvailable -->
<h3 class="fn" id="isAvailable"><a name="isAvailable"></a><span class="type">bool</span> QNearFieldManager::<span class="name">isAvailable</span>() const</h3>
<p>Returns <code>true</code> if the device has a NFC adapter and it is turned on; 否则则返回 <code>false</code>。</p>
<p><b> 参见 </b><a href="qnearfieldmanager.html#isSupported">isSupported</a>().</p>
<!-- @@@isAvailable -->
<!-- $$$isSupported[overload1]$$$isSupported -->
<h3 class="fn" id="isSupported"><a name="isSupported"></a><span class="type">bool</span> QNearFieldManager::<span class="name">isSupported</span>() const</h3>
<p>Returns <code>true</code> if the underlying device has a NFC adapter; 否则则返回 <code>false</code>。</p>
<p>这个函数是在Qt 5.12版本中新增引入的。</p>
<p><b> 参见 </b><a href="qnearfieldmanager.html#isAvailable">isAvailable</a>().</p>
<!-- @@@isSupported -->
<!-- $$$registerNdefMessageHandler[overload1]$$$registerNdefMessageHandlerQObject*constchar* -->
<h3 class="fn" id="registerNdefMessageHandler"><a name="registerNdefMessageHandler"></a><span class="type">int</span> QNearFieldManager::<span class="name">registerNdefMessageHandler</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>, const <span class="type">char</span> *<i>method</i>)</h3>
<p>Registers <i>object</i> to receive notifications on <i>method</i> when a tag has been detected and has an NDEF message that matches a pre-registered message format. The <i>method</i> on <i>object</i> should have the prototype 'void <a href="qnearfieldmanager.html#targetDetected">targetDetected</a>(const <a href="qndefmessage.html">QNdefMessage</a> &amp;message, <a href="qnearfieldtarget.html">QNearFieldTarget</a> *target)'.</p>
<p>Returns an identifier, which can be used to unregister the handler, on success; otherwise returns -1.</p>
<p>This function is used to register a <a href="qnearfieldmanager.html">QNearFieldManager</a> instance to receive notifications when a NDEF message matching a pre-registered message format is received. See the section on <a href="qnearfieldmanager.html#automatically-launching-ndef-message-handlers">Automatically launching NDEF message handlers</a>.</p>
<p><b>注意： </b>The <i>target</i> parameter of <i>method</i> may not be available on all platforms, in which case <i>target</i> will be 0.</p><!-- @@@registerNdefMessageHandler -->
<!-- $$$registerNdefMessageHandler$$$registerNdefMessageHandlerQNdefRecord::TypeNameFormatconstQByteArray&QObject*constchar* -->
<h3 class="fn" id="registerNdefMessageHandler-1"><a name="registerNdefMessageHandler-1"></a><span class="type">int</span> QNearFieldManager::<span class="name">registerNdefMessageHandler</span>(<span class="type"><a href="qndefrecord.html#TypeNameFormat-enum">QNdefRecord::TypeNameFormat</a></span> <i>typeNameFormat</i>, const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>type</i>, <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>, const <span class="type">char</span> *<i>method</i>)</h3>
<p>Registers <i>object</i> to receive notifications on <i>method</i> when a tag has been detected and has an NDEF record that matches <i>typeNameFormat</i> and <i>type</i>. The <i>method</i> on <i>object</i> should have the prototype 'void <a href="qnearfieldmanager.html#targetDetected">targetDetected</a>(const <a href="qndefmessage.html">QNdefMessage</a> &amp;message, <a href="qnearfieldtarget.html">QNearFieldTarget</a> *target)'.</p>
<p>Returns an identifier, which can be used to unregister the handler, on success; otherwise returns -1.</p>
<p><b>注意： </b>The <i>target</i> parameter of <i>method</i> may not be available on all platforms, in which case <i>target</i> will be 0.</p><p><b>注意： </b>On platforms using neard registering message handlers is not supported.</p><!-- @@@registerNdefMessageHandler -->
<!-- $$$registerNdefMessageHandler$$$registerNdefMessageHandlerconstQNdefFilter&QObject*constchar* -->
<h3 class="fn" id="registerNdefMessageHandler-2"><a name="registerNdefMessageHandler-2"></a><span class="type">int</span> QNearFieldManager::<span class="name">registerNdefMessageHandler</span>(const <span class="type"><a href="qndeffilter.html">QNdefFilter</a></span> &amp;<i>filter</i>, <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>, const <span class="type">char</span> *<i>method</i>)</h3>
<p>Registers <i>object</i> to receive notifications on <i>method</i> when a tag has been detected and has an NDEF message that matches <i>filter</i> is detected. The <i>method</i> on <i>object</i> should have the prototype 'void <a href="qnearfieldmanager.html#targetDetected">targetDetected</a>(const <a href="qndefmessage.html">QNdefMessage</a> &amp;message, <a href="qnearfieldtarget.html">QNearFieldTarget</a> *target)'.</p>
<p>Returns an identifier, which can be used to unregister the handler, on success; otherwise returns -1.</p>
<p><b>注意： </b>The <i>target</i> parameter of <i>method</i> may not be available on all platforms, in which case <i>target</i> will be 0.</p><!-- @@@registerNdefMessageHandler -->
<!-- $$$setTargetAccessModes[overload1]$$$setTargetAccessModesQNearFieldManager::TargetAccessModes -->
<h3 class="fn" id="setTargetAccessModes"><a name="setTargetAccessModes"></a><span class="type">void</span> QNearFieldManager::<span class="name">setTargetAccessModes</span>(<span class="type"><a href="qnearfieldmanager.html#TargetAccessMode-enum">QNearFieldManager::TargetAccessModes</a></span> <i>accessModes</i>)</h3>
<p>Sets the requested target access modes to <i>accessModes</i>.</p>
<p><b> 参见 </b><a href="qnearfieldmanager.html#targetAccessModes">targetAccessModes</a>().</p>
<!-- @@@setTargetAccessModes -->
<!-- $$$startTargetDetection[overload1]$$$startTargetDetection -->
<h3 class="fn" id="startTargetDetection"><a name="startTargetDetection"></a><span class="type">bool</span> QNearFieldManager::<span class="name">startTargetDetection</span>()</h3>
<p>Starts detecting targets and returns true if target detection is successfully started; otherwise returns false. Causes the <a href="qnearfieldmanager.html#targetDetected">targetDetected</a>() signal to be emitted when a target is within proximity.</p>
<p><b>注意： </b>For platforms using neard: target detection will stop as soon as a tag has been detected.</p><p><b> 参见 </b><a href="qnearfieldmanager.html#stopTargetDetection">stopTargetDetection</a>().</p>
<!-- @@@startTargetDetection -->
<!-- $$$stopTargetDetection[overload1]$$$stopTargetDetection -->
<h3 class="fn" id="stopTargetDetection"><a name="stopTargetDetection"></a><span class="type">void</span> QNearFieldManager::<span class="name">stopTargetDetection</span>()</h3>
<p>Stops detecting targets. The <a href="qnearfieldmanager.html#targetDetected">targetDetected</a>() signal will no longer be emitted until another call to <a href="qnearfieldmanager.html#startTargetDetection">startTargetDetection</a>() is made.</p>
<!-- @@@stopTargetDetection -->
<!-- $$$targetAccessModes[overload1]$$$targetAccessModes -->
<h3 class="fn" id="targetAccessModes"><a name="targetAccessModes"></a><span class="type"><a href="qnearfieldmanager.html#TargetAccessMode-enum">QNearFieldManager::TargetAccessModes</a></span> QNearFieldManager::<span class="name">targetAccessModes</span>() const</h3>
<p>Returns current requested target access modes.</p>
<p><b> 参见 </b><a href="qnearfieldmanager.html#setTargetAccessModes">setTargetAccessModes</a>().</p>
<!-- @@@targetAccessModes -->
<!-- $$$targetDetected[overload1]$$$targetDetectedQNearFieldTarget* -->
<h3 class="fn" id="targetDetected"><a name="targetDetected"></a><code>[信号] </code><span class="type">void</span> QNearFieldManager::<span class="name">targetDetected</span>(<span class="type"><a href="qnearfieldtarget.html">QNearFieldTarget</a></span> *<i>target</i>)</h3>
<p>This signal is emitted whenever a target is detected. The <i>target</i> parameter represents the detected target.</p>
<p>This signal will be emitted for all detected targets.</p>
<p><a href="qnearfieldmanager.html">QNearFieldManager</a> maintains ownership of <i>target</i>, however, it will not be destroyed until the <a href="qnearfieldmanager.html">QNearFieldManager</a> destructor is called. Ownership may be transferred by calling <a href="../qtcore/qobject.html#setParent">setParent</a>().</p>
<p>Do not delete <i>target</i> from the slot connected to this signal, instead call <a href="../qtcore/qobject.html#deleteLater">deleteLater</a>().</p>
<p><b>注意： </b>that if <i>target</i> is deleted before it moves out of proximity the <a href="qnearfieldmanager.html#targetLost">targetLost</a>() signal will not be emitted.</p><p><b> 参见 </b><a href="qnearfieldmanager.html#targetLost">targetLost</a>().</p>
<!-- @@@targetDetected -->
<!-- $$$targetLost[overload1]$$$targetLostQNearFieldTarget* -->
<h3 class="fn" id="targetLost"><a name="targetLost"></a><code>[信号] </code><span class="type">void</span> QNearFieldManager::<span class="name">targetLost</span>(<span class="type"><a href="qnearfieldtarget.html">QNearFieldTarget</a></span> *<i>target</i>)</h3>
<p>This signal is emitted whenever a target moves out of proximity. The <i>target</i> parameter represents the lost target.</p>
<p>Do not delete <i>target</i> from the slot connected to this signal, instead use <a href="../qtcore/qobject.html#deleteLater">deleteLater</a>().</p>
<p><b> 参见 </b><a href="qnearfieldtarget.html#disconnected">QNearFieldTarget::disconnected</a>().</p>
<!-- @@@targetLost -->
<!-- $$$unregisterNdefMessageHandler[overload1]$$$unregisterNdefMessageHandlerint -->
<h3 class="fn" id="unregisterNdefMessageHandler"><a name="unregisterNdefMessageHandler"></a><span class="type">bool</span> QNearFieldManager::<span class="name">unregisterNdefMessageHandler</span>(<span class="type">int</span> <i>handlerId</i>)</h3>
<p>Unregisters the target detect handler identified by <i>handlerId</i>.</p>
<p>Returns true on success; otherwise returns false.</p>
<!-- @@@unregisterNdefMessageHandler -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
