<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qx11info_x11.cpp -->
  <title>QX11Info Class | Qt X11 Extras 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtx11extras-index.html">Qt X11 扩展包</a></td><td ><a href="qtx11extras-module.html">C++ 类</a></td><td >QX11Info</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.12.0 参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公共类型</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QX11Info类</h1>
<!-- $$$QX11Info-brief -->
<p>提供了关于X显示配置的信息. <a href="#details">更多...</a></p>
<!-- @@@QX11Info -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件:</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QX11Info&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += x11extras</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 开始于:</td><td class="memItemRight bottomAlign">  Qt 5.1</td></tr></table></div><ul>
<li><a href="qx11info-members.html">所有成员清单列表，包括继承而来的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公共类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#PeekOption-enum">PeekOption</a></b> { PeekDefault, PeekFromCachedIndex }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#PeekOption-enum">PeekOptions</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#PeekerCallback-typedef">PeekerCallback</a></b></td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#appDpiX">appDpiX</a></b>(int <i>screen</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#appDpiY">appDpiY</a></b>(int <i>screen</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> unsigned long </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#appRootWindow">appRootWindow</a></b>(int <i>screen</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#appScreen">appScreen</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> unsigned long </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#appTime">appTime</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> unsigned long </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#appUserTime">appUserTime</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> xcb_connection_t *</td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#connection">connection</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Display *</td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#display">display</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint32 </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#generatePeekerId">generatePeekerId</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> unsigned long </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#getTimestamp">getTimestamp</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#isCompositingManagerRunning">isCompositingManagerRunning</a></b>(int <i>screen</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#isPlatformX11">isPlatformX11</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#nextStartupId">nextStartupId</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#peekEventQueue">peekEventQueue</a></b>(QX11Info::PeekerCallback <i>peeker</i>, void *<i>peekerData</i> = nullptr, QX11Info::PeekOptions <i>option</i> = PeekDefault, qint32 <i>peekerId</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#removePeekerId">removePeekerId</a></b>(qint32 <i>peekerId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#setAppTime">setAppTime</a></b>(unsigned long <i>time</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#setAppUserTime">setAppUserTime</a></b>(unsigned long <i>time</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qx11info.html#setNextStartupId">setNextStartupId</a></b>(const QByteArray &amp;<i>id</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QX11Info-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>提供了关于X显示配置的信息。</p>
<p>此类提供了2种APIs:非静态函数集合提供了关于特定部件或位图的接口，静态函数集合提供了应用程序的默认信息的接口。</p>
<p><b>警告:</b> 此类只适用于X11平台。若想便捷的查询单屏信息，请使用 QDesktopWidget类。</p>
</div>
<!-- @@@QX11Info -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$PeekOption$$$PeekDefault$$$PeekFromCachedIndex -->
<h3 class="flags" id="PeekOption-enum"><a name="PeekOption-enum"></a>enum QX11Info::<span class="name">PeekOption</span><br/>flags QX11Info::<span class="name">PeekOptions</span></h3>
<p>An enum to tune the behavior of <a href="qx11info.html#peekEventQueue">QX11Info::peekEventQueue</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QX11Info::PeekDefault</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">Peek from the beginning of the buffered native event queue. A peeker id is optional with PeekDefault. If a peeker id is provided to <a href="qx11info.html#peekEventQueue">peekEventQueue</a>() when using PeekDefault, then peeking starts from the beginning of the queue, not from the cached index; thus, this can be used to manually reset a cached index to peek from the start of the queue. When this operation completes, the associated index will be updated to the new position in the queue.</td></tr>
<tr><td class="topAlign"><code>QX11Info::PeekFromCachedIndex</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign"><a href="qx11info.html#peekEventQueue">QX11Info::peekEventQueue</a>() can optimize the peeking algorithm by skipping events that it already has seen in earlier calls to <a href="qx11info.html#peekEventQueue">peekEventQueue</a>(). When control returns to the main event loop, which causes the buffered native event queue to be flushed to Qt's event queue, the cached indices are marked invalid and will be reset on the next access. The same is true if the program explicitly flushes the buffered native event queue by <a href="../qtcore/qcoreapplication.html#processEvents">QCoreApplication::processEvents</a>().</td></tr>
</table></div>
<p>This enum was introduced or modified in  Qt 5.10.</p>
<p>The PeekOptions type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;PeekOption&gt;. It stores an OR combination of PeekOption values.</p>
<!-- @@@PeekOption -->
<!-- $$$PeekerCallback -->
<h3 class="fn" id="PeekerCallback-typedef"><a name="PeekerCallback-typedef"></a>typedef QX11Info::<span class="name">PeekerCallback</span></h3>
<p>Typedef for a pointer to a function with the following signature:</p>
<pre class="cpp">

  bool (<span class="operator">*</span>PeekerCallback)(xcb_generic_event_t <span class="operator">*</span>event<span class="operator">,</span> <span class="type">void</span> <span class="operator">*</span>peekerData);

</pre>
<p>The <i>event</i> is a native XCB event. The <i>peekerData</i> is a pointer to data, passed in via <a href="qx11info.html#peekEventQueue">peekEventQueue</a>().</p>
<p>Return <code>true</code> from this function to stop examining the buffered native event queue or <code>false</code> to continue.</p>
<p><b>Note: </b>A non-capturing lambda can serve as a PeekerCallback.</p><p>This typedef was introduced in  Qt 5.10.</p>
<!-- @@@PeekerCallback -->
</div>
<div class="prop">
<h2>属性文档</h2>
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$appDpiX[overload1]$$$appDpiXint -->
<h3 class="fn" id="appDpiX"><a name="appDpiX"></a><code>[静态] </code><span class="type">int</span> QX11Info::<span class="name">appDpiX</span>(<span class="type">int</span> <i>screen</i> = -1)</h3>
<p>Returns the horizontal resolution of the given <i>screen</i> in terms of the number of dots per inch.</p>
<p>The <i>screen</i> argument is an X screen number. Be aware that if the user's system uses Xinerama (as opposed to traditional X11 multiscreen), there is only one X screen. Use QDesktopWidget to query for information about Xinerama screens.</p>
<p><b>参见</b><a href="qx11info.html#appDpiY">appDpiY</a>().</p>
<!-- @@@appDpiX -->
<!-- $$$appDpiY[overload1]$$$appDpiYint -->
<h3 class="fn" id="appDpiY"><a name="appDpiY"></a><code>[静态] </code><span class="type">int</span> QX11Info::<span class="name">appDpiY</span>(<span class="type">int</span> <i>screen</i> = -1)</h3>
<p>Returns the vertical resolution of the given <i>screen</i> in terms of the number of dots per inch.</p>
<p>The <i>screen</i> argument is an X screen number. Be aware that if the user's system uses Xinerama (as opposed to traditional X11 multiscreen), there is only one X screen. Use QDesktopWidget to query for information about Xinerama screens.</p>
<p><b>参见</b><a href="qx11info.html#appDpiX">appDpiX</a>().</p>
<!-- @@@appDpiY -->
<!-- $$$appRootWindow[overload1]$$$appRootWindowint -->
<h3 class="fn" id="appRootWindow"><a name="appRootWindow"></a><code>[静态] </code><span class="type">unsigned</span> <span class="type">long</span> QX11Info::<span class="name">appRootWindow</span>(<span class="type">int</span> <i>screen</i> = -1)</h3>
<!-- @@@appRootWindow -->
<!-- $$$appScreen[overload1]$$$appScreen -->
<h3 class="fn" id="appScreen"><a name="appScreen"></a><code>[静态] </code><span class="type">int</span> QX11Info::<span class="name">appScreen</span>()</h3>
<p>Returns the number of the screen where the application is being displayed.</p>
<p>This method refers to screens in the original X11 meaning with a different DISPLAY environment variable per screen. This information is only useful if your application needs to know on which X screen it is running.</p>
<p>In a typical multi-head configuration, multiple physical monitors are combined in one X11 screen. This means this method returns the same number for each of the physical monitors. In such a setup you are interested in the monitor information as provided by the X11 RandR extension. This is available through QDesktopWidget and QScreen.</p>
<p><b>参见</b><a href="qx11info.html#display">display</a>().</p>
<!-- @@@appScreen -->
<!-- $$$appTime[overload1]$$$appTime -->
<h3 class="fn" id="appTime"><a name="appTime"></a><code>[静态] </code><span class="type">unsigned</span> <span class="type">long</span> QX11Info::<span class="name">appTime</span>()</h3>
<p>Returns the X11 time.</p>
<p><b>参见</b><a href="qx11info.html#setAppTime">setAppTime</a>() and <a href="qx11info.html#appUserTime">appUserTime</a>().</p>
<!-- @@@appTime -->
<!-- $$$appUserTime[overload1]$$$appUserTime -->
<h3 class="fn" id="appUserTime"><a name="appUserTime"></a><code>[静态] </code><span class="type">unsigned</span> <span class="type">long</span> QX11Info::<span class="name">appUserTime</span>()</h3>
<p>Returns the X11 user time.</p>
<p><b>参见</b><a href="qx11info.html#setAppUserTime">setAppUserTime</a>() and <a href="qx11info.html#appTime">appTime</a>().</p>
<!-- @@@appUserTime -->
<!-- $$$connection[overload1]$$$connection -->
<h3 class="fn" id="connection"><a name="connection"></a><code>[静态] </code><span class="type">xcb_connection_t</span> *QX11Info::<span class="name">connection</span>()</h3>
<p>Returns the default XCB connection for the application.</p>
<p><b>参见</b><a href="qx11info.html#display">display</a>().</p>
<!-- @@@connection -->
<!-- $$$display[overload1]$$$display -->
<h3 class="fn" id="display"><a name="display"></a><code>[静态] </code><span class="type">Display</span> *QX11Info::<span class="name">display</span>()</h3>
<p>Returns the default display for the application.</p>
<p><b>参见</b><a href="qx11info.html#appScreen">appScreen</a>().</p>
<!-- @@@display -->
<!-- $$$generatePeekerId[overload1]$$$generatePeekerId -->
<h3 class="fn" id="generatePeekerId"><a name="generatePeekerId"></a><code>[静态] </code><span class="type"><a href="../qtcore/qtglobal.html#qint32-typedef">qint32</a></span> QX11Info::<span class="name">generatePeekerId</span>()</h3>
<p>Returns a new peeker id or -1 if some interal error has occurred. Each peeker id is associated with an index in the buffered native event queue.</p>
<p>For more details see <a href="qx11info.html#PeekOption-enum">QX11Info::PeekOption</a> and <a href="qx11info.html#peekEventQueue">peekEventQueue</a>().</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b>参见</b><a href="qx11info.html#peekEventQueue">peekEventQueue</a>() and <a href="qx11info.html#removePeekerId">removePeekerId</a>().</p>
<!-- @@@generatePeekerId -->
<!-- $$$getTimestamp[overload1]$$$getTimestamp -->
<h3 class="fn" id="getTimestamp"><a name="getTimestamp"></a><code>[静态] </code><span class="type">unsigned</span> <span class="type">long</span> QX11Info::<span class="name">getTimestamp</span>()</h3>
<p>Fetches the current X11 time stamp from the X Server.</p>
<p>This method creates a property notify event and blocks till it is received back from the X Server.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@getTimestamp -->
<!-- $$$isCompositingManagerRunning[overload1]$$$isCompositingManagerRunningint -->
<h3 class="fn" id="isCompositingManagerRunning"><a name="isCompositingManagerRunning"></a><code>[静态] </code><span class="type">bool</span> QX11Info::<span class="name">isCompositingManagerRunning</span>(<span class="type">int</span> <i>screen</i> = -1)</h3>
<p>Returns true if there is a compositing manager running for the connection attached to <i>screen</i>.</p>
<p>If <i>screen</i> equals -1, the application's primary screen is used.</p>
<p>这个函数是在Qt 5.7版本中新增引入的。</p>
<!-- @@@isCompositingManagerRunning -->
<!-- $$$isPlatformX11[overload1]$$$isPlatformX11 -->
<h3 class="fn" id="isPlatformX11"><a name="isPlatformX11"></a><code>[静态] </code><span class="type">bool</span> QX11Info::<span class="name">isPlatformX11</span>()</h3>
<p>Returns true if the application is currently running on X11.</p>
<p>这个函数是在Qt 5.2版本中新增引入的。</p>
<!-- @@@isPlatformX11 -->
<!-- $$$nextStartupId[overload1]$$$nextStartupId -->
<h3 class="fn" id="nextStartupId"><a name="nextStartupId"></a><code>[静态] </code><span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> QX11Info::<span class="name">nextStartupId</span>()</h3>
<p>Returns the startup ID that will be used for the next window to be shown by this process.</p>
<p>After the next window is shown, the next startup ID will be empty.</p>
<p>http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b>参见</b><a href="qx11info.html#setNextStartupId">setNextStartupId</a>().</p>
<!-- @@@nextStartupId -->
<!-- $$$peekEventQueue[overload1]$$$peekEventQueueQX11Info::PeekerCallbackvoid*QX11Info::PeekOptionsqint32 -->
<h3 class="fn" id="peekEventQueue"><a name="peekEventQueue"></a><code>[静态] </code><span class="type">bool</span> QX11Info::<span class="name">peekEventQueue</span>(<span class="type"><a href="qx11info.html#PeekerCallback-typedef">QX11Info::PeekerCallback</a></span> <i>peeker</i>, <span class="type">void</span> *<i>peekerData</i> = nullptr, <span class="type"><a href="qx11info.html#PeekOption-enum">QX11Info::PeekOptions</a></span> <i>option</i> = PeekDefault, <span class="type"><a href="../qtcore/qtglobal.html#qint32-typedef">qint32</a></span> <i>peekerId</i> = -1)</h3>
<p>Peek into the buffered XCB event queue.</p>
<p>You can call peekEventQueue() periodically, when your program is busy performing a long-running operation, to peek into the buffered native event queue. The more time the long-running operation blocks the program from returning control to the main event loop, the more events will accumulate in the buffered XCB event queue. Once control returns to the main event loop these events will be flushed to Qt's event queue, which is a separate event queue from the queue this function is peeking into.</p>
<p><b>Note: </b>It is usually better to run CPU-intensive operations in a non-GUI thread, instead of blocking the main event loop.</p><p>The buffered XCB event queue is populated from a non-GUI thread and therefore might be ahead of the current GUI state. To handle native events as they are processed by the GUI thread, see <a href="../qtcore/qabstractnativeeventfilter.html#nativeEventFilter">QAbstractNativeEventFilter::nativeEventFilter</a>().</p>
<p>The <i>peeker</i> is a callback function as documented in <a href="qx11info.html#PeekerCallback-typedef">PeekerCallback</a>. The <i>peekerData</i> can be used to pass in arbitrary data to the <i>peeker</i> callback. The <i>option</i> is an enum that tunes the behavior of peekEventQueue(). The <i>peekerId</i> is used to track an index in the queue, for more details see <a href="qx11info.html#PeekOption-enum">QX11Info::PeekOption</a>. There can be several indices, each tracked individually by a peeker id obtained via <a href="qx11info.html#generatePeekerId">generatePeekerId</a>().</p>
<p>This function returns <code>true</code> when the peeker has stopped the event proccesing by returning <code>true</code> from the callback. If there were no events in the buffered native event queue to peek at or all the events have been processed by the peeker, this function returns <code>false</code>.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b>参见</b><a href="qx11info.html#generatePeekerId">generatePeekerId</a>() and <a href="../qtcore/qabstractnativeeventfilter.html#nativeEventFilter">QAbstractNativeEventFilter::nativeEventFilter</a>().</p>
<!-- @@@peekEventQueue -->
<!-- $$$removePeekerId[overload1]$$$removePeekerIdqint32 -->
<h3 class="fn" id="removePeekerId"><a name="removePeekerId"></a><code>[静态] </code><span class="type">bool</span> QX11Info::<span class="name">removePeekerId</span>(<span class="type"><a href="../qtcore/qtglobal.html#qint32-typedef">qint32</a></span> <i>peekerId</i>)</h3>
<p>Removes <i>peekerId</i>, which was earlier obtained via <a href="qx11info.html#generatePeekerId">generatePeekerId</a>().</p>
<p>Returns <code>true</code> on success or <code>false</code> if unknown peeker id was provided or some interal error has occurred.</p>
<p>这个函数是在Qt 5.10版本中新增引入的。</p>
<p><b>参见</b><a href="qx11info.html#generatePeekerId">generatePeekerId</a>().</p>
<!-- @@@removePeekerId -->
<!-- $$$setAppTime[overload1]$$$setAppTimeunsignedlong -->
<h3 class="fn" id="setAppTime"><a name="setAppTime"></a><code>[静态] </code><span class="type">void</span> QX11Info::<span class="name">setAppTime</span>(<span class="type">unsigned</span> <span class="type">long</span> <i>time</i>)</h3>
<p>Sets the X11 time to the value specified by <i>time</i>.</p>
<p><b>参见</b><a href="qx11info.html#appTime">appTime</a>() and <a href="qx11info.html#setAppUserTime">setAppUserTime</a>().</p>
<!-- @@@setAppTime -->
<!-- $$$setAppUserTime[overload1]$$$setAppUserTimeunsignedlong -->
<h3 class="fn" id="setAppUserTime"><a name="setAppUserTime"></a><code>[静态] </code><span class="type">void</span> QX11Info::<span class="name">setAppUserTime</span>(<span class="type">unsigned</span> <span class="type">long</span> <i>time</i>)</h3>
<p>Sets the X11 user time as specified by <i>time</i>.</p>
<p><b>参见</b><a href="qx11info.html#appUserTime">appUserTime</a>() and <a href="qx11info.html#setAppTime">setAppTime</a>().</p>
<!-- @@@setAppUserTime -->
<!-- $$$setNextStartupId[overload1]$$$setNextStartupIdconstQByteArray& -->
<h3 class="fn" id="setNextStartupId"><a name="setNextStartupId"></a><code>[静态] </code><span class="type">void</span> QX11Info::<span class="name">setNextStartupId</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>id</i>)</h3>
<p>Sets the next startup ID to <i>id</i>.</p>
<p>This is the startup ID that will be used for the next window to be shown by this process.</p>
<p>The startup ID of the first window comes from the environment variable DESKTOP_STARTUP_ID. This method is useful for subsequent windows, when the request comes from another process (e.g&#x2e; via DBus).</p>
<p>这个函数是在Qt 5.4版本中新增引入的。</p>
<p><b>参见</b><a href="qx11info.html#nextStartupId">nextStartupId</a>().</p>
<!-- @@@setNextStartupId -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关非成员变量文档</h2>
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
