<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qsurfacedataproxy.cpp -->
  <title>QSurfaceDataProxy Class | Qt数据可视化5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtdatavisualization-index.html">Qt数据可视化</a></td><td ><a href="qtdatavisualization-module.html">C++类</a></td><td >QSurfaceDataProxy</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt Data Visualization | Commercial or GPLv3</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公共成员</a></li>
<li class="level1"><a href="#related-non-members">相关的非成员</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QSurfaceDataProxy Class</h1>
<!-- $$$QSurfaceDataProxy-brief -->
<p>The <a href="qsurfacedataproxy.html">QSurfaceDataProxy</a> class is the data proxy for a 3D surface graph. <a href="#details">More...</a></p>
<!-- @@@QSurfaceDataProxy -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> 头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QSurfaceDataProxy&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  QtDataVisualization 1.0</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Instantiated By:</td><td class="memItemRight bottomAlign"> <a href="qml-qtdatavisualization-surfacedataproxy.html">SurfaceDataProxy</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的父类是：</td><td class="memItemRight bottomAlign"> <a href="qabstractdataproxy.html">QAbstractDataProxy</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> 继承的子类有：</td><td class="memItemRight bottomAlign"> <p><a href="qheightmapsurfacedataproxy.html">QHeightMapSurfaceDataProxy</a> 和 <a href="qitemmodelsurfacedataproxy.html">QItemModelSurfaceDataProxy</a></p>
</td></tr></table></div><ul>
<li><a href="qsurfacedataproxy-members.html">所有成员清单，包括继承而来的成员</a></li>
<li><a href="qsurfacedataproxy-obsolete.html">过时的成员</a></li>
</ul>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<ul>
<li class="fn"><b><a href="qsurfacedataproxy.html#columnCount-prop">columnCount</a></b> : const int</li>
<li class="fn"><b><a href="qsurfacedataproxy.html#rowCount-prop">rowCount</a></b> : const int</li>
<li class="fn"><b><a href="qsurfacedataproxy.html#series-prop">series</a></b> : QSurface3DSeries* const</li>
</ul>
<ul>
<li class="fn">1 property inherited from <a href="qabstractdataproxy.html#properties">QAbstractDataProxy</a></li>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#QSurfaceDataProxy">QSurfaceDataProxy</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#dtor.QSurfaceDataProxy">~QSurfaceDataProxy</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#addRow">addRow</a></b>(QSurfaceDataRow *<i>row</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#addRows">addRows</a></b>(const QSurfaceDataArray &amp;<i>rows</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QSurfaceDataArray *</td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#array">array</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#columnCount-prop">columnCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#insertRow">insertRow</a></b>(int <i>rowIndex</i>, QSurfaceDataRow *<i>row</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#insertRows">insertRows</a></b>(int <i>rowIndex</i>, const QSurfaceDataArray &amp;<i>rows</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QSurfaceDataItem *</td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#itemAt">itemAt</a></b>(int <i>rowIndex</i>, int <i>columnIndex</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QSurfaceDataItem *</td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#itemAt-1">itemAt</a></b>(const QPoint &amp;<i>position</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#removeRows">removeRows</a></b>(int <i>rowIndex</i>, int <i>removeCount</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#resetArray">resetArray</a></b>(QSurfaceDataArray *<i>newArray</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#rowCount-prop">rowCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSurface3DSeries *</td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#series-prop">series</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#setItem">setItem</a></b>(int <i>rowIndex</i>, int <i>columnIndex</i>, const QSurfaceDataItem &amp;<i>item</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#setItem-1">setItem</a></b>(const QPoint &amp;<i>position</i>, const QSurfaceDataItem &amp;<i>item</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#setRow">setRow</a></b>(int <i>rowIndex</i>, QSurfaceDataRow *<i>row</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#setRows">setRows</a></b>(int <i>rowIndex</i>, const QSurfaceDataArray &amp;<i>rows</i>)</td></tr>
</table></div>
<ul>
<li class="fn">1 public function inherited from <a href="qabstractdataproxy.html#public-functions">QAbstractDataProxy</a></li>
<li class="fn">31 public functions inherited from <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#arrayReset">arrayReset</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#columnCount-prop">columnCountChanged</a></b>(int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#itemChanged">itemChanged</a></b>(int <i>rowIndex</i>, int <i>columnIndex</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#rowCount-prop">rowCountChanged</a></b>(int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#rowsAdded">rowsAdded</a></b>(int <i>startIndex</i>, int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#rowsChanged">rowsChanged</a></b>(int <i>startIndex</i>, int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#rowsInserted">rowsInserted</a></b>(int <i>startIndex</i>, int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#rowsRemoved">rowsRemoved</a></b>(int <i>startIndex</i>, int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#series-prop">seriesChanged</a></b>(QSurface3DSeries *<i>series</i>)</td></tr>
</table></div>
<ul>
<li class="fn">2 signals inherited from <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公共成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">1 static public member inherited from <a href="qabstractdataproxy.html#static-public-members">QAbstractDataProxy</a></li>
<li class="fn">9 static public members inherited from <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="related-non-members"></a>
<h2 id="related-non-members">相关的非成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#QSurfaceDataArray-typedef">QSurfaceDataArray</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qsurfacedataproxy.html#QSurfaceDataRow-typedef">QSurfaceDataRow</a></b></td></tr>
</table></div>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 public slot inherited from <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 public variable inherited from <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 protected type inherited from <a href="qabstractdataproxy.html#protected-variables">QAbstractDataProxy</a></li>
<li class="fn">2 protected variables inherited from <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QSurfaceDataProxy-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qsurfacedataproxy.html">QSurfaceDataProxy</a> class is the data proxy for a 3D surface graph.</p>
<p>A surface data proxy handles surface related data in rows. For this it provides two auxiliary typedefs: QtDataVisualization::QSurfaceDataArray and QtDataVisualization::QSurfaceDataRow. <code>QSurfaceDataArray</code> is a <a href="../qtcore/qlist.html">QList</a> that controls the rows. <code>QSurfaceDataRow</code> is a <a href="../qtcore/qvector.html">QVector</a> that contains <a href="qsurfacedataitem.html">QSurfaceDataItem</a> objects. For more information about how to feed the data to the proxy, see the sample code in the <a href="q3dsurface.html">Q3DSurface</a> documentation.</p>
<p>All rows must have the same number of items.</p>
<p><a href="qsurfacedataproxy.html">QSurfaceDataProxy</a> takes ownership of all <code>QSurfaceDataRow</code> objects passed to it, whether directly or in a <code>QSurfaceDataArray</code> container. To use surface data row pointers to directly modify data after adding the array to the proxy, the appropriate signal must be emitted to update the graph.</p>
<p>To make a sensible surface, the x-value of each successive item in all rows must be either ascending or descending throughout the row. Similarly, the z-value of each successive item in all columns must be either ascending or descending throughout the column.</p>
<p><b>Note: </b>Currently only surfaces with straight rows and columns are fully supported. Any row with items that do not have the exact same z-value or any column with items that do not have the exact same x-value may get clipped incorrectly if the whole surface does not completely fit within the visible x-axis or z-axis ranges.</p><p><b>Note: </b>Surfaces with less than two rows or columns are not considered valid surfaces and will not be rendered.</p><p><b>Note: </b>On some environments, surfaces with a lot of visible vertices may not render, because they exceed the per-draw vertex count supported by the graphics driver. This is mostly an issue on 32-bit and OpenGL ES2 platforms.</p></div>
<p><b> 参见 </b><a href="qtdatavisualization-data-handling.html">Qt Data Visualization Data Handling</a>.</p>
<!-- @@@QSurfaceDataProxy -->
<div class="types">
<h2>成员类型文档</h2>
</div>
<div class="prop">
<h2>属性文档</h2>
<!-- $$$columnCount-prop$$$columnCount$$$columnCountChangedint -->
<h3 class="fn" id="columnCount-prop"><a name="columnCount-prop"></a><span class="name">columnCount</span> : const <span class="type">int</span></h3>
<p>This property holds the number of columns in the data array.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>columnCount</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>columnCountChanged</b></span>(int <i>count</i>)</td></tr>
</table></div>
<!-- @@@columnCount -->
<!-- $$$rowCount-prop$$$rowCount$$$rowCountChangedint -->
<h3 class="fn" id="rowCount-prop"><a name="rowCount-prop"></a><span class="name">rowCount</span> : const <span class="type">int</span></h3>
<p>This property holds the number of rows in the data array.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>rowCount</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>rowCountChanged</b></span>(int <i>count</i>)</td></tr>
</table></div>
<!-- @@@rowCount -->
<!-- $$$series-prop$$$series$$$seriesChangedQSurface3DSeries* -->
<h3 class="fn" id="series-prop"><a name="series-prop"></a><span class="name">series</span> : <span class="type"><a href="qsurface3dseries.html">QSurface3DSeries</a></span>* const</h3>
<p>This property holds the series this proxy is attached to.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSurface3DSeries *</td><td class="memItemRight bottomAlign"><span class="name"><b>series</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>seriesChanged</b></span>(QSurface3DSeries *<i>series</i>)</td></tr>
</table></div>
<!-- @@@series -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QSurfaceDataProxy[overload1]$$$QSurfaceDataProxyQObject* -->
<h3 class="fn" id="QSurfaceDataProxy"><a name="QSurfaceDataProxy"></a>QSurfaceDataProxy::<span class="name">QSurfaceDataProxy</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs <a href="qsurfacedataproxy.html">QSurfaceDataProxy</a> with the given <i>parent</i>.</p>
<!-- @@@QSurfaceDataProxy -->
<!-- $$$~QSurfaceDataProxy[overload1]$$$~QSurfaceDataProxy -->
<h3 class="fn" id="dtor.QSurfaceDataProxy"><a name="dtor.QSurfaceDataProxy"></a><code>[virtual] </code>QSurfaceDataProxy::<span class="name">~QSurfaceDataProxy</span>()</h3>
<p>Deletes the surface data proxy.</p>
<!-- @@@~QSurfaceDataProxy -->
<!-- $$$addRow[overload1]$$$addRowQSurfaceDataRow* -->
<h3 class="fn" id="addRow"><a name="addRow"></a><span class="type">int</span> QSurfaceDataProxy::<span class="name">addRow</span>(<span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataRow-typedef">QSurfaceDataRow</a></span> *<i>row</i>)</h3>
<p>Adds the new row <i>row</i> to the end of an array. The new row must have the same number of columns as the rows in the initial array.</p>
<p>Returns the index of the added row.</p>
<!-- @@@addRow -->
<!-- $$$addRows[overload1]$$$addRowsconstQSurfaceDataArray& -->
<h3 class="fn" id="addRows"><a name="addRows"></a><span class="type">int</span> QSurfaceDataProxy::<span class="name">addRows</span>(const <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataArray-typedef">QSurfaceDataArray</a></span> &amp;<i>rows</i>)</h3>
<p>Adds new <i>rows</i> to the end of an array. The new rows must have the same number of columns as the rows in the initial array.</p>
<p>Returns the index of the first added row.</p>
<!-- @@@addRows -->
<!-- $$$array[overload1]$$$array -->
<h3 class="fn" id="array"><a name="array"></a>const <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataArray-typedef">QSurfaceDataArray</a></span> *QSurfaceDataProxy::<span class="name">array</span>() const</h3>
<p>Returns the pointer to the data array.</p>
<!-- @@@array -->
<!-- $$$arrayReset[overload1]$$$arrayReset -->
<h3 class="fn" id="arrayReset"><a name="arrayReset"></a><code>[signal] </code><span class="type">void</span> QSurfaceDataProxy::<span class="name">arrayReset</span>()</h3>
<p>This signal is emitted when the data array is reset. If the contents of the whole array are changed without calling <a href="qsurfacedataproxy.html#resetArray">resetArray</a>(), this signal needs to be emitted to update the graph.</p>
<!-- @@@arrayReset -->
<!-- $$$insertRow[overload1]$$$insertRowintQSurfaceDataRow* -->
<h3 class="fn" id="insertRow"><a name="insertRow"></a><span class="type">void</span> QSurfaceDataProxy::<span class="name">insertRow</span>(<span class="type">int</span> <i>rowIndex</i>, <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataRow-typedef">QSurfaceDataRow</a></span> *<i>row</i>)</h3>
<p>Inserts the new row <i>row</i> into <i>rowIndex</i>. If <i>rowIndex</i> is equal to the array size, the rows are added to the end of the array. The new row must have the same number of columns as the rows in the initial array.</p>
<!-- @@@insertRow -->
<!-- $$$insertRows[overload1]$$$insertRowsintconstQSurfaceDataArray& -->
<h3 class="fn" id="insertRows"><a name="insertRows"></a><span class="type">void</span> QSurfaceDataProxy::<span class="name">insertRows</span>(<span class="type">int</span> <i>rowIndex</i>, const <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataArray-typedef">QSurfaceDataArray</a></span> &amp;<i>rows</i>)</h3>
<p>Inserts new <i>rows</i> into <i>rowIndex</i>. If <i>rowIndex</i> is equal to the array size, the rows are added to the end of the array. The new <i>rows</i> must have the same number of columns as the rows in the initial array.</p>
<!-- @@@insertRows -->
<!-- $$$itemAt[overload1]$$$itemAtintint -->
<h3 class="fn" id="itemAt"><a name="itemAt"></a>const <span class="type"><a href="qsurfacedataitem.html">QSurfaceDataItem</a></span> *QSurfaceDataProxy::<span class="name">itemAt</span>(<span class="type">int</span> <i>rowIndex</i>, <span class="type">int</span> <i>columnIndex</i>) const</h3>
<p>Returns the pointer to the item at the position specified by <i>rowIndex</i> and <i>columnIndex</i>. It is guaranteed to be valid only until the next call that modifies data.</p>
<!-- @@@itemAt -->
<!-- $$$itemAt$$$itemAtconstQPoint& -->
<h3 class="fn" id="itemAt-1"><a name="itemAt-1"></a>const <span class="type"><a href="qsurfacedataitem.html">QSurfaceDataItem</a></span> *QSurfaceDataProxy::<span class="name">itemAt</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>position</i>) const</h3>
<p>Returns the pointer to the item at the position <i>position</i>. The x-value of <i>position</i> indicates the row and the y-value indicates the column. The item is guaranteed to be valid only until the next call that modifies data.</p>
<!-- @@@itemAt -->
<!-- $$$itemChanged[overload1]$$$itemChangedintint -->
<h3 class="fn" id="itemChanged"><a name="itemChanged"></a><code>[signal] </code><span class="type">void</span> QSurfaceDataProxy::<span class="name">itemChanged</span>(<span class="type">int</span> <i>rowIndex</i>, <span class="type">int</span> <i>columnIndex</i>)</h3>
<p>This signal is emitted when the item at the position specified by <i>rowIndex</i> and <i>columnIndex</i> changes. If the item is changed in the array without calling <a href="qsurfacedataproxy.html#setItem">setItem</a>(), this signal needs to be emitted to update the graph.</p>
<!-- @@@itemChanged -->
<!-- $$$removeRows[overload1]$$$removeRowsintint -->
<h3 class="fn" id="removeRows"><a name="removeRows"></a><span class="type">void</span> QSurfaceDataProxy::<span class="name">removeRows</span>(<span class="type">int</span> <i>rowIndex</i>, <span class="type">int</span> <i>removeCount</i>)</h3>
<p>Removes the number of rows specified by <i>removeCount</i> starting at the position <i>rowIndex</i>. Attempting to remove rows past the end of the array does nothing.</p>
<!-- @@@removeRows -->
<!-- $$$resetArray[overload1]$$$resetArrayQSurfaceDataArray* -->
<h3 class="fn" id="resetArray"><a name="resetArray"></a><span class="type">void</span> QSurfaceDataProxy::<span class="name">resetArray</span>(<span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataArray-typedef">QSurfaceDataArray</a></span> *<i>newArray</i>)</h3>
<p>Takes ownership of the array <i>newArray</i>. Clears the existing array if the new array differs from it. If the arrays are the same, this function just triggers the <a href="qsurfacedataproxy.html#arrayReset">arrayReset</a>() signal.</p>
<p>Passing a null array deletes the old array and creates a new empty array. All rows in <i>newArray</i> must be of same length.</p>
<!-- @@@resetArray -->
<!-- $$$rowsAdded[overload1]$$$rowsAddedintint -->
<h3 class="fn" id="rowsAdded"><a name="rowsAdded"></a><code>[signal] </code><span class="type">void</span> QSurfaceDataProxy::<span class="name">rowsAdded</span>(<span class="type">int</span> <i>startIndex</i>, <span class="type">int</span> <i>count</i>)</h3>
<p>This signal is emitted when the number of rows specified by <i>count</i> is added starting at the position <i>startIndex</i>. If rows are added to the array without calling <a href="qsurfacedataproxy.html#addRow">addRow</a>() or <a href="qsurfacedataproxy.html#addRows">addRows</a>(), this signal needs to be emitted to update the graph.</p>
<!-- @@@rowsAdded -->
<!-- $$$rowsChanged[overload1]$$$rowsChangedintint -->
<h3 class="fn" id="rowsChanged"><a name="rowsChanged"></a><code>[signal] </code><span class="type">void</span> QSurfaceDataProxy::<span class="name">rowsChanged</span>(<span class="type">int</span> <i>startIndex</i>, <span class="type">int</span> <i>count</i>)</h3>
<p>This signal is emitted when the number of rows specified by <i>count</i> is changed starting at the position <i>startIndex</i>. If rows are changed in the array without calling <a href="qsurfacedataproxy.html#setRow">setRow</a>() or <a href="qsurfacedataproxy.html#setRows">setRows</a>(), this signal needs to be emitted to update the graph.</p>
<!-- @@@rowsChanged -->
<!-- $$$rowsInserted[overload1]$$$rowsInsertedintint -->
<h3 class="fn" id="rowsInserted"><a name="rowsInserted"></a><code>[signal] </code><span class="type">void</span> QSurfaceDataProxy::<span class="name">rowsInserted</span>(<span class="type">int</span> <i>startIndex</i>, <span class="type">int</span> <i>count</i>)</h3>
<p>This signal is emitted when the number of rows specified by <i>count</i> is inserted at the position <i>startIndex</i>.</p>
<p>If rows are inserted into the array without calling <a href="qsurfacedataproxy.html#insertRow">insertRow</a>() or <a href="qsurfacedataproxy.html#insertRows">insertRows</a>(), this signal needs to be emitted to update the graph.</p>
<!-- @@@rowsInserted -->
<!-- $$$rowsRemoved[overload1]$$$rowsRemovedintint -->
<h3 class="fn" id="rowsRemoved"><a name="rowsRemoved"></a><code>[signal] </code><span class="type">void</span> QSurfaceDataProxy::<span class="name">rowsRemoved</span>(<span class="type">int</span> <i>startIndex</i>, <span class="type">int</span> <i>count</i>)</h3>
<p>This signal is emitted when the number of rows specified by <i>count</i> is removed starting at the position <i>startIndex</i>.</p>
<p>The index is the current array size if the rows were removed from the end of the array. If rows are removed from the array without calling <a href="qsurfacedataproxy.html#removeRows">removeRows</a>(), this signal needs to be emitted to update the graph.</p>
<!-- @@@rowsRemoved -->
<!-- $$$setItem[overload1]$$$setItemintintconstQSurfaceDataItem& -->
<h3 class="fn" id="setItem"><a name="setItem"></a><span class="type">void</span> QSurfaceDataProxy::<span class="name">setItem</span>(<span class="type">int</span> <i>rowIndex</i>, <span class="type">int</span> <i>columnIndex</i>, const <span class="type"><a href="qsurfacedataitem.html">QSurfaceDataItem</a></span> &amp;<i>item</i>)</h3>
<p>Changes a single item at the position specified by <i>rowIndex</i> and <i>columnIndex</i> to the item <i>item</i>.</p>
<!-- @@@setItem -->
<!-- $$$setItem$$$setItemconstQPoint&constQSurfaceDataItem& -->
<h3 class="fn" id="setItem-1"><a name="setItem-1"></a><span class="type">void</span> QSurfaceDataProxy::<span class="name">setItem</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>position</i>, const <span class="type"><a href="qsurfacedataitem.html">QSurfaceDataItem</a></span> &amp;<i>item</i>)</h3>
<p>Changes a single item at the position <i>position</i> to the item <i>item</i>. The x-value of <i>position</i> indicates the row and the y-value indicates the column.</p>
<!-- @@@setItem -->
<!-- $$$setRow[overload1]$$$setRowintQSurfaceDataRow* -->
<h3 class="fn" id="setRow"><a name="setRow"></a><span class="type">void</span> QSurfaceDataProxy::<span class="name">setRow</span>(<span class="type">int</span> <i>rowIndex</i>, <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataRow-typedef">QSurfaceDataRow</a></span> *<i>row</i>)</h3>
<p>Changes an existing row by replacing the row at the position <i>rowIndex</i> with the new row specified by <i>row</i>. The new row can be the same as the existing row already stored at the <i>rowIndex</i>. The new row must have the same number of columns as the row it is replacing.</p>
<!-- @@@setRow -->
<!-- $$$setRows[overload1]$$$setRowsintconstQSurfaceDataArray& -->
<h3 class="fn" id="setRows"><a name="setRows"></a><span class="type">void</span> QSurfaceDataProxy::<span class="name">setRows</span>(<span class="type">int</span> <i>rowIndex</i>, const <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataArray-typedef">QSurfaceDataArray</a></span> &amp;<i>rows</i>)</h3>
<p>Changes existing rows by replacing the rows starting at the position <i>rowIndex</i> with the new rows specifies by <i>rows</i>. The rows in the <i>rows</i> array can be the same as the existing rows already stored at the <i>rowIndex</i>. The new rows must have the same number of columns as the rows they are replacing.</p>
<!-- @@@setRows -->
</div>
<div class="vars">
<h2>成员变量文档</h2>
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
<!-- $$$QSurfaceDataArray -->
<h3 class="fn" id="QSurfaceDataArray-typedef"><a name="QSurfaceDataArray-typedef"></a>typedef <span class="name">QSurfaceDataArray</span></h3>
<p>A list of pointers to <a href="qsurfacedataproxy.html#QSurfaceDataRow-typedef">QSurfaceDataRow</a> objects.</p>
<!-- @@@QSurfaceDataArray -->
<!-- $$$QSurfaceDataRow -->
<h3 class="fn" id="QSurfaceDataRow-typedef"><a name="QSurfaceDataRow-typedef"></a>typedef <span class="name">QSurfaceDataRow</span></h3>
<p>A vector of <a href="qsurfacedataitem.html">QSurfaceDataItem</a> objects.</p>
<!-- @@@QSurfaceDataRow -->
</div>
<div class="macros">
<h2>宏定义文档</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
